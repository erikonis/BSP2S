<clones>
<systeminfo processor="nicad6" system="hum_codes_raw" granularity="files" threshold="0%" minlines="10" maxlines="2500"/>
<cloneinfo npcs="33864" npairs="377"/>
<runinfo ncompares="6690223" cputime="1644428"/>
<classinfo nclasses="313"/>

<class classid="1" nclones="2" nlines="88" similarity="100">
<source file="../hum_codes_raw/s002237166.java" startline="1" endline="108" pcid="62">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

class Card {
  String suit;
  int value;
  int storedNo;

  public Card( String suit, int value, int storedNo ) {
    this.suit  = suit;
    this.value = value;
    this.storedNo = storedNo;
  }
  public Card( Card card ) {
    this(card.suit, card.value, card.storedNo);
  }

  @Override
  public String toString() {
    return suit + String.valueOf(value);
  }
}

public class Main {

  public static void main(String[] args) throws IOException {
    
    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      int n = Integer.parseInt(br.readLine());
      Card[][] cards = new Card[2][n];
      String[] line = br.readLine().split(" ");
      for (int i=0; i < n; i++) {
        cards[0][i] = new Card(
          line[i].substring(0, 1),
          Integer.parseInt(line[i].substring(1)),
          i );
        cards[1][i] = new Card(cards[0][i]);
      }

      bubbleSort(cards[0], n);
      dispIntArray(cards[0]);
      System.out.println(isStableSorted(cards[0], n) ? "Stable" : "Not stable");
      selectionSort(cards[1], n);
      dispIntArray(cards[1]);
      System.out.println(isStableSorted(cards[1], n) ? "Stable" : "Not stable");
    }
  }

  static int bubbleSort(Card[] a, int n) {
    int count=0;
    Card t;

    for(int i=0,f=1; f==1 || i<n; i++ ) {
      f=0;
      for(int j=n-1; j>0; j-- ) {
        if( a[j].value < a[j-1].value) {
          t = a[j]; a[j] = a[j-1]; a[j-1] = t;
          count++;
          f=1;
        }
      }
    }

    return count;
  }

  static int selectionSort(Card a[], int n) {
    int count = 0;
    Card t;

    for(int i=0,min; i<n-1; i++ ) {
      min = i;
      for(int j=i+1; j<n; j++ ) {
        if( a[min].value > a[j].value) min = j;
      }
      if( min != i ) {
        t = a[i]; a[i] = a[min]; a[min] = t;
        count++;
      }
    }

    return count;
  }

  static boolean isStableSorted(Card[] sorted, int n) {
    boolean ret = true;

    for (int i=0, max=n-1; i < max; i++) {
      if( sorted[i].value == sorted[i+1].value
        && sorted[i].storedNo > sorted[i+1].storedNo )
        ret = false;
    }

    return ret;
  }

  public static void dispIntArray(Card[] a) {
    StringBuilder s = new StringBuilder();

    for (Card c : a) { s.append(c.toString()).append(" "); }
    s.setLength(s.length()-1);

    System.out.println(s);
  }
}

</source>
<source file="../hum_codes_raw/s005012101.java" startline="1" endline="108" pcid="165">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

class Card {
  String suit;
  int value;
  int storedNo;

  public Card( String suit, int value, int storedNo ) {
    this.suit  = suit;
    this.value = value;
    this.storedNo = storedNo;
  }
  public Card( Card card ) {
    this(card.suit, card.value, card.storedNo);
  }

  @Override
  public String toString() {
    return suit + String.valueOf(value);
  }
}

public class Main {

  public static void main(String[] args) throws IOException {
    
    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      int n = Integer.parseInt(br.readLine());
      Card[][] cards = new Card[2][n];
      String[] line = br.readLine().split(" ");
      for (int i=0; i < n; i++) {
        cards[0][i] = new Card(
          line[i].substring(0, 1),
          Integer.parseInt(line[i].substring(1)),
          i );
        cards[1][i] = new Card(cards[0][i]);
      }

      bubbleSort(cards[0], n);
      dispIntArray(cards[0]);
      System.out.println(isStableSorted(cards[0], n) ? "Stable" : "Not stable");
      selectionSort(cards[1], n);
      dispIntArray(cards[1]);
      System.out.println(isStableSorted(cards[1], n) ? "Stable" : "Not stable");
    }
  }

  static int bubbleSort(Card[] a, int n) {
    int count=0;
    Card t;

    for(int i=0,f=1; f==1 || i<n; i++ ) {
      f=0;
      for(int j=n-1; j>0; j-- ) {
        if( a[j].value < a[j-1].value) {
          t = a[j]; a[j] = a[j-1]; a[j-1] = t;
          count++;
          f=1;
        }
      }
    }

    return count;
  }

  static int selectionSort(Card a[], int n) {
    int count = 0;
    Card t;

    for(int i=0,min; i<n-1; i++ ) {
      min = i;
      for(int j=i+1; j<n; j++ ) {
        if( a[min].value > a[j].value) min = j;
      }
      if( min != i ) {
        t = a[i]; a[i] = a[min]; a[min] = t;
        count++;
      }
    }

    return count;
  }

  static boolean isStableSorted(Card[] sorted, int n) {
    boolean ret = true;

    for (int i=0, max=n-1; i < max; i++) {
      if( sorted[i].value == sorted[i+1].value
        && sorted[i].storedNo > sorted[i+1].storedNo )
        ret = false;
    }

    return ret;
  }

  public static void dispIntArray(Card[] a) {
    StringBuilder s = new StringBuilder();

    for (Card c : a) { s.append(c.toString()).append(" "); }
    s.setLength(s.length()-1);

    System.out.println(s);
  }
}

</source>
</class>

<class classid="2" nclones="3" nlines="173" similarity="100">
<source file="../hum_codes_raw/s002901400.java" startline="1" endline="207" pcid="92">
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Deque;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

public class Main {

	static PrintWriter out;
	static InputReader ir;
	static boolean debug = false;

	static void solve() {
		int R=ir.nextInt();
		int C=ir.nextInt();
		int N=ir.nextInt();
		ArrayList<int[]> ps=new ArrayList<>();
		for(int i=0;i<N;i++){
			int[] p=ir.nextIntArray(2);
			int[] q=ir.nextIntArray(2);
			if(!(p[0]==0||p[0]==R||p[1]==0||p[1]==C)){
				continue;
			}
			if(!(q[0]==0||q[0]==R||q[1]==0||q[1]==C)){
				continue;
			}
			ps.add(new int[]{i,dist(p,R,C)});
			ps.add(new int[]{i,dist(q,R,C)});
		}
		Collections.sort(ps,new Comparator<int[]>(){
			public int compare(int[] A,int[] B){
				return A[1]-B[1];
			}
		});
		Deque<Integer> que=new ArrayDeque<>();
		for(int[] p : ps){
			if(!que.isEmpty()&&que.peekFirst()==p[0]){
				que.pollFirst();
			}
			else{
				que.offerFirst(p[0]);
			}
		}
		out.println(que.isEmpty()?"YES":"NO");
	}

	static int dist(int[] x,int R,int C){
		if(x[0]==0){
			return x[1];
		}
		else if(x[1]==C){
			return x[0]+C;
		}
		else if(x[0]==R){
			return C-x[1]+R+C;
		}
		else{
			return 2*(R+C)-x[0];
		}
	}

	public static void main(String[] args) {
		ir = new InputReader(System.in);
		out = new PrintWriter(System.out);
		solve();
		out.flush();
	}

	static class InputReader {

		private InputStream in;
		private byte[] buffer = new byte[1024];
		private int curbuf;
		private int lenbuf;

		public InputReader(InputStream in) {
			this.in = in;
			this.curbuf = this.lenbuf = 0;
		}

		public boolean hasNextByte() {
			if (curbuf >= lenbuf) {
				curbuf = 0;
				try {
					lenbuf = in.read(buffer);
				} catch (IOException e) {
					throw new InputMismatchException();
				}
				if (lenbuf <= 0)
					return false;
			}
			return true;
		}

		private int readByte() {
			if (hasNextByte())
				return buffer[curbuf++];
			else
				return -1;
		}

		private boolean isSpaceChar(int c) {
			return !(c >= 33 && c <= 126);
		}

		private void skip() {
			while (hasNextByte() && isSpaceChar(buffer[curbuf]))
				curbuf++;
		}

		public boolean hasNext() {
			skip();
			return hasNextByte();
		}

		public String next() {
			if (!hasNext())
				throw new NoSuchElementException();
			StringBuilder sb = new StringBuilder();
			int b = readByte();
			while (!isSpaceChar(b)) {
				sb.appendCodePoint(b);
				b = readByte();
			}
			return sb.toString();
		}

		public int nextInt() {
			if (!hasNext())
				throw new NoSuchElementException();
			int c = readByte();
			while (isSpaceChar(c))
				c = readByte();
			boolean minus = false;
			if (c == '-') {
				minus = true;
				c = readByte();
			}
			int res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res = res * 10 + c - '0';
				c = readByte();
			} while (!isSpaceChar(c));
			return (minus) ? -res : res;
		}

		public long nextLong() {
			if (!hasNext())
				throw new NoSuchElementException();
			int c = readByte();
			while (isSpaceChar(c))
				c = readByte();
			boolean minus = false;
			if (c == '-') {
				minus = true;
				c = readByte();
			}
			long res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res = res * 10 + c - '0';
				c = readByte();
			} while (!isSpaceChar(c));
			return (minus) ? -res : res;
		}

		public double nextDouble() {
			return Double.parseDouble(next());
		}

		public int[] nextIntArray(int n) {
			int[] a = new int[n];
			for (int i = 0; i < n; i++)
				a[i] = nextInt();
			return a;
		}

		public long[] nextLongArray(int n) {
			long[] a = new long[n];
			for (int i = 0; i < n; i++)
				a[i] = nextLong();
			return a;
		}

		public char[][] nextCharMap(int n, int m) {
			char[][] map = new char[n][m];
			for (int i = 0; i < n; i++)
				map[i] = next().toCharArray();
			return map;
		}
	}

	static void tr(Object... o) {
		if (debug)
			out.println(Arrays.deepToString(o));
	}
}

</source>
<source file="../hum_codes_raw/s770657796.java" startline="1" endline="207" pcid="25873">
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Deque;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

public class Main {

	static PrintWriter out;
	static InputReader ir;
	static boolean debug = false;

	static void solve() {
		int R=ir.nextInt();
		int C=ir.nextInt();
		int N=ir.nextInt();
		ArrayList<int[]> ps=new ArrayList<>();
		for(int i=0;i<N;i++){
			int[] p=ir.nextIntArray(2);
			int[] q=ir.nextIntArray(2);
			if(!(p[0]==0||p[0]==R||p[1]==0||p[1]==C)){
				continue;
			}
			if(!(q[0]==0||q[0]==R||q[1]==0||q[1]==C)){
				continue;
			}
			ps.add(new int[]{i,dist(p,R,C)});
			ps.add(new int[]{i,dist(q,R,C)});
		}
		Collections.sort(ps,new Comparator<int[]>(){
			public int compare(int[] A,int[] B){
				return A[1]-B[1];
			}
		});
		Deque<Integer> que=new ArrayDeque<>();
		for(int[] p : ps){
			if(!que.isEmpty()&&que.peekFirst()==p[0]){
				que.pollFirst();
			}
			else{
				que.offerFirst(p[0]);
			}
		}
		out.println(que.isEmpty()?"YES":"NO");
	}

	static int dist(int[] x,int R,int C){
		if(x[0]==0){
			return x[1];
		}
		else if(x[1]==C){
			return x[0]+C;
		}
		else if(x[0]==R){
			return C-x[1]+R+C;
		}
		else{
			return 2*(R+C)-x[0];
		}
	}

	public static void main(String[] args) {
		ir = new InputReader(System.in);
		out = new PrintWriter(System.out);
		solve();
		out.flush();
	}

	static class InputReader {

		private InputStream in;
		private byte[] buffer = new byte[1024];
		private int curbuf;
		private int lenbuf;

		public InputReader(InputStream in) {
			this.in = in;
			this.curbuf = this.lenbuf = 0;
		}

		public boolean hasNextByte() {
			if (curbuf >= lenbuf) {
				curbuf = 0;
				try {
					lenbuf = in.read(buffer);
				} catch (IOException e) {
					throw new InputMismatchException();
				}
				if (lenbuf <= 0)
					return false;
			}
			return true;
		}

		private int readByte() {
			if (hasNextByte())
				return buffer[curbuf++];
			else
				return -1;
		}

		private boolean isSpaceChar(int c) {
			return !(c >= 33 && c <= 126);
		}

		private void skip() {
			while (hasNextByte() && isSpaceChar(buffer[curbuf]))
				curbuf++;
		}

		public boolean hasNext() {
			skip();
			return hasNextByte();
		}

		public String next() {
			if (!hasNext())
				throw new NoSuchElementException();
			StringBuilder sb = new StringBuilder();
			int b = readByte();
			while (!isSpaceChar(b)) {
				sb.appendCodePoint(b);
				b = readByte();
			}
			return sb.toString();
		}

		public int nextInt() {
			if (!hasNext())
				throw new NoSuchElementException();
			int c = readByte();
			while (isSpaceChar(c))
				c = readByte();
			boolean minus = false;
			if (c == '-') {
				minus = true;
				c = readByte();
			}
			int res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res = res * 10 + c - '0';
				c = readByte();
			} while (!isSpaceChar(c));
			return (minus) ? -res : res;
		}

		public long nextLong() {
			if (!hasNext())
				throw new NoSuchElementException();
			int c = readByte();
			while (isSpaceChar(c))
				c = readByte();
			boolean minus = false;
			if (c == '-') {
				minus = true;
				c = readByte();
			}
			long res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res = res * 10 + c - '0';
				c = readByte();
			} while (!isSpaceChar(c));
			return (minus) ? -res : res;
		}

		public double nextDouble() {
			return Double.parseDouble(next());
		}

		public int[] nextIntArray(int n) {
			int[] a = new int[n];
			for (int i = 0; i < n; i++)
				a[i] = nextInt();
			return a;
		}

		public long[] nextLongArray(int n) {
			long[] a = new long[n];
			for (int i = 0; i < n; i++)
				a[i] = nextLong();
			return a;
		}

		public char[][] nextCharMap(int n, int m) {
			char[][] map = new char[n][m];
			for (int i = 0; i < n; i++)
				map[i] = next().toCharArray();
			return map;
		}
	}

	static void tr(Object... o) {
		if (debug)
			out.println(Arrays.deepToString(o));
	}
}

</source>
<source file="../hum_codes_raw/s451652701.java" startline="1" endline="207" pcid="15146">
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Deque;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

public class Main {

	static PrintWriter out;
	static InputReader ir;
	static boolean debug = false;

	static void solve() {
		int R=ir.nextInt();
		int C=ir.nextInt();
		int N=ir.nextInt();
		ArrayList<int[]> ps=new ArrayList<>();
		for(int i=0;i<N;i++){
			int[] p=ir.nextIntArray(2);
			int[] q=ir.nextIntArray(2);
			if(!(p[0]==0||p[0]==R||p[1]==0||p[1]==C)){
				continue;
			}
			if(!(q[0]==0||q[0]==R||q[1]==0||q[1]==C)){
				continue;
			}
			ps.add(new int[]{i,dist(p,R,C)});
			ps.add(new int[]{i,dist(q,R,C)});
		}
		Collections.sort(ps,new Comparator<int[]>(){
			public int compare(int[] A,int[] B){
				return A[1]-B[1];
			}
		});
		Deque<Integer> que=new ArrayDeque<>();
		for(int[] p : ps){
			if(!que.isEmpty()&&que.peekFirst()==p[0]){
				que.pollFirst();
			}
			else{
				que.offerFirst(p[0]);
			}
		}
		out.println(que.isEmpty()?"YES":"NO");
	}

	static int dist(int[] x,int R,int C){
		if(x[0]==0){
			return x[1];
		}
		else if(x[1]==C){
			return x[0]+C;
		}
		else if(x[0]==R){
			return C-x[1]+R+C;
		}
		else{
			return 2*(R+C)-x[0];
		}
	}

	public static void main(String[] args) {
		ir = new InputReader(System.in);
		out = new PrintWriter(System.out);
		solve();
		out.flush();
	}

	static class InputReader {

		private InputStream in;
		private byte[] buffer = new byte[1024];
		private int curbuf;
		private int lenbuf;

		public InputReader(InputStream in) {
			this.in = in;
			this.curbuf = this.lenbuf = 0;
		}

		public boolean hasNextByte() {
			if (curbuf >= lenbuf) {
				curbuf = 0;
				try {
					lenbuf = in.read(buffer);
				} catch (IOException e) {
					throw new InputMismatchException();
				}
				if (lenbuf <= 0)
					return false;
			}
			return true;
		}

		private int readByte() {
			if (hasNextByte())
				return buffer[curbuf++];
			else
				return -1;
		}

		private boolean isSpaceChar(int c) {
			return !(c >= 33 && c <= 126);
		}

		private void skip() {
			while (hasNextByte() && isSpaceChar(buffer[curbuf]))
				curbuf++;
		}

		public boolean hasNext() {
			skip();
			return hasNextByte();
		}

		public String next() {
			if (!hasNext())
				throw new NoSuchElementException();
			StringBuilder sb = new StringBuilder();
			int b = readByte();
			while (!isSpaceChar(b)) {
				sb.appendCodePoint(b);
				b = readByte();
			}
			return sb.toString();
		}

		public int nextInt() {
			if (!hasNext())
				throw new NoSuchElementException();
			int c = readByte();
			while (isSpaceChar(c))
				c = readByte();
			boolean minus = false;
			if (c == '-') {
				minus = true;
				c = readByte();
			}
			int res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res = res * 10 + c - '0';
				c = readByte();
			} while (!isSpaceChar(c));
			return (minus) ? -res : res;
		}

		public long nextLong() {
			if (!hasNext())
				throw new NoSuchElementException();
			int c = readByte();
			while (isSpaceChar(c))
				c = readByte();
			boolean minus = false;
			if (c == '-') {
				minus = true;
				c = readByte();
			}
			long res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res = res * 10 + c - '0';
				c = readByte();
			} while (!isSpaceChar(c));
			return (minus) ? -res : res;
		}

		public double nextDouble() {
			return Double.parseDouble(next());
		}

		public int[] nextIntArray(int n) {
			int[] a = new int[n];
			for (int i = 0; i < n; i++)
				a[i] = nextInt();
			return a;
		}

		public long[] nextLongArray(int n) {
			long[] a = new long[n];
			for (int i = 0; i < n; i++)
				a[i] = nextLong();
			return a;
		}

		public char[][] nextCharMap(int n, int m) {
			char[][] map = new char[n][m];
			for (int i = 0; i < n; i++)
				map[i] = next().toCharArray();
			return map;
		}
	}

	static void tr(Object... o) {
		if (debug)
			out.println(Arrays.deepToString(o));
	}
}

</source>
</class>

<class classid="3" nclones="2" nlines="117" similarity="100">
<source file="../hum_codes_raw/s003348081.java" startline="1" endline="143" pcid="109">
import java.io.*;
import java.util.*;

public class Main implements Runnable{
    private boolean[][] graph;
    private int X;
    private int Y;
    public static void main(String[] args) throws Exception {
        new Thread(null, new Main(), "bridge", 16 * 1024 * 1024).start();
    }

    @Override
    public void run() {
        try {
            solve();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void solve() throws Exception{
        FastScanner scanner = new FastScanner(System.in);

        X = scanner.nextInt();
        Y = scanner.nextInt();
        int E = scanner.nextInt();

        if(X == 0 || Y == 0 || E == 0){
            System.out.println("0");
            return;
        }

        graph = new boolean[X][Y];

        for(int i = 0; i < E; ++i){
            int u = scanner.nextInt();
            int v = scanner.nextInt();

            graph[u][v] = true;
        }

        System.out.println(maxBPM());
    }

    private int maxBPM(){
        int[] match = new int[Y];
        Arrays.fill(match, -1);

        int result = 0;
        for(int u = 0; u < X; ++u){
            if(existPath(u, new boolean[Y], match)){
                ++result;
            }
        }

        return result;
    }

    private boolean existPath(int u, boolean[] visited, int[] match){
        for(int v = 0; v < Y; ++v){
            if(graph[u][v] && !visited[v]){
                visited[v] = true;

                if(match[v] < 0 || existPath(match[v], visited, match)){
                    match[v] = u;
                    return true;
                }
            }
        }

        return false;
    }

    static class FastScanner {
        private InputStream in;
        private final byte[] buffer = new byte[1024 * 8];
        private int ptr = 0;
        private int buflen = 0;

        public FastScanner(InputStream in){
            this.in = in;
        }

        private boolean hasNextByte() {
            if (ptr < buflen) {
                return true;
            } else {
                ptr = 0;
                try {
                    buflen = in.read(buffer);
                } catch (IOException e) {
                    e.printStackTrace();
                }
                if (buflen <= 0) {
                    return false;
                }
            }
            return true;
        }

        private int readByte() {
            if (hasNextByte()) return buffer[ptr++];
            else return -1;
        }

        private static boolean isPrintableChar(int c) {
            return 33 <= c && c <= 126;
        }

        private void skipUnprintable() {
            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        }

        public boolean hasNext() {
            skipUnprintable();
            return hasNextByte();
        }

        public String next() {
            if (!hasNext()) throw new NoSuchElementException();
            StringBuilder sb = new StringBuilder();
            int b = readByte();
            while (isPrintableChar(b)) {
                sb.appendCodePoint(b);
                b = readByte();
            }
            return sb.toString();
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }
    }
}

</source>
<source file="../hum_codes_raw/s974382719.java" startline="1" endline="142" pcid="32792">
import java.io.*;
import java.util.*;

public class Main implements Runnable{
    private boolean[][] graph;
    private int X;
    private int Y;
    public static void main(String[] args) throws Exception {
        new Thread(null, new Main(), "bridge", 16 * 1024 * 1024).start();
    }

    @Override
    public void run() {
        try {
            solve();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void solve() throws Exception{
        FastScanner scanner = new FastScanner(System.in);

        X = scanner.nextInt();
        Y = scanner.nextInt();
        int E = scanner.nextInt();

        if(X == 0 || Y == 0 || E == 0){
            System.out.println("0");
            return;
        }

        graph = new boolean[X][Y];

        for(int i = 0; i < E; ++i){
            int u = scanner.nextInt();
            int v = scanner.nextInt();

            graph[u][v] = true;
        }

        System.out.println(maxBPM());
    }

    private int maxBPM(){
        int[] match = new int[Y];
        Arrays.fill(match, -1);

        int result = 0;
        for(int u = 0; u < X; ++u){
            if(existPath(u, new boolean[Y], match)){
                ++result;
            }
        }

        return result;
    }

    private boolean existPath(int u, boolean[] visited, int[] match){
        for(int v = 0; v < Y; ++v){
            if(graph[u][v] && !visited[v]){
                visited[v] = true;
                if(match[v] < 0 || existPath(match[v], visited, match)){
                    match[v] = u;
                    return true;
                }
            }
        }

        return false;
    }

    static class FastScanner {
        private InputStream in;
        private final byte[] buffer = new byte[1024 * 8];
        private int ptr = 0;
        private int buflen = 0;

        public FastScanner(InputStream in){
            this.in = in;
        }

        private boolean hasNextByte() {
            if (ptr < buflen) {
                return true;
            } else {
                ptr = 0;
                try {
                    buflen = in.read(buffer);
                } catch (IOException e) {
                    e.printStackTrace();
                }
                if (buflen <= 0) {
                    return false;
                }
            }
            return true;
        }

        private int readByte() {
            if (hasNextByte()) return buffer[ptr++];
            else return -1;
        }

        private static boolean isPrintableChar(int c) {
            return 33 <= c && c <= 126;
        }

        private void skipUnprintable() {
            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        }

        public boolean hasNext() {
            skipUnprintable();
            return hasNextByte();
        }

        public String next() {
            if (!hasNext()) throw new NoSuchElementException();
            StringBuilder sb = new StringBuilder();
            int b = readByte();
            while (isPrintableChar(b)) {
                sb.appendCodePoint(b);
                b = readByte();
            }
            return sb.toString();
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }
    }
}

</source>
</class>

<class classid="4" nclones="2" nlines="128" similarity="100">
<source file="../hum_codes_raw/s004280554.java" startline="1" endline="161" pcid="142">
import java.io.*;
import java.util.*;

public class Main {
	static PrintWriter out;
	static StringBuilder sb;
	static int n, m, k;
	static long mod = 998244353;
	static Boolean[][] memo;
	static String s;
	static ArrayList<Integer>[] ad;
	static long inf = Long.MAX_VALUE;
	static int[] color;
	static ArrayList<Integer> o;
	static char[][] g;
	static boolean[] vis, vis1;
	static long[] f;
	static long[] a, dest;

	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(System.in);
		out = new PrintWriter(System.out);
		int k = sc.nextInt();
		int n = sc.nextInt();
		f = new long[4001];
		f[0] = 1;
		long[][] tab = new long[4001][4001];
		// for (int i = 1; i < 4001; i++)
		// f[i] = i * f[i - 1] % mod;
		tab[0][0] = 1;
		for (int i = 1; i < 4001; i++) {
			tab[i][0] = 1;
			for (int j = 1; j <= i; j++) {
				tab[i][j] = (tab[i - 1][j] + tab[i - 1][j - 1]) % mod;
			}
		}
		for (int i = 2; i <= 2 * k; i++) {
			long ans = 0;
			int und = i / 2;
			int up = k - (i - i / 2) + 1;
			int av = Math.min(up, und);
			for (int j = 0; j <= av; j++) {
				// System.out.println(i+" "+j+" "+av);
				if (n - j * 2 < 0)
					continue;
				long v = tab[av][j] * tab[n - j * 2 + k - 1][n - j * 2]% mod;
				if (j % 2 == 0) {
					ans = (ans + v) % mod;
				} else {
					ans = (ans - v + mod) % mod;
				}
			}
			out.println(ans);
		}
		out.flush();
	}

	static long nCk(int n, int k) {
		long ll = f[n] * modPow(f[n - k], mod - 2) % mod;
		ll = ll * modPow(f[k], mod - 2) % mod;
		return ll;
	}

	static long modPow(long a, long e)

	{
		long res = 1;
		while (e > 0) {
			if ((e & 1) == 1)
				res = (res * a) % mod;
			a = (a * a) % mod;
			e >>= 1;
		}
		return res;
	}

	static class pair implements Comparable<pair> {
		long x;
		int y, lv;

		pair(long x, int y, int l) {
			this.x = x;
			this.y = y;
			lv = l;
		}

		public String toString() {
			return x + " " + y + " " + lv;
		}

		@Override
		public int compareTo(pair o) {
			if (x == o.x)
				return y - o.y;
			return Long.compare(o.x, x);
		}

	}

	static class Scanner {
		StringTokenizer st;
		BufferedReader br;

		public Scanner(InputStream system) {
			br = new BufferedReader(new InputStreamReader(system));
		}

		public Scanner(String file) throws Exception {
			br = new BufferedReader(new FileReader(file));
		}

		public String next() throws IOException {
			while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}

		public String nextLine() throws IOException {
			return br.readLine();
		}

		public int nextInt() throws IOException {
			return Integer.parseInt(next());
		}

		public double nextDouble() throws IOException {
			return Double.parseDouble(next());
		}

		public char nextChar() throws IOException {
			return next().charAt(0);
		}

		public Long nextLong() throws IOException {
			return Long.parseLong(next());
		}

		public int[] nextArrInt(int n) throws IOException {
			int[] a = new int[n];
			for (int i = 0; i < n; i++)
				a[i] = nextInt();
			return a;
		}

		public long[] nextArrLong(int n) throws IOException {
			long[] a = new long[n];
			for (int i = 0; i < n; i++)
				a[i] = nextLong();
			return a;
		}

		public boolean ready() throws IOException {
			return br.ready();
		}

		public void waitForInput() throws InterruptedException {
			Thread.sleep(3000);
		}
	}
}

</source>
<source file="../hum_codes_raw/s154876882.java" startline="1" endline="161" pcid="5197">
import java.io.*;
import java.util.*;

public class Main {
	static PrintWriter out;
	static StringBuilder sb;
	static int n, m, k;
	static long mod = 998244353;
	static Boolean[][] memo;
	static String s;
	static ArrayList<Integer>[] ad;
	static long inf = Long.MAX_VALUE;
	static int[] color;
	static ArrayList<Integer> o;
	static char[][] g;
	static boolean[] vis, vis1;
	static long[] f;
	static long[] a, dest;

	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(System.in);
		out = new PrintWriter(System.out);
		int k = sc.nextInt();
		int n = sc.nextInt();
		f = new long[4001];
		f[0] = 1;
		long[][] tab = new long[4001][4001];
		// for (int i = 1; i < 4001; i++)
		// f[i] = i * f[i - 1] % mod;
		tab[0][0] = 1;
		for (int i = 1; i < 4001; i++) {
			tab[i][0] = 1;
			for (int j = 1; j <= i; j++) {
				tab[i][j] = (tab[i - 1][j] + tab[i - 1][j - 1]) % mod;
			}
		}
		for (int i = 2; i <= 2 * k; i++) {
			long ans = 0;
			int und = i / 2;
			int up = k - (i - i / 2) + 1;
			int av = Math.min(up, und);
			for (int j = 0; j <= av; j++) {
				// System.out.println(i+" "+j+" "+av);
				if (n - j * 2 < 0)
					continue;
				long v = tab[av][j] * tab[n - j * 2 + k - 1][n - j * 2]% mod;
				if (j % 2 == 0) {
					ans = (ans + v) % mod;
				} else {
					ans = (ans - v + mod) % mod;
				}
			}
			out.println(ans);
		}
		out.flush();
	}

	static long nCk(int n, int k) {
		long ll = f[n] * modPow(f[n - k], mod - 2) % mod;
		ll = ll * modPow(f[k], mod - 2) % mod;
		return ll;
	}

	static long modPow(long a, long e)

	{
		long res = 1;
		while (e > 0) {
			if ((e & 1) == 1)
				res = (res * a) % mod;
			a = (a * a) % mod;
			e >>= 1;
		}
		return res;
	}

	static class pair implements Comparable<pair> {
		long x;
		int y, lv;

		pair(long x, int y, int l) {
			this.x = x;
			this.y = y;
			lv = l;
		}

		public String toString() {
			return x + " " + y + " " + lv;
		}

		@Override
		public int compareTo(pair o) {
			if (x == o.x)
				return y - o.y;
			return Long.compare(o.x, x);
		}

	}

	static class Scanner {
		StringTokenizer st;
		BufferedReader br;

		public Scanner(InputStream system) {
			br = new BufferedReader(new InputStreamReader(system));
		}

		public Scanner(String file) throws Exception {
			br = new BufferedReader(new FileReader(file));
		}

		public String next() throws IOException {
			while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}

		public String nextLine() throws IOException {
			return br.readLine();
		}

		public int nextInt() throws IOException {
			return Integer.parseInt(next());
		}

		public double nextDouble() throws IOException {
			return Double.parseDouble(next());
		}

		public char nextChar() throws IOException {
			return next().charAt(0);
		}

		public Long nextLong() throws IOException {
			return Long.parseLong(next());
		}

		public int[] nextArrInt(int n) throws IOException {
			int[] a = new int[n];
			for (int i = 0; i < n; i++)
				a[i] = nextInt();
			return a;
		}

		public long[] nextArrLong(int n) throws IOException {
			long[] a = new long[n];
			for (int i = 0; i < n; i++)
				a[i] = nextLong();
			return a;
		}

		public boolean ready() throws IOException {
			return br.ready();
		}

		public void waitForInput() throws InterruptedException {
			Thread.sleep(3000);
		}
	}
}

</source>
</class>

<class classid="5" nclones="2" nlines="208" similarity="100">
<source file="../hum_codes_raw/s004280841.java" startline="1" endline="252" pcid="143">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            CNuskeVsPhantomThnook solver = new CNuskeVsPhantomThnook();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class CNuskeVsPhantomThnook {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            int m = in.readInt();
            int q = in.readInt();
            //even for vertex, odd for edge
            int[][] mat = new int[n + 1][m + 1];
            //edge with top
            int[][] colEdge = new int[n + 1][m + 1];
            //edge with right
            int[][] rowEdge = new int[n + 1][m + 1];
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    mat[i][j] = in.readChar() - '0';
                }
            }

            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if (mat[i][j] + mat[i + 1][j] == 2) {
                        colEdge[i][j] = 1;
                    }
                    if (mat[i][j] + mat[i][j + 1] == 2) {
                        rowEdge[i][j] = 1;
                    }
                }
            }

            presum(mat);
            presum(colEdge);
            presum(rowEdge);

            for (int i = 0; i < q; i++) {
                int b = in.readInt() - 1;
                int l = in.readInt() - 1;
                int t = in.readInt() - 1;
                int r = in.readInt() - 1;

                int vertexCnt = region(mat, b, t, l, r);
                int edge = region(colEdge, b, t - 1, l, r) +
                        region(rowEdge, b, t, l, r - 1);

                int cc = vertexCnt - edge;
                out.println(cc);
            }
        }

        public int region(int[][] mat, int b, int t, int l, int r) {
            if (b > t || l > r) {
                return 0;
            }

            int ans = mat[t][r];
            if (b > 0) {
                ans -= mat[b - 1][r];
            }
            if (l > 0) {
                ans -= mat[t][l - 1];
            }
            if (b > 0 && l > 0) {
                ans += mat[b - 1][l - 1];
            }
            return ans;
        }

        public void presum(int[][] mat) {
            int n = mat.length;
            int m = mat[0].length;
            for (int i = 0; i < n; i++) {
                for (int j = 1; j < m; j++) {
                    mat[i][j] += mat[i][j - 1];
                }
                if (i > 0) {
                    for (int j = 0; j < m; j++) {
                        mat[i][j] += mat[i - 1][j];
                    }
                }
            }
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

        public char readChar() {
            skipBlank();
            char c = (char) next;
            next = read();
            return c;
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }
}


</source>
<source file="../hum_codes_raw/s940481462.java" startline="1" endline="252" pcid="31621">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            CNuskeVsPhantomThnook solver = new CNuskeVsPhantomThnook();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class CNuskeVsPhantomThnook {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            int m = in.readInt();
            int q = in.readInt();
            //even for vertex, odd for edge
            int[][] mat = new int[n + 1][m + 1];
            //edge with top
            int[][] colEdge = new int[n + 1][m + 1];
            //edge with right
            int[][] rowEdge = new int[n + 1][m + 1];
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    mat[i][j] = in.readChar() - '0';
                }
            }

            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if (mat[i][j] + mat[i + 1][j] == 2) {
                        colEdge[i][j] = 1;
                    }
                    if (mat[i][j] + mat[i][j + 1] == 2) {
                        rowEdge[i][j] = 1;
                    }
                }
            }

            presum(mat);
            presum(colEdge);
            presum(rowEdge);

            for (int i = 0; i < q; i++) {
                int b = in.readInt() - 1;
                int l = in.readInt() - 1;
                int t = in.readInt() - 1;
                int r = in.readInt() - 1;

                int vertexCnt = region(mat, b, t, l, r);
                int edge = region(colEdge, b, t - 1, l, r) +
                        region(rowEdge, b, t, l, r - 1);

                int cc = vertexCnt - edge;
                out.println(cc);
            }
        }

        public int region(int[][] mat, int b, int t, int l, int r) {
            if (b > t || l > r) {
                return 0;
            }

            int ans = mat[t][r];
            if (b > 0) {
                ans -= mat[b - 1][r];
            }
            if (l > 0) {
                ans -= mat[t][l - 1];
            }
            if (b > 0 && l > 0) {
                ans += mat[b - 1][l - 1];
            }
            return ans;
        }

        public void presum(int[][] mat) {
            int n = mat.length;
            int m = mat[0].length;
            for (int i = 0; i < n; i++) {
                for (int j = 1; j < m; j++) {
                    mat[i][j] += mat[i][j - 1];
                }
                if (i > 0) {
                    for (int j = 0; j < m; j++) {
                        mat[i][j] += mat[i - 1][j];
                    }
                }
            }
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

        public char readChar() {
            skipBlank();
            char c = (char) next;
            next = read();
            return c;
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }
}


</source>
</class>

<class classid="6" nclones="2" nlines="16" similarity="100">
<source file="../hum_codes_raw/s004448131.java" startline="1" endline="17" pcid="148">
import java.util.*;
 
public class Main {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        Stack<Integer> stack = new Stack<Integer>();
        while(sc.hasNextInt()){
            int a=sc.nextInt();
            if(a==0){
                System.out.println(stack.pop());
            }else{
                stack.push(a);
            }
        }
    }
}

</source>
<source file="../hum_codes_raw/s302006164.java" startline="1" endline="17" pcid="10174">
import java.util.*;
 
public class Main {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        Stack<Integer> stack = new Stack<Integer>();
        while(sc.hasNextInt()){
            int a=sc.nextInt();
            if(a==0){
                System.out.println(stack.pop());
            }else{
                stack.push(a);
            }
        }
    }
}

</source>
</class>

<class classid="7" nclones="2" nlines="15" similarity="100">
<source file="../hum_codes_raw/s006695439.java" startline="1" endline="18" pcid="220">
import java.util.Scanner;

public class Main {
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		int score[] = new int[5];
		int average = 0;
		for(int i=0;i<5;i++){
			score[i] = sc.nextInt();
			if(score[i]<40) score[i] = 40;
			average += score[i];
		}
		average /= 5;
		System.out.println(average);
	}

}

</source>
<source file="../hum_codes_raw/s697108891.java" startline="1" endline="18" pcid="23447">
import java.util.Scanner;

public class Main {
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		int score[] = new int[5];
		int average = 0;
		for(int i=0;i<5;i++){
			score[i] = sc.nextInt();
			if(score[i]<40) score[i] = 40;
			average += score[i];
		}
		average /= 5;
		System.out.println(average);
	}

}

</source>
</class>

<class classid="8" nclones="2" nlines="171" similarity="100">
<source file="../hum_codes_raw/s007084036.java" startline="1" endline="199" pcid="236">
import java.util.*;
class Main {
  public static void main(String args[]){
    new Main().run();
  }

  int idx;
  String s;

  Scanner sc = new Scanner(System.in);
  void run(){
    while(true){
      s = sc.nextLine();
      if(s.equals("#"))break;
      idx=0;
      Expr e = equation();
      boolean ans = true;
      for(int i = 0 ; i < 1 << 11; i++){
        Map<Character,Boolean> env = new HashMap<Character, Boolean>();
        for(int j = 0 ; j < 11; j++){
          env.put((char)('a' + j), ((i >> j) & 1) == 1);
        }
        ans = ans && e.eval(env);
      }
      System.out.println(ans ? "YES" : "NO");
    }
  }

  Expr equation(){
    Expr e1 = formula();
    idx++;
    Expr e2 = formula();
    return new Eq(e1,e2);
  }

  Expr formula(){
    char c;
    switch(c = s.charAt(idx++)){
      case 'T': 
        return new True();
      case 'F':
        return new False();
      case '-': 
        return new Not(formula());
      case '(':
        Expr e1 = formula();
        Expr e3 = null;
        if(s.charAt(idx) == '*'){
          idx++;
          Expr e2 = formula();
          e3= new And(e1,e2);
        }else if(s.charAt(idx)=='+'){
          idx++;
          Expr e2 = formula();
          e3= new Or(e1,e2);
        } else{
          idx++;
          idx++;
          Expr e2 = formula();
          e3 = new Imp(e1,e2);
        }
        idx++;
        return e3;
      default:
        return new Var(c);
    }
  }
}

abstract class Expr {
  abstract boolean eval(Map<Character, Boolean> env);
}

class Eq extends Expr{
  Expr e1,e2;
  Eq(Expr a, Expr b){
    e1=a;
    e2=b;
  }

  public boolean eval(Map<Character, Boolean> env){
    return e1.eval(env) == e2.eval(env);
  }

  public String toString(){
    return e1 + "=" + e2;
  }
}

class Not extends Expr{
  Expr e;
  Not(Expr expr){
    this.e = expr;
  }

  public boolean eval(Map<Character, Boolean> env){
    return !(e.eval(env));
  }

  public String toString(){
    return "-" + e;
  }
}

class False extends Expr {
  False(){
  }

  public boolean eval(Map<Character, Boolean> env){
    return false;
  }

  public String toString(){
    return "F";
  }
}

class True extends Expr {
  True(){
  }

  public boolean eval(Map<Character, Boolean> env){
    return true;
  }

  public String toString(){
    return "T";
  }
}

class And extends Expr {
  Expr e1;
  Expr e2;
  And(Expr a, Expr b){
    e1 = a;
    e2 = b;
  }

  public boolean eval(Map<Character, Boolean> env){
    return e1.eval(env) && e2.eval(env);
  }

  public String toString(){
    return "(" + e1 + "*" + e2 +")";
  }
}

class Or extends Expr {
  Expr e1;
  Expr e2;
  Or(Expr a, Expr b){
    e1 = a;
    e2 = b;
  }

  public boolean eval(Map<Character, Boolean> env){
    return e1.eval(env) || e2.eval(env);
  }

  public String toString(){
    return "(" + e1 + "+" + e2 +")";
  }
}

class Imp extends Expr {
  Expr e1;
  Expr e2;
  Imp(Expr a, Expr b){
    e1 = a;
    e2 = b;
  }
  public boolean eval(Map<Character, Boolean> env){
    return !(e1.eval(env)) || e2.eval(env);
  }

  public String toString(){
    return "(" + e1 + "->" + e2 +")";
  }
}

class Var extends Expr {
  public char name;
  Var(char c){
    name =c;
  }

  public boolean equals (Var v){
    return name == v.name;
  }

  public boolean eval(Map<Character, Boolean> env){
    return env.get(name);
  }

  public String toString(){
    return name+"";
  }
}

</source>
<source file="../hum_codes_raw/s499329413.java" startline="1" endline="199" pcid="16743">
import java.util.*;
class Main {
  public static void main(String args[]){
    new Main().run();
  }
 
  int idx;
  String s;
 
  Scanner sc = new Scanner(System.in);
  void run(){
    while(true){
      s = sc.nextLine();
      if(s.equals("#"))break;
      idx=0;
      Expr e = equation();
      boolean ans = true;
      for(int i = 0 ; i < 1 << 11; i++){
        Map<Character,Boolean> env = new HashMap<Character, Boolean>();
        for(int j = 0 ; j < 11; j++){
          env.put((char)('a' + j), ((i >> j) & 1) == 1);
        }
        ans = ans && e.eval(env);
      }
      System.out.println(ans ? "YES" : "NO");
    }
  }
 
  Expr equation(){
    Expr e1 = formula();
    idx++;
    Expr e2 = formula();
    return new Eq(e1,e2);
  }
 
  Expr formula(){
    char c;
    switch(c = s.charAt(idx++)){
      case 'T': 
        return new True();
      case 'F':
        return new False();
      case '-': 
        return new Not(formula());
      case '(':
        Expr e1 = formula();
        Expr e3 = null;
        if(s.charAt(idx) == '*'){
          idx++;
          Expr e2 = formula();
          e3= new And(e1,e2);
        }else if(s.charAt(idx)=='+'){
          idx++;
          Expr e2 = formula();
          e3= new Or(e1,e2);
        } else{
          idx++;
          idx++;
          Expr e2 = formula();
          e3 = new Imp(e1,e2);
        }
        idx++;
        return e3;
      default:
        return new Var(c);
    }
  }
}
 
abstract class Expr {
  abstract boolean eval(Map<Character, Boolean> env);
}
 
class Eq extends Expr{
  Expr e1,e2;
  Eq(Expr a, Expr b){
    e1=a;
    e2=b;
  }
 
  public boolean eval(Map<Character, Boolean> env){
    return e1.eval(env) == e2.eval(env);
  }
 
  public String toString(){
    return e1 + "=" + e2;
  }
}
 
class Not extends Expr{
  Expr e;
  Not(Expr expr){
    this.e = expr;
  }
 
  public boolean eval(Map<Character, Boolean> env){
    return !(e.eval(env));
  }
 
  public String toString(){
    return "-" + e;
  }
}
 
class False extends Expr {
  False(){
  }
 
  public boolean eval(Map<Character, Boolean> env){
    return false;
  }
 
  public String toString(){
    return "F";
  }
}
 
class True extends Expr {
  True(){
  }
 
  public boolean eval(Map<Character, Boolean> env){
    return true;
  }
 
  public String toString(){
    return "T";
  }
}
 
class And extends Expr {
  Expr e1;
  Expr e2;
  And(Expr a, Expr b){
    e1 = a;
    e2 = b;
  }
 
  public boolean eval(Map<Character, Boolean> env){
    return e1.eval(env) && e2.eval(env);
  }
 
  public String toString(){
    return "(" + e1 + "*" + e2 +")";
  }
}
 
class Or extends Expr {
  Expr e1;
  Expr e2;
  Or(Expr a, Expr b){
    e1 = a;
    e2 = b;
  }
 
  public boolean eval(Map<Character, Boolean> env){
    return e1.eval(env) || e2.eval(env);
  }
 
  public String toString(){
    return "(" + e1 + "+" + e2 +")";
  }
}
 
class Imp extends Expr {
  Expr e1;
  Expr e2;
  Imp(Expr a, Expr b){
    e1 = a;
    e2 = b;
  }
  public boolean eval(Map<Character, Boolean> env){
    return !(e1.eval(env)) || e2.eval(env);
  }
 
  public String toString(){
    return "(" + e1 + "->" + e2 +")";
  }
}
 
class Var extends Expr {
  public char name;
  Var(char c){
    name =c;
  }
 
  public boolean equals (Var v){
    return name == v.name;
  }
 
  public boolean eval(Map<Character, Boolean> env){
    return env.get(name);
  }
 
  public String toString(){
    return name+"";
  }
}

</source>
</class>

<class classid="9" nclones="2" nlines="41" similarity="100">
<source file="../hum_codes_raw/s007673167.java" startline="1" endline="45" pcid="255">
import java.util.Scanner;

//Rectangular Searching
public class Main{

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int h = sc.nextInt();
			int w = sc.nextInt();
			if((h|w)==0)break;
			char[][] m = new char[h][w];
			for(int i=0;i<h;i++)m[i]=sc.next().toCharArray();
			int[][] c = new int[h][w];
			for(int i=0;i<h;i++){
				int x = 1;
				for(int j=w-1;j>=0;j--){
					if(m[i][j]=='.'){
						c[i][j] = x++;
					}
					else{
						c[i][j] = 0;
						x = 1;
					}
				}
			}
			int max = 0;
			for(int i=0;i<h;i++){
				for(int j=0;j<w;j++){
					if(0<i&&c[i][j]==c[i-1][j]||c[i][j]==0)continue;
					int k = 1;
					int min = c[i][j];
					max = Math.max(max, k*min);
					while(i+k<h&&c[i+k][j]>0){
						min = Math.min(min, c[i+k][j]);
						k++;
						max = Math.max(max, k*min);
					}
				}
			}
			System.out.println(max);
		}
	}
}

</source>
<source file="../hum_codes_raw/s742875524.java" startline="1" endline="45" pcid="24961">
import java.util.Scanner;

//Rectangular Searching
public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int h = sc.nextInt();
			int w = sc.nextInt();
			if((h|w)==0)break;
			char[][] m = new char[h][w];
			for(int i=0;i<h;i++)m[i]=sc.next().toCharArray();
			int[][] c = new int[h][w];
			for(int i=0;i<h;i++){
				int x = 1;
				for(int j=w-1;j>=0;j--){
					if(m[i][j]=='.'){
						c[i][j] = x++;
					}
					else{
						c[i][j] = 0;
						x = 1;
					}
				}
			}
			int max = 0;
			for(int i=0;i<h;i++){
				for(int j=0;j<w;j++){
					if(0<i&&c[i][j]==c[i-1][j]||c[i][j]==0)continue;
					int k = 1;
					int min = c[i][j];
					max = Math.max(max, k*min);
					while(i+k<h&&c[i+k][j]>0){
						min = Math.min(min, c[i+k][j]);
						k++;
						max = Math.max(max, k*min);
					}
				}
			}
			System.out.println(max);
		}
	}
}

</source>
</class>

<class classid="10" nclones="2" nlines="45" similarity="100">
<source file="../hum_codes_raw/s008973744.java" startline="1" endline="56" pcid="296">
import java.util.*;

import javax.xml.crypto.Data;

import java.math.*;

public class Main {
	
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int[] listA = new int[n];
		for(int i = 0; i < n; i++) {
			listA[i] = sc.nextInt() * 3600 + sc.nextInt() * 60;
		}
		int m = sc.nextInt();
		int[] listB = new int[m];
		for(int i = 0; i < m; i++) {
			listB[i] = sc.nextInt() * 3600 + sc.nextInt() * 60;
		}
		int[] list = new int[n + m];
		for(int i = 0; i < n; i++) {
			list[i] = listA[i];
		}
		for(int i = 0; i < m; i++) {
			list[i + n] = listB[i];
		}
		
		Arrays.sort(list);
		int pre = list[0];
		show(pre);
		for(int i = 1; i < n+m; i++) {
			if(list[i] == pre) continue;
			System.out.print(" ");
			show(list[i]);
			pre = list[i];
		}
		System.out.println();
		
	}
	
	static void show(int a) {
		int h = a / 3600;
		System.out.print(h + ":");
		
		a -= h * 3600;
		a /= 60;
		if(a < 10) {
			System.out.print("0");
		}
		System.out.print(a);
	}
	
}

</source>
<source file="../hum_codes_raw/s953865763.java" startline="1" endline="56" pcid="32055">
import java.util.*;
 
import javax.xml.crypto.Data;
 
import java.math.*;
 
public class Main {
     
     
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] listA = new int[n];
        for(int i = 0; i < n; i++) {
            listA[i] = sc.nextInt() * 3600 + sc.nextInt() * 60;
        }
        int m = sc.nextInt();
        int[] listB = new int[m];
        for(int i = 0; i < m; i++) {
            listB[i] = sc.nextInt() * 3600 + sc.nextInt() * 60;
        }
        int[] list = new int[n + m];
        for(int i = 0; i < n; i++) {
            list[i] = listA[i];
        }
        for(int i = 0; i < m; i++) {
            list[i + n] = listB[i];
        }
         
        Arrays.sort(list);
        int pre = list[0];
        show(pre);
        for(int i = 1; i < n+m; i++) {
            if(list[i] == pre) continue;
            System.out.print(" ");
            show(list[i]);
            pre = list[i];
        }
        System.out.println();
         
    }
     
    static void show(int a) {
        int h = a / 3600;
        System.out.print(h + ":");
         
        a -= h * 3600;
        a /= 60;
        if(a < 10) {
            System.out.print("0");
        }
        System.out.print(a);
    }
     
}

</source>
</class>

<class classid="11" nclones="2" nlines="22" similarity="100">
<source file="../hum_codes_raw/s009927387.java" startline="1" endline="26" pcid="326">
import java.util.Scanner;

//Delivery Fee
public class Main{

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int[] s = {60,80,100,120,140,160};
		int[] w = {2,5,10,15,20,25};
		int[] p = {600,800,1000,1200,1400,1600,0};
		while(true){
			int n = sc.nextInt();
			if(n==0)break;
			int t = 0;
			for(int i=0;i<n;i++){
				int size = sc.nextInt()+sc.nextInt()+sc.nextInt();
				int we = sc.nextInt();
				int k = 0;
				while(k<6 && !(size<=s[k]&&we<=w[k]))k++;
				t+=p[k];
			}
			System.out.println(t);
		}
	}
}

</source>
<source file="../hum_codes_raw/s330442435.java" startline="1" endline="25" pcid="11060">
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int[] s = {60,80,100,120,140,160};
		int[] w = {2,5,10,15,20,25};
		int[] p = {600,800,1000,1200,1400,1600,0};
		while(true){
			int n = sc.nextInt();
			if(n==0)break;
			int t = 0;
			for(int i=0;i<n;i++){
				int size = sc.nextInt()+sc.nextInt()+sc.nextInt();
				int we = sc.nextInt();
				int k = 0;
				while(k<6 && !(size<=s[k]&&we<=w[k]))k++;
				t+=p[k];
			}
			System.out.println(t);
		}
	}
}

</source>
</class>

<class classid="12" nclones="2" nlines="16" similarity="100">
<source file="../hum_codes_raw/s010329415.java" startline="1" endline="14" pcid="343">
//Volume5-0543
import java.util.Scanner;
public class Main {
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		while(true){
			int sum = sc.nextInt();
			if(sum==0){break;}
			for(int i=0;i<9;i++){sum -= sc.nextInt();}
			System.out.println(sum);
		}
	}
}

</source>
<source file="../hum_codes_raw/s345660098.java" startline="1" endline="25" pcid="11608">
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		while(true){
			int sum = sc.nextInt();
			
			if(sum == 0){
				break;
			}
			
			for(int i = 0; i < 9; i++){
				sum -= sc.nextInt();
			}
			
			System.out.println(sum);
		}
		
	}

}

</source>
</class>

<class classid="13" nclones="2" nlines="140" similarity="100">
<source file="../hum_codes_raw/s012414151.java" startline="1" endline="151" pcid="424">
import java.io.*;
import java.util.*;
import java.util.Map.Entry;
import java.util.stream.Collectors;

@SuppressWarnings("unused")
public class Main {
	String fileName = "input.txt";
	final boolean isDebug = false;
	//final boolean isDebug = true;
	FastScanner in = new FastScanner(System.in);
	PrintWriter out = new PrintWriter(System.out);
	final int MOD = (int)1e9+7;
	final long INF = Long.MAX_VALUE / 2;
	//final int INF = Integer.MAX_VALUE / 2;
	
	void solve() throws Exception{
		int N = in.nextInt(), K = in.nextInt();
		
		if(K == 0){
			System.out.println((long)N*N);
		}else{
			long ans = 0;
			for(int b = K + 1; b <= N; b++){
				long num = N / b;
				int q = N % b;
				ans += num * (b - K);
				if(q >= K) ans += (q - K + 1);
			}
			System.out.println(ans);
		}
	}
	
	/* end solve */
	
	/* main */
	public static void main(String[] args) throws Exception {
		new Main().m();
	}
	
	void m() throws Exception {
		if(isDebug) in = new FastScanner(new FileInputStream(fileName));
		solve();
		out.flush();
	}
	/* end main */
}
/* end Main */

class FastScanner {
	Reader input;

	FastScanner() {this(System.in);}
	FastScanner(InputStream stream) {this.input = new BufferedReader(new InputStreamReader(stream));}
	
	int nextInt() {return (int) nextLong();}

	long nextLong() {
		try {
			int sign = 1;
			int b = input.read();
			while ((b < '0' || '9' < b) && b != '-' && b != '+') {
				b = input.read();
			}
			if (b == '-') {
				sign = -1;
				b = input.read();
			} else if (b == '+') {
				b = input.read();
			}
			long ret = b - '0';
			while (true) {
				b = input.read();
				if (b < '0' || '9' < b) return ret * sign;
				ret *= 10;
				ret += b - '0';
			}
		} catch (IOException e) {
			e.printStackTrace();
			return -1;
		}
	}

	double nextDouble() {
		try {
			double sign = 1;
			int b = input.read();
			while ((b < '0' || '9' < b) && b != '-' && b != '+') {
				b = input.read();
			}
			if (b == '-') {
				sign = -1;
				b = input.read();
			} else if (b == '+') {
				b = input.read();
			}
			double ret = b - '0';
			while (true) {
				b = input.read();
				if (b < '0' || '9' < b) break;
				ret *= 10;
				ret += b - '0';
			}
			if (b != '.') return sign * ret;
			double div = 1;
			b = input.read();
			while ('0' <= b && b <= '9') {
				ret *= 10;
				ret += b - '0';
				div *= 10;
				b = input.read();
			}
			return sign * ret / div;
		} catch (IOException e) {
			e.printStackTrace();
			return Double.NaN;
		}
	}

	char nextChar() {
		try {
			int b = input.read();
			while (Character.isWhitespace(b)) {
				b = input.read();
			}
			return (char) b;
		} catch (IOException e) {
			e.printStackTrace();
			return 0;
		}
	}

	String nextStr() {
		try {
			StringBuilder sb = new StringBuilder();
			int b = input.read();
			while (Character.isWhitespace(b)) {
				b = input.read();
			}
			while (b != -1 && !Character.isWhitespace(b)) {
				sb.append((char) b);
				b = input.read();
			}
			return sb.toString();
		} catch (IOException e) {
			e.printStackTrace();
			return "";
		}
	}
}

</source>
<source file="../hum_codes_raw/s185507055.java" startline="1" endline="151" pcid="6250">
import java.io.*;
import java.util.*;
import java.util.Map.Entry;
import java.util.stream.Collectors;

@SuppressWarnings("unused")
public class Main {
	String fileName = "input.txt";
	final boolean isDebug = false;
	//final boolean isDebug = true;
	FastScanner in = new FastScanner(System.in);
	PrintWriter out = new PrintWriter(System.out);
	final int MOD = (int)1e9+7;
	final long INF = Long.MAX_VALUE / 2;
	//final int INF = Integer.MAX_VALUE / 2;
	
	void solve() throws Exception{
		int N = in.nextInt(), K = in.nextInt();
		
		if(K == 0){
			System.out.println((long)N*N);
		}else{
			long ans = 0;
			for(int b = K + 1; b <= N; b++){
				long num = N / b;
				int q = N % b;
				ans += num * (b - K);
				if(q >= K) ans += (q - K + 1);
			}
			System.out.println(ans);
		}
	}
	
	/* end solve */
	
	/* main */
	public static void main(String[] args) throws Exception {
		new Main().m();
	}
	
	void m() throws Exception {
		if(isDebug) in = new FastScanner(new FileInputStream(fileName));
		solve();
		out.flush();
	}
	/* end main */
}
/* end Main */

class FastScanner {
	Reader input;

	FastScanner() {this(System.in);}
	FastScanner(InputStream stream) {this.input = new BufferedReader(new InputStreamReader(stream));}
	
	int nextInt() {return (int) nextLong();}

	long nextLong() {
		try {
			int sign = 1;
			int b = input.read();
			while ((b < '0' || '9' < b) && b != '-' && b != '+') {
				b = input.read();
			}
			if (b == '-') {
				sign = -1;
				b = input.read();
			} else if (b == '+') {
				b = input.read();
			}
			long ret = b - '0';
			while (true) {
				b = input.read();
				if (b < '0' || '9' < b) return ret * sign;
				ret *= 10;
				ret += b - '0';
			}
		} catch (IOException e) {
			e.printStackTrace();
			return -1;
		}
	}

	double nextDouble() {
		try {
			double sign = 1;
			int b = input.read();
			while ((b < '0' || '9' < b) && b != '-' && b != '+') {
				b = input.read();
			}
			if (b == '-') {
				sign = -1;
				b = input.read();
			} else if (b == '+') {
				b = input.read();
			}
			double ret = b - '0';
			while (true) {
				b = input.read();
				if (b < '0' || '9' < b) break;
				ret *= 10;
				ret += b - '0';
			}
			if (b != '.') return sign * ret;
			double div = 1;
			b = input.read();
			while ('0' <= b && b <= '9') {
				ret *= 10;
				ret += b - '0';
				div *= 10;
				b = input.read();
			}
			return sign * ret / div;
		} catch (IOException e) {
			e.printStackTrace();
			return Double.NaN;
		}
	}

	char nextChar() {
		try {
			int b = input.read();
			while (Character.isWhitespace(b)) {
				b = input.read();
			}
			return (char) b;
		} catch (IOException e) {
			e.printStackTrace();
			return 0;
		}
	}

	String nextStr() {
		try {
			StringBuilder sb = new StringBuilder();
			int b = input.read();
			while (Character.isWhitespace(b)) {
				b = input.read();
			}
			while (b != -1 && !Character.isWhitespace(b)) {
				sb.append((char) b);
				b = input.read();
			}
			return sb.toString();
		} catch (IOException e) {
			e.printStackTrace();
			return "";
		}
	}
}

</source>
</class>

<class classid="14" nclones="2" nlines="39" similarity="100">
<source file="../hum_codes_raw/s018327802.java" startline="1" endline="39" pcid="619">
import java.util.*;
public class Main {
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		int day=sc.nextInt(),n=sc.nextInt();//入力
		int[] high=new int[day];
		for(int i=0;i<day;i++){
			high[i]=sc.nextInt();
		}
		int[] ht=new int[n];
		int[] lt=new int[n];
		int[] loud=new int[n];
		for(int i=0;i<n;i++){
			lt[i]=sc.nextInt();ht[i]=sc.nextInt();loud[i]=sc.nextInt();
		}//入力
		
		int[][] dp=new int[day][n];
		for(int i=0;i<day;i++){
			for(int j=0;j<n;j++){
				dp[i][j] = 0;
			}
		}
		int ans=0;
		for(int i=1;i<day;i++){
			for(int j=0;j<n;j++){
				if(lt[j]<=high[i]&&high[i]<=ht[j]);
				else continue;
				for(int k=0;k<n;k++){
					if(lt[k]<=high[i-1]&&high[i-1]<=ht[k]);
					else continue;
					dp[i][j]=Math.max(dp[i][j],Math.abs(loud[j]-loud[k]) + dp[i-1][k]);
					ans=Math.max(ans,dp[i][j]);
				}
			}	
		}	
		System.out.println(ans);
	}
}

</source>
<source file="../hum_codes_raw/s975590468.java" startline="1" endline="39" pcid="32830">
import java.util.*;
public class Main {
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		int day=sc.nextInt(),n=sc.nextInt();//入力
		int[] high=new int[day];
		for(int i=0;i<day;i++){
			high[i]=sc.nextInt();
		}
		int[] ht=new int[n];
		int[] lt=new int[n];
		int[] loud=new int[n];
		for(int i=0;i<n;i++){
			lt[i]=sc.nextInt();ht[i]=sc.nextInt();loud[i]=sc.nextInt();
		}//入力
		
		int[][] dp=new int[day][n];
		for(int i=0;i<day;i++){//派手さの絶対値の初期値を入力
			for(int j=0;j<n;j++){
				dp[i][j] = 0;
			}
		}
		int ans=0;
		for(int i=1;i<day;i++){//日数-1分ループ
			for(int j=0;j<n;j++){//i日目に適した服の数実行
				if(lt[j]<=high[i]&&high[i]<=ht[j]);//適温の判定
				else continue;
				for(int k=0;k<n;k++){//i-1日目に適した服の数実行
					if(lt[k]<=high[i-1]&&high[i-1]<=ht[k]);//適温の判定
					else continue;
					dp[i][j]=Math.max(dp[i][j],Math.abs(loud[j]-loud[k])+dp[i-1][k]);//
					ans=Math.max(ans,dp[i][j]);
				}
			}	
		}	
		System.out.println(ans);
	}
}

</source>
</class>

<class classid="15" nclones="2" nlines="112" similarity="100">
<source file="../hum_codes_raw/s018652122.java" startline="1" endline="128" pcid="635">
public class Main {
	MyScanner sc = new MyScanner();
	int N, M, a, b, w;
	int[] parent;
	Node[] node;

	void run() {
		for (;;) {
			N = sc.nextInt(); // 荷物数
			M = sc.nextInt(); // クエリ数
			if ((N | M) == 0) {
				return;
			}
			parent = new int[N + 1];
			node = new Node[N + 1];
			init();

			for (int i = 0; i < M; i++) {
				String query = sc.next();
				a = sc.nextInt();
				b = sc.nextInt();
				if (query.equals("!")) {
					w = sc.nextInt();
					union(a, b, w);
				} else if (query.equals("?")) {
					System.out.println(same(a, b) ? node[b].weight
							- node[a].weight : "UNKNOWN");
				}
			}
		}
	}

	void init() {
		for (int i = 0; i <= N; i++) {
			parent[i] = i;
			node[i] = new Node(0, 0);
		}
	}

	void union(int x, int y, int w) {
		int rootX = find(x);
		int rootY = find(y);
		if (rootX == rootY) {
			return;
		}
		if (node[rootX].rank < node[rootY].rank) {
			node[rootX].weight = -w - node[x].weight + node[y].weight;
			parent[rootX] = rootY;
		} else {
			node[rootY].weight = w - node[y].weight + node[x].weight;
			parent[rootY] = rootX;

			if (node[rootX].rank == node[rootY].rank) {
				node[rootX].rank++;
			}
		}
	}

	int find(int target) {
		if (parent[target] == target) {
			return target;
		} else {
			int tmp = find(parent[target]);
			node[target].weight += node[parent[target]].weight;
			return parent[target] = tmp;
		}
	}

	boolean same(int x, int y) {
		return find(x) == find(y);
	}

	class Node {
		int weight;
		int rank;

		/**
		 * @param weight
		 * @param rank
		 */
		public Node(int weight, int rank) {
			super();
			this.weight = weight;
			this.rank = rank;
		}
	}

	public static void main(String[] args) {
		new Main().run();
	}

	class MyScanner {
		int nextInt() {
			try {
				int c = System.in.read();
				while (c != '-' && (c < '0' || '9' < c))
					c = System.in.read();
				if (c == '-')
					return -nextInt();
				int res = 0;
				do {
					res *= 10;
					res += c - '0';
					c = System.in.read();
				} while ('0' <= c && c <= '9');
				return res;
			} catch (Exception e) {
				return -1;
			}
		}

		String next() {
			try {
				StringBuilder res = new StringBuilder("");
				int c = System.in.read();
				while (Character.isWhitespace(c))
					c = System.in.read();
				do {
					res.append((char) c);
				} while (!Character.isWhitespace(c = System.in.read()));
				return res.toString();
			} catch (Exception e) {
				return null;
			}
		}
	}
}

</source>
<source file="../hum_codes_raw/s413172553.java" startline="1" endline="128" pcid="13893">
public class Main {
	MyScanner sc = new MyScanner();
	int N, M, a, b, w;
	int[] parent;
	Node[] node;

	void run() {
		for (;;) {
			N = sc.nextInt(); // 荷物数
			M = sc.nextInt(); // クエリ数
			if ((N | M) == 0) {
				return;
			}
			parent = new int[N + 1];
			node = new Node[N + 1];
			init();

			for (int i = 0; i < M; i++) {
				String query = sc.next();
				a = sc.nextInt();
				b = sc.nextInt();
				if (query.equals("!")) {
					w = sc.nextInt();
					union(a, b, w);
				} else if (query.equals("?")) {
					System.out.println(same(a, b) ? node[b].weight
							- node[a].weight : "UNKNOWN");
				}
			}
		}
	}

	void init() {
		for (int i = 0; i <= N; i++) {
			parent[i] = i;
			node[i] = new Node(0, 0);
		}
	}

	void union(int x, int y, int w) {
		int rootX = find(x);
		int rootY = find(y);
		if (rootX == rootY) {
			return;
		}
		if (node[rootX].rank < node[rootY].rank) {
			node[rootX].weight = -w - node[x].weight + node[y].weight;
			parent[rootX] = rootY;
		} else {
			node[rootY].weight = w - node[y].weight + node[x].weight;
			parent[rootY] = rootX;

			if (node[rootX].rank == node[rootY].rank) {
				node[rootX].rank++;
			}
		}
	}

	int find(int target) {
		if (parent[target] == target) {
			return target;
		} else {
			int tmp = find(parent[target]);
			node[target].weight += node[parent[target]].weight;
			return parent[target] = tmp;
		}
	}

	boolean same(int x, int y) {
		return find(x) == find(y);
	}

	class Node {
		int weight;
		int rank;

		/**
		 * @param weight
		 * @param rank
		 */
		public Node(int weight, int rank) {
			super();
			this.weight = weight;
			this.rank = rank;
		}
	}

	public static void main(String[] args) {
		new Main().run();
	}

	class MyScanner {
		int nextInt() {
			try {
				int c = System.in.read();
				while (c != '-' && (c < '0' || '9' < c))
					c = System.in.read();
				if (c == '-')
					return -nextInt();
				int res = 0;
				do {
					res *= 10;
					res += c - '0';
					c = System.in.read();
				} while ('0' <= c && c <= '9');
				return res;
			} catch (Exception e) {
				return -1;
			}
		}

		String next() {
			try {
				StringBuilder res = new StringBuilder("");
				int c = System.in.read();
				while (Character.isWhitespace(c))
					c = System.in.read();
				do {
					res.append((char) c);
				} while (!Character.isWhitespace(c = System.in.read()));
				return res.toString();
			} catch (Exception e) {
				return null;
			}
		}
	}
}

</source>
</class>

<class classid="16" nclones="2" nlines="16" similarity="100">
<source file="../hum_codes_raw/s020151971.java" startline="1" endline="30" pcid="693">
import java.util.Scanner;

public class Main {

	// ????????????10??????
	public static int LOAN = 100000;

	public static void main(String[] args) {

		// ???????????????
		@SuppressWarnings("resource")
		Scanner sc = new Scanner(System.in);
		int input = sc.nextInt();
		double result = LOAN;

		// ?????±??????????¨????
		for (int i = 0; input > i; i++) {

			// ??????????????????
			result = result * 1.05;

			// 1000??§?????????????????\??????????????????
			result = Math.ceil(result / 1000);
			// ?????????????????????
			result = result * 1000;
		}
		System.out.println((int) result);
	}
}

</source>
<source file="../hum_codes_raw/s111684299.java" startline="1" endline="30" pcid="3720">
import java.util.Scanner;

public class Main{

	// 借金額：10万円
	public static int LOAN = 100000;

	public static void main(String[] args) {

		// インプット
		@SuppressWarnings("resource")
		Scanner sc = new Scanner(System.in);
		int input = sc.nextInt();
		double result = LOAN;

		// 一週間ずつ計算
		for (int i = 0; input > i; i++) {

			// 利子を加える
			result = result * 1.05;

			// 1000で割り、千円以下を切り上げ
			result = Math.ceil(result / 1000);
			// 金額を元に戻す
			result = result * 1000;
		}
		System.out.println((int) result);
	}
}

</source>
</class>

<class classid="17" nclones="2" nlines="49" similarity="100">
<source file="../hum_codes_raw/s022887755.java" startline="1" endline="48" pcid="780">
import java.io.*;
class Main {
    public static void main(String[] args) {
        try {
                BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
            String str = br.readLine();
            int n = Integer.parseInt(str.split(" ")[0]);
            int k = Integer.parseInt(str.split(" ")[1]);
            int[] nimotu = new int[n];
            int totalWeight = 0;
            for (int i = 0; i < n; i++) {
                nimotu[i] = Integer.parseInt(br.readLine());
                totalWeight += nimotu[i];
            }
            int aver = totalWeight / k;
            int maxweight = aver;
            int tracknum;
            while(maxweight <= totalWeight){
                int weight = 0;
                tracknum = 1;
                boolean flg = true;
                for(int i = 0;i < n && tracknum <= k;) {
                    if(weight + nimotu[i] <= maxweight){
                        weight += nimotu[i];
                        i++;
                    } else if(weight > 0){
                        if(maxweight < weight){
                            maxweight = weight;
                        }
                        weight = 0;
                        tracknum++;
                    } else {
                        flg = false;
                        break;
                    }
                }
                if(tracknum <= k && flg){
                    System.out.println(maxweight);
                    break;
                }
                maxweight++;
            }
        } catch (IOException e) {
            System.out.println("error");
        }
    }
}

</source>
<source file="../hum_codes_raw/s191365573.java" startline="1" endline="66" pcid="6443">
import java.io.*;

class Main {
	public static void main(String[] args) {
		// BufferedReader br = new BufferedReader(new
		// InputStreamReader(System.in));
		try {
		        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
			String str = br.readLine();
			// n:???????????°???k:?????????????????°
			int n = Integer.parseInt(str.split(" ")[0]);
			int k = Integer.parseInt(str.split(" ")[1]);
			// ?????????????´?????????????
			int[] nimotu = new int[n];
			// ??¨????????????????????????????¨?????????????
			int totalWeight = 0;
			// ??????????????????????´????????????????????±???????
			for (int i = 0; i < n; i++) {
				nimotu[i] = Integer.parseInt(br.readLine());
				totalWeight += nimotu[i];
			}
			// ???????????????????±???????
			int aver = totalWeight / k;
			int maxweight = aver;
			int tracknum;
			while(maxweight <= totalWeight){
				//if(limit == 1)break;
				int weight = 0;
				tracknum = 1;
				boolean flg = true;
				// ???????????????????¶???????????????????????????????????????????
				for(int i = 0;i < n && tracknum <= k;) {
					// ????????????????????????????????°?????????
					if(weight + nimotu[i] <= maxweight){
						weight += nimotu[i];
						i++;
					//??????????????????????????????????????????????????£?????????????????°?¬????
					} else if(weight > 0){
						if(maxweight < weight){
							maxweight = weight;
						}
						weight = 0;
						tracknum++;
					//??????????????¨????¨??????§??????????????????????????????????????°?¬????
					} else {
						flg = false;
						break;
					}
				}
				/* ???????????¶
				 * 1.tracknum = k?????¨??????????????????????????¨?????????????????¨
				 * 2.flg = true????????¨?????????????????????????????????????????¨
				*/
				if(tracknum <= k && flg){
					System.out.println(maxweight);
					break;
				}
				// ?????????????????´?????????????????????????¬????
				maxweight++;
			}
		} catch (IOException e) {
			System.out.println("error");
		}
	}
}

</source>
</class>

<class classid="18" nclones="2" nlines="143" similarity="100">
<source file="../hum_codes_raw/s023291288.java" startline="1" endline="165" pcid="797">
import java.io.*;
import java.util.*;

public class Main {

    private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));    
	private static StringTokenizer st;

    public static void main ( String [] args ) throws IOException
    {

	int h,w,s;

	while(true){
	
		st = new StringTokenizer(br.readLine());
		h = Integer.parseInt(st.nextToken());
		w = Integer.parseInt(st.nextToken());
		s = Integer.parseInt(st.nextToken());
		if( h == 0 && w == 0 && s == 0)	break;
	    new Main().cal(h,w,s);
	}
	
    }


int min;
int[][] area;
int[][][][] sumArea;
int[][] basicSum;
int[][][][] grouparray;
int[][][][] minDep;

    private void cal(int h, int w, int s) throws IOException 
    {
	int areaSum = 0;
	area = new int[h][w];
	grouparray = new int[h][w][h][w];
	minDep =new int[h][w][h][w];
	for(int i=0; i < h; i++){
		st = new StringTokenizer(br.readLine());
		for(int j=0; j < w; j++){
			area[i][j] = Integer.parseInt(st.nextToken());
			areaSum += area[i][j];
		}
	}
	calBasicSum(h,w);
	calSum(h,w);

	//cal max
	min = areaSum - s;
	int[] out = grouping(0,0,h-1,w-1);

	System.out.println(out[0]+" "+(out[1]-min));

    }


    private int[] grouping(int hs, int ws, int hl, int wl){
	int[] ret = new int[2];
	if( grouparray[hs][ws][hl][wl] != -1 ){
		ret[0] = grouparray[hs][ws][hl][wl];
		ret[1] = minDep[hs][ws][hl][wl];
		return ret;
	}
	grouparray[hs][ws][hl][wl] = 0;
	ret[0] = 1;
	ret[1] = sumArea[hs][ws][hl][wl];
	int[] tmp = new int[2];
	int grptmp;
	int tempDep;

	//&#44032;&#47196;&#47196; &#51900;&#44060;&#44592;
	for(int i = hs; i < hl; i++){
		if(sumArea[hs][ws][i][wl] < min){
			continue;
		}
		if(sumArea[i+1][ws][hl][wl] < min){
			break;
		}
		tmp = grouping(hs, ws, i, wl);
		grptmp = tmp[0];
		tempDep = tmp[1];

		tmp = grouping(i+1, ws, hl, wl);
		grptmp += tmp[0];
		if( tempDep < tmp[1] ){ tmp[1] = tempDep; }

		if( grptmp > ret[0] ){ ret[0] = grptmp; ret[1] = tmp[1]; }
		if( grptmp == ret[0] && tmp[1] > ret[1] ){ ret[1] = tmp[1]; }
	}
	//&#49464;&#47196;&#47196; &#51900;&#44060;&#44592;
	for(int i = ws; i < wl; i++){
		if(sumArea[hs][ws][hl][i] < min){
			continue;
		}
		if(sumArea[hs][i+1][hl][wl] < min){
			break;
		}
		tmp = grouping(hs, ws, hl, i);
		grptmp = tmp[0];
		tempDep = tmp[1];

		tmp = grouping(hs, i+1, hl, wl);
		grptmp += tmp[0];

		if( tempDep < tmp[1] ){ tmp[1] = tempDep; }

		if( grptmp > ret[0] ){ ret[0] = grptmp; ret[1] = tmp[1]; }
		if( grptmp == ret[0] && tmp[1] > ret[1] ){ ret[1] = tmp[1]; }

	}

	grouparray[hs][ws][hl][wl] = ret[0];
	minDep[hs][ws][hl][wl] = ret[1];
	return ret;
	
    }


   private void calBasicSum(int h, int w){
	basicSum = new int[h][w];
	basicSum[0][0] = area[0][0];
	for(int j = 1; j < w; j++){
		basicSum[0][j] = basicSum[0][j-1] + area[0][j];
	}
	for(int i = 1; i < h; i++){
		basicSum[i][0] = basicSum[i-1][0] + area[i][0];
	}
	for(int i = 1; i < h; i++){
		for(int j=1; j < w; j++){
			basicSum[i][j] = basicSum[i][j-1] + basicSum[i-1][j] + area[i][j] - basicSum[i-1][j-1];
		}
	}
   }

   private void calSum(int h, int w ){
	sumArea = new int[h][w][h][w];

	for(int i = 0; i < h; i++){
	for(int j = 0; j < w; j++){
		for(int l = i; l < h; l++){
		for(int k = j; k < w; k++){
			grouparray[i][j][l][k] = -1;
			if( i == 0 && j ==0 ){
				sumArea[0][0][l][k] = basicSum[l][k];
			}
			else if( i == 0 ){
				sumArea[0][j][l][k] = basicSum[l][k] - basicSum[l][j-1];
			}
			else if( j == 0 ){
				sumArea[i][0][l][k] = basicSum[l][k] - basicSum[i-1][k];
			}
			else{
				sumArea[i][j][l][k] = basicSum[l][k] - basicSum[l][j-1] - basicSum[i-1][k] + basicSum[i-1][j-1];
			}
		}
		}
	}
	}
   }


}

</source>
<source file="../hum_codes_raw/s226173606.java" startline="1" endline="163" pcid="7646">
import java.io.*;
import java.util.*;

public class Main {

    private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));    
	private static StringTokenizer st;

    public static void main ( String [] args ) throws IOException
    {

	int h,w,s;

	while(true){
	
		st = new StringTokenizer(br.readLine());
		h = Integer.parseInt(st.nextToken());
		w = Integer.parseInt(st.nextToken());
		s = Integer.parseInt(st.nextToken());
		if( h == 0 && w == 0 && s == 0)	break;
	    new Main().cal(h,w,s);
	}
	
    }


int min;
int[][] area;
int[][][][] sumArea;
int[][] basicSum;
int[][][][] grouparray;
int[][][][] minDep;

    private void cal(int h, int w, int s) throws IOException 
    {
	int areaSum = 0;
	area = new int[h][w];
	grouparray = new int[h][w][h][w];
	minDep =new int[h][w][h][w];
	for(int i=0; i < h; i++){
		st = new StringTokenizer(br.readLine());
		for(int j=0; j < w; j++){
			area[i][j] = Integer.parseInt(st.nextToken());
			areaSum += area[i][j];
		}
	}
	calBasicSum(h,w);
	calSum(h,w);

	//cal max
	min = areaSum - s;
	int[] out = grouping(0,0,h-1,w-1);

	System.out.println(out[0]+" "+(out[1]-min));

    }


    private int[] grouping(int hs, int ws, int hl, int wl){
	int[] ret = new int[2];
	if( grouparray[hs][ws][hl][wl] != -1 ){
		ret[0] = grouparray[hs][ws][hl][wl];
		ret[1] = minDep[hs][ws][hl][wl];
		return ret;
	}
	grouparray[hs][ws][hl][wl] = 0;
	ret[0] = 1;
	ret[1] = sumArea[hs][ws][hl][wl];
	int[] tmp = new int[2];
	int grptmp;
	int tempDep;

	for(int i = hs; i < hl; i++){
		if(sumArea[hs][ws][i][wl] < min){
			continue;
		}
		if(sumArea[i+1][ws][hl][wl] < min){
			break;
		}
		tmp = grouping(hs, ws, i, wl);
		grptmp = tmp[0];
		tempDep = tmp[1];

		tmp = grouping(i+1, ws, hl, wl);
		grptmp += tmp[0];
		if( tempDep < tmp[1] ){ tmp[1] = tempDep; }

		if( grptmp > ret[0] ){ ret[0] = grptmp; ret[1] = tmp[1]; }
		if( grptmp == ret[0] && tmp[1] > ret[1] ){ ret[1] = tmp[1]; }
	}
	for(int i = ws; i < wl; i++){
		if(sumArea[hs][ws][hl][i] < min){
			continue;
		}
		if(sumArea[hs][i+1][hl][wl] < min){
			break;
		}
		tmp = grouping(hs, ws, hl, i);
		grptmp = tmp[0];
		tempDep = tmp[1];

		tmp = grouping(hs, i+1, hl, wl);
		grptmp += tmp[0];

		if( tempDep < tmp[1] ){ tmp[1] = tempDep; }

		if( grptmp > ret[0] ){ ret[0] = grptmp; ret[1] = tmp[1]; }
		if( grptmp == ret[0] && tmp[1] > ret[1] ){ ret[1] = tmp[1]; }

	}

	grouparray[hs][ws][hl][wl] = ret[0];
	minDep[hs][ws][hl][wl] = ret[1];
	return ret;
	
    }


   private void calBasicSum(int h, int w){
	basicSum = new int[h][w];
	basicSum[0][0] = area[0][0];
	for(int j = 1; j < w; j++){
		basicSum[0][j] = basicSum[0][j-1] + area[0][j];
	}
	for(int i = 1; i < h; i++){
		basicSum[i][0] = basicSum[i-1][0] + area[i][0];
	}
	for(int i = 1; i < h; i++){
		for(int j=1; j < w; j++){
			basicSum[i][j] = basicSum[i][j-1] + basicSum[i-1][j] + area[i][j] - basicSum[i-1][j-1];
		}
	}
   }

   private void calSum(int h, int w ){
	sumArea = new int[h][w][h][w];

	for(int i = 0; i < h; i++){
	for(int j = 0; j < w; j++){
		for(int l = i; l < h; l++){
		for(int k = j; k < w; k++){
			grouparray[i][j][l][k] = -1;
			if( i == 0 && j ==0 ){
				sumArea[0][0][l][k] = basicSum[l][k];
			}
			else if( i == 0 ){
				sumArea[0][j][l][k] = basicSum[l][k] - basicSum[l][j-1];
			}
			else if( j == 0 ){
				sumArea[i][0][l][k] = basicSum[l][k] - basicSum[i-1][k];
			}
			else{
				sumArea[i][j][l][k] = basicSum[l][k] - basicSum[l][j-1] - basicSum[i-1][k] + basicSum[i-1][j-1];
			}
		}
		}
	}
	}
   }


}

</source>
</class>

<class classid="19" nclones="2" nlines="111" similarity="100">
<source file="../hum_codes_raw/s027059550.java" startline="1" endline="117" pcid="898">
import java.io.IOException;
import java.io.InputStream;
import java.util.NoSuchElementException;
public class Main {
    public static void main(String[] args) {
       FS fs = new FS();
        int n = fs.nextInt();
        int a[] = new int[n];
        int max= Integer.MIN_VALUE;
        int min =Integer.MAX_VALUE;
        for(int i =0;i<n;i++){
            a[i]=fs.nextInt();
            if (a[i]>max)max=a[i];
            if (a[i]<min)min=a[i];
        }
        int mm = max - min + 1;
        int[] b = new int[mm];
        for(int i=0;i<n;i++){
            b[a[i]-min]++;
        }
        for (int i=1;i<mm;i++){
            b[i]+=b[i-1];
        }
        int[] c = new int[n];
        for (int i=n-1;i>=0;i--){
             c[b[a[i]-min]-1]=a[i];
             b[a[i]-min]--;
        }
        StringBuilder sb= new StringBuilder();
        for(int i=0;i<n;i++){
            sb.append(c[i]+" ");
        }
        sb.deleteCharAt(sb.length()-1);
        System.out.println(sb.toString());
    }
   static class FS {
    private final InputStream in = System.in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        } else {
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }

    private int readByte() {
        return hasNextByte() ? buffer[ptr++] : -1;
    }

    private boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }

    private void skipUnprintable() {
        while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
    }

    public boolean hasNext() {
        skipUnprintable();
        return hasNextByte();
    }

    public String next() {
        if (!hasNext()) throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while (isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }

    public int nextInt() {
        return (int) nextLong();
    }

    public long nextLong() {
        if (!hasNext()) throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                n *= 10;
                n += b - '0';
            } else if (b == -1 || !isPrintableChar(b)) {
                return minus ? -n : n;
            } else {
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
}
}

</source>
<source file="../hum_codes_raw/s132834697.java" startline="1" endline="117" pcid="4430">
import java.io.IOException;
import java.io.InputStream;
import java.util.NoSuchElementException;
public class Main {
    public static void main(String[] args) {
       FS fs = new FS();
        int n = fs.nextInt();
        int a[] = new int[n];
        int max= Integer.MIN_VALUE;
        int min =Integer.MAX_VALUE;
        for(int i =0;i<n;i++){
            a[i]=fs.nextInt();
            if (a[i]>max)max=a[i];
            if (a[i]<min)min=a[i];
        }
        int mm = max - min + 1;
        int[] b = new int[mm];
        for(int i=0;i<n;i++){
            b[a[i]-min]++;
        }
        for (int i=1;i<mm;i++){
            b[i]+=b[i-1];
        }
        int[] c = new int[n];
        for (int i=n-1;i>=0;i--){
             c[b[a[i]-min]-1]=a[i];
             b[a[i]-min]--;
        }
        StringBuilder sb= new StringBuilder();
        for(int i=0;i<n;i++){
            sb.append(c[i]+" ");
        }
        sb.deleteCharAt(sb.length()-1);
        System.out.println(sb.toString());
    }
   static class FS {
    private final InputStream in = System.in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        } else {
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }

    private int readByte() {
        return hasNextByte() ? buffer[ptr++] : -1;
    }

    private boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }

    private void skipUnprintable() {
        while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
    }

    public boolean hasNext() {
        skipUnprintable();
        return hasNextByte();
    }

    public String next() {
        if (!hasNext()) throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while (isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }

    public int nextInt() {
        return (int) nextLong();
    }

    public long nextLong() {
        if (!hasNext()) throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                n *= 10;
                n += b - '0';
            } else if (b == -1 || !isPrintableChar(b)) {
                return minus ? -n : n;
            } else {
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
}
}

</source>
</class>

<class classid="20" nclones="2" nlines="34" similarity="100">
<source file="../hum_codes_raw/s029203789.java" startline="1" endline="37" pcid="968">
import java.util.BitSet;
import java.util.HashMap;
import java.util.Scanner;
 
public class Main{
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        BitSet gdp = gdp(300000);
        while(true){
            int n = in.nextInt();
            if(n == 1) return;
            StringBuilder sb = new StringBuilder();
            sb.append(n+": ");
            for(int i=gdp.nextSetBit(0); i!=-1 && i<=n; i=gdp.nextSetBit(i+1)){
                if(n%i==0) sb.append(i+" ");
            }
            System.out.println(sb.toString().trim());
        }
    }
     
    public static BitSet gdp(int max){
        BitSet gdn = new BitSet(max+1);
        for(int i=1; i<=max; i++){
            int mod = i%7;
            if(mod == 6 || mod == 1) gdn.set(i);
        }
        BitSet gdp = (BitSet)gdn.clone();
        gdp.clear(1);
        for(int i=gdn.nextSetBit(2); i!=-1; i=gdn.nextSetBit(i+1)){
            for(long j=gdn.nextSetBit(2); j!=-1 && j*i<=max; j=gdn.nextSetBit((int)j+1)){
                gdp.clear((int)j*i);
            }
        }
        return gdp;
    }
}

</source>
<source file="../hum_codes_raw/s904246863.java" startline="1" endline="37" pcid="30430">
import java.util.BitSet;
import java.util.HashMap;
import java.util.Scanner;
 
public class Main{
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        BitSet gdp = gdp(300000);
        while(true){
            int n = in.nextInt();
            if(n == 1) return;
            StringBuilder sb = new StringBuilder();
            sb.append(n+": ");
            for(int i=gdp.nextSetBit(0); i!=-1 && i<=n; i=gdp.nextSetBit(i+1)){
                if(n%i==0) sb.append(i+" ");
            }
            System.out.println(sb.toString().trim());
        }
    }
     
    public static BitSet gdp(int max){
        BitSet gdn = new BitSet(max+1);
        for(int i=1; i<=max; i++){
            int mod = i%7;
            if(mod == 6 || mod == 1) gdn.set(i);
        }
        BitSet gdp = (BitSet)gdn.clone();
        gdp.clear(1);
        for(int i=gdn.nextSetBit(2); i!=-1; i=gdn.nextSetBit(i+1)){
            for(long j=gdn.nextSetBit(2); j!=-1 && j*i<=max; j=gdn.nextSetBit((int)j+1)){
                gdp.clear((int)j*i);
            }
        }
        return gdp;
    }
}

</source>
</class>

<class classid="21" nclones="2" nlines="67" similarity="100">
<source file="../hum_codes_raw/s030330886.java" startline="1" endline="88" pcid="1002">
import java.io.*;
import java.util.*;
 
public class Main {
	static Scanner sc = new Scanner(System.in);
	static PrintWriter out = new PrintWriter(System.out);
 
	public static void main(String[] args) throws Exception {
		int n = sc.nextInt();
		long arr[] = new long[n], xor = 0;
		
		for(int i = 0; i < n; i++) {
			arr[i] = sc.nextLong();
			xor ^= i < 2 ? 0 : arr[i];
		}
		
		long sum = arr[0] + arr[1];
		long and = (sum - xor) >> 1;
		long a = 0, b = 0;
		
		for(int i = 60; i >= 0; i--) {
			boolean xi = (xor & (1L << i)) > 0;
			boolean ai = (and & (1L << i)) > 0;
			
			if(!xi && ai) {
				a |= 1L << i;
				b |= 1L << i;
			}
		}
		
		
		for(int i = 60; i >= 0; i--) {
			boolean xi = (xor & (1L << i)) > 0;
			boolean ai = (and & (1L << i)) > 0;
			
			if(xi && !ai) {
				if((a | 1L << i) <= arr[0]) {
					a |= 1L << i;
				}else {
					b |= 1L << i;
				}
			}
		}
		
		boolean flag = (a + b) == sum && (a ^ b) == xor;
		flag &= a >= 1 && a <= arr[0] && b >= arr[1];
		
		out.println(flag ? arr[0] - a : -1);
		out.close();
	}
 
}
 
class Scanner {
	StringTokenizer st;
	BufferedReader br;
 
	public Scanner(InputStream system) {
		br = new BufferedReader(new InputStreamReader(system));
	}
 
	public Scanner(String file) throws Exception {
		br = new BufferedReader(new FileReader(file));
	}
 
	public String next() throws IOException {
		while (st == null || !st.hasMoreTokens())
			st = new StringTokenizer(br.readLine());
		return st.nextToken();
	}
 
	public String nextLine() throws IOException {
		return br.readLine();
	}
 
	public int nextInt() throws IOException {
		return Integer.parseInt(next());
	}
 
	public double nextDouble() throws IOException {
		return Double.parseDouble(next());
	}
 
	public Long nextLong() throws IOException {
		return Long.parseLong(next());
	}
}

</source>
<source file="../hum_codes_raw/s488982935.java" startline="1" endline="88" pcid="16426">
import java.io.*;
import java.util.*;

public class Main {
	static Scanner sc = new Scanner(System.in);
	static PrintWriter out = new PrintWriter(System.out);

	public static void main(String[] args) throws Exception {
		int n = sc.nextInt();
		long arr[] = new long[n], xor = 0;
		
		for(int i = 0; i < n; i++) {
			arr[i] = sc.nextLong();
			xor ^= i < 2 ? 0 : arr[i];
		}
		
		long sum = arr[0] + arr[1];
		long and = (sum - xor) >> 1;
		long a = 0, b = 0;
		
		for(int i = 60; i >= 0; i--) {
			boolean xi = (xor & (1L << i)) > 0;
			boolean ai = (and & (1L << i)) > 0;
			
			if(!xi && ai) {
				a |= 1L << i;
				b |= 1L << i;
			}
		}
		
		
		for(int i = 60; i >= 0; i--) {
			boolean xi = (xor & (1L << i)) > 0;
			boolean ai = (and & (1L << i)) > 0;
			
			if(xi && !ai) {
				if((a | 1L << i) <= arr[0]) {
					a |= 1L << i;
				}else {
					b |= 1L << i;
				}
			}
		}
		
		boolean flag = (a + b) == sum && (a ^ b) == xor;
		flag &= a >= 1 && a <= arr[0] && b >= arr[1];
		
		out.println(flag ? arr[0] - a : -1);
		out.close();
	}

}

class Scanner {
	StringTokenizer st;
	BufferedReader br;

	public Scanner(InputStream system) {
		br = new BufferedReader(new InputStreamReader(system));
	}

	public Scanner(String file) throws Exception {
		br = new BufferedReader(new FileReader(file));
	}

	public String next() throws IOException {
		while (st == null || !st.hasMoreTokens())
			st = new StringTokenizer(br.readLine());
		return st.nextToken();
	}

	public String nextLine() throws IOException {
		return br.readLine();
	}

	public int nextInt() throws IOException {
		return Integer.parseInt(next());
	}

	public double nextDouble() throws IOException {
		return Double.parseDouble(next());
	}

	public Long nextLong() throws IOException {
		return Long.parseLong(next());
	}
}

</source>
</class>

<class classid="22" nclones="5" nlines="10" similarity="100">
<source file="../hum_codes_raw/s031103200.java" startline="1" endline="17" pcid="1029">

import java.util.Scanner;

class Main {

    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int p = scan.nextInt();
        int m = scan.nextInt();
        int c = scan.nextInt();
        System.out.println(p + m + c);

    }

}


</source>
<source file="../hum_codes_raw/s465667606.java" startline="1" endline="16" pcid="15628">
import java.util.Scanner;

class Main {

    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int p = scan.nextInt();
        int m = scan.nextInt();
        int c = scan.nextInt();
        
        System.out.println(p+m+c);
        }

    }


</source>
<source file="../hum_codes_raw/s327150544.java" startline="1" endline="20" pcid="10951">

import java.util.Scanner;

class Main {

    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int p = scan.nextInt();
        int m = scan.nextInt();
        int c = scan.nextInt();
        System.out.println(p+m+c);
        
        
        }
        
    }




</source>
<source file="../hum_codes_raw/s720895574.java" startline="1" endline="17" pcid="24229">

import java.util.Scanner;

class Main {

    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int p = scan.nextInt();
        int m = scan.nextInt();
        int c = scan.nextInt();

        System.out.println(p + m + c);

    }
}


</source>
<source file="../hum_codes_raw/s110992293.java" startline="1" endline="19" pcid="3688">
import java.util.Scanner;

class Main {

    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int p = scan.nextInt();
        int m = scan.nextInt();
        int c = scan.nextInt();
        
       System.out.println(p+m+c);
       
       
           }
        
    }



</source>
</class>

<class classid="23" nclones="2" nlines="67" similarity="100">
<source file="../hum_codes_raw/s031315623.java" startline="1" endline="70" pcid="1042">
import java.util.*;

class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(true){
        int h = scanner.nextInt();
        int w = scanner.nextInt();
        if(h == 0 && w == 0){
            break;
        }
        int[][] yard = new int[h][w];
        int max = 0;
        int cap = 0;
        int lakemax = 0;
        int yardmin = 10;
        int flag = 0;
        int cap1 = 0;
        for(int i = 0;i<h;i++){
            for(int j = 0;j<w;j++){
                yard[i][j] = scanner.nextInt();
            }
        }

        for(int i = 3;i <= h;i++){
            for(int j = 3;j<=w;j++){
                for(int h_start = 0;h_start<=h-i;h_start++){
                    for(int w_start = 0;w_start<=w-j;w_start++){
                        for(int h_yardsearch = h_start;h_yardsearch<h_start+i;h_yardsearch++){
                            for(int w_yardsearch = w_start;w_yardsearch<w_start+j;w_yardsearch++){
                                if(h_yardsearch != h_start && h_yardsearch != h_start+i-1){
                                    yardmin = yardmin>yard[h_yardsearch][w_yardsearch]?yard[h_yardsearch][w_yardsearch]:yardmin;
                                    yardmin = yardmin>yard[h_yardsearch][w_yardsearch+j-1]?yard[h_yardsearch][w_yardsearch+j-1]:yardmin;
                                    break;
                                }
                                yardmin = yardmin>yard[h_yardsearch][w_yardsearch]?yard[h_yardsearch][w_yardsearch]:yardmin;
                                
                            }
                        }
                        for(int h_lakesearch = h_start+1;h_lakesearch<h_start+i-1;h_lakesearch++){
                            for(int w_lakesearch = w_start+1;w_lakesearch<w_start+j-1;w_lakesearch++){
                                cap1 = yardmin-yard[h_lakesearch][w_lakesearch];
                                if(cap1<=0){
                                    flag = 1;
                                    break;
                                }else{
                                    cap += cap1;
                                }
                            }
                            if(flag == 1){
                                break;
                            }
                        }
                        if(flag ==1){
                        }else{
                            max = max<cap?cap:max;
                        }
                        cap = 0;
                        flag = 0;
                        yardmin = 10;
                    }
                }
            }
        }

        System.out.println(max);
    }
    }
}

</source>
<source file="../hum_codes_raw/s687849691.java" startline="1" endline="70" pcid="23106">
import java.util.*;

class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(true){
        int h = scanner.nextInt();
        int w = scanner.nextInt();
        if(h == 0 && w == 0){
            break;
        }
        int[][] yard = new int[h][w];
        int max = 0;
        int cap = 0;
        int lakemax = 0;
        int yardmin = 10;
        int flag = 0;
        int cap1 = 0;
        for(int i = 0;i<h;i++){
            for(int j = 0;j<w;j++){
                yard[i][j] = scanner.nextInt();
            }
        }

        for(int i = 3;i <= h;i++){
            for(int j = 3;j<=w;j++){
                for(int h_start = 0;h_start<=h-i;h_start++){
                    for(int w_start = 0;w_start<=w-j;w_start++){
                        for(int h_yardsearch = h_start;h_yardsearch<h_start+i;h_yardsearch++){
                            for(int w_yardsearch = w_start;w_yardsearch<w_start+j;w_yardsearch++){
                                if(h_yardsearch != h_start && h_yardsearch != h_start+i-1){
                                    yardmin = yardmin>yard[h_yardsearch][w_yardsearch]?yard[h_yardsearch][w_yardsearch]:yardmin;
                                    yardmin = yardmin>yard[h_yardsearch][w_yardsearch+j-1]?yard[h_yardsearch][w_yardsearch+j-1]:yardmin;
                                    break;
                                }
                                yardmin = yardmin>yard[h_yardsearch][w_yardsearch]?yard[h_yardsearch][w_yardsearch]:yardmin;
                                
                            }
                        }
                        for(int h_lakesearch = h_start+1;h_lakesearch<h_start+i-1;h_lakesearch++){
                            for(int w_lakesearch = w_start+1;w_lakesearch<w_start+j-1;w_lakesearch++){
                                cap1 = yardmin-yard[h_lakesearch][w_lakesearch];
                                if(cap1<=0){
                                    flag = 1;
                                    break;
                                }else{
                                    cap += cap1;
                                }
                            }
                            if(flag == 1){
                                break;
                            }
                        }
                        if(flag ==1){
                        }else{
                            max = max<cap?cap:max;
                        }
                        cap = 0;
                        flag = 0;
                        yardmin = 10;
                    }
                }
            }
        }

        System.out.println(max);
    }
    }
}

</source>
</class>

<class classid="24" nclones="2" nlines="47" similarity="100">
<source file="../hum_codes_raw/s033141889.java" startline="1" endline="57" pcid="1101">
import java.io.*;
import java.math.*;
import java.util.*;

public class Main {
    private static boolean debug = false;
    private static boolean elapsed = false;

    private static PrintWriter _out = new PrintWriter(System.out);
    private static PrintWriter _err = new PrintWriter(System.err);

    private void solve(Scanner sc) {
        long X = sc.nextLong();
        long Y = sc.nextLong();

        if (Math.abs(X - Y) <= 1) {
            _out.println("Brown");
        } else {
            _out.println("Alice");
        }
    }
    private static BigInteger C(long n, long r) {
        BigInteger res = BigInteger.ONE;
        for (long i = n; i > n - r; --i) {
            res = res.multiply(BigInteger.valueOf(i));
        }
        for (long i = r; i > 1; --i) {
            res = res.divide(BigInteger.valueOf(i));
        }
        return res;
    }
    private static BigInteger P(long n, long r) {
        BigInteger res = BigInteger.ONE;
        for (long i = n; i > n - r; --i) {
            res = res.multiply(BigInteger.valueOf(i));
        }
        return res;
    }
    /*
     * 10^10 > Integer.MAX_VALUE = 2147483647 > 10^9
     * 10^19 > Long.MAX_VALUE = 9223372036854775807L > 10^18
     */
    public static void main(String[] args) {
        long S = System.currentTimeMillis();

        Scanner sc = new Scanner(System.in);
        new Main().solve(sc);
        _out.flush();

        long G = System.currentTimeMillis();
        if (elapsed) {
            _err.println((G - S) + "ms");
        }
        _err.flush();
    }
}

</source>
<source file="../hum_codes_raw/s740915416.java" startline="1" endline="57" pcid="24899">
import java.io.*;
import java.math.*;
import java.util.*;

public class Main {
    private static boolean debug = false;
    private static boolean elapsed = false;

    private static PrintWriter _out = new PrintWriter(System.out);
    private static PrintWriter _err = new PrintWriter(System.err);

    private void solve(Scanner sc) {
        long X = sc.nextLong();
        long Y = sc.nextLong();

        if (Math.abs(X - Y) <= 1) {
            _out.println("Brown");
        } else {
            _out.println("Alice");
        }
    }
    private static BigInteger C(long n, long r) {
        BigInteger res = BigInteger.ONE;
        for (long i = n; i > n - r; --i) {
            res = res.multiply(BigInteger.valueOf(i));
        }
        for (long i = r; i > 1; --i) {
            res = res.divide(BigInteger.valueOf(i));
        }
        return res;
    }
    private static BigInteger P(long n, long r) {
        BigInteger res = BigInteger.ONE;
        for (long i = n; i > n - r; --i) {
            res = res.multiply(BigInteger.valueOf(i));
        }
        return res;
    }
    /*
     * 10^10 > Integer.MAX_VALUE = 2147483647 > 10^9
     * 10^19 > Long.MAX_VALUE = 9223372036854775807L > 10^18
     */
    public static void main(String[] args) {
        long S = System.currentTimeMillis();

        Scanner sc = new Scanner(System.in);
        new Main().solve(sc);
        _out.flush();

        long G = System.currentTimeMillis();
        if (elapsed) {
            _err.println((G - S) + "ms");
        }
        _err.flush();
    }
}

</source>
</class>

<class classid="25" nclones="2" nlines="143" similarity="100">
<source file="../hum_codes_raw/s034088895.java" startline="1" endline="174" pcid="1134">
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.PriorityQueue;
import java.util.Comparator;
 
class Point implements Comparable<Point>{
    public static int nextId = 0;
  
    public int id;
    public int x;
    public int y;
    public int type;
    public int distanceFromStart;
    
    public Point() {
        this(-1, -1, -1);
    }
     
    public Point(final int x, final int y, final int type) {
        init(x, y, type);
    }
  
    public int distance(final Point p) {
        return abs(this.x - p.x) + abs(this.y - p.y);
    }
     
    public void init(final int x, final int y, final int type){
        this.id = nextId++;
        this.x = x;
        this.y = y;
        this.type = type;
        this.distanceFromStart = Integer.MAX_VALUE;
    }
    
    @Override
    public int compareTo(final Point p) {
        return this.distanceFromStart - p.distanceFromStart;
    }
     
    private static int abs(final int n) {
        int mask = n >> 31;
        return (n ^ mask) - mask;
    }
}
  
public class Main {
    public static final BufferedReader br =
            new BufferedReader(new InputStreamReader(System.in));
  
    public static final Point start = new Point();
    public static final Point goal = new Point();

    public static final PriorityQueue<Point> q = new PriorityQueue<Point>();
     
    public static final List<List<Point> > pointListByType =
            new ArrayList<List<Point> >();
     
    static {
        for(int i = 0; i < 5; i++) {
            pointListByType.add(new ArrayList<Point>());
        }
    }
  
    public static void main(String args[]) throws IOException {
        while(true) {
            final String mapSizeStr = br.readLine();
            if("0 0".equals(mapSizeStr)) break;
  
            final String[] splittedStr = mapSizeStr.split(" ");
            final int x = Integer.parseInt(splittedStr[0]);
            final int y = Integer.parseInt(splittedStr[1]);

            for(int i = 0; i < 5; i++) {
                pointListByType.get(i).clear();
            }
            Point.nextId = 0;
  
            for(int r = 0; r < y; r++){
                final String line = br.readLine();
                final char[] caray = line.toCharArray();
                for(int c = 0; c < x; c++) {
                    char pointLiteral = caray[c];
                    switch(pointLiteral) {
                    case '.':
                        //Do Nothing
                        break;
                    case 'S':
                        start.init(c, r, -1);
                        start.distanceFromStart = 0;
                        break;
                    case 'G':
                        goal.init(c, r, -1);
                        break;
                    default:
                        final int type = (int)pointLiteral - (int)'1';
                        pointListByType.get(type).add(new Point(c, r, type));
                    }
                }
            }
  
            int minLenType = -1;
            int minLen = Integer.MAX_VALUE;
            for (int firstType = 0; firstType < 5; firstType++) { 
                final int shortestPathLen = searchShortestPath(firstType, minLen);
  
                if(minLen > shortestPathLen) {
                    minLen = shortestPathLen;
                    minLenType = firstType;
                }
  
                if(firstType == 4) break;
                
                for(int i = 0; i < 5; i++) {
                    final List<Point> tempPointList = pointListByType.get(i);
                    final int pointListSize = tempPointList.size();
                    for(int j = 0; j < pointListSize; j++) {
                        tempPointList.get(j).distanceFromStart = Integer.MAX_VALUE;
                    }
                }
                goal.distanceFromStart = Integer.MAX_VALUE;
            }
  
            if(minLen == Integer.MAX_VALUE) {
                System.out.println("NA");
            } else {
                System.out.println((minLenType + 1) + " " + minLen);
            }
        }
    }
  
    private static int searchShortestPath(final int firstType, final int minLen) {
        final int lastType = (firstType + 4) % 5;
            
        q.clear();
  
        q.add(start);
        start.type = firstType;
           
        while(!q.isEmpty()) {
            final Point searchingPoint = q.poll();

            if(searchingPoint.distanceFromStart >= minLen) return Integer.MAX_VALUE;
            if(searchingPoint.id == goal.id) return goal.distanceFromStart;

            if(searchingPoint.type == lastType) {
                final int distance = searchingPoint.distance(goal);
                final int searchingPointDistance = searchingPoint.distanceFromStart;
                if(goal.distanceFromStart > searchingPointDistance + distance) {
                    goal.distanceFromStart = searchingPointDistance + distance;
                    q.add(goal);
                }
            } else {
                final List<Point> nextPointList = pointListByType.get((searchingPoint.type + 1) % 5);
                final int nextPointListSize = nextPointList.size();
                
                for(int i = 0; i < nextPointListSize; i++) {
                    final Point tempNextPoint = nextPointList.get(i);
                    final int distance = searchingPoint.distance(tempNextPoint);
                    final int searchingPointDistance = searchingPoint.distanceFromStart;
                    if(tempNextPoint.distanceFromStart > searchingPointDistance + distance) {
                        tempNextPoint.distanceFromStart = searchingPointDistance + distance;
                        q.add(tempNextPoint);
                    }
                }
            }
        }
        return Integer.MAX_VALUE;
    }
}   

</source>
<source file="../hum_codes_raw/s497904534.java" startline="1" endline="174" pcid="16704">
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.PriorityQueue;
import java.util.Comparator;
 
class Point implements Comparable<Point>{
    public static int nextId = 0;
  
    public int id;
    public int x;
    public int y;
    public int type;
    public int distanceFromStart;
    
    public Point() {
        this(-1, -1, -1);
    }
     
    public Point(final int x, final int y, final int type) {
        init(x, y, type);
    }
  
    public int distance(final Point p) {
        return abs(this.x - p.x) + abs(this.y - p.y);
    }
     
    public void init(final int x, final int y, final int type){
        this.id = nextId++;
        this.x = x;
        this.y = y;
        this.type = type;
        this.distanceFromStart = Integer.MAX_VALUE;
    }
    
    @Override
    public int compareTo(final Point p) {
        return this.distanceFromStart - p.distanceFromStart;
    }
     
    private static int abs(final int n) {
        int mask = n >> 31;
        return (n ^ mask) - mask;
    }
}
  
public class Main {
    public static final BufferedReader br =
            new BufferedReader(new InputStreamReader(System.in));
  
    public static final Point start = new Point();
    public static final Point goal = new Point();

    public static final PriorityQueue<Point> q = new PriorityQueue<Point>();
     
    public static final List<List<Point> > pointListByType =
            new ArrayList<List<Point> >();
     
    static {
        for(int i = 0; i < 5; i++) {
            pointListByType.add(new ArrayList<Point>());
        }
    }
  
    public static void main(String args[]) throws IOException {
        while(true) {
            final String mapSizeStr = br.readLine();
            if("0 0".equals(mapSizeStr)) break;
  
            final String[] splittedStr = mapSizeStr.split(" ");
            final int x = Integer.parseInt(splittedStr[0]);
            final int y = Integer.parseInt(splittedStr[1]);

            for(int i = 0; i < 5; i++) {
                pointListByType.get(i).clear();
            }
            Point.nextId = 0;
  
            for(int r = 0; r < y; r++){
                final String line = br.readLine();
                final char[] caray = line.toCharArray();
                for(int c = 0; c < x; c++) {
                    char pointLiteral = caray[c];
                    switch(pointLiteral) {
                    case '.':
                        //Do Nothing
                        break;
                    case 'S':
                        start.init(c, r, -1);
                        start.distanceFromStart = 0;
                        break;
                    case 'G':
                        goal.init(c, r, -1);
                        break;
                    default:
                        final int type = (int)pointLiteral - (int)'1';
                        pointListByType.get(type).add(new Point(c, r, type));
                    }
                }
            }
  
            int minLenType = -1;
            int minLen = Integer.MAX_VALUE;
            for (int firstType = 0; firstType < 5; firstType++) { 
                final int shortestPathLen = searchShortestPath(firstType, minLen);
  
                if(minLen > shortestPathLen) {
                    minLen = shortestPathLen;
                    minLenType = firstType;
                }
  
                if(firstType == 4) break;
                
                for(int i = 0; i < 5; i++) {
                    final List<Point> tempPointList = pointListByType.get(i);
                    final int pointListSize = tempPointList.size();
                    for(int j = 0; j < pointListSize; j++) {
                        tempPointList.get(j).distanceFromStart = Integer.MAX_VALUE;
                    }
                }
                goal.distanceFromStart = Integer.MAX_VALUE;
            }
  
            if(minLen == Integer.MAX_VALUE) {
                System.out.println("NA");
            } else {
                System.out.println((minLenType + 1) + " " + minLen);
            }
        }
    }
  
    private static int searchShortestPath(final int firstType, final int minLen) {
        final int lastType = (firstType + 4) % 5;
            
        q.clear();
  
        q.add(start);
        start.type = firstType;
           
        while(!q.isEmpty()) {
            final Point searchingPoint = q.poll();

            if(searchingPoint.distanceFromStart >= minLen) return Integer.MAX_VALUE;
            if(searchingPoint.id == goal.id) return goal.distanceFromStart;

            if(searchingPoint.type == lastType) {
                final int distance = searchingPoint.distance(goal);
                final int searchingPointDistance = searchingPoint.distanceFromStart;
                if(goal.distanceFromStart > searchingPointDistance + distance) {
                    goal.distanceFromStart = searchingPointDistance + distance;
                    q.add(goal);
                }
            } else {
                final List<Point> nextPointList = pointListByType.get((searchingPoint.type + 1) % 5);
                final int nextPointListSize = nextPointList.size();
                
                for(int i = 0; i < nextPointListSize; i++) {
                    final Point tempNextPoint = nextPointList.get(i);
                    final int distance = searchingPoint.distance(tempNextPoint);
                    final int searchingPointDistance = searchingPoint.distanceFromStart;
                    if(tempNextPoint.distanceFromStart > searchingPointDistance + distance) {
                        tempNextPoint.distanceFromStart = searchingPointDistance + distance;
                        q.add(tempNextPoint);
                    }
                }
            }
        }
        return Integer.MAX_VALUE;
    }
}   

</source>
</class>

<class classid="26" nclones="2" nlines="83" similarity="100">
<source file="../hum_codes_raw/s034131919.java" startline="1" endline="86" pcid="1136">
import java.util.Scanner;

public class Main {
    static int[][][] caves = new int[2][1000][1000];
    static boolean[] primes = new boolean[1000000];
    static int[][] dp = new int[2][1000];
    static int[] vx = {1, 0, -1, 0};
    static int[] vy = {0, -1, 0, 1};

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        MakeCaves();
        while (true){
            int m = sc.nextInt();
            int n = sc.nextInt();
            if(m==0 && n==0) break;

            int x = -1, y = -1;
            for (int i = 0; i < 1000; i++) {
                for (int j = 0; j < 1000; j++) {
                    if(caves[0][i][j]==n){
                        x = j; y = i;
                        break;
                    }
                }
                if(x!=-1) break;
            }
            for (int i = 0; i <1000 ; i++) {
                dp[0][i] = dp[1][i] = 0;
            }

            int max = 0, dy = 0, mx = x, my = y;
            while (y+dy<1000){
                for (int i = (x-dy>=0)?x-dy:0; i <= ((x+dy<1000)?x+dy:999); i++) {
                    if(caves[0][y+dy][i]>m) continue;
                    dp[dy%2][i] = dp[(dy+1)%2][i] + caves[1][y+dy][i];
                    if(i>0&&dp[(dy+1)%2][i-1]!=0){
                        dp[dy%2][i] = Math.max(dp[dy%2][i], dp[(dy+1)%2][i-1] + caves[1][y+dy][i]);
                    }
                    if(i<999&&dp[(dy+1)%2][i+1]!=0){
                        dp[dy%2][i] = Math.max(dp[dy%2][i], dp[(dy+1)%2][i+1] + caves[1][y+dy][i]);
                    }
                    if(max<dp[dy%2][i]){
                        max = dp[dy%2][i];
                        mx = i; my = y + dy;
                    }else if(max==dp[dy%2][i] && caves[1][y+dy][i]==1){
                        if(caves[0][my][mx]<caves[0][y+dy][i]){
                            mx = i; my = y + dy;
                        }
                    }
                }
                dy++;
            }
            System.out.println(max+" "+((max!=0)?caves[0][my][mx]:0));
        }
    }

    static void FindPrimes() {
        primes[0] = true;
        for (int i = 1; i < 500000; i++) {
            if(primes[i]) continue;
            int j = (i+1)*2;
            while (j<1000000){
                primes[j-1] = true;
                j += i+1;
            }
        }
    }

    static void MakeCaves() {
        int n = 2, x = 499, y = 500;
        FindPrimes();
        caves[0][y][x] = 1;
        caves[1][y][x] = 0;

        for (int i = 0; i < 2000; i++) {
            for (int j = 0; j <= i/2; j++, n++) {
                if(n==1000001) break;
                x+=vx[i%4]; y+=vy[i%4];
                caves[0][y][x] = n;
                caves[1][y][x] = (primes[n-1])?0:1;
            }
        }
    }
}

</source>
<source file="../hum_codes_raw/s239204937.java" startline="1" endline="86" pcid="8079">
import java.util.Scanner;

public class Main{
    static int[][][] caves = new int[2][1000][1000];
    static boolean[] primes = new boolean[1000000];
    static int[][] dp = new int[2][1000];
    static int[] vx = {1, 0, -1, 0};
    static int[] vy = {0, -1, 0, 1};

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        MakeCaves();
        while (true){
            int m = sc.nextInt();
            int n = sc.nextInt();
            if(m==0 && n==0) break;

            int x = -1, y = -1;
            for (int i = 0; i < 1000; i++) {
                for (int j = 0; j < 1000; j++) {
                    if(caves[0][i][j]==n){
                        x = j; y = i;
                        break;
                    }
                }
                if(x!=-1) break;
            }
            for (int i = 0; i <1000 ; i++) {
                dp[0][i] = dp[1][i] = 0;
            }

            int max = 0, dy = 0, mx = x, my = y;
            while (y+dy<1000){
                for (int i = (x-dy>=0)?x-dy:0; i <= ((x+dy<1000)?x+dy:999); i++) {
                    if(caves[0][y+dy][i]>m) continue;
                    dp[dy%2][i] = dp[(dy+1)%2][i] + caves[1][y+dy][i];
                    if(i>0&&dp[(dy+1)%2][i-1]!=0){
                        dp[dy%2][i] = Math.max(dp[dy%2][i], dp[(dy+1)%2][i-1] + caves[1][y+dy][i]);
                    }
                    if(i<999&&dp[(dy+1)%2][i+1]!=0){
                        dp[dy%2][i] = Math.max(dp[dy%2][i], dp[(dy+1)%2][i+1] + caves[1][y+dy][i]);
                    }
                    if(max<dp[dy%2][i]){
                        max = dp[dy%2][i];
                        mx = i; my = y + dy;
                    }else if(max==dp[dy%2][i] && caves[1][y+dy][i]==1){
                        if(caves[0][my][mx]<caves[0][y+dy][i]){
                            mx = i; my = y + dy;
                        }
                    }
                }
                dy++;
            }
            System.out.println(max+" "+((max!=0)?caves[0][my][mx]:0));
        }
    }

    static void FindPrimes() {
        primes[0] = true;
        for (int i = 1; i < 500000; i++) {
            if(primes[i]) continue;
            int j = (i+1)*2;
            while (j<1000000){
                primes[j-1] = true;
                j += i+1;
            }
        }
    }

    static void MakeCaves() {
        int n = 2, x = 499, y = 500;
        FindPrimes();
        caves[0][y][x] = 1;
        caves[1][y][x] = 0;

        for (int i = 0; i < 2000; i++) {
            for (int j = 0; j <= i/2; j++, n++) {
                if(n==1000001) break;
                x+=vx[i%4]; y+=vy[i%4];
                caves[0][y][x] = n;
                caves[1][y][x] = (primes[n-1])?0:1;
            }
        }
    }
}

</source>
</class>

<class classid="27" nclones="2" nlines="220" similarity="100">
<source file="../hum_codes_raw/s034727591.java" startline="1" endline="265" pcid="1156">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.io.IOException;
import java.util.ArrayList;
import java.io.UncheckedIOException;
import java.util.List;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            DIsomorphismFreak solver = new DIsomorphismFreak();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class DIsomorphismFreak {
        int[] seq;
        int depthest;
        int minDepth;
        long minLeaf;

        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            Node[] nodes = new Node[n];
            for (int i = 0; i < n; i++) {
                nodes[i] = new Node();
                nodes[i].id = i;
            }
            int[][] edges = new int[n - 1][2];
            for (int i = 0; i < n - 1; i++) {
                edges[i][0] = in.readInt() - 1;
                edges[i][1] = in.readInt() - 1;
                Node a = nodes[edges[i][0]];
                Node b = nodes[edges[i][1]];
                a.adj.add(b);
                b.adj.add(a);
            }
            seq = new int[n];


            minDepth = n;
            minLeaf = Long.MAX_VALUE;
            for (int i = 0; i < n; i++) {
                reset();
                dfs(nodes[i], null, 0);
                update(1);
            }

            for (int[] e : edges) {
                Node a = nodes[e[0]];
                Node b = nodes[e[1]];
                reset();
                dfs(a, b, 0);
                dfs(b, a, 0);
                update(2);
            }

            out.println(minDepth + 1).println(minLeaf);
        }

        public void update(int mul) {
            int depth = depthest;
            long leaf = mul;
            for (int j = 0; j <= depth; j++) {
                leaf *= seq[j];
            }

            if (depth < minDepth) {
                minDepth = depth;
                minLeaf = Long.MAX_VALUE;
            }
            if (depth == minDepth) {
                minLeaf = Math.min(minLeaf, leaf);
            }
        }

        public void reset() {
            Arrays.fill(seq, 1);
            depthest = 0;
        }

        public void dfs(Node root, Node p, int d) {
            depthest = Math.max(depthest, d);
            int degree = root.adj.size() - (p == null ? 0 : 1);
            seq[d] = Math.max(seq[d], degree);
            for (Node node : root.adj) {
                if (node == p) {
                    continue;
                }
                dfs(node, root, d + 1);
            }
        }

    }

    static class Node {
        List<Node> adj = new ArrayList<>();
        int id;

        public String toString() {
            return "" + (id + 1);
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(long c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println(long c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }
}


</source>
<source file="../hum_codes_raw/s160294044.java" startline="1" endline="265" pcid="5378">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.io.IOException;
import java.util.ArrayList;
import java.io.UncheckedIOException;
import java.util.List;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            DIsomorphismFreak solver = new DIsomorphismFreak();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class DIsomorphismFreak {
        int[] seq;
        int depthest;
        int minDepth;
        long minLeaf;

        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            Node[] nodes = new Node[n];
            for (int i = 0; i < n; i++) {
                nodes[i] = new Node();
                nodes[i].id = i;
            }
            int[][] edges = new int[n - 1][2];
            for (int i = 0; i < n - 1; i++) {
                edges[i][0] = in.readInt() - 1;
                edges[i][1] = in.readInt() - 1;
                Node a = nodes[edges[i][0]];
                Node b = nodes[edges[i][1]];
                a.adj.add(b);
                b.adj.add(a);
            }
            seq = new int[n];


            minDepth = n;
            minLeaf = Long.MAX_VALUE;
            for (int i = 0; i < n; i++) {
                reset();
                dfs(nodes[i], null, 0);
                update(1);
            }

            for (int[] e : edges) {
                Node a = nodes[e[0]];
                Node b = nodes[e[1]];
                reset();
                dfs(a, b, 0);
                dfs(b, a, 0);
                update(2);
            }

            out.println(minDepth + 1).println(minLeaf);
        }

        public void update(int mul) {
            int depth = depthest;
            long leaf = mul;
            for (int j = 0; j <= depth; j++) {
                leaf *= seq[j];
            }

            if (depth < minDepth) {
                minDepth = depth;
                minLeaf = Long.MAX_VALUE;
            }
            if (depth == minDepth) {
                minLeaf = Math.min(minLeaf, leaf);
            }
        }

        public void reset() {
            Arrays.fill(seq, 1);
            depthest = 0;
        }

        public void dfs(Node root, Node p, int d) {
            depthest = Math.max(depthest, d);
            int degree = root.adj.size() - (p == null ? 0 : 1);
            seq[d] = Math.max(seq[d], degree);
            for (Node node : root.adj) {
                if (node == p) {
                    continue;
                }
                dfs(node, root, d + 1);
            }
        }

    }

    static class Node {
        List<Node> adj = new ArrayList<>();
        int id;

        public String toString() {
            return "" + (id + 1);
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(long c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println(long c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }
}


</source>
</class>

<class classid="28" nclones="2" nlines="17" similarity="100">
<source file="../hum_codes_raw/s035027406.java" startline="1" endline="19" pcid="1176">
import java.util.Scanner;
public class Main {

	public static void main(String[] args){

		Scanner sc = new Scanner(System.in);
		int a = sc.nextInt();
		int b = sc.nextInt();

		if(a + b == 15){
			System.out.println("+");
		}else if(a * b == 15){
			System.out.println("*");
		}else{
			System.out.println("x");
		}
	}
}

</source>
<source file="../hum_codes_raw/s180691434.java" startline="1" endline="28" pcid="6087">
import java.util.Scanner;
 
 
public class Main {
 
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc = new Scanner(System.in);
		
		int a = sc.nextInt();
		int b = sc.nextInt();
		
		if(a + b == 15){
			System.out.println("+");
		}
		else if(a * b == 15){
			System.out.println("*");
		}
		else {
			System.out.println("x");
		}
	}
 
}

</source>
</class>

<class classid="29" nclones="2" nlines="123" similarity="100">
<source file="../hum_codes_raw/s035477307.java" startline="1" endline="153" pcid="1194">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.PriorityQueue;
import java.util.Queue;

public class Main {

  public static void main(String[] args) {
    
    new Main().run();
  }

  public void run() {

    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      int n = Integer.parseInt(br.readLine());
      Graph graph = new Graph(n);
      String[] vInfo;
      int id,degree,key,val;
      IntTuple[] ajacent;

      for(int i=0; i<n; i++) {
        vInfo = br.readLine().split(" ");
        id     = Integer.parseInt(vInfo[0]);
        degree = Integer.parseInt(vInfo[1]);
        ajacent = new IntTuple[degree];
        for (int j=0,k=2; j<degree; j++) {
          key = Integer.parseInt(vInfo[k++]);
          val = Integer.parseInt(vInfo[k++]);
          ajacent[j] = new IntTuple(key, val);
        }
        graph.setVertex(id, ajacent);
      }

      graph.calcSSSPWeightSum();

      StringBuilder buf = new StringBuilder();
      for (Vertex v : graph.vertices) {
        buf.append(v.id).append(" ").append(v.minPathCost)
           .append("\n");
      }
      System.out.print(buf);
    }
    catch (IOException e) {
      System.err.println(e);
    }
  }


  class Graph {

    Vertex[] vertices;
    Queue<IntTuple> queue;

    public Graph(int size ) {
      vertices  = new Vertex[size];
      queue = new PriorityQueue<>(size);
    }

    public void setVertex(int id) {
      vertices[id] = new Vertex(id);
    }
    public void setVertex(int id, int[] distance) {
      setVertex(id);
      setAjacent(id, distance);
    }
    public void setVertex(int id, IntTuple[] ajacent) {
      setVertex(id);
      setAjacent(id, ajacent);
    }
    public void setAjacent(int id, int[] distance) {
      vertices[id].distance = distance;
    }
    public void setAjacent(int id, IntTuple[] ajasent) {
      vertices[id].ajacent = ajasent;
    }

    public void calcSSSPWeightSum() {
      algorithmDijkstra(0);
    }

    private void algorithmDijkstra(int s) {
      vertices[s].minPathCost = 0;
      Vertex current,next;
      queue.offer(new IntTuple(vertices[s].id, vertices[s].minPathCost));
      vertices[s].state = Vertex.GRAY;

      IntTuple v;
      while( (v = queue.poll()) != null ) {
        vertices[v.key].state = Vertex.BLACK;

        if(vertices[v.key].minPathCost < v.val) continue;
        
        current = vertices[v.key];
        for (IntTuple w: current.ajacent) {
          next = vertices[w.key];
          if( (next.state != Vertex.BLACK) &&
              (current.minPathCost + w.val < next.minPathCost) ) {
            next.minPathCost = current.minPathCost + w.val;
            queue.offer(new IntTuple(next.id, next.minPathCost));
            next.state = Vertex.GRAY;
          }
        }
        continue;
      }
    }
  }

  class Vertex {

    static final int NILL  =-1;
    static final int WHITE = 0;
    static final int GRAY  = 1;
    static final int BLACK = 2;
    int id;
    int state;
    int minPathCost;
    int parent;
    int[] distance;
    IntTuple[] ajacent;

    public Vertex(int id) {
      this.id = id;
      state = WHITE;
      minPathCost = Integer.MAX_VALUE;
    }
  }

  class IntTuple implements Comparable<IntTuple> {
    public int key;
    public int val;

    public IntTuple(int key, int val) {
      this.key = key;
      this.val = val;
    }

    @Override
    public String toString() {
      return "[" + key + "," + val + "]";
    }
    @Override
    public int compareTo(IntTuple obj) {
      if(this.val < obj.val) return -1;
      if(this.val > obj.val) return  1;

      return 0;
    }
  }
}

</source>
<source file="../hum_codes_raw/s150933663.java" startline="1" endline="153" pcid="5051">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.PriorityQueue;
import java.util.Queue;

public class Main {

  public static void main(String[] args) {
    
    new Main().run();
  }

  public void run() {

    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      int n = Integer.parseInt(br.readLine());
      Graph graph = new Graph(n);
      String[] vInfo;
      int id,degree,key,val;
      IntTuple[] ajacent;

      for(int i=0; i<n; i++) {
        vInfo = br.readLine().split(" ");
        id     = Integer.parseInt(vInfo[0]);
        degree = Integer.parseInt(vInfo[1]);
        ajacent = new IntTuple[degree];
        for (int j=0,k=2; j<degree; j++) {
          key = Integer.parseInt(vInfo[k++]);
          val = Integer.parseInt(vInfo[k++]);
          ajacent[j] = new IntTuple(key, val);
        }
        graph.setVertex(id, ajacent);
      }

      graph.calcSSSPWeightSum();

      StringBuilder buf = new StringBuilder();
      for (Vertex v : graph.vertices) {
        buf.append(v.id).append(" ").append(v.minPathCost)
           .append("\n");
      }
      System.out.print(buf);
    }
    catch (IOException e) {
      System.err.println(e);
    }
  }


  class Graph {

    Vertex[] vertices;
    Queue<IntTuple> queue;

    public Graph(int size ) {
      vertices  = new Vertex[size];
      queue = new PriorityQueue<>(size);
    }

    public void setVertex(int id) {
      vertices[id] = new Vertex(id);
    }
    public void setVertex(int id, int[] distance) {
      setVertex(id);
      setAjacent(id, distance);
    }
    public void setVertex(int id, IntTuple[] ajacent) {
      setVertex(id);
      setAjacent(id, ajacent);
    }
    public void setAjacent(int id, int[] distance) {
      vertices[id].distance = distance;
    }
    public void setAjacent(int id, IntTuple[] ajasent) {
      vertices[id].ajacent = ajasent;
    }

    public void calcSSSPWeightSum() {
      algorithmDijkstra(0);
    }

    private void algorithmDijkstra(int s) {
      vertices[s].minPathCost = 0;
      Vertex current,next;
      queue.offer(new IntTuple(vertices[s].id, vertices[s].minPathCost));
      vertices[s].state = Vertex.GRAY;

      IntTuple v;
      while( (v = queue.poll()) != null ) {
        vertices[v.key].state = Vertex.BLACK;

        if(vertices[v.key].minPathCost < v.val) continue;
        
        current = vertices[v.key];
        for (IntTuple w: current.ajacent) {
          next = vertices[w.key];
          if( (next.state != Vertex.BLACK) &&
              (current.minPathCost + w.val < next.minPathCost) ) {
            next.minPathCost = current.minPathCost + w.val;
            queue.offer(new IntTuple(next.id, next.minPathCost));
            next.state = Vertex.GRAY;
          }
        }
        continue;
      }
    }
  }

  class Vertex {

    static final int NILL  =-1;
    static final int WHITE = 0;
    static final int GRAY  = 1;
    static final int BLACK = 2;
    int id;
    int state;
    int minPathCost;
    int parent;
    int[] distance;
    IntTuple[] ajacent;

    public Vertex(int id) {
      this.id = id;
      state = WHITE;
      minPathCost = Integer.MAX_VALUE;
    }
  }

  class IntTuple implements Comparable<IntTuple> {
    public int key;
    public int val;

    public IntTuple(int key, int val) {
      this.key = key;
      this.val = val;
    }

    @Override
    public String toString() {
      return "[" + key + "," + val + "]";
    }
    @Override
    public int compareTo(IntTuple obj) {
      if(this.val < obj.val) return -1;
      if(this.val > obj.val) return  1;

      return 0;
    }
  }
}

</source>
</class>

<class classid="30" nclones="2" nlines="362" similarity="100">
<source file="../hum_codes_raw/s035539207.java" startline="1" endline="445" pcid="1198">
import java.io.*;
import java.math.*;
import java.util.*;
import java.util.stream.*;

public class Main {

	static final int P = 998_244_353;

	void submit() {
		int[] cnt = new int[100_000];
		int n = nextInt();
		for (int i = 0; i < 2 * n; i++) {
			cnt[nextInt() - 1]++;
		}

		long[] pair = new long[n + 1];
		pair[0] = 1;
		for (int i = 1; i < pair.length; i++) {
			pair[i] = pair[i - 1] * (2 * i - 1) % P;
		}

		long[] inv = new long[2 * n + 1];
		inv[1] = 1;

		for (int i = 2; i < inv.length; i++) {
			inv[i] = P - (long) (P / i) * inv[P % i] % P;
		}

		PriorityQueue<int[]> pq = new PriorityQueue<>((int[] a, int[] b) -> Integer.compare(a.length, b.length));
		pq.add(new int[] { 1 });
		for (int x : cnt) {
			if (x < 2) {
				continue;
			}
			int[] p = new int[x / 2 + 1];
			long cur = p[0] = 1;
			for (int i = 1; i < p.length; i++) {
				cur = cur * (x - 2 * i + 2) % P * (x - 2 * i + 1) % P * inv[2 * i - 1] % P * inv[2 * i] % P;
				p[i] = (int) (cur * pair[i] % P);
			}
			pq.add(p);
		}

		while (pq.size() > 1) {
			int[] a = pq.poll();
			int[] b = pq.poll();
			pq.add(mult(a, b));
		}

		int[] p = pq.poll();
		long ans = 0;
		for (int i = 0; i < p.length; i++) {
			ans += (1 - i % 2 * 2) * p[i] * pair[n - i];
			if (ans >= P2) {
				ans -= P2;
			}
			if (ans < 0) {
				ans += P2;
			}
		}
		out.println(ans % P);
	}

	static final int NAIVE_MULT_THRESHOLD = 128;
	static final long P2 = (long) P * P;

	int[] mult(int[] a, int[] b) {
		int[] ret = multSmall(a, b);
		return ret != null ? ret : multFFT(a, b);
	}

	static int[] getNonZeroesIdx(int[] p) {
		int n = 0;
		for (int i = 0; i < p.length; i++) {
			if (p[i] != 0) {
				n++;
			}
		}
		int[] ret = new int[n];
		for (int i = 0; i < p.length; i++) {
			if (p[i] != 0) {
				ret[--n] = i;
			}
		}
		return ret;
	}

	static int[] removeLeadingZeroes(int[] a) {
		int i = a.length - 1;
		while (i >= 0 && a[i] == 0) {
			i--;
		}
		return i == a.length - 1 ? a : Arrays.copyOf(a, i + 1);
	}

	int[] multSmall(int[] a, int[] b) {
		int[] nza = getNonZeroesIdx(a);
		int[] nzb = getNonZeroesIdx(b);
		if (nza.length == 0 || nzb.length == 0) {
			return new int[] { 0 };
		}
		if (Math.min(nza.length, nzb.length) <= NAIVE_MULT_THRESHOLD) {
			long[] c = new long[nza[0] + nzb[0] + 1];
			for (int i : nza) {
				for (int j : nzb) {
					c[i + j] += (long) a[i] * b[j];
					if (c[i + j] >= P2) {
						c[i + j] -= P2;
					}
				}
			}
			int[] ret = new int[c.length];
			for (int i = 0; i < c.length; i++) {
				ret[i] = (int) (c[i] % P);
			}
			return removeLeadingZeroes(ret);
		}
		return null;
	}

	static int nextPowerOf2(int x) {
		return x == 1 ? 1 : Integer.highestOneBit(x - 1) << 1;
	}

	static final int L = (int) Math.sqrt(P);
	static final int L2 = L * L;

	/**
	 * Decomposes intV into vectors a and b s.t. intV = a + b * L.
	 * 
	 * @param len - length to pad intV to. !!! MUST BE A POWER OF 2 !!!
	 * @return double[][]{FFT(a), FFT(b)}.
	 */
	static double[][] decomposeAndFFT(int[] intV, int len) {
		// pack into one complex vector
		double[] f = new double[len << 1];
		for (int i = 0; i < intV.length; i++) {
			f[i << 1] = intV[i] % L;
			f[i << 1 | 1] = intV[i] / L;
		}

		fft(f, false);

		// unpack
		double[] f1 = new double[len << 1];
		double[] f2 = new double[len << 1];
		int zzz = (len << 1) - 1;
		for (int i = 0; i < len << 1; i += 2) {
			int j = (-i) & zzz;
			f1[i] = .5 * (f[i] + f[j]);
			f1[i + 1] = .5 * (f[i + 1] - f[j + 1]);
			f2[i] = .5 * (f[i + 1] + f[j + 1]);
			f2[i + 1] = .5 * (f[j] - f[i]);
		}

		return new double[][] { f1, f2 };
	}

	public static int[] multFFT(int[] a, int[] b) {
		int len = nextPowerOf2(a.length + b.length - 1);
		int len2 = len << 1;

		double[][] fA = decomposeAndFFT(a, len);
		double[][] fB = decomposeAndFFT(b, len);

		// Multiply FFT-ed vectors and pack them in pairs for inverse FFT.
		// We need to calcualte smth like (a0 b0) + L(a0 b1 + a1 b0) + L^2 (a1 b1)
		// a0 b0 goes into invF[0] real part
		// (a0 b1 + a1 b0) invF[0] imag part
		// a1 b1 -> invF[1] real part
		double[][] invF = new double[2][len2];
		for (int ia = 0; ia < 2; ia++) {
			for (int ib = 0; ib < 2; ib++) {

				double[] r = invF[(ia + ib) >> 1];
				double[] p = fA[ia];
				double[] q = fB[ib];

				if (((ia + ib) & 1) == 0) {
					for (int i = 0; i < len2; i += 2) {
						r[i] += p[i] * q[i] - p[i + 1] * q[i + 1];
						r[i + 1] += p[i] * q[i + 1] + p[i + 1] * q[i];
					}

				} else {
					for (int i = 0; i < len2; i += 2) {
						r[i] -= p[i] * q[i + 1] + p[i + 1] * q[i];
						r[i + 1] += p[i] * q[i] - p[i + 1] * q[i + 1];
					}
				}

			}
		}

		fft(invF[0], true);
		fft(invF[1], true);

		int[] ret = new int[len];

		for (int i = 0; i < len2; i += 2) {
			long v0 = Math.round(invF[0][i]);
			long v1 = Math.round(invF[0][i + 1]) % P * L;
			long v2 = Math.round(invF[1][i]) % P * L2;
			ret[i >> 1] = (int) ((v0 + v1 + v2) % P);
		}

		return removeLeadingZeroes(ret);
	}

	public static void fft(double[] v, boolean invert) {
		int n2 = v.length;
		int n = n2 >> 1;
		int logN = Integer.numberOfTrailingZeros(n);
		prepareArrays(logN);
		int[] rev = rev2D[logN];

		for (int i = 0; i < n2; i += 2) {
			int j = rev[i >> 1] << 1;
			if (i < j) {
				double t = v[i];
				v[i] = v[j];
				v[j] = t;
				t = v[i + 1];
				v[i + 1] = v[j + 1];
				v[j + 1] = t;
			}
		}

		double conj = invert ? -1 : 1;

		for (int len = 2, row = 0; len <= n; len <<= 1, row++) {
			double[] pow = pow2D[row];
			for (int i = 0; i < n; i += len) {
				for (int j1 = i << 1, j2 = j1 + len, k = 0; k < len; j1 += 2, j2 += 2, k += 2) {
					double uA = v[j1];
					double uB = v[j1 + 1];

					double mRe = pow[k];
					double mIm = pow[k + 1] * conj;

					double vA = v[j2] * mRe - v[j2 + 1] * mIm;
					double vB = v[j2] * mIm + v[j2 + 1] * mRe;

					v[j1] = uA + vA;
					v[j1 + 1] = uB + vB;
					v[j2] = uA - vA;
					v[j2 + 1] = uB - vB;
				}
			}
		}
		if (invert) {
			for (int i = 0; i < n2; i++) {
				v[i] /= n;
			}
		}
	}

	static double[][] pow2D = { { 1, 0 } };
	static int[][] rev2D = {};

	static void prepareArrays(int n) {
		if (rev2D.length < n + 1) {
			rev2D = Arrays.copyOf(rev2D, n + 1);
		}

		if (rev2D[n] == null) {
			int[] tmp = rev2D[n] = new int[1 << n];
			for (int i = 0; i < (1 << n); i++) {
				tmp[i] = (tmp[i >> 1] >> 1) | ((i & 1) << (n - 1));
			}
		}

		int oldN = pow2D.length;

		if (oldN >= n) {
			return;
		}

		pow2D = Arrays.copyOf(pow2D, n);

		for (int i = oldN; i < n; i++) {
			double angle = Math.PI / (1 << i);

			double mRe = Math.cos(angle);
			double mIm = Math.sin(angle);

			double[] dst = pow2D[i] = new double[2 << i];
			double[] src = pow2D[i - 1];

			for (int j = 0; j < 1 << i; j += 2) {
				double re = src[j];
				double im = src[j + 1];

				dst[j << 1] = re;
				dst[j << 1 | 1] = im;
				dst[j << 1 | 2] = re * mRe - im * mIm;
				dst[j << 1 | 3] = re * mIm + im * mRe;
			}
		}
	}

	void test() {

	}

	void stress() {
		for (int tst = 0;; tst++) {
			if (false) {
				throw new AssertionError();
			}
			System.err.println(tst);
		}
	}

	Main() throws IOException {
		is = System.in;
		out = new PrintWriter(System.out);
		submit();
		// stress();
		// test();
		out.close();
	}

	static final Random rng = new Random();
	static final int C = 5;

	static int rand(int l, int r) {
		return l + rng.nextInt(r - l + 1);
	}

	public static void main(String[] args) throws IOException {
		new Main();
	}

	private InputStream is;
	PrintWriter out;

	private byte[] buf = new byte[1 << 14];
	private int bufSz = 0, bufPtr = 0;

	private int readByte() {
		if (bufSz == -1)
			throw new RuntimeException("Reading past EOF");
		if (bufPtr >= bufSz) {
			bufPtr = 0;
			try {
				bufSz = is.read(buf);
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
			if (bufSz <= 0)
				return -1;
		}
		return buf[bufPtr++];
	}

	private boolean isTrash(int c) {
		return c < 33 || c > 126;
	}

	private int skip() {
		int b;
		while ((b = readByte()) != -1 && isTrash(b))
			;
		return b;
	}

	String nextToken() {
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while (!isTrash(b)) {
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}

	String nextString() {
		int b = readByte();
		StringBuilder sb = new StringBuilder();
		while (!isTrash(b) || b == ' ') {
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}

	double nextDouble() {
		return Double.parseDouble(nextToken());
	}

	char nextChar() {
		return (char) skip();
	}

	int nextInt() {
		int ret = 0;
		int b = skip();
		if (b != '-' && (b < '0' || b > '9')) {
			throw new InputMismatchException();
		}
		boolean neg = false;
		if (b == '-') {
			neg = true;
			b = readByte();
		}
		while (true) {
			if (b >= '0' && b <= '9') {
				ret = ret * 10 + (b - '0');
			} else {
				if (b != -1 && !isTrash(b)) {
					throw new InputMismatchException();
				}
				return neg ? -ret : ret;
			}
			b = readByte();
		}
	}

	long nextLong() {
		long ret = 0;
		int b = skip();
		if (b != '-' && (b < '0' || b > '9')) {
			throw new InputMismatchException();
		}
		boolean neg = false;
		if (b == '-') {
			neg = true;
			b = readByte();
		}
		while (true) {
			if (b >= '0' && b <= '9') {
				ret = ret * 10 + (b - '0');
			} else {
				if (b != -1 && !isTrash(b)) {
					throw new InputMismatchException();
				}
				return neg ? -ret : ret;
			}
			b = readByte();
		}
	}
}

</source>
<source file="../hum_codes_raw/s770870772.java" startline="1" endline="445" pcid="25878">
import java.io.*;
import java.math.*;
import java.util.*;
import java.util.stream.*;

public class Main {

	static final int P = 998_244_353;

	void submit() {
		int[] cnt = new int[100_000];
		int n = nextInt();
		for (int i = 0; i < 2 * n; i++) {
			cnt[nextInt() - 1]++;
		}

		long[] pair = new long[n + 1];
		pair[0] = 1;
		for (int i = 1; i < pair.length; i++) {
			pair[i] = pair[i - 1] * (2 * i - 1) % P;
		}

		long[] inv = new long[2 * n + 1];
		inv[1] = 1;

		for (int i = 2; i < inv.length; i++) {
			inv[i] = P - (long) (P / i) * inv[P % i] % P;
		}

		PriorityQueue<int[]> pq = new PriorityQueue<>((int[] a, int[] b) -> Integer.compare(a.length, b.length));
		pq.add(new int[] { 1 });
		for (int x : cnt) {
			if (x < 2) {
				continue;
			}
			int[] p = new int[x / 2 + 1];
			long cur = p[0] = 1;
			for (int i = 1; i < p.length; i++) {
				cur = cur * (x - 2 * i + 2) % P * (x - 2 * i + 1) % P * inv[2 * i - 1] % P * inv[2 * i] % P;
				p[i] = (int) (cur * pair[i] % P);
			}
			pq.add(p);
		}

		while (pq.size() > 1) {
			int[] a = pq.poll();
			int[] b = pq.poll();
			pq.add(mult(a, b));
		}

		int[] p = pq.poll();
		long ans = 0;
		for (int i = 0; i < p.length; i++) {
			ans += (1 - i % 2 * 2) * p[i] * pair[n - i];
			if (ans >= P2) {
				ans -= P2;
			}
			if (ans < 0) {
				ans += P2;
			}
		}
		out.println(ans % P);
	}

	static final int NAIVE_MULT_THRESHOLD = 128;
	static final long P2 = (long) P * P;

	int[] mult(int[] a, int[] b) {
		int[] ret = multSmall(a, b);
		return ret != null ? ret : multFFT(a, b);
	}

	static int[] getNonZeroesIdx(int[] p) {
		int n = 0;
		for (int i = 0; i < p.length; i++) {
			if (p[i] != 0) {
				n++;
			}
		}
		int[] ret = new int[n];
		for (int i = 0; i < p.length; i++) {
			if (p[i] != 0) {
				ret[--n] = i;
			}
		}
		return ret;
	}

	static int[] removeLeadingZeroes(int[] a) {
		int i = a.length - 1;
		while (i >= 0 && a[i] == 0) {
			i--;
		}
		return i == a.length - 1 ? a : Arrays.copyOf(a, i + 1);
	}

	int[] multSmall(int[] a, int[] b) {
		int[] nza = getNonZeroesIdx(a);
		int[] nzb = getNonZeroesIdx(b);
		if (nza.length == 0 || nzb.length == 0) {
			return new int[] { 0 };
		}
		if (Math.min(nza.length, nzb.length) <= NAIVE_MULT_THRESHOLD) {
			long[] c = new long[nza[0] + nzb[0] + 1];
			for (int i : nza) {
				for (int j : nzb) {
					c[i + j] += (long) a[i] * b[j];
					if (c[i + j] >= P2) {
						c[i + j] -= P2;
					}
				}
			}
			int[] ret = new int[c.length];
			for (int i = 0; i < c.length; i++) {
				ret[i] = (int) (c[i] % P);
			}
			return removeLeadingZeroes(ret);
		}
		return null;
	}

	static int nextPowerOf2(int x) {
		return x == 1 ? 1 : Integer.highestOneBit(x - 1) << 1;
	}

	static final int L = (int) Math.sqrt(P);
	static final int L2 = L * L;

	/**
	 * Decomposes intV into vectors a and b s.t. intV = a + b * L.
	 * 
	 * @param len - length to pad intV to. !!! MUST BE A POWER OF 2 !!!
	 * @return double[][]{FFT(a), FFT(b)}.
	 */
	static double[][] decomposeAndFFT(int[] intV, int len) {
		// pack into one complex vector
		double[] f = new double[len << 1];
		for (int i = 0; i < intV.length; i++) {
			f[i << 1] = intV[i] % L;
			f[i << 1 | 1] = intV[i] / L;
		}

		fft(f, false);

		// unpack
		double[] f1 = new double[len << 1];
		double[] f2 = new double[len << 1];
		int zzz = (len << 1) - 1;
		for (int i = 0; i < len << 1; i += 2) {
			int j = (-i) & zzz;
			f1[i] = .5 * (f[i] + f[j]);
			f1[i + 1] = .5 * (f[i + 1] - f[j + 1]);
			f2[i] = .5 * (f[i + 1] + f[j + 1]);
			f2[i + 1] = .5 * (f[j] - f[i]);
		}

		return new double[][] { f1, f2 };
	}

	public static int[] multFFT(int[] a, int[] b) {
		int len = nextPowerOf2(a.length + b.length - 1);
		int len2 = len << 1;

		double[][] fA = decomposeAndFFT(a, len);
		double[][] fB = decomposeAndFFT(b, len);

		// Multiply FFT-ed vectors and pack them in pairs for inverse FFT.
		// We need to calcualte smth like (a0 b0) + L(a0 b1 + a1 b0) + L^2 (a1 b1)
		// a0 b0 goes into invF[0] real part
		// (a0 b1 + a1 b0) invF[0] imag part
		// a1 b1 -> invF[1] real part
		double[][] invF = new double[2][len2];
		for (int ia = 0; ia < 2; ia++) {
			for (int ib = 0; ib < 2; ib++) {

				double[] r = invF[(ia + ib) >> 1];
				double[] p = fA[ia];
				double[] q = fB[ib];

				if (((ia + ib) & 1) == 0) {
					for (int i = 0; i < len2; i += 2) {
						r[i] += p[i] * q[i] - p[i + 1] * q[i + 1];
						r[i + 1] += p[i] * q[i + 1] + p[i + 1] * q[i];
					}

				} else {
					for (int i = 0; i < len2; i += 2) {
						r[i] -= p[i] * q[i + 1] + p[i + 1] * q[i];
						r[i + 1] += p[i] * q[i] - p[i + 1] * q[i + 1];
					}
				}

			}
		}

		fft(invF[0], true);
		fft(invF[1], true);

		int[] ret = new int[len];

		for (int i = 0; i < len2; i += 2) {
			long v0 = Math.round(invF[0][i]);
			long v1 = Math.round(invF[0][i + 1]) % P * L;
			long v2 = Math.round(invF[1][i]) % P * L2;
			ret[i >> 1] = (int) ((v0 + v1 + v2) % P);
		}

		return removeLeadingZeroes(ret);
	}

	public static void fft(double[] v, boolean invert) {
		int n2 = v.length;
		int n = n2 >> 1;
		int logN = Integer.numberOfTrailingZeros(n);
		prepareArrays(logN);
		int[] rev = rev2D[logN];

		for (int i = 0; i < n2; i += 2) {
			int j = rev[i >> 1] << 1;
			if (i < j) {
				double t = v[i];
				v[i] = v[j];
				v[j] = t;
				t = v[i + 1];
				v[i + 1] = v[j + 1];
				v[j + 1] = t;
			}
		}

		double conj = invert ? -1 : 1;

		for (int len = 2, row = 0; len <= n; len <<= 1, row++) {
			double[] pow = pow2D[row];
			for (int i = 0; i < n; i += len) {
				for (int j1 = i << 1, j2 = j1 + len, k = 0; k < len; j1 += 2, j2 += 2, k += 2) {
					double uA = v[j1];
					double uB = v[j1 + 1];

					double mRe = pow[k];
					double mIm = pow[k + 1] * conj;

					double vA = v[j2] * mRe - v[j2 + 1] * mIm;
					double vB = v[j2] * mIm + v[j2 + 1] * mRe;

					v[j1] = uA + vA;
					v[j1 + 1] = uB + vB;
					v[j2] = uA - vA;
					v[j2 + 1] = uB - vB;
				}
			}
		}
		if (invert) {
			for (int i = 0; i < n2; i++) {
				v[i] /= n;
			}
		}
	}

	static double[][] pow2D = { { 1, 0 } };
	static int[][] rev2D = {};

	static void prepareArrays(int n) {
		if (rev2D.length < n + 1) {
			rev2D = Arrays.copyOf(rev2D, n + 1);
		}

		if (rev2D[n] == null) {
			int[] tmp = rev2D[n] = new int[1 << n];
			for (int i = 0; i < (1 << n); i++) {
				tmp[i] = (tmp[i >> 1] >> 1) | ((i & 1) << (n - 1));
			}
		}

		int oldN = pow2D.length;

		if (oldN >= n) {
			return;
		}

		pow2D = Arrays.copyOf(pow2D, n);

		for (int i = oldN; i < n; i++) {
			double angle = Math.PI / (1 << i);

			double mRe = Math.cos(angle);
			double mIm = Math.sin(angle);

			double[] dst = pow2D[i] = new double[2 << i];
			double[] src = pow2D[i - 1];

			for (int j = 0; j < 1 << i; j += 2) {
				double re = src[j];
				double im = src[j + 1];

				dst[j << 1] = re;
				dst[j << 1 | 1] = im;
				dst[j << 1 | 2] = re * mRe - im * mIm;
				dst[j << 1 | 3] = re * mIm + im * mRe;
			}
		}
	}

	void test() {

	}

	void stress() {
		for (int tst = 0;; tst++) {
			if (false) {
				throw new AssertionError();
			}
			System.err.println(tst);
		}
	}

	Main() throws IOException {
		is = System.in;
		out = new PrintWriter(System.out);
		submit();
		// stress();
		// test();
		out.close();
	}

	static final Random rng = new Random();
	static final int C = 5;

	static int rand(int l, int r) {
		return l + rng.nextInt(r - l + 1);
	}

	public static void main(String[] args) throws IOException {
		new Main();
	}

	private InputStream is;
	PrintWriter out;

	private byte[] buf = new byte[1 << 14];
	private int bufSz = 0, bufPtr = 0;

	private int readByte() {
		if (bufSz == -1)
			throw new RuntimeException("Reading past EOF");
		if (bufPtr >= bufSz) {
			bufPtr = 0;
			try {
				bufSz = is.read(buf);
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
			if (bufSz <= 0)
				return -1;
		}
		return buf[bufPtr++];
	}

	private boolean isTrash(int c) {
		return c < 33 || c > 126;
	}

	private int skip() {
		int b;
		while ((b = readByte()) != -1 && isTrash(b))
			;
		return b;
	}

	String nextToken() {
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while (!isTrash(b)) {
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}

	String nextString() {
		int b = readByte();
		StringBuilder sb = new StringBuilder();
		while (!isTrash(b) || b == ' ') {
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}

	double nextDouble() {
		return Double.parseDouble(nextToken());
	}

	char nextChar() {
		return (char) skip();
	}

	int nextInt() {
		int ret = 0;
		int b = skip();
		if (b != '-' && (b < '0' || b > '9')) {
			throw new InputMismatchException();
		}
		boolean neg = false;
		if (b == '-') {
			neg = true;
			b = readByte();
		}
		while (true) {
			if (b >= '0' && b <= '9') {
				ret = ret * 10 + (b - '0');
			} else {
				if (b != -1 && !isTrash(b)) {
					throw new InputMismatchException();
				}
				return neg ? -ret : ret;
			}
			b = readByte();
		}
	}

	long nextLong() {
		long ret = 0;
		int b = skip();
		if (b != '-' && (b < '0' || b > '9')) {
			throw new InputMismatchException();
		}
		boolean neg = false;
		if (b == '-') {
			neg = true;
			b = readByte();
		}
		while (true) {
			if (b >= '0' && b <= '9') {
				ret = ret * 10 + (b - '0');
			} else {
				if (b != -1 && !isTrash(b)) {
					throw new InputMismatchException();
				}
				return neg ? -ret : ret;
			}
			b = readByte();
		}
	}
}

</source>
</class>

<class classid="31" nclones="2" nlines="26" similarity="100">
<source file="../hum_codes_raw/s037591628.java" startline="1" endline="27" pcid="1268">
import java.util.Scanner;
public class Main{
  public static void main(String[] args){
    Scanner sc = new Scanner(System.in);
    int n=sc.nextInt();
    long[] a=new long[n];
   double l=0,sum=0;
    for(int i=0;i<n;i++) {
    	a[i]=sc.nextLong();
    	sum+=a[i];
    }
    for(int i=0;i<n;i++) {
    	if(l<sum/2) {
    		l+=a[i];
    	}
    	if(l==sum/2){
    		System.out.println("0");
    		break;
    	}
    	if(l>sum/2){
    		System.out.println((long)Math.min(Math.abs(2*l-sum), Math.abs(2*(l-a[i])-sum)));
    		break;
    	}
    }
  }
}

</source>
<source file="../hum_codes_raw/s248723278.java" startline="1" endline="27" pcid="8362">
import java.util.Scanner;
public class Main{
  public static void main(String[] args){
    Scanner sc = new Scanner(System.in);
    int n=sc.nextInt();
    long[] a=new long[n];
   double l=0,sum=0;
    for(int i=0;i<n;i++) {
    	a[i]=sc.nextLong();
    	sum+=a[i];
    }
    for(int i=0;i<n;i++) {
    	if(l<sum/2) {
    		l+=a[i];
    	}
    	if(l==sum/2){
    		System.out.println("0");
    		break;
    	}
    	if(l>sum/2){
    		System.out.println((long)Math.min(Math.abs(2*l-sum), Math.abs(2*(l-a[i])-sum)));
    		break;
    	}
    }
  }
}

</source>
</class>

<class classid="32" nclones="2" nlines="428" similarity="100">
<source file="../hum_codes_raw/s037905705.java" startline="1" endline="522" pcid="1275">
import java.io.*;
import java.math.*;
import java.util.*;
import java.util.stream.*;

public class Main {

	static final int P = 998_244_353;

	void submit() {
		int n = nextInt();
		int[] cnt = new int[100_000];
		for (int i = 0; i < 2 * n; i++) {
			cnt[nextInt() - 1]++;
		}

		long[] pair = new long[n + 1];
		pair[0] = 1;
		for (int i = 1; i < pair.length; i++) {
			pair[i] = pair[i - 1] * (2 * i - 1) % P;
		}

		long[] inv = new long[2 * n + 1];
		inv[1] = 1;

		for (int i = 2; i < inv.length; i++) {
			inv[i] = P - (long) (P / i) * inv[P % i] % P;
		}

		PriorityQueue<int[]> pq = new PriorityQueue<>((int[] a, int[] b) -> Integer.compare(a.length, b.length));
		pq.add(new int[] { 1 });
		for (int x : cnt) {
			if (x < 2) {
				continue;
			}
			int[] p = new int[x / 2 + 1];
			long cur = p[0] = 1;
			for (int i = 1; i < p.length; i++) {
				cur = cur * (x - 2 * i + 2) % P * (x - 2 * i + 1) % P * inv[2 * i - 1] % P * inv[2 * i] % P;
				p[i] = (int) (cur * pair[i] % P);
			}
			pq.add(p);
		}

		while (pq.size() > 1) {
			int[] a = pq.poll();
			int[] b = pq.poll();
			pq.add(mult(a, b));
		}
		
		int[] p = pq.poll();
		long ans = 0;
		for (int i = 0; i < p.length; i++) {
			ans += (1 - i % 2 * 2) * p[i] * pair[n - i];
			if (ans >= P2) {
				ans -= P2;
			}
			if (ans < 0) {
				ans += P2;
			}
		}
		out.println(ans % P);
	}

	static final int NAIVE_MULT_THRESHOLD = 32;
	static final long P2 = (long)P * P;
	
	int[] mult(int[] a, int[] b) {
		return multSmall(a, b).orElse(multFFT(a, b));
	}
	
	static int[] getNonZeroesIdx(int[] p) {
		int n = 0;
		for (int i = 0; i < p.length; i++) {
			if (p[i] != 0) {
				n++;
			}
		}
		int[] ret = new int[n];
		for (int i = 0; i < p.length; i++) {
			if (p[i] != 0) {
				ret[--n] = i;
			}
		}
		return ret;
	}
	
	static int[] removeLeadingZeroes(int[] a) {
		int i = a.length - 1;
		while (i >= 0 && a[i] == 0) {
			i--;
		}
		return i == a.length - 1 ? a : Arrays.copyOf(a, i + 1);
	}

	Optional<int[]> multSmall(int[] a, int[] b) {
		int[] nza = getNonZeroesIdx(a);
		int[] nzb = getNonZeroesIdx(b);
		if (nza.length == 0 || nzb.length == 0) {
			return Optional.of(new int[] {0});
		}
		if (Math.min(nza.length, nzb.length) <= NAIVE_MULT_THRESHOLD) {
			long[] c = new long[nza[0] + nzb[0] + 1];
			for (int i : nza) {
				for (int j : nzb) {
					c[i + j] += (long)a[i] * b[j];
					if (c[i + j] >= P2) {
						c[i + j] -= P2;
					}
				}
			}
			int[] ret = new int[c.length];
			for (int i = 0; i < c.length; i++) {
				ret[i] = (int) (c[i] % P);
			}
			return Optional.of(removeLeadingZeroes(ret));
		}
		return Optional.empty();
	}
	
	static int nextPowerOf2(int x) {
		return x == 1 ? 1 : Integer.highestOneBit(x - 1) << 1;
	}

	static class CompV {
		double[] re, im;

		void add(CompV o) {
			for (int i = 0; i < re.length; i++) {
				re[i] += o.re[i];
				im[i] += o.im[i];
			}
		}

		static CompV times(CompV a, CompV b) {
			double[] aRe = a.re;
			double[] aIm = a.im;
			double[] bRe = b.re;
			double[] bIm = b.im;
			double[] re = new double[aRe.length];
			double[] im = new double[aRe.length];

			for (int i = 0; i < aRe.length; i++) {
				re[i] = aRe[i] * bRe[i] - aIm[i] * bIm[i];
				im[i] = aRe[i] * bIm[i] + aIm[i] * bRe[i];
			}

			return new CompV(re, im);
		}

		static CompV plus(CompV a, CompV b) {
			double[] aRe = a.re;
			double[] aIm = a.im;
			double[] bRe = b.re;
			double[] bIm = b.im;
			double[] re = new double[aRe.length];
			double[] im = new double[aRe.length];

			for (int i = 0; i < aRe.length; i++) {
				re[i] = aRe[i] + bRe[i];
				im[i] = aIm[i] + bIm[i];
			}

			return new CompV(re, im);
		}

		/**
		 * @return a + bi
		 */
		static CompV packFFT(CompV a, CompV b) {
			double[] aRe = a.re;
			double[] aIm = a.im;
			double[] bRe = b.re;
			double[] bIm = b.im;
			double[] re = new double[aRe.length];
			double[] im = new double[aRe.length];
			for (int i = 0; i < aRe.length; i++) {
				re[i] = aRe[i] - bIm[i];
				im[i] = aIm[i] + bRe[i];
			}
			return new CompV(re, im);
		}

		/**
		 * for real-valued a and b restores FFT(a) and FFT(b) from FFT(a + bi)
		 */
		void unpackFFT(CompV a, CompV b) {
			int n = re.length;
			double[] aRe = a.re;
			double[] aIm = a.im;
			double[] bRe = b.re;
			double[] bIm = b.im;
			for (int i = 0; i < n; i++) {
				int j = i == 0 ? 0 : n - i;
				aRe[i] = (re[i] + re[j]) * 0.5;
				aIm[i] = (im[i] - im[j]) * 0.5;
				bRe[i] = (im[i] + im[j]) * 0.5;
				bIm[i] = (re[j] - re[i]) * 0.5;
			}
		}

		public CompV(double[] re, double[] im) {
			this.re = re;
			this.im = im;
		}

		public CompV(int len) {
			re = new double[len];
			im = new double[len];
		}
	}

	static final int L = (int) Math.sqrt(P);
	static final int L2 = L * L;

	public static int[] multFFT(int[] a, int[] b) {
		int len = nextPowerOf2(a.length + b.length - 1);

		double[] p1 = new double[len];
		double[] q1 = new double[len];
		for (int i = 0; i < a.length; i++) {
			p1[i] = a[i] % L;
			q1[i] = a[i] / L;
		}

		double[] p2 = new double[len];
		double[] q2 = new double[len];
		for (int i = 0; i < b.length; i++) {
			p2[i] = b[i] % L;
			q2[i] = b[i] / L;
		}

		CompV p1p2Pack = new CompV(p1, p2);
		CompV q1q2Pack = new CompV(q1, q2);

		fft(p1p2Pack, false);
		fft(q1q2Pack, false);

		CompV fp1 = new CompV(len);
		CompV fp2 = new CompV(len);
		p1p2Pack.unpackFFT(fp1, fp2);

		CompV fq1 = new CompV(len);
		CompV fq2 = new CompV(len);
		q1q2Pack.unpackFFT(fq1, fq2);

		CompV back0 = CompV.times(fp1, fp2);

		CompV back1 = CompV.times(fp1, fq2);
		back1.add(CompV.times(fq1, fp2));

		CompV back2 = CompV.times(fq1, fq2);

		CompV back01 = CompV.packFFT(back0, back1);

		fft(back01, true);
		fft(back2, true);

		int[] ret = new int[len];

		for (int i = 0; i < len; i++) {
			long v0 = Math.round(back01.re[i]) % P;
			long v1 = Math.round(back01.im[i]) % P * L % P;
			long v2 = Math.round(back2.re[i]) % P * L2 % P;
			ret[i] = (int) ((v0 + v1 + v2) % P);
		}

		return removeLeadingZeroes(ret);
	}

	public static void fft(CompV v, boolean invert) {
		double[] a = v.re;
		double[] b = v.im;
		
		int n = a.length;
		int shift = 32 - Integer.numberOfTrailingZeros(n);
		prepareArrays(32 - shift);
		int[] rev = rev2D[32 - shift];
		for (int i = 1; i < n; i++) {
			int j = rev[i];
			if (i < j) {
				double temp = a[i];
				a[i] = a[j];
				a[j] = temp;
				temp = b[i];
				b[i] = b[j];
				b[j] = temp;
			}
		}

		double multInv = invert ? -1 : 1;

		for (int len = 2, row = 0; len <= n; len <<= 1, row++) {
			int halfLen = len >> 1;
			double[] multReArr = powRe[row];
			double[] multImArr = powIm[row];
			for (int i = 0; i < n; i += len) {
				int toJ = i + halfLen;

				for (int j1 = i, j2 = toJ, k = 0; k < halfLen; j1++, j2++, k++) {
					double uA = a[j1];
					double uB = b[j1];

					double multRe = multReArr[k];
					double multIm = multImArr[k] * multInv;

					double vA = a[j2] * multRe - b[j2] * multIm;
					double vB = a[j2] * multIm + b[j2] * multRe;
					a[j1] = uA + vA;
					b[j1] = uB + vB;
					a[j2] = uA - vA;
					b[j2] = uB - vB;
				}
			}
		}
		if (invert) {
			for (int i = 0; i < n; i++) {
				a[i] /= n;
				b[i] /= n;
			}
		}
	}

	static double[][] powRe = { { 1 } };
	static double[][] powIm = { { 0 } };
	static int[][] rev2D = {};

	static void prepareArrays(int n) {

		if (rev2D.length < n + 1) {
				rev2D = Arrays.copyOf(rev2D, n + 1);
		}

		if (rev2D[n] == null) {
			int[] tmp = rev2D[n] = new int[1 << n];
			for (int i = 0; i < (1 << n); i++) {
				tmp[i] = tmp[i >> 1] >> 1;
				if ((i & 1) == 1) {
					tmp[i] |= 1 << (n - 1);
				}
			}
		}

		int oldN = powRe.length;

		if (oldN >= n) {
			return;
		}

		powRe = Arrays.copyOf(powRe, n);
		powIm = Arrays.copyOf(powIm, n);

		for (int i = oldN; i < n; i++) {

			double angle = Math.PI / (1 << i);

			double multRe = Math.cos(angle);
			double multIm = Math.sin(angle);

			double[] toRe = powRe[i] = new double[1 << i];
			double[] toIm = powIm[i] = new double[1 << i];

			double[] fromRe = powRe[i - 1];
			double[] fromIm = powIm[i - 1];

			for (int j = 0; j < 1 << (i - 1); j++) {

				double re = fromRe[j];
				double im = fromIm[j];

				toRe[j << 1] = re;
				toIm[j << 1] = im;
				toRe[(j << 1) | 1] = re * multRe - im * multIm;
				toIm[(j << 1) | 1] = re * multIm + im * multRe;
			}
		}
	}


	void test() {
		
	}

	void stress() {
		for (int tst = 0;; tst++) {
			if (false) {
				throw new AssertionError();
			}
			System.err.println(tst);
		}
	}

	Main() throws IOException {
		is = System.in;
		out = new PrintWriter(System.out);
		submit();
		// stress();
		// test();
		out.close();
	}

	static final Random rng = new Random();
	static final int C = 5;

	static int rand(int l, int r) {
		return l + rng.nextInt(r - l + 1);
	}

	public static void main(String[] args) throws IOException {
		new Main();
	}

	private InputStream is;
	PrintWriter out;

	private byte[] buf = new byte[1 << 14];
	private int bufSz = 0, bufPtr = 0;

	private int readByte() {
		if (bufSz == -1)
			throw new RuntimeException("Reading past EOF");
		if (bufPtr >= bufSz) {
			bufPtr = 0;
			try {
				bufSz = is.read(buf);
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
			if (bufSz <= 0)
				return -1;
		}
		return buf[bufPtr++];
	}

	private boolean isTrash(int c) {
		return c < 33 || c > 126;
	}

	private int skip() {
		int b;
		while ((b = readByte()) != -1 && isTrash(b))
			;
		return b;
	}

	String nextToken() {
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while (!isTrash(b)) {
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}

	String nextString() {
		int b = readByte();
		StringBuilder sb = new StringBuilder();
		while (!isTrash(b) || b == ' ') {
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}

	double nextDouble() {
		return Double.parseDouble(nextToken());
	}

	char nextChar() {
		return (char) skip();
	}

	int nextInt() {
		int ret = 0;
		int b = skip();
		if (b != '-' && (b < '0' || b > '9')) {
			throw new InputMismatchException();
		}
		boolean neg = false;
		if (b == '-') {
			neg = true;
			b = readByte();
		}
		while (true) {
			if (b >= '0' && b <= '9') {
				ret = ret * 10 + (b - '0');
			} else {
				if (b != -1 && !isTrash(b)) {
					throw new InputMismatchException();
				}
				return neg ? -ret : ret;
			}
			b = readByte();
		}
	}

	long nextLong() {
		long ret = 0;
		int b = skip();
		if (b != '-' && (b < '0' || b > '9')) {
			throw new InputMismatchException();
		}
		boolean neg = false;
		if (b == '-') {
			neg = true;
			b = readByte();
		}
		while (true) {
			if (b >= '0' && b <= '9') {
				ret = ret * 10 + (b - '0');
			} else {
				if (b != -1 && !isTrash(b)) {
					throw new InputMismatchException();
				}
				return neg ? -ret : ret;
			}
			b = readByte();
		}
	}
}

</source>
<source file="../hum_codes_raw/s226367837.java" startline="1" endline="522" pcid="7653">
import java.io.*;
import java.math.*;
import java.util.*;
import java.util.stream.*;

public class Main {

	static final int P = 998_244_353;

	void submit() {
		int n = nextInt();
		int[] cnt = new int[100_000];
		for (int i = 0; i < 2 * n; i++) {
			cnt[nextInt() - 1]++;
		}

		long[] pair = new long[n + 1];
		pair[0] = 1;
		for (int i = 1; i < pair.length; i++) {
			pair[i] = pair[i - 1] * (2 * i - 1) % P;
		}

		long[] inv = new long[2 * n + 1];
		inv[1] = 1;

		for (int i = 2; i < inv.length; i++) {
			inv[i] = P - (long) (P / i) * inv[P % i] % P;
		}

		PriorityQueue<int[]> pq = new PriorityQueue<>((int[] a, int[] b) -> Integer.compare(a.length, b.length));
		pq.add(new int[] { 1 });
		for (int x : cnt) {
			if (x < 2) {
				continue;
			}
			int[] p = new int[x / 2 + 1];
			long cur = p[0] = 1;
			for (int i = 1; i < p.length; i++) {
				cur = cur * (x - 2 * i + 2) % P * (x - 2 * i + 1) % P * inv[2 * i - 1] % P * inv[2 * i] % P;
				p[i] = (int) (cur * pair[i] % P);
			}
			pq.add(p);
		}

		while (pq.size() > 1) {
			int[] a = pq.poll();
			int[] b = pq.poll();
			pq.add(mult(a, b));
		}
		
		int[] p = pq.poll();
		long ans = 0;
		for (int i = 0; i < p.length; i++) {
			ans += (1 - i % 2 * 2) * p[i] * pair[n - i];
			if (ans >= P2) {
				ans -= P2;
			}
			if (ans < 0) {
				ans += P2;
			}
		}
		out.println(ans % P);
	}

	static final int NAIVE_MULT_THRESHOLD = 32;
	static final long P2 = (long)P * P;
	
	int[] mult(int[] a, int[] b) {
		return multSmall(a, b).orElse(multFFT(a, b));
	}
	
	static int[] getNonZeroesIdx(int[] p) {
		int n = 0;
		for (int i = 0; i < p.length; i++) {
			if (p[i] != 0) {
				n++;
			}
		}
		int[] ret = new int[n];
		for (int i = 0; i < p.length; i++) {
			if (p[i] != 0) {
				ret[--n] = i;
			}
		}
		return ret;
	}
	
	static int[] removeLeadingZeroes(int[] a) {
		int i = a.length - 1;
		while (i >= 0 && a[i] == 0) {
			i--;
		}
		return i == a.length - 1 ? a : Arrays.copyOf(a, i + 1);
	}

	Optional<int[]> multSmall(int[] a, int[] b) {
		int[] nza = getNonZeroesIdx(a);
		int[] nzb = getNonZeroesIdx(b);
		if (nza.length == 0 || nzb.length == 0) {
			return Optional.of(new int[] {0});
		}
		if (Math.min(nza.length, nzb.length) <= NAIVE_MULT_THRESHOLD) {
			long[] c = new long[nza[0] + nzb[0] + 1];
			for (int i : nza) {
				for (int j : nzb) {
					c[i + j] += (long)a[i] * b[j];
					if (c[i + j] >= P2) {
						c[i + j] -= P2;
					}
				}
			}
			int[] ret = new int[c.length];
			for (int i = 0; i < c.length; i++) {
				ret[i] = (int) (c[i] % P);
			}
			return Optional.of(removeLeadingZeroes(ret));
		}
		return Optional.empty();
	}
	
	static int nextPowerOf2(int x) {
		return x == 1 ? 1 : Integer.highestOneBit(x - 1) << 1;
	}

	static class CompV {
		double[] re, im;

		void add(CompV o) {
			for (int i = 0; i < re.length; i++) {
				re[i] += o.re[i];
				im[i] += o.im[i];
			}
		}

		static CompV times(CompV a, CompV b) {
			double[] aRe = a.re;
			double[] aIm = a.im;
			double[] bRe = b.re;
			double[] bIm = b.im;
			double[] re = new double[aRe.length];
			double[] im = new double[aRe.length];

			for (int i = 0; i < aRe.length; i++) {
				re[i] = aRe[i] * bRe[i] - aIm[i] * bIm[i];
				im[i] = aRe[i] * bIm[i] + aIm[i] * bRe[i];
			}

			return new CompV(re, im);
		}

		static CompV plus(CompV a, CompV b) {
			double[] aRe = a.re;
			double[] aIm = a.im;
			double[] bRe = b.re;
			double[] bIm = b.im;
			double[] re = new double[aRe.length];
			double[] im = new double[aRe.length];

			for (int i = 0; i < aRe.length; i++) {
				re[i] = aRe[i] + bRe[i];
				im[i] = aIm[i] + bIm[i];
			}

			return new CompV(re, im);
		}

		/**
		 * @return a + bi
		 */
		static CompV packFFT(CompV a, CompV b) {
			double[] aRe = a.re;
			double[] aIm = a.im;
			double[] bRe = b.re;
			double[] bIm = b.im;
			double[] re = new double[aRe.length];
			double[] im = new double[aRe.length];
			for (int i = 0; i < aRe.length; i++) {
				re[i] = aRe[i] - bIm[i];
				im[i] = aIm[i] + bRe[i];
			}
			return new CompV(re, im);
		}

		/**
		 * for real-valued a and b restores FFT(a) and FFT(b) from FFT(a + bi)
		 */
		void unpackFFT(CompV a, CompV b) {
			int n = re.length;
			double[] aRe = a.re;
			double[] aIm = a.im;
			double[] bRe = b.re;
			double[] bIm = b.im;
			for (int i = 0; i < n; i++) {
				int j = i == 0 ? 0 : n - i;
				aRe[i] = (re[i] + re[j]) * 0.5;
				aIm[i] = (im[i] - im[j]) * 0.5;
				bRe[i] = (im[i] + im[j]) * 0.5;
				bIm[i] = (re[j] - re[i]) * 0.5;
			}
		}

		public CompV(double[] re, double[] im) {
			this.re = re;
			this.im = im;
		}

		public CompV(int len) {
			re = new double[len];
			im = new double[len];
		}
	}

	static final int L = (int) Math.sqrt(P);
	static final int L2 = L * L;

	public static int[] multFFT(int[] a, int[] b) {
		int len = nextPowerOf2(a.length + b.length - 1);

		double[] p1 = new double[len];
		double[] q1 = new double[len];
		for (int i = 0; i < a.length; i++) {
			p1[i] = a[i] % L;
			q1[i] = a[i] / L;
		}

		double[] p2 = new double[len];
		double[] q2 = new double[len];
		for (int i = 0; i < b.length; i++) {
			p2[i] = b[i] % L;
			q2[i] = b[i] / L;
		}

		CompV p1p2Pack = new CompV(p1, p2);
		CompV q1q2Pack = new CompV(q1, q2);

		fft(p1p2Pack, false);
		fft(q1q2Pack, false);

		CompV fp1 = new CompV(len);
		CompV fp2 = new CompV(len);
		p1p2Pack.unpackFFT(fp1, fp2);

		CompV fq1 = new CompV(len);
		CompV fq2 = new CompV(len);
		q1q2Pack.unpackFFT(fq1, fq2);

		CompV back0 = CompV.times(fp1, fp2);

		CompV back1 = CompV.times(fp1, fq2);
		back1.add(CompV.times(fq1, fp2));

		CompV back2 = CompV.times(fq1, fq2);

		CompV back01 = CompV.packFFT(back0, back1);

		fft(back01, true);
		fft(back2, true);

		int[] ret = new int[len];

		for (int i = 0; i < len; i++) {
			long v0 = Math.round(back01.re[i]) % P;
			long v1 = Math.round(back01.im[i]) % P * L % P;
			long v2 = Math.round(back2.re[i]) % P * L2 % P;
			ret[i] = (int) ((v0 + v1 + v2) % P);
		}

		return removeLeadingZeroes(ret);
	}

	public static void fft(CompV v, boolean invert) {
		double[] a = v.re;
		double[] b = v.im;
		
		int n = a.length;
		int shift = 32 - Integer.numberOfTrailingZeros(n);
		prepareArrays(32 - shift);
		int[] rev = rev2D[32 - shift];
		for (int i = 1; i < n; i++) {
			int j = rev[i];
			if (i < j) {
				double temp = a[i];
				a[i] = a[j];
				a[j] = temp;
				temp = b[i];
				b[i] = b[j];
				b[j] = temp;
			}
		}

		double multInv = invert ? -1 : 1;

		for (int len = 2, row = 0; len <= n; len <<= 1, row++) {
			int halfLen = len >> 1;
			double[] multReArr = powRe[row];
			double[] multImArr = powIm[row];
			for (int i = 0; i < n; i += len) {
				int toJ = i + halfLen;

				for (int j1 = i, j2 = toJ, k = 0; k < halfLen; j1++, j2++, k++) {
					double uA = a[j1];
					double uB = b[j1];

					double multRe = multReArr[k];
					double multIm = multImArr[k] * multInv;

					double vA = a[j2] * multRe - b[j2] * multIm;
					double vB = a[j2] * multIm + b[j2] * multRe;
					a[j1] = uA + vA;
					b[j1] = uB + vB;
					a[j2] = uA - vA;
					b[j2] = uB - vB;
				}
			}
		}
		if (invert) {
			for (int i = 0; i < n; i++) {
				a[i] /= n;
				b[i] /= n;
			}
		}
	}

	static double[][] powRe = { { 1 } };
	static double[][] powIm = { { 0 } };
	static int[][] rev2D = {};

	static void prepareArrays(int n) {

		if (rev2D.length < n + 1) {
				rev2D = Arrays.copyOf(rev2D, n + 1);
		}

		if (rev2D[n] == null) {
			int[] tmp = rev2D[n] = new int[1 << n];
			for (int i = 0; i < (1 << n); i++) {
				tmp[i] = tmp[i >> 1] >> 1;
				if ((i & 1) == 1) {
					tmp[i] |= 1 << (n - 1);
				}
			}
		}

		int oldN = powRe.length;

		if (oldN >= n) {
			return;
		}

		powRe = Arrays.copyOf(powRe, n);
		powIm = Arrays.copyOf(powIm, n);

		for (int i = oldN; i < n; i++) {

			double angle = Math.PI / (1 << i);

			double multRe = Math.cos(angle);
			double multIm = Math.sin(angle);

			double[] toRe = powRe[i] = new double[1 << i];
			double[] toIm = powIm[i] = new double[1 << i];

			double[] fromRe = powRe[i - 1];
			double[] fromIm = powIm[i - 1];

			for (int j = 0; j < 1 << (i - 1); j++) {

				double re = fromRe[j];
				double im = fromIm[j];

				toRe[j << 1] = re;
				toIm[j << 1] = im;
				toRe[(j << 1) | 1] = re * multRe - im * multIm;
				toIm[(j << 1) | 1] = re * multIm + im * multRe;
			}
		}
	}


	void test() {
		
	}

	void stress() {
		for (int tst = 0;; tst++) {
			if (false) {
				throw new AssertionError();
			}
			System.err.println(tst);
		}
	}

	Main() throws IOException {
		is = System.in;
		out = new PrintWriter(System.out);
		submit();
		// stress();
		// test();
		out.close();
	}

	static final Random rng = new Random();
	static final int C = 5;

	static int rand(int l, int r) {
		return l + rng.nextInt(r - l + 1);
	}

	public static void main(String[] args) throws IOException {
		new Main();
	}

	private InputStream is;
	PrintWriter out;

	private byte[] buf = new byte[1 << 14];
	private int bufSz = 0, bufPtr = 0;

	private int readByte() {
		if (bufSz == -1)
			throw new RuntimeException("Reading past EOF");
		if (bufPtr >= bufSz) {
			bufPtr = 0;
			try {
				bufSz = is.read(buf);
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
			if (bufSz <= 0)
				return -1;
		}
		return buf[bufPtr++];
	}

	private boolean isTrash(int c) {
		return c < 33 || c > 126;
	}

	private int skip() {
		int b;
		while ((b = readByte()) != -1 && isTrash(b))
			;
		return b;
	}

	String nextToken() {
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while (!isTrash(b)) {
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}

	String nextString() {
		int b = readByte();
		StringBuilder sb = new StringBuilder();
		while (!isTrash(b) || b == ' ') {
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}

	double nextDouble() {
		return Double.parseDouble(nextToken());
	}

	char nextChar() {
		return (char) skip();
	}

	int nextInt() {
		int ret = 0;
		int b = skip();
		if (b != '-' && (b < '0' || b > '9')) {
			throw new InputMismatchException();
		}
		boolean neg = false;
		if (b == '-') {
			neg = true;
			b = readByte();
		}
		while (true) {
			if (b >= '0' && b <= '9') {
				ret = ret * 10 + (b - '0');
			} else {
				if (b != -1 && !isTrash(b)) {
					throw new InputMismatchException();
				}
				return neg ? -ret : ret;
			}
			b = readByte();
		}
	}

	long nextLong() {
		long ret = 0;
		int b = skip();
		if (b != '-' && (b < '0' || b > '9')) {
			throw new InputMismatchException();
		}
		boolean neg = false;
		if (b == '-') {
			neg = true;
			b = readByte();
		}
		while (true) {
			if (b >= '0' && b <= '9') {
				ret = ret * 10 + (b - '0');
			} else {
				if (b != -1 && !isTrash(b)) {
					throw new InputMismatchException();
				}
				return neg ? -ret : ret;
			}
			b = readByte();
		}
	}
}

</source>
</class>

<class classid="33" nclones="2" nlines="434" similarity="100">
<source file="../hum_codes_raw/s039503237.java" startline="1" endline="407" pcid="1331">
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.lang.reflect.Field;
import java.util.NoSuchElementException;
import java.util.PrimitiveIterator;
import java.util.function.IntUnaryOperator;
import java.util.function.LongUnaryOperator;
import static java.lang.Math.max;

public class Main {
    public static void main(String[] args) throws Exception {
        Field f = System.out.getClass().getDeclaredField("autoFlush");
        f.setAccessible(true);
        f.set(System.out, false);
        Out out = new Out(System.out);
        solve(new FastScanner(), out);
        out.flush();
        out.close();
    }

    public static void solve(FastScanner fsc, Out out) {
        int n = fsc.nextInt();
        int[] v = new int[0x40000];
        int[] w = new int[0x40000];
        for (int i = 1; i <= n; i++) {
            v[i] = fsc.nextInt();
            w[i] = fsc.nextInt();
        }
        int lmax = 100001;
        int[] memo = new int[0x200 * lmax];
        for (int i = 1; i < 0x200; i++) {
            for (int j = 1; j < lmax; j++) {
                if (j >= w[i]) {
                    memo[i * lmax + j] = max(memo[(i >> 1) * lmax + j], memo[(i >> 1) * lmax + j - w[i]] + v[i]);
                } else {
                    memo[i * lmax + j] = memo[(i >> 1) * lmax + j];
                }
                memo[i * lmax + j] = max(memo[i * lmax + j], memo[i * lmax + j - 1]);
            }
        }
        int q = fsc.nextInt();
        LongQueue que = new LongQueue(0x200);
        while (q --> 0) {
            int x = fsc.nextInt();
            int m = fsc.nextInt();
            que.add(0);
            int max = 0;
            for (; x >= 0x200; x >>= 1) {
                int sz = que.size();
                while (sz --> 0) {
                    long vw = que.poll();
                    if ((vw & 0xffff_ffffl) + w[x] <= m) que.add(vw + ((long) v[x] << 32) + w[x]);
                    que.add(vw);
                }
            }
            while (que.size() > 0) {
                long vw = que.poll();
                int vs = (int) (vw >>> 32);
                int ws = (int) (vw & 0xffff_ffffl);
                max = max(max, vs + memo[x * lmax + m - ws]);
            }
            out.write(max).write('\n');
            que.clear();
        }
    }
}


/**
 * @author https://atcoder.jp/users/suisen
 */
final class In {
    public static final FastScanner fsc = new FastScanner();
    public static int ni() {return fsc.nextInt();}
    public static int[] ni(final int n) {
        final int[] a = new int[n];
        for (int i = 0; i < n; i++) a[i] = fsc.nextInt();
        return a;
    }
    public static int[] ni(final int n, final IntUnaryOperator f) {
        final int[] a = new int[n];
        for (int i = 0; i < n; i++) a[i] = f.applyAsInt(fsc.nextInt());
        return a;
    }
    public static int[][] ni(final int n, final int m) {
        final int[][] a = new int[n][m];
        for (int i = 0; i < n; i++) a[i] = ni(m);
        return a;
    }
    public static int[][] ni(final int n, final int m, final IntUnaryOperator f) {
        final int[][] a = new int[n][m];
        for (int i = 0; i < n; i++) a[i] = ni(m, f);
        return a;
    }
    public static long nl() {return fsc.nextLong();}
    public static long[] nl(final int n) {
        final long[] a = new long[n];
        for (int i = 0; i < n; i++) a[i] = fsc.nextLong();
        return a;
    }
    public static long[] nl(final int n, final LongUnaryOperator f) {
        final long[] a = new long[n];
        for (int i = 0; i < n; i++) a[i] = f.applyAsLong(fsc.nextLong());
        return a;
    }
    public static long[][] nl(final int n, final int m) {
        final long[][] a = new long[n][m];
        for (int i = 0; i < n; i++) a[i] = nl(m);
        return a;
    }
    public static long[][] nl(final int n, final int m, final LongUnaryOperator f) {
        final long[][] a = new long[n][m];
        for (int i = 0; i < n; i++) a[i] = nl(m, f);
        return a;
    }
    public static char[] nc() {return fsc.next().toCharArray();}
    public static char[][] nc(final int n) {
        final char[][] c = new char[n][];
        for (int i = 0; i < n; i++) c[i] = nc();
        return c;
    }
    public static double nd() {return fsc.nextDouble();}
    public static double[] nd(final int n) {
        final double[] a = new double[n];
        for (int i = 0; i < n; i++) a[i] = fsc.nextDouble();
        return a;
    }
    public static double[][] nd(final int n, final int m) {
        final double[][] a = new double[n][m];
        for (int i = 0; i < n; i++) a[i] = nd(m);
        return a;
    }
    public static String ns() {return fsc.next();}
    public static String[] ns(final int n) {
        final String[] s = new String[n];
        for (int i = 0; i < n; i++) s[i] = fsc.next();
        return s;
    }
    public static boolean[][] grid(final int h, final int w, final char trueCharacter) {
        final boolean[][] grid = new boolean[h][w];
        for (int i = 0; i < h; i++) {
            final char[] s = fsc.next().toCharArray();
            for (int j = 0; j < w; j++) grid[i][j] = s[j] == trueCharacter;
        }
        return grid;
    }
}


final class FastScanner {
    private final InputStream in = System.in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;
    private boolean hasNextByte() {
        if (ptr < buflen) return true;
        ptr = 0;
        try {buflen = in.read(buffer);}
        catch (final IOException e) {e.printStackTrace();}
        return buflen > 0;
    }
    private int readByte() {return hasNextByte() ? buffer[ptr++] : -1;}
    public boolean hasNext() {
        while (hasNextByte() && !(33 <= buffer[ptr] && buffer[ptr] <= 126)) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new NoSuchElementException();
        final StringBuilder sb = new StringBuilder();
        int b = readByte();
        while (33 <= b && b <= 126) {sb.appendCodePoint(b); b = readByte();}
        return sb.toString();
    }
    public long nextLong() {
        if (!hasNext()) throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {minus = true; b = readByte();}
        if (b < '0' || '9' < b) throw new NumberFormatException();
        for (; ; b = readByte()) {
            if ('0' <= b && b <= '9') n = n * 10 + b - '0';
            else if (b == -1 || !(33 <= b && b <= 126)) return minus ? -n : n;
            else throw new NumberFormatException();
        }
    }
    public int nextInt() {return Math.toIntExact(nextLong());}
    public double nextDouble() {return Double.parseDouble(next());}
}


/**
 * @author https://atcoder.jp/users/suisen
 * 
 * Queue for long type.
 */
final class LongQueue implements Iterable<Long> {
    private static final int DEFAULT_SIZE = 64;
    private long[] q;
    private int head = 0, tail = 0;
    public LongQueue(final int capacity) {this.q = new long[capacity];}
    public LongQueue() {this(DEFAULT_SIZE);}
    public long peek() {
        if (head == tail) throw new NoSuchElementException("No Elements.");
        return q[head];
    }
    public long getFromHead(int index) {
        if (head + index >= tail || index < 0) throw new NoSuchElementException("Index out of bounds.");
        return q[head + index];
    }
    public long getFromTail(int index) {
        if (head + index >= tail || index < 0) throw new NoSuchElementException("Index out of bounds.");
        return q[tail - 1 - index];
    }
    public void add(final long v) {
        if (tail == q.length) grow();
        q[tail++] = v;
    }
    public void add(final long... vals) {for (long v : vals) add(v);}
    public long poll() {
        if (head == tail) throw new NoSuchElementException("No Elements.");
        return q[head++];
    }
    public int size() {return tail - head;}
    public void clear() {head = tail = 0;}
    private void grow() {
        final long[] grown = new long[q.length << 1];
        final int len = size();
        System.arraycopy(q, head, grown, 0, len);
        q = grown;
        tail = len;
        head = 0;
    }
    public PrimitiveIterator.OfLong iterator() {return new LongQueueIterator();}
    private class LongQueueIterator implements PrimitiveIterator.OfLong {
        private int i = head;
        public boolean hasNext() {return i < tail;}
        public long nextLong() {return q[i++];}
    }
}


class Out {
    private final OutputStream out;
    private byte[] buf = new byte[1024];
    private int ptr = 0;
    private static final int AUTO_FLUSH_THRETHOLD = 1 << 17;

    public Out(OutputStream out) {
        this.out = out;
    }

    public void flush() {
        try {
            out.write(buf, 0, ptr);
            out.flush();
            ptr = 0;
        } catch (IOException e) {e.printStackTrace();}
    }

    public void close() {
        try {out.close();} catch (IOException e) {e.printStackTrace();}
    }

    public Out write(Object o) {
        return write(o.toString());
    }

    public Out write(String s) {
        try {
            Field strValueField = s.getClass().getDeclaredField("value");
            strValueField.setAccessible(true);
            byte[] b = (byte[]) strValueField.get(s);
            int l = s.length();
            if (l > AUTO_FLUSH_THRETHOLD) {
                flush();
                int i = 0;
                while (i + AUTO_FLUSH_THRETHOLD < l) {
                    out.write(b, i, AUTO_FLUSH_THRETHOLD);
                    out.flush();
                    i += AUTO_FLUSH_THRETHOLD;
                }
                ensureCapacity(l - i);
                System.arraycopy(b, i, buf, 0, l - i);
                ptr = l - i;
            } else {
                ensureCapacity(ptr + l);
                System.arraycopy(b, 0, buf, ptr, l);
                ptr += l;
            }
        } catch (Exception e) {e.printStackTrace();}
        return this;
    }

    public Out write(char[] c) {
        int l = c.length;
        if (l > AUTO_FLUSH_THRETHOLD) {
            flush();
            ensureCapacity(AUTO_FLUSH_THRETHOLD);
            int i = 0;
            while (i + AUTO_FLUSH_THRETHOLD < l) {
                for (int j = 0; j < AUTO_FLUSH_THRETHOLD; j++) {
                    buf[ptr++] = (byte) c[i + j];
                }
                flush();
                i += AUTO_FLUSH_THRETHOLD;
            }
            for (; i < l; i++) {
                buf[ptr++] = (byte) c[i];
            }
        } else {
            ensureCapacity(ptr + l);
            for (char ch : c) buf[ptr++] = (byte) ch;
        }
        return this;
    }

    public Out write(char c) {
        ensureCapacity(ptr + 1);
        buf[ptr++] = (byte) c;
        return this;
    }

    public Out write(byte b) {
        ensureCapacity(ptr + 1);
        buf[ptr++] = b;
        return this;
    }

    public Out write(int x) {
        if (x == 0) {
            ensureCapacity(ptr + 1);
            buf[ptr++] = '0';
            return this;
        }
        int d = stringSize(x);
        ensureCapacity(ptr + d);
        if (x < 0) {
            buf[ptr++] = '-';
            x = -x;
            d--;
        }
        int j = ptr + d; 
        while (x > 0) {
            buf[--j] = (byte) ('0' + (x % 10));
            x /= 10;
        }
        ptr += d;
        return this;
    }

    public Out write(long x) {
        if (x == 0) {
            ensureCapacity(ptr + 1);
            buf[ptr++] = '0';
            return this;
        }
        int d = stringSize(x);
        ensureCapacity(ptr + d);
        if (x < 0) {
            buf[ptr++] = '-';
            x = -x;
            d--;
        }
        int j = ptr + d; 
        while (x > 0) {
            buf[--j] = (byte) ('0' + (x % 10));
            x /= 10;
        }
        ptr += d;
        return this;
    }

    public Out write(double d) {
        return write(Double.toString(d));
    }

    private void ensureCapacity(int cap) {
        if (cap > AUTO_FLUSH_THRETHOLD) {
            flush();
        }
        if (cap >= buf.length) {
            int newLength = buf.length;
            while (newLength < cap) newLength <<= 1;
            byte[] newBuf = new byte[newLength];
            System.arraycopy(buf, 0, newBuf, 0, buf.length);
            buf = newBuf;
        }
    }
    private static int stringSize(long x) {
        int d = 1;
        if (x >= 0) {d = 0; x = -x;}
        long p = -10;
        for (int i = 1; i < 19; i++, p *= 10) if (x > p) return i + d;
        return 19 + d;
    }
    private static int stringSize(int x) {
        int d = 1;
        if (x >= 0) {d = 0; x = -x;}
        int p = -10;
        for (int i = 1; i < 10; i++, p *= 10) if (x > p) return i + d;
        return 10 + d;
    }
}

</source>
<source file="../hum_codes_raw/s268695582.java" startline="1" endline="407" pcid="8996">
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.lang.reflect.Field;
import java.util.NoSuchElementException;
import java.util.PrimitiveIterator;
import java.util.function.IntUnaryOperator;
import java.util.function.LongUnaryOperator;
import static java.lang.Math.max;

public class Main {
    public static void main(String[] args) throws Exception {
        Field f = System.out.getClass().getDeclaredField("autoFlush");
        f.setAccessible(true);
        f.set(System.out, false);
        Out out = new Out(System.out);
        solve(new FastScanner(), out);
        out.flush();
        out.close();
    }

    public static void solve(FastScanner fsc, Out out) {
        int n = fsc.nextInt();
        int[] v = new int[0x40000];
        int[] w = new int[0x40000];
        for (int i = 1; i <= n; i++) {
            v[i] = fsc.nextInt();
            w[i] = fsc.nextInt();
        }
        int lmax = 100001;
        int[] memo = new int[0x200 * lmax];
        for (int i = 1; i < 0x200; i++) {
            for (int j = 1; j < lmax; j++) {
                if (j >= w[i]) {
                    memo[i * lmax + j] = max(memo[(i >> 1) * lmax + j], memo[(i >> 1) * lmax + j - w[i]] + v[i]);
                } else {
                    memo[i * lmax + j] = memo[(i >> 1) * lmax + j];
                }
                memo[i * lmax + j] = max(memo[i * lmax + j], memo[i * lmax + j - 1]);
            }
        }
        int q = fsc.nextInt();
        LongQueue que = new LongQueue(0x200);
        while (q --> 0) {
            int x = fsc.nextInt();
            int m = fsc.nextInt();
            que.add(0);
            int max = 0;
            for (; x >= 0x200; x >>= 1) {
                int sz = que.size();
                while (sz --> 0) {
                    long vw = que.poll();
                    if ((vw & 0xffff_ffffl) + w[x] <= m) que.add(vw + ((long) v[x] << 32) + w[x]);
                    que.add(vw);
                }
            }
            while (que.size() > 0) {
                long vw = que.poll();
                int vs = (int) (vw >>> 32);
                int ws = (int) (vw & 0xffff_ffffl);
                max = max(max, vs + memo[x * lmax + m - ws]);
            }
            out.write(max).write('\n');
            que.clear();
        }
    }
}


/**
 * @author https://atcoder.jp/users/suisen
 */
final class In {
    public static final FastScanner fsc = new FastScanner();
    public static int ni() {return fsc.nextInt();}
    public static int[] ni(final int n) {
        final int[] a = new int[n];
        for (int i = 0; i < n; i++) a[i] = fsc.nextInt();
        return a;
    }
    public static int[] ni(final int n, final IntUnaryOperator f) {
        final int[] a = new int[n];
        for (int i = 0; i < n; i++) a[i] = f.applyAsInt(fsc.nextInt());
        return a;
    }
    public static int[][] ni(final int n, final int m) {
        final int[][] a = new int[n][m];
        for (int i = 0; i < n; i++) a[i] = ni(m);
        return a;
    }
    public static int[][] ni(final int n, final int m, final IntUnaryOperator f) {
        final int[][] a = new int[n][m];
        for (int i = 0; i < n; i++) a[i] = ni(m, f);
        return a;
    }
    public static long nl() {return fsc.nextLong();}
    public static long[] nl(final int n) {
        final long[] a = new long[n];
        for (int i = 0; i < n; i++) a[i] = fsc.nextLong();
        return a;
    }
    public static long[] nl(final int n, final LongUnaryOperator f) {
        final long[] a = new long[n];
        for (int i = 0; i < n; i++) a[i] = f.applyAsLong(fsc.nextLong());
        return a;
    }
    public static long[][] nl(final int n, final int m) {
        final long[][] a = new long[n][m];
        for (int i = 0; i < n; i++) a[i] = nl(m);
        return a;
    }
    public static long[][] nl(final int n, final int m, final LongUnaryOperator f) {
        final long[][] a = new long[n][m];
        for (int i = 0; i < n; i++) a[i] = nl(m, f);
        return a;
    }
    public static char[] nc() {return fsc.next().toCharArray();}
    public static char[][] nc(final int n) {
        final char[][] c = new char[n][];
        for (int i = 0; i < n; i++) c[i] = nc();
        return c;
    }
    public static double nd() {return fsc.nextDouble();}
    public static double[] nd(final int n) {
        final double[] a = new double[n];
        for (int i = 0; i < n; i++) a[i] = fsc.nextDouble();
        return a;
    }
    public static double[][] nd(final int n, final int m) {
        final double[][] a = new double[n][m];
        for (int i = 0; i < n; i++) a[i] = nd(m);
        return a;
    }
    public static String ns() {return fsc.next();}
    public static String[] ns(final int n) {
        final String[] s = new String[n];
        for (int i = 0; i < n; i++) s[i] = fsc.next();
        return s;
    }
    public static boolean[][] grid(final int h, final int w, final char trueCharacter) {
        final boolean[][] grid = new boolean[h][w];
        for (int i = 0; i < h; i++) {
            final char[] s = fsc.next().toCharArray();
            for (int j = 0; j < w; j++) grid[i][j] = s[j] == trueCharacter;
        }
        return grid;
    }
}


final class FastScanner {
    private final InputStream in = System.in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;
    private boolean hasNextByte() {
        if (ptr < buflen) return true;
        ptr = 0;
        try {buflen = in.read(buffer);}
        catch (final IOException e) {e.printStackTrace();}
        return buflen > 0;
    }
    private int readByte() {return hasNextByte() ? buffer[ptr++] : -1;}
    public boolean hasNext() {
        while (hasNextByte() && !(33 <= buffer[ptr] && buffer[ptr] <= 126)) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new NoSuchElementException();
        final StringBuilder sb = new StringBuilder();
        int b = readByte();
        while (33 <= b && b <= 126) {sb.appendCodePoint(b); b = readByte();}
        return sb.toString();
    }
    public long nextLong() {
        if (!hasNext()) throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {minus = true; b = readByte();}
        if (b < '0' || '9' < b) throw new NumberFormatException();
        for (; ; b = readByte()) {
            if ('0' <= b && b <= '9') n = n * 10 + b - '0';
            else if (b == -1 || !(33 <= b && b <= 126)) return minus ? -n : n;
            else throw new NumberFormatException();
        }
    }
    public int nextInt() {return Math.toIntExact(nextLong());}
    public double nextDouble() {return Double.parseDouble(next());}
}


/**
 * @author https://atcoder.jp/users/suisen
 * 
 * Queue for long type.
 */
final class LongQueue implements Iterable<Long> {
    private static final int DEFAULT_SIZE = 64;
    private long[] q;
    private int head = 0, tail = 0;
    public LongQueue(final int capacity) {this.q = new long[capacity];}
    public LongQueue() {this(DEFAULT_SIZE);}
    public long peek() {
        if (head == tail) throw new NoSuchElementException("No Elements.");
        return q[head];
    }
    public long getFromHead(int index) {
        if (head + index >= tail || index < 0) throw new NoSuchElementException("Index out of bounds.");
        return q[head + index];
    }
    public long getFromTail(int index) {
        if (head + index >= tail || index < 0) throw new NoSuchElementException("Index out of bounds.");
        return q[tail - 1 - index];
    }
    public void add(final long v) {
        if (tail == q.length) grow();
        q[tail++] = v;
    }
    public void add(final long... vals) {for (long v : vals) add(v);}
    public long poll() {
        if (head == tail) throw new NoSuchElementException("No Elements.");
        return q[head++];
    }
    public int size() {return tail - head;}
    public void clear() {head = tail = 0;}
    private void grow() {
        final long[] grown = new long[q.length << 1];
        final int len = size();
        System.arraycopy(q, head, grown, 0, len);
        q = grown;
        tail = len;
        head = 0;
    }
    public PrimitiveIterator.OfLong iterator() {return new LongQueueIterator();}
    private class LongQueueIterator implements PrimitiveIterator.OfLong {
        private int i = head;
        public boolean hasNext() {return i < tail;}
        public long nextLong() {return q[i++];}
    }
}


class Out {
    private final OutputStream out;
    private byte[] buf = new byte[1024];
    private int ptr = 0;
    private static final int AUTO_FLUSH_THRETHOLD = 1 << 17;

    public Out(OutputStream out) {
        this.out = out;
    }

    public void flush() {
        try {
            out.write(buf, 0, ptr);
            out.flush();
            ptr = 0;
        } catch (IOException e) {e.printStackTrace();}
    }

    public void close() {
        try {out.close();} catch (IOException e) {e.printStackTrace();}
    }

    public Out write(Object o) {
        return write(o.toString());
    }

    public Out write(String s) {
        try {
            Field strValueField = s.getClass().getDeclaredField("value");
            strValueField.setAccessible(true);
            byte[] b = (byte[]) strValueField.get(s);
            int l = s.length();
            if (l > AUTO_FLUSH_THRETHOLD) {
                flush();
                int i = 0;
                while (i + AUTO_FLUSH_THRETHOLD < l) {
                    out.write(b, i, AUTO_FLUSH_THRETHOLD);
                    out.flush();
                    i += AUTO_FLUSH_THRETHOLD;
                }
                ensureCapacity(l - i);
                System.arraycopy(b, i, buf, 0, l - i);
                ptr = l - i;
            } else {
                ensureCapacity(ptr + l);
                System.arraycopy(b, 0, buf, ptr, l);
                ptr += l;
            }
        } catch (Exception e) {e.printStackTrace();}
        return this;
    }

    public Out write(char[] c) {
        int l = c.length;
        if (l > AUTO_FLUSH_THRETHOLD) {
            flush();
            ensureCapacity(AUTO_FLUSH_THRETHOLD);
            int i = 0;
            while (i + AUTO_FLUSH_THRETHOLD < l) {
                for (int j = 0; j < AUTO_FLUSH_THRETHOLD; j++) {
                    buf[ptr++] = (byte) c[i + j];
                }
                flush();
                i += AUTO_FLUSH_THRETHOLD;
            }
            for (; i < l; i++) {
                buf[ptr++] = (byte) c[i];
            }
        } else {
            ensureCapacity(ptr + l);
            for (char ch : c) buf[ptr++] = (byte) ch;
        }
        return this;
    }

    public Out write(char c) {
        ensureCapacity(ptr + 1);
        buf[ptr++] = (byte) c;
        return this;
    }

    public Out write(byte b) {
        ensureCapacity(ptr + 1);
        buf[ptr++] = b;
        return this;
    }

    public Out write(int x) {
        if (x == 0) {
            ensureCapacity(ptr + 1);
            buf[ptr++] = '0';
            return this;
        }
        int d = stringSize(x);
        ensureCapacity(ptr + d);
        if (x < 0) {
            buf[ptr++] = '-';
            x = -x;
            d--;
        }
        int j = ptr + d; 
        while (x > 0) {
            buf[--j] = (byte) ('0' + (x % 10));
            x /= 10;
        }
        ptr += d;
        return this;
    }

    public Out write(long x) {
        if (x == 0) {
            ensureCapacity(ptr + 1);
            buf[ptr++] = '0';
            return this;
        }
        int d = stringSize(x);
        ensureCapacity(ptr + d);
        if (x < 0) {
            buf[ptr++] = '-';
            x = -x;
            d--;
        }
        int j = ptr + d; 
        while (x > 0) {
            buf[--j] = (byte) ('0' + (x % 10));
            x /= 10;
        }
        ptr += d;
        return this;
    }

    public Out write(double d) {
        return write(Double.toString(d));
    }

    private void ensureCapacity(int cap) {
        if (cap > AUTO_FLUSH_THRETHOLD) {
            flush();
        }
        if (cap >= buf.length) {
            int newLength = buf.length;
            while (newLength < cap) newLength <<= 1;
            byte[] newBuf = new byte[newLength];
            System.arraycopy(buf, 0, newBuf, 0, buf.length);
            buf = newBuf;
        }
    }
    private static int stringSize(long x) {
        int d = 1;
        if (x >= 0) {d = 0; x = -x;}
        long p = -10;
        for (int i = 1; i < 19; i++, p *= 10) if (x > p) return i + d;
        return 19 + d;
    }
    private static int stringSize(int x) {
        int d = 1;
        if (x >= 0) {d = 0; x = -x;}
        int p = -10;
        for (int i = 1; i < 10; i++, p *= 10) if (x > p) return i + d;
        return 10 + d;
    }
}

</source>
</class>

<class classid="34" nclones="2" nlines="21" similarity="100">
<source file="../hum_codes_raw/s039841887.java" startline="1" endline="25" pcid="1344">

import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int k = sc.nextInt();
		long t = 0;
		long ans = 0;
		if (k % 2 == 0) {
			t = n / k;
			ans += (t * t * t);
			t = ((n*2) / k +1)/2;
			ans += (t * t * t);
		} else {
			t = n / k;
			ans += (t * t * t);
		}

		System.out.println(ans);

	}
}

</source>
<source file="../hum_codes_raw/s717718126.java" startline="1" endline="24" pcid="24128">
import java.util.Scanner;
 
public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int k = sc.nextInt();
		long t = 0;
		long ans = 0;
		if (k % 2 == 0) {
			t = n / k;
			ans += (t * t * t);
			t = ((n*2) / k +1)/2;
			ans += (t * t * t);
		} else {
			t = n / k;
			ans += (t * t * t);
		}
 
		System.out.println(ans);
 
	}
}

</source>
</class>

<class classid="35" nclones="2" nlines="37" similarity="100">
<source file="../hum_codes_raw/s040949687.java" startline="1" endline="45" pcid="1377">
import java.util.*;

public class Main{
    void run(){
        Scanner sc = new Scanner(System.in);
        while(true){
            int[] card_num = new int[101];
            int m = sc.nextInt();
            if(m==0){
                break;
            }
            int[] value = new int[m];
            int[] num = new int[m];
            for(int i = 0; i < m; i++){
                value[i] = sc.nextInt();
                num[i] = sc.nextInt();
            }
            int[] dp = new int[1001];
            dp[0] = 1;
            for(int i = 0; i < m; i++){
                for(int ii = 1000 - value[i] -1; ii >= 0; ii--){
                    for(int iii = 1; iii <= num[i]; iii++){
                        if(ii + value[i]*iii <= 1000){
                            dp[ii + value[i]*iii] += dp[ii];
                        }
                    }
                }
            }
            /*
              System.out.println(Arrays.toString(dp));
              for(int i = 0; i < 100; i++){
              System.out.println(i + " : " + dp[i]);
              }
            */
            int g = sc.nextInt();
            for(int i = 0; i < g; i++){
                System.out.println(dp[sc.nextInt()]);
            }
        }
    }
    public static void main(String[] args){
        new Main().run();
    }
}

</source>
<source file="../hum_codes_raw/s207613195.java" startline="1" endline="45" pcid="6998">
import java.util.*;

public class Main{
    void run(){
        Scanner sc = new Scanner(System.in);
        while(true){
            int[] card_num = new int[101];
            int m = sc.nextInt();
            if(m==0){
                break;
            }
            int[] value = new int[m];
            int[] num = new int[m];
            for(int i = 0; i < m; i++){
                value[i] = sc.nextInt();
                num[i] = sc.nextInt();
            }
            int[] dp = new int[1001];
            dp[0] = 1;
            for(int i = 0; i < m; i++){
                for(int ii = 1000 - value[i] -1; ii >= 0; ii--){
                    for(int iii = 1; iii <= num[i]; iii++){
                        if(ii + value[i]*iii <= 1000){
                            dp[ii + value[i]*iii] += dp[ii];
                        }
                    }
                }
            }
            /*
              System.out.println(Arrays.toString(dp));
              for(int i = 0; i < 100; i++){
              System.out.println(i + " : " + dp[i]);
              }
            */
            int g = sc.nextInt();
            for(int i = 0; i < g; i++){
                System.out.println(dp[sc.nextInt()]);
            }
        }
    }
    public static void main(String[] args){
        new Main().run();
    }
}

</source>
</class>

<class classid="36" nclones="2" nlines="14" similarity="100">
<source file="../hum_codes_raw/s041632907.java" startline="1" endline="16" pcid="1396">
import java.util.*;

public class Main {
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int a = sc.nextInt();
        int b = sc.nextInt();
        if(b%a == 0) {
            System.out.println(a + b);
        } else {
            System.out.println(b - a);
        }
    }
}

</source>
<source file="../hum_codes_raw/s659265746.java" startline="1" endline="17" pcid="22140">

import java.util.*;

public class Main {
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int a = sc.nextInt();
        int b = sc.nextInt();
        if(b%a == 0) {
            System.out.println(a + b);
        } else {
            System.out.println(b - a);
        }
    }
}

</source>
</class>

<class classid="37" nclones="2" nlines="100" similarity="100">
<source file="../hum_codes_raw/s043441489.java" startline="1" endline="104" pcid="1446">
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

//Doctor's Memorable Codes
public class Main{

	public static void main(String[] args) {
		Map<String, Character> t = new HashMap<String, Character>();
		t.put("101", ' ');
		t.put("000000", '\'');
		t.put("000011", ',');
		t.put("10010001", '-');
		t.put("010001", '.');
		t.put("000001", '?');
		t.put("100101", 'A');
		t.put("10011010", 'B');
		t.put("0101", 'C');
		t.put("0001", 'D');
		t.put("110", 'E');
		t.put("01001", 'F');
		t.put("10011011", 'G');
		t.put("010000", 'H');
		t.put("0111", 'I');
		t.put("10011000", 'J');
		t.put("0110", 'K');
		t.put("00100", 'L');
		t.put("10011001", 'M');
		t.put("10011110", 'N');
		t.put("00101", 'O');
		t.put("111", 'P');
		t.put("10011111", 'Q');
		t.put("1000", 'R');
		t.put("00110", 'S');
		t.put("00111", 'T');
		t.put("10011100", 'U');
		t.put("10011101", 'V');
		t.put("000010", 'W');
		t.put("10010010", 'X');
		t.put("10010011", 'Y');
		t.put("10010000", 'Z');
		Map<Character, String> r = new HashMap<Character, String>();
		r.put('A', "00000");
		r.put('B', "00001");
		r.put('C', "00010");
		r.put('D', "00011");
		r.put('E', "00100");
		r.put('F', "00101");
		r.put('G', "00110");
		r.put('H', "00111");
		r.put('I', "01000");
		r.put('J', "01001");
		r.put('K', "01010");
		r.put('L', "01011");
		r.put('M', "01100");
		r.put('N', "01101");
		r.put('O', "01110");
		r.put('P', "01111");
		r.put('Q', "10000");
		r.put('R', "10001");
		r.put('S', "10010");
		r.put('T', "10011");
		r.put('U', "10100");
		r.put('V', "10101");
		r.put('W', "10110");
		r.put('X', "10111");
		r.put('Y', "11000");
		r.put('Z', "11001");
		r.put(' ', "11010");
		r.put('.', "11011");
		r.put(',', "11100");
		r.put('-', "11101");
		r.put('\'', "11110");
		r.put('?', "11111");
		Scanner sc = new Scanner(System.in);
		while(sc.hasNext()){
			char[] m = sc.nextLine().toCharArray();
			StringBuilder sb = new StringBuilder();
			for(char c:m)sb.append(r.get(c));
			String s = sb.toString();
			sb = new StringBuilder();
			int i=0;
			while(i<s.length()){
				int k;
				for(k=3;i+k<=s.length();k++){
					String sub = s.substring(i,i+k);
					boolean f = false;
					for(String v : t.keySet()){
						if(v.equals(sub)){
							f = true;
							break;
						}
					}
					if(f)break;
				}
				if(i+k>s.length())break;
				sb.append(t.get(s.substring(i,i+k)));
				i+=k;
			}
			System.out.println(sb);
		}
	}
}

</source>
<source file="../hum_codes_raw/s760882476.java" startline="1" endline="104" pcid="25563">
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

//Doctor's Memorable Codes
public class Main {

	public static void main(String[] args) {
		Map<String, Character> t = new HashMap<String, Character>();
		t.put("101", ' ');
		t.put("000000", '\'');
		t.put("000011", ',');
		t.put("10010001", '-');
		t.put("010001", '.');
		t.put("000001", '?');
		t.put("100101", 'A');
		t.put("10011010", 'B');
		t.put("0101", 'C');
		t.put("0001", 'D');
		t.put("110", 'E');
		t.put("01001", 'F');
		t.put("10011011", 'G');
		t.put("010000", 'H');
		t.put("0111", 'I');
		t.put("10011000", 'J');
		t.put("0110", 'K');
		t.put("00100", 'L');
		t.put("10011001", 'M');
		t.put("10011110", 'N');
		t.put("00101", 'O');
		t.put("111", 'P');
		t.put("10011111", 'Q');
		t.put("1000", 'R');
		t.put("00110", 'S');
		t.put("00111", 'T');
		t.put("10011100", 'U');
		t.put("10011101", 'V');
		t.put("000010", 'W');
		t.put("10010010", 'X');
		t.put("10010011", 'Y');
		t.put("10010000", 'Z');
		Map<Character, String> r = new HashMap<Character, String>();
		r.put('A', "00000");
		r.put('B', "00001");
		r.put('C', "00010");
		r.put('D', "00011");
		r.put('E', "00100");
		r.put('F', "00101");
		r.put('G', "00110");
		r.put('H', "00111");
		r.put('I', "01000");
		r.put('J', "01001");
		r.put('K', "01010");
		r.put('L', "01011");
		r.put('M', "01100");
		r.put('N', "01101");
		r.put('O', "01110");
		r.put('P', "01111");
		r.put('Q', "10000");
		r.put('R', "10001");
		r.put('S', "10010");
		r.put('T', "10011");
		r.put('U', "10100");
		r.put('V', "10101");
		r.put('W', "10110");
		r.put('X', "10111");
		r.put('Y', "11000");
		r.put('Z', "11001");
		r.put(' ', "11010");
		r.put('.', "11011");
		r.put(',', "11100");
		r.put('-', "11101");
		r.put('\'', "11110");
		r.put('?', "11111");
		Scanner sc = new Scanner(System.in);
		while(sc.hasNext()){
			char[] m = sc.nextLine().toCharArray();
			StringBuilder sb = new StringBuilder();
			for(char c:m)sb.append(r.get(c));
			String s = sb.toString();
			sb = new StringBuilder();
			int i=0;
			while(i<s.length()){
				int k;
				for(k=3;i+k<=s.length();k++){
					String sub = s.substring(i,i+k);
					boolean f = false;
					for(String v : t.keySet()){
						if(v.equals(sub)){
							f = true;
							break;
						}
					}
					if(f)break;
				}
				if(i+k>s.length())break;
				sb.append(t.get(s.substring(i,i+k)));
				i+=k;
			}
			System.out.println(sb);
		}
	}
}

</source>
</class>

<class classid="38" nclones="2" nlines="63" similarity="100">
<source file="../hum_codes_raw/s043731904.java" startline="1" endline="92" pcid="1453">
import java.io.BufferedReader; 
import java.io.*;
import java.io.InputStreamReader; 
import java.util.Scanner; 
import java.util.StringTokenizer; 
import java.util.*;
import java.math.*;
public class Main 
{ 
    static class FastReader 
    { 
        BufferedReader br; 
        StringTokenizer st; 
  
        public FastReader()
        { 
            br = new BufferedReader(new
                     InputStreamReader(System.in)); 
        } 
  
        String next()
        { 
            while (st == null || !st.hasMoreElements()) 
            { 
                try
                { 
                    st = new StringTokenizer(br.readLine()); 
                } 
                catch (IOException  e) 
                { 
                    e.printStackTrace(); 
                } 
            } 
            return st.nextToken(); 
        } 
  
        int nextInt() 
        { 
            return Integer.parseInt(next()); 
        } 
  
        long nextLong() 
        { 
            return Long.parseLong(next()); 
        } 
  
        double nextDouble() 
        { 
            return Double.parseDouble(next()); 
        } 
  
        String nextLine() 
        { 
            String str = ""; 
            try
            { 
                str = br.readLine();
            } 
            catch (IOException e) 
            { 
                e.printStackTrace(); 
            } 
            return str; 
        } 
    } 
   public static void main(String args[])
    {
        FastReader sc=new FastReader();
        PrintWriter pw=new PrintWriter(System.out);
        int t=1;//sc.nextInt();
        while(t-->0)
        {
           int n=sc.nextInt(),f=0,a[]=new int[n];
           for(int i=0;i<n;i++)
           {
             a[i]=sc.nextInt();
           }int ans[]=new int[n],p=0,q=n-1;
           for(int i=n-1;i>=0;i-=2)
           {
             ans[p++]=a[i];
             if(i-1>=0)
             ans[q--]=a[i-1];
           }
           for(int w:ans)
           pw.print(w+" ");
           pw.println();
        }
           pw.close();
    }
}
  

</source>
<source file="../hum_codes_raw/s500506438.java" startline="1" endline="92" pcid="16774">
import java.io.BufferedReader; 
import java.io.*;
import java.io.InputStreamReader; 
import java.util.Scanner; 
import java.util.StringTokenizer; 
import java.util.*;
import java.math.*;
public class Main 
{ 
    static class FastReader 
    { 
        BufferedReader br; 
        StringTokenizer st; 
  
        public FastReader()
        { 
            br = new BufferedReader(new
                     InputStreamReader(System.in)); 
        } 
  
        String next()
        { 
            while (st == null || !st.hasMoreElements()) 
            { 
                try
                { 
                    st = new StringTokenizer(br.readLine()); 
                } 
                catch (IOException  e) 
                { 
                    e.printStackTrace(); 
                } 
            } 
            return st.nextToken(); 
        } 
  
        int nextInt() 
        { 
            return Integer.parseInt(next()); 
        } 
  
        long nextLong() 
        { 
            return Long.parseLong(next()); 
        } 
  
        double nextDouble() 
        { 
            return Double.parseDouble(next()); 
        } 
  
        String nextLine() 
        { 
            String str = ""; 
            try
            { 
                str = br.readLine();
            } 
            catch (IOException e) 
            { 
                e.printStackTrace(); 
            } 
            return str; 
        } 
    } 
   public static void main(String args[])
    {
        FastReader sc=new FastReader();
        PrintWriter pw=new PrintWriter(System.out);
        int t=1;//sc.nextInt();
        while(t-->0)
        {
           int n=sc.nextInt(),f=0,a[]=new int[n];
           for(int i=0;i<n;i++)
           {
             a[i]=sc.nextInt();
           }int ans[]=new int[n],p=0,q=n-1;
           for(int i=n-1;i>=0;i-=2)
           {
             ans[p++]=a[i];
             if(i-1>=0)
             ans[q--]=a[i-1];
           }
           for(int w:ans)
           pw.print(w+" ");
           pw.println();
        }
           pw.close();
    }
}
  

</source>
</class>

<class classid="39" nclones="3" nlines="91" similarity="100">
<source file="../hum_codes_raw/s043913838.java" startline="1" endline="135" pcid="1462">
import java.util.*;
import java.lang.*;
import java.io.*;

class Main{

    private static int[][] used;
    private static int N,M,L;
    private static List<Pox>[] list;
    private static final int INF = 100000000;

    private static class Pox{
	public int B,D,E;
	Pox(){
	    B = D = E = 0;
	}

	Pox(int b,int d,int e){
	    B = b;
	    D = d;
	    E = e;
	}
    }

    private static class Eleac implements Comparable<Eleac>{
	public int id,L,num;

	Eleac(){
	    id = L = num = 0;
	}

	Eleac(int a,int b,int c){
	    id = a;
	    L = b;
	    num = c;
	}

	@Override
	public int compareTo(Eleac a){
	    return 1;
	}

    }

     @SuppressWarnings("unchecked")
      public static void main(String args[])throws IOException{
	  BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
	  
	  while(true)
	      {
		  String[] elements = in.readLine().split(" ");
		  N = Integer.parseInt(elements[0]);
		  M = Integer.parseInt(elements[1]);
		  L = Integer.parseInt(elements[2]);
		  if(N == 0 && M == 0 && L == 0)
		      break;

		  

		  used = new int[N+1][L+1];
		  list = new ArrayList[N+2];

		  for(int i=0;i<N+1;i++)
		      for(int j=0;j<L+1;j++)
			  used[i][j] = INF;

		  for(int i=0;i<N+1;i++)
		      list[i] = new ArrayList<Pox>();
		  
		  for(int i=0;i<M;i++)
		      {
			 elements = in.readLine().split(" ");
			 int A,B,D,E;
			  A = Integer.parseInt(elements[0]);
			  B = Integer.parseInt(elements[1]);
			  D = Integer.parseInt(elements[2]);
			  E = Integer.parseInt(elements[3]);

			  list[A].add(new Pox(B,D,E));  
			  list[B].add(new Pox(A,D,E));
		      }

		  Queue<Eleac> que = new PriorityQueue<Eleac>();

		  que.offer(new Eleac(1,L,0)); //Eleac(id,money,the number of eemy)
		  used[1][L] = 0;		

		  int men = INF;
		  while(que.size() > 0)
		      {
			  Eleac p = que.poll(); 
			  int now = p.id;
			  int money = p.L;
			  int val = p.num;
			  
			  if(now == N)
			      {
				  used[now][money] = Math.min(used[now][money],val);	
				  continue;
			      }
		      
			 
			  for(int i=0;i<list[now].size();i++)
			      {
				  int need = list[now].get(i).D;

				  int new_pos = list[now].get(i).B;
				  int the_number = list[now].get(i).E;
				  
				  if(money-need >= 0 && used[new_pos][money-need] > val)
				      {
					  used[new_pos][money-need] = val;
					  que.add(new Eleac(new_pos,money-need,val));
				      }				  	
				  if(used[new_pos][money] > val+the_number)
				      {
					  used[new_pos][money] = val+the_number;
					  que.add(new Eleac(new_pos,money,val+the_number));
				      }

			      }

		      
		      }

		  for(int i=0;i<=L;i++)
		      {
			  men = Math.min(men,used[N][i]);
		      }
		  System.out.println(men);
	      }
      }

}

</source>
<source file="../hum_codes_raw/s983391347.java" startline="1" endline="135" pcid="33069">
import java.util.*;
import java.lang.*;
import java.io.*;

class Main{

    private static int[][] used;
    private static int N,M,L;
    private static List<Pox>[] list;
    private static final int INF = 100000000;

    private static class Pox{
	public int B,D,E;
	Pox(){
	    B = D = E = 0;
	}

	Pox(int b,int d,int e){
	    B = b;
	    D = d;
	    E = e;
	}
    }

    private static class Eleac implements Comparable<Eleac>{
	public int id,L,num;

	Eleac(){
	    id = L = num = 0;
	}

	Eleac(int a,int b,int c){
	    id = a;
	    L = b;
	    num = c;
	}

	@Override
	public int compareTo(Eleac a){
	    return 1;
	}

    }

     @SuppressWarnings("unchecked")
      public static void main(String args[])throws IOException{
	  BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
	  
	  while(true)
	      {
		  String[] elements = in.readLine().split(" ");
		  N = Integer.parseInt(elements[0]);
		  M = Integer.parseInt(elements[1]);
		  L = Integer.parseInt(elements[2]);
		  if(N == 0 && M == 0 && L == 0)
		      break;

		  

		  used = new int[N+1][L+1];
		  list = new ArrayList[N+2];

		  for(int i=0;i<N+1;i++)
		      for(int j=0;j<L+1;j++)
			  used[i][j] = INF;

		  for(int i=0;i<N+1;i++)
		      list[i] = new ArrayList<Pox>();
		  
		  for(int i=0;i<M;i++)
		      {
			 elements = in.readLine().split(" ");
			 int A,B,D,E;
			  A = Integer.parseInt(elements[0]);
			  B = Integer.parseInt(elements[1]);
			  D = Integer.parseInt(elements[2]);
			  E = Integer.parseInt(elements[3]);

			  list[A].add(new Pox(B,D,E));  
			  list[B].add(new Pox(A,D,E));
		      }

		  Queue<Eleac> que = new PriorityQueue<Eleac>();

		  que.offer(new Eleac(1,L,0)); //Eleac(id,money,the number of eemy)
		  used[1][L] = 0;		

		  int men = INF;
		  while(que.size() > 0)
		      {
			  Eleac p = que.poll(); 
			  int now = p.id;
			  int money = p.L;
			  int val = p.num;
			  
			  if(now == N)
			      {
				  used[now][money] = Math.min(used[now][money],val);	
				  continue;
			      }
		      
			 
			  for(int i=0;i<list[now].size();i++)
			      {
				  int need = list[now].get(i).D;

				  int new_pos = list[now].get(i).B;
				  int the_number = list[now].get(i).E;
				  
				  if(money-need >= 0 && used[new_pos][money-need] > val)
				      {
					  used[new_pos][money-need] = val;
					  que.add(new Eleac(new_pos,money-need,val));
				      }				  	
				  if(used[new_pos][money] > val+the_number)
				      {
					  used[new_pos][money] = val+the_number;
					  que.add(new Eleac(new_pos,money,val+the_number));
				      }

			      }

		      
		      }

		  for(int i=0;i<=L;i++)
		      {
			  men = Math.min(men,used[N][i]);
		      }
		  System.out.println(men);
	      }
      }

}

</source>
<source file="../hum_codes_raw/s133051952.java" startline="1" endline="135" pcid="4440">
import java.util.*;
import java.lang.*;
import java.io.*;
 
class Main{
 
    private static int[][] used;
    private static int N,M,L;
    private static List<Pox>[] list;
    private static final int INF = 100000000;
 
    private static class Pox{
    public int B,D,E;
    Pox(){
        B = D = E = 0;
    }
 
    Pox(int b,int d,int e){
        B = b;
        D = d;
        E = e;
    }
    }
 
    private static class Eleac implements Comparable<Eleac>{
    public int id,L,num;
 
    Eleac(){
        id = L = num = 0;
    }
 
    Eleac(int a,int b,int c){
        id = a;
        L = b;
        num = c;
    }
 
    @Override
    public int compareTo(Eleac a){
        return 1;
    }
 
    }
 
     @SuppressWarnings("unchecked")
      public static void main(String args[])throws IOException{
      BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
       
      while(true)
          {
          String[] elements = in.readLine().split(" ");
          N = Integer.parseInt(elements[0]);
          M = Integer.parseInt(elements[1]);
          L = Integer.parseInt(elements[2]);
          if(N == 0 && M == 0 && L == 0)
              break;
 
           
 
          used = new int[N+1][L+1];
          list = new ArrayList[N+2];
 
          for(int i=0;i<N+1;i++)
              for(int j=0;j<L+1;j++)
              used[i][j] = INF;
 
          for(int i=0;i<N+1;i++)
              list[i] = new ArrayList<Pox>();
           
          for(int i=0;i<M;i++)
              {
             elements = in.readLine().split(" ");
             int A,B,D,E;
              A = Integer.parseInt(elements[0]);
              B = Integer.parseInt(elements[1]);
              D = Integer.parseInt(elements[2]);
              E = Integer.parseInt(elements[3]);
 
              list[A].add(new Pox(B,D,E));  
              list[B].add(new Pox(A,D,E));
              }
 
          Queue<Eleac> que = new PriorityQueue<Eleac>();
 
          que.offer(new Eleac(1,L,0)); //Eleac(id,money,the number of eemy)
          used[1][L] = 0;       
 
          int men = INF;
          while(que.size() > 0)
              {
              Eleac p = que.poll(); 
              int now = p.id;
              int money = p.L;
              int val = p.num;
               
              if(now == N)
                  {
                  used[now][money] = Math.min(used[now][money],val);    
                  continue;
                  }
               
              
              for(int i=0;i<list[now].size();i++)
                  {
                  int need = list[now].get(i).D;
 
                  int new_pos = list[now].get(i).B;
                  int the_number = list[now].get(i).E;
                   
                  if(money-need >= 0 && used[new_pos][money-need] > val)
                      {
                      used[new_pos][money-need] = val;
                      que.add(new Eleac(new_pos,money-need,val));
                      }                 
                  if(used[new_pos][money] > val+the_number)
                      {
                      used[new_pos][money] = val+the_number;
                      que.add(new Eleac(new_pos,money,val+the_number));
                      }
 
                  }
 
               
              }
 
          for(int i=0;i<=L;i++)
              {
              men = Math.min(men,used[N][i]);
              }
          System.out.println(men);
          }
      }
 
}

</source>
</class>

<class classid="40" nclones="2" nlines="242" similarity="100">
<source file="../hum_codes_raw/s045421668.java" startline="1" endline="290" pcid="1506">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.util.Deque;
import java.util.ArrayList;
import java.io.UncheckedIOException;
import java.util.List;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.ArrayDeque;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            CThreeCircuits solver = new CThreeCircuits();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class CThreeCircuits {
        Deque<Node> trace = new ArrayDeque<>();

        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            int m = in.readInt();
            int[] deg = new int[n];
            Node[] nodes = new Node[n];
            for (int i = 0; i < n; i++) {
                nodes[i] = new Node();
            }
            for (int i = 0; i < m; i++) {
                int a = in.readInt() - 1;
                int b = in.readInt() - 1;
                deg[a]++;
                deg[b]++;
                Edge e = new Edge();
                e.a = nodes[a];
                e.b = nodes[b];
                e.a.adj.add(e);
                e.b.adj.add(e);
            }

            String no = "No";
            String yes = "Yes";
            for (int i = 0; i < n; i++) {
                if (deg[i] % 2 == 1) {
                    out.println("No");
                    return;
                }
            }


            List<Node> xy = new ArrayList<>(2);
            for (int i = 0; i < n; i++) {
                if (deg[i] >= 6) {
                    out.println(yes);
                    return;
                }
                if (deg[i] == 4) {
                    xy.add(nodes[i]);
                }
            }

            if (xy.size() >= 3) {
                out.println(yes);
                return;
            }
            if (xy.size() <= 1) {
                out.println(no);
                return;
            }

            dfs(nodes[0]);
            List<Node> list = new ArrayList<>(trace);
            SequenceUtils.reverse(list);

            List<Node> compressed = new ArrayList<>();
            for (Node node : list) {
                if (xy.contains(node)) {
                    compressed.add(node);
                }
            }

            if (compressed.get(0) == compressed.get(1) || compressed.get(1) == compressed.get(2)) {
                out.println(yes);
            } else {
                out.println(no);
            }
        }

        public void dfs(Node root) {
            while (!root.adj.isEmpty()) {
                Edge tail = root.adj.remove(root.adj.size() - 1);
                if (tail.handled) {
                    continue;
                }
                tail.handled = true;
                Node node = tail.other(root);
                dfs(node);
            }
            trace.addLast(root);
        }

    }

    static class SequenceUtils {
        public static <T> void swap(List<T> data, int i, int j) {
            T tmp = data.get(i);
            data.set(i, data.get(j));
            data.set(j, tmp);
        }

        public static <T> void reverse(List<T> data, int l, int r) {
            while (l < r) {
                swap(data, l, r);
                l++;
                r--;
            }
        }

        public static <T> void reverse(List<T> data) {
            reverse(data, 0, data.size() - 1);
        }

    }

    static class Node {
        List<Edge> adj = new ArrayList<>();

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(String c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(String c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class Edge {
        Node a;
        Node b;
        boolean handled;

        Node other(Node x) {
            return a == x ? b : a;
        }

    }
}


</source>
<source file="../hum_codes_raw/s195610269.java" startline="1" endline="290" pcid="6594">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.util.Deque;
import java.util.ArrayList;
import java.io.UncheckedIOException;
import java.util.List;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.ArrayDeque;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            CThreeCircuits solver = new CThreeCircuits();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class CThreeCircuits {
        Deque<Node> trace = new ArrayDeque<>();

        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            int m = in.readInt();
            int[] deg = new int[n];
            Node[] nodes = new Node[n];
            for (int i = 0; i < n; i++) {
                nodes[i] = new Node();
            }
            for (int i = 0; i < m; i++) {
                int a = in.readInt() - 1;
                int b = in.readInt() - 1;
                deg[a]++;
                deg[b]++;
                Edge e = new Edge();
                e.a = nodes[a];
                e.b = nodes[b];
                e.a.adj.add(e);
                e.b.adj.add(e);
            }

            String no = "No";
            String yes = "Yes";
            for (int i = 0; i < n; i++) {
                if (deg[i] % 2 == 1) {
                    out.println("No");
                    return;
                }
            }


            List<Node> xy = new ArrayList<>(2);
            for (int i = 0; i < n; i++) {
                if (deg[i] >= 6) {
                    out.println(yes);
                    return;
                }
                if (deg[i] == 4) {
                    xy.add(nodes[i]);
                }
            }

            if (xy.size() >= 3) {
                out.println(yes);
                return;
            }
            if (xy.size() <= 1) {
                out.println(no);
                return;
            }

            dfs(nodes[0]);
            List<Node> list = new ArrayList<>(trace);
            SequenceUtils.reverse(list);

            List<Node> compressed = new ArrayList<>();
            for (Node node : list) {
                if (xy.contains(node)) {
                    compressed.add(node);
                }
            }

            if (compressed.get(0) == compressed.get(1) || compressed.get(1) == compressed.get(2)) {
                out.println(yes);
            } else {
                out.println(no);
            }
        }

        public void dfs(Node root) {
            while (!root.adj.isEmpty()) {
                Edge tail = root.adj.remove(root.adj.size() - 1);
                if (tail.handled) {
                    continue;
                }
                tail.handled = true;
                Node node = tail.other(root);
                dfs(node);
            }
            trace.addLast(root);
        }

    }

    static class SequenceUtils {
        public static <T> void swap(List<T> data, int i, int j) {
            T tmp = data.get(i);
            data.set(i, data.get(j));
            data.set(j, tmp);
        }

        public static <T> void reverse(List<T> data, int l, int r) {
            while (l < r) {
                swap(data, l, r);
                l++;
                r--;
            }
        }

        public static <T> void reverse(List<T> data) {
            reverse(data, 0, data.size() - 1);
        }

    }

    static class Node {
        List<Edge> adj = new ArrayList<>();

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(String c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(String c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class Edge {
        Node a;
        Node b;
        boolean handled;

        Node other(Node x) {
            return a == x ? b : a;
        }

    }
}


</source>
</class>

<class classid="41" nclones="2" nlines="178" similarity="100">
<source file="../hum_codes_raw/s047739433.java" startline="1" endline="219" pcid="1581">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            EAwkwardResponse solver = new EAwkwardResponse();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class EAwkwardResponse {
        FastOutput out;
        FastInput in;

        public void solve(int testNumber, FastInput in, FastOutput out) {
            this.out = out;
            this.in = in;

            long limit = (long) 1e15;
            long x = 1;
            while (ask(x) && x < limit) {
                x = x * 10;
            }

            if (x >= limit) {
                //all one
                x = 1;
                while (!ask(x + 1)) {
                    x = x * 10;
                }
                answer(x);
                return;
            }

            int len = Long.toString(x).length();
            long min = Math.round(Math.pow(10, len));
            long max = min * 10 - 1;

            LongBinarySearch lbs = new LongBinarySearch() {

                public boolean check(long mid) {
                    return ask(mid);
                }
            };

            long ans = lbs.binarySearch(min, max);
            ans /= 100;
            answer(ans);
        }

        public boolean ask(long x) {
            out.printf("? %d\n", x);
            out.flush();
            return in.readChar() == 'Y';
        }

        public void answer(long x) {
            out.printf("! %d\n", x);
            out.flush();
        }

    }

    static class DigitUtils {
        private DigitUtils() {
        }

        public static long floorAverage(long x, long y) {
            return (x & y) + ((x ^ y) >> 1);
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public char readChar() {
            skipBlank();
            char c = (char) next;
            next = read();
            return c;
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput printf(String format, Object... args) {
            cache.append(String.format(format, args));
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static abstract class LongBinarySearch {
        public abstract boolean check(long mid);

        public long binarySearch(long l, long r) {
            if (l > r) {
                throw new IllegalArgumentException();
            }
            while (l < r) {
                long mid = DigitUtils.floorAverage(l, r);
                if (check(mid)) {
                    r = mid;
                } else {
                    l = mid + 1;
                }
            }
            return l;
        }

    }
}


</source>
<source file="../hum_codes_raw/s998465037.java" startline="1" endline="219" pcid="33615">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            EAwkwardResponse solver = new EAwkwardResponse();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class EAwkwardResponse {
        FastOutput out;
        FastInput in;

        public void solve(int testNumber, FastInput in, FastOutput out) {
            this.out = out;
            this.in = in;

            long limit = (long) 1e15;
            long x = 1;
            while (ask(x) && x < limit) {
                x = x * 10;
            }

            if (x >= limit) {
                //all one
                x = 1;
                while (!ask(x + 1)) {
                    x = x * 10;
                }
                answer(x);
                return;
            }

            int len = Long.toString(x).length();
            long min = Math.round(Math.pow(10, len));
            long max = min * 10 - 1;

            LongBinarySearch lbs = new LongBinarySearch() {

                public boolean check(long mid) {
                    return ask(mid);
                }
            };

            long ans = lbs.binarySearch(min, max);
            ans /= 100;
            answer(ans);
        }

        public boolean ask(long x) {
            out.printf("? %d\n", x);
            out.flush();
            return in.readChar() == 'Y';
        }

        public void answer(long x) {
            out.printf("! %d\n", x);
            out.flush();
        }

    }

    static class DigitUtils {
        private DigitUtils() {
        }

        public static long floorAverage(long x, long y) {
            return (x & y) + ((x ^ y) >> 1);
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public char readChar() {
            skipBlank();
            char c = (char) next;
            next = read();
            return c;
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput printf(String format, Object... args) {
            cache.append(String.format(format, args));
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static abstract class LongBinarySearch {
        public abstract boolean check(long mid);

        public long binarySearch(long l, long r) {
            if (l > r) {
                throw new IllegalArgumentException();
            }
            while (l < r) {
                long mid = DigitUtils.floorAverage(l, r);
                if (check(mid)) {
                    r = mid;
                } else {
                    l = mid + 1;
                }
            }
            return l;
        }

    }
}


</source>
</class>

<class classid="42" nclones="2" nlines="387" similarity="100">
<source file="../hum_codes_raw/s048659297.java" startline="1" endline="472" pcid="1615">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.util.Collection;
import java.io.IOException;
import java.util.HashMap;
import java.util.Deque;
import java.util.ArrayList;
import java.io.UncheckedIOException;
import java.util.List;
import java.io.Closeable;
import java.util.Map;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.ArrayDeque;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author daltao
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "daltao", 1 << 27);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            TaskD solver = new TaskD();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class TaskD {
        int n;
        int m;

        int idOfRow(int i) {
            return i;
        }

        int idOfCol(int i) {
            return n + i;
        }

        int idOfSrc() {
            return n + m + 1;
        }

        int idOfDst() {
            return idOfSrc() + 1;
        }

        public void solve(int testNumber, FastInput in, FastOutput out) {
            n = in.readInt();
            m = in.readInt();

            int inf = (int) 1e8;
            ISAP isap = new ISAP(idOfDst());
            for (int i = 1; i <= n; i++) {
                for (int j = 1; j <= m; j++) {
                    char c = in.readChar();
                    if (c == '.') {
                        continue;
                    }
                    isap.getChannel(idOfRow(i), idOfCol(j)).modify(2, 1);
                    if (c == 'S') {
                        isap.getChannel(idOfSrc(), idOfRow(i)).modify(inf, 0);
                        isap.getChannel(idOfSrc(), idOfCol(j)).modify(inf, 0);
                    }
                    if (c == 'T') {
                        isap.getChannel(idOfRow(i), idOfDst()).modify(inf, 0);
                        isap.getChannel(idOfCol(j), idOfDst()).modify(inf, 0);
                    }
                }
            }

            isap.setSource(idOfSrc());
            isap.setTarget(idOfDst());

            int f = (int) (isap.sendFlow(inf) + 0.5);
            if (f == inf) {
                out.println(-1);
                return;
            }
            out.println(f);
        }

    }

    static class ISAP {
        ISAP.Node[] nodes;
        int[] distanceCnt;
        ISAP.Node source;
        ISAP.Node target;
        int nodeNum;
        Map<Long, ISAP.DirectChannel> channelMap = new HashMap();
        Deque<ISAP.Node> deque;
        boolean bfsFlag = false;

        private Collection<ISAP.DirectChannel> getChannels() {
            return channelMap.values();
        }

        private ISAP.DirectChannel addChannel(int src, int dst) {
            ISAP.DirectChannel channel = new ISAP.DirectChannel(nodes[src], nodes[dst], 0, 0);
            nodes[src].channelList.add(channel);
            nodes[dst].channelList.add(channel.getInverse());
            return channel;
        }

        public ISAP.DirectChannel getChannel(int src, int dst) {
            Long id = (((long) src) << 32) | dst;
            ISAP.DirectChannel channel = channelMap.get(id);
            if (channel == null) {
                channel = addChannel(src, dst);
                channelMap.put(id, channel);
            }
            return channel;
        }

        public ISAP(int nodeNum) {
            this.nodeNum = nodeNum;
            deque = new ArrayDeque(nodeNum);
            nodes = new ISAP.Node[nodeNum + 1];
            distanceCnt = new int[nodeNum + 2];
            for (int i = 1; i <= nodeNum; i++) {
                ISAP.Node node = new ISAP.Node();
                node.id = i;
                nodes[i] = node;
            }
        }

        public double sendFlow(double flow) {
            bfs();
            double flowSnapshot = flow;
            while (flow > 0 && source.distance < nodeNum) {
                flow -= send(source, flow);
            }
            return flowSnapshot - flow;
        }

        private double send(ISAP.Node node, double flowRemain) {
            if (node == target) {
                return flowRemain;
            }

            double flowSnapshot = flowRemain;
            int nextDistance = node.distance - 1;
            for (ISAP.Channel channel : node.channelList) {
                double channelRemain = channel.getCapacity() - channel.getFlow();
                ISAP.Node dst = channel.getDst();
                if (channelRemain == 0 || dst.distance != nextDistance) {
                    continue;
                }
                double actuallySend = send(channel.getDst(), Math.min(flowRemain, channelRemain));
                channel.sendFlow(actuallySend);
                flowRemain -= actuallySend;
                if (flowRemain == 0) {
                    break;
                }
            }

            if (flowSnapshot == flowRemain) {
                if (--distanceCnt[node.distance] == 0) {
                    distanceCnt[source.distance]--;
                    source.distance = nodeNum;
                    distanceCnt[source.distance]++;
                    if (node != source) {
                        distanceCnt[++node.distance]++;
                    }
                } else {
                    distanceCnt[++node.distance]++;
                }
            }

            return flowSnapshot - flowRemain;
        }

        public void setSource(int id) {
            source = nodes[id];
        }

        public void setTarget(int id) {
            target = nodes[id];
        }

        private void bfs() {
            if (bfsFlag) {
                return;
            }
            bfsFlag = true;
            Arrays.fill(distanceCnt, 0);
            deque.clear();

            for (int i = 1; i <= nodeNum; i++) {
                nodes[i].distance = nodeNum;
            }

            target.distance = 0;
            deque.addLast(target);

            while (!deque.isEmpty()) {
                ISAP.Node head = deque.removeFirst();
                distanceCnt[head.distance]++;
                for (ISAP.Channel channel : head.channelList) {
                    ISAP.Channel inverse = channel.getInverse();
                    if (inverse.getCapacity() == inverse.getFlow()) {
                        continue;
                    }
                    ISAP.Node dst = channel.getDst();
                    if (dst.distance != nodeNum) {
                        continue;
                    }
                    dst.distance = head.distance + 1;
                    deque.addLast(dst);
                }
            }
        }

        public String toString() {
            StringBuilder builder = new StringBuilder();
            for (ISAP.DirectChannel channel : getChannels()) {
                if (channel.getFlow() == 0) {
                    continue;
                }
                builder.append(channel).append('\n');
            }

            for (ISAP.DirectChannel channel : getChannels()) {
                if (channel.getFlow() != 0) {
                    continue;
                }
                builder.append(channel).append('\n');
            }
            return builder.toString();
        }

        public static interface Channel {
            public ISAP.Node getSrc();

            public ISAP.Node getDst();

            public double getCapacity();

            public double getFlow();

            public void sendFlow(double volume);

            public ISAP.Channel getInverse();

        }

        public static class DirectChannel implements ISAP.Channel {
            final ISAP.Node src;
            final ISAP.Node dst;
            final int id;
            double capacity;
            double flow;
            ISAP.Channel inverse;

            public DirectChannel(ISAP.Node src, ISAP.Node dst, int capacity, int id) {
                this.src = src;
                this.dst = dst;
                this.capacity = capacity;
                this.id = id;
                inverse = new ISAP.InverseChannelWrapper(this);
            }

            public void modify(double cap, double flow) {
                this.capacity += cap;
                this.flow += flow;
            }

            public String toString() {
                return String.format("%s--%s/%s-->%s", getSrc(), getFlow(), getCapacity(), getDst());
            }

            public ISAP.Node getSrc() {
                return src;
            }

            public ISAP.Channel getInverse() {
                return inverse;
            }

            public ISAP.Node getDst() {
                return dst;
            }

            public double getCapacity() {
                return capacity;
            }

            public double getFlow() {
                return flow;
            }

            public void sendFlow(double volume) {
                flow += volume;
            }

        }

        public static class InverseChannelWrapper implements ISAP.Channel {
            final ISAP.Channel channel;

            public InverseChannelWrapper(ISAP.Channel channel) {
                this.channel = channel;
            }

            public ISAP.Channel getInverse() {
                return channel;
            }

            public ISAP.Node getSrc() {
                return channel.getDst();
            }

            public ISAP.Node getDst() {
                return channel.getSrc();
            }

            public double getCapacity() {
                return channel.getFlow();
            }

            public double getFlow() {
                return 0;
            }

            public void sendFlow(double volume) {
                channel.sendFlow(-volume);
            }

            public String toString() {
                return String.format("%s--%s/%s-->%s", getSrc(), getFlow(), getCapacity(), getDst());
            }

        }

        public static class Node {
            int id;
            int distance;
            List<ISAP.Channel> channelList = new ArrayList(1);

            public String toString() {
                return "" + id;
            }

        }

    }

    static class FastOutput implements AutoCloseable, Closeable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput println(int c) {
            cache.append(c).append('\n');
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

        public char readChar() {
            skipBlank();
            char c = (char) next;
            next = read();
            return c;
        }

    }
}


</source>
<source file="../hum_codes_raw/s569549516.java" startline="1" endline="472" pcid="19155">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.util.Collection;
import java.io.IOException;
import java.util.HashMap;
import java.util.Deque;
import java.util.ArrayList;
import java.io.UncheckedIOException;
import java.util.List;
import java.io.Closeable;
import java.util.Map;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.ArrayDeque;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author daltao
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "daltao", 1 << 27);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            TaskD solver = new TaskD();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class TaskD {
        int n;
        int m;

        int idOfRow(int i) {
            return i;
        }

        int idOfCol(int i) {
            return n + i;
        }

        int idOfSrc() {
            return n + m + 1;
        }

        int idOfDst() {
            return idOfSrc() + 1;
        }

        public void solve(int testNumber, FastInput in, FastOutput out) {
            n = in.readInt();
            m = in.readInt();

            int inf = (int) 1e8;
            ISAP isap = new ISAP(idOfDst());
            for (int i = 1; i <= n; i++) {
                for (int j = 1; j <= m; j++) {
                    char c = in.readChar();
                    if (c == '.') {
                        continue;
                    }
                    isap.getChannel(idOfRow(i), idOfCol(j)).modify(2, 1);
                    if (c == 'S') {
                        isap.getChannel(idOfSrc(), idOfRow(i)).modify(inf, 0);
                        isap.getChannel(idOfSrc(), idOfCol(j)).modify(inf, 0);
                    }
                    if (c == 'T') {
                        isap.getChannel(idOfRow(i), idOfDst()).modify(inf, 0);
                        isap.getChannel(idOfCol(j), idOfDst()).modify(inf, 0);
                    }
                }
            }

            isap.setSource(idOfSrc());
            isap.setTarget(idOfDst());

            int f = (int) (isap.sendFlow(inf) + 0.5);
            if (f == inf) {
                out.println(-1);
                return;
            }
            out.println(f);
        }

    }

    static class ISAP {
        ISAP.Node[] nodes;
        int[] distanceCnt;
        ISAP.Node source;
        ISAP.Node target;
        int nodeNum;
        Map<Long, ISAP.DirectChannel> channelMap = new HashMap();
        Deque<ISAP.Node> deque;
        boolean bfsFlag = false;

        private Collection<ISAP.DirectChannel> getChannels() {
            return channelMap.values();
        }

        private ISAP.DirectChannel addChannel(int src, int dst) {
            ISAP.DirectChannel channel = new ISAP.DirectChannel(nodes[src], nodes[dst], 0, 0);
            nodes[src].channelList.add(channel);
            nodes[dst].channelList.add(channel.getInverse());
            return channel;
        }

        public ISAP.DirectChannel getChannel(int src, int dst) {
            Long id = (((long) src) << 32) | dst;
            ISAP.DirectChannel channel = channelMap.get(id);
            if (channel == null) {
                channel = addChannel(src, dst);
                channelMap.put(id, channel);
            }
            return channel;
        }

        public ISAP(int nodeNum) {
            this.nodeNum = nodeNum;
            deque = new ArrayDeque(nodeNum);
            nodes = new ISAP.Node[nodeNum + 1];
            distanceCnt = new int[nodeNum + 2];
            for (int i = 1; i <= nodeNum; i++) {
                ISAP.Node node = new ISAP.Node();
                node.id = i;
                nodes[i] = node;
            }
        }

        public double sendFlow(double flow) {
            bfs();
            double flowSnapshot = flow;
            while (flow > 0 && source.distance < nodeNum) {
                flow -= send(source, flow);
            }
            return flowSnapshot - flow;
        }

        private double send(ISAP.Node node, double flowRemain) {
            if (node == target) {
                return flowRemain;
            }

            double flowSnapshot = flowRemain;
            int nextDistance = node.distance - 1;
            for (ISAP.Channel channel : node.channelList) {
                double channelRemain = channel.getCapacity() - channel.getFlow();
                ISAP.Node dst = channel.getDst();
                if (channelRemain == 0 || dst.distance != nextDistance) {
                    continue;
                }
                double actuallySend = send(channel.getDst(), Math.min(flowRemain, channelRemain));
                channel.sendFlow(actuallySend);
                flowRemain -= actuallySend;
                if (flowRemain == 0) {
                    break;
                }
            }

            if (flowSnapshot == flowRemain) {
                if (--distanceCnt[node.distance] == 0) {
                    distanceCnt[source.distance]--;
                    source.distance = nodeNum;
                    distanceCnt[source.distance]++;
                    if (node != source) {
                        distanceCnt[++node.distance]++;
                    }
                } else {
                    distanceCnt[++node.distance]++;
                }
            }

            return flowSnapshot - flowRemain;
        }

        public void setSource(int id) {
            source = nodes[id];
        }

        public void setTarget(int id) {
            target = nodes[id];
        }

        private void bfs() {
            if (bfsFlag) {
                return;
            }
            bfsFlag = true;
            Arrays.fill(distanceCnt, 0);
            deque.clear();

            for (int i = 1; i <= nodeNum; i++) {
                nodes[i].distance = nodeNum;
            }

            target.distance = 0;
            deque.addLast(target);

            while (!deque.isEmpty()) {
                ISAP.Node head = deque.removeFirst();
                distanceCnt[head.distance]++;
                for (ISAP.Channel channel : head.channelList) {
                    ISAP.Channel inverse = channel.getInverse();
                    if (inverse.getCapacity() == inverse.getFlow()) {
                        continue;
                    }
                    ISAP.Node dst = channel.getDst();
                    if (dst.distance != nodeNum) {
                        continue;
                    }
                    dst.distance = head.distance + 1;
                    deque.addLast(dst);
                }
            }
        }

        public String toString() {
            StringBuilder builder = new StringBuilder();
            for (ISAP.DirectChannel channel : getChannels()) {
                if (channel.getFlow() == 0) {
                    continue;
                }
                builder.append(channel).append('\n');
            }

            for (ISAP.DirectChannel channel : getChannels()) {
                if (channel.getFlow() != 0) {
                    continue;
                }
                builder.append(channel).append('\n');
            }
            return builder.toString();
        }

        public static interface Channel {
            public ISAP.Node getSrc();

            public ISAP.Node getDst();

            public double getCapacity();

            public double getFlow();

            public void sendFlow(double volume);

            public ISAP.Channel getInverse();

        }

        public static class DirectChannel implements ISAP.Channel {
            final ISAP.Node src;
            final ISAP.Node dst;
            final int id;
            double capacity;
            double flow;
            ISAP.Channel inverse;

            public DirectChannel(ISAP.Node src, ISAP.Node dst, int capacity, int id) {
                this.src = src;
                this.dst = dst;
                this.capacity = capacity;
                this.id = id;
                inverse = new ISAP.InverseChannelWrapper(this);
            }

            public void modify(double cap, double flow) {
                this.capacity += cap;
                this.flow += flow;
            }

            public String toString() {
                return String.format("%s--%s/%s-->%s", getSrc(), getFlow(), getCapacity(), getDst());
            }

            public ISAP.Node getSrc() {
                return src;
            }

            public ISAP.Channel getInverse() {
                return inverse;
            }

            public ISAP.Node getDst() {
                return dst;
            }

            public double getCapacity() {
                return capacity;
            }

            public double getFlow() {
                return flow;
            }

            public void sendFlow(double volume) {
                flow += volume;
            }

        }

        public static class InverseChannelWrapper implements ISAP.Channel {
            final ISAP.Channel channel;

            public InverseChannelWrapper(ISAP.Channel channel) {
                this.channel = channel;
            }

            public ISAP.Channel getInverse() {
                return channel;
            }

            public ISAP.Node getSrc() {
                return channel.getDst();
            }

            public ISAP.Node getDst() {
                return channel.getSrc();
            }

            public double getCapacity() {
                return channel.getFlow();
            }

            public double getFlow() {
                return 0;
            }

            public void sendFlow(double volume) {
                channel.sendFlow(-volume);
            }

            public String toString() {
                return String.format("%s--%s/%s-->%s", getSrc(), getFlow(), getCapacity(), getDst());
            }

        }

        public static class Node {
            int id;
            int distance;
            List<ISAP.Channel> channelList = new ArrayList(1);

            public String toString() {
                return "" + id;
            }

        }

    }

    static class FastOutput implements AutoCloseable, Closeable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput println(int c) {
            cache.append(c).append('\n');
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

        public char readChar() {
            skipBlank();
            char c = (char) next;
            next = read();
            return c;
        }

    }
}


</source>
</class>

<class classid="43" nclones="2" nlines="165" similarity="100">
<source file="../hum_codes_raw/s049532884.java" startline="1" endline="213" pcid="1653">
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.PriorityQueue;
import java.util.Queue;
public class Main {
    private static final PrintStream ps     = System.out;
    private static final InputStream IS     = System.in;
    private static final byte[]      BUFFER = new byte[1024];
    private static int               ptr    = 0;
    private static int               buflen = 0;

    public static void main(String[] args) {

        int n = ni();
        //無向グラフの作成
        @SuppressWarnings("unchecked")
        List<Edge>[] edges = new List[n];
        for (int i = 0; i < edges.length; i++) {
            edges[i] = new ArrayList<Edge>();
        }
        for (int i = 0; i < n; i++) {
            int u = ni();
            int m = ni();
            for (int j = 0; j < m; j++) {
                edges[i].add(new Edge(u, ni(), ni()));
            }   
        }
        int[] d = dijkstra(n, edges, 0);
        
        for (int i = 0; i < n; i++) {
            System.out.println(i + " " + d[i]);
        }
    }
    //ダイクストラ法[単一始点最短経路(Single Source Shortest Path)]
    static int[] dijkstra(int n, List<Edge>[] edges, int s) {
        int[] distance = new int[n];        //始点からの最短距離

        Arrays.fill(distance, Integer.MAX_VALUE);    //各頂点までの距離を初期化(INF 値)
        distance[s] = 0;    //始点の距離は０

        Queue<Edge> q = new PriorityQueue<Edge>();
        q.add(new Edge(s, s, 0));     //始点を入れる

        while (!q.isEmpty()) {
            Edge e = q.poll();        //最小距離(cost)の頂点を取り出す
            if (distance[e.target] < e.cost) {
                continue;
            }

            //隣接している頂点の最短距離を更新する
            for (Edge v : edges[e.target]) {
                if (distance[v.target] > distance[e.target] + v.cost) {  //(始点～)接続元＋接続先までの距離    
                    distance[v.target] = distance[e.target] + v.cost;    //現在記録されている距離より小さければ更新
                    q.add(new Edge(e.target, v.target, distance[v.target]));  //始点～接続先までの距離    
                }
            }
        }

        return distance;    //到達できなかったときは、INF となる
    }

    static class Edge implements Comparable<Edge> {
        public int source = 0;    //接続元ノード
        public int target = 0;    //接続先ノード
        public int cost = 0;      //重み

        public Edge(int source, int target, int cost) {
            this.source = source;
            this.target = target;
            this.cost = cost;
        }

        @Override
        public int compareTo(Edge o) {
            return this.cost - o.cost;
        }

        @Override
        public String toString() {    //デバッグ用
            return "source = " + source + ", target = " + target + ", cost = " + cost;
        }
    }

    private static boolean hasNextByte() {
        if (ptr < buflen)
            return true;
        else {
            ptr = 0;
            try {
                buflen = IS.read(BUFFER);
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0)
                return false;
        }
        return true;
    }

    private static int readByte() {
        if (hasNextByte())
            return BUFFER[ptr++];
        else
            return -1;
    }

    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }

    public static boolean hasNext() {
        while (hasNextByte() && !isPrintableChar(BUFFER[ptr]))
            ptr++;
        return hasNextByte();
    }

    public static String n() {
        if (!hasNext())
            throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while (isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }

    public static long nl() {
        if (!hasNext())
            throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b)
            throw new NumberFormatException();
        while (true) {
            if ('0' <= b && b <= '9') {
                n *= 10;
                n += b - '0';
            } else if (b == -1 || !isPrintableChar(b))
                return minus ? -n : n;
            else
                throw new NumberFormatException();
            b = readByte();
        }
    }

    public static int ni() {
        long nl = nl();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)
            throw new NumberFormatException();
        return (int) nl;
    }

    public static double nextDouble() {
        return Double.parseDouble(n());
    }

    private static int[] nia(int n) {
        int[] a = new int[n];
        for (int i = 0; i < n; i++)
            a[i] = ni();
        return a;
    }

    private static long[] nla(int n) {
        long[] a = new long[n];
        for (int i = 0; i < n; i++)
            a[i] = nl();
        return a;
    }

    private static String[] na(int n) {
        String[] a = new String[n];
        for (int i = 0; i < n; i++)
            a[i] = n();
        return a;
    }

    private static int[][] nia2(int n, int m) {
        int[][] a = new int[n][m];
        for (int i = 0; i < n; i++)
            a[i] = nia(m);
        return a;
    }

    private static long[][] nla2(int n, int m) {
        long[][] a = new long[n][m];
        for (int i = 0; i < n; i++)
            a[i] = nla(m);
        return a;
    }

    private static char[][] nca2(int n) {
        char[][] a = new char[n][];
        for (int i = 0; i < n; i++)
            a[i] = n().toCharArray();
        return a;

    }
}


</source>
<source file="../hum_codes_raw/s691517963.java" startline="1" endline="213" pcid="23266">
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.PriorityQueue;
import java.util.Queue;
public class Main {
    private static final PrintStream ps     = System.out;
    private static final InputStream IS     = System.in;
    private static final byte[]      BUFFER = new byte[1024];
    private static int               ptr    = 0;
    private static int               buflen = 0;

    public static void main(String[] args) {

        int n = ni();
        //無向グラフの作成
        @SuppressWarnings("unchecked")
        List<Edge>[] edges = new List[n];
        for (int i = 0; i < edges.length; i++) {
            edges[i] = new ArrayList<Edge>();
        }
        for (int i = 0; i < n; i++) {
            int u = ni();
            int m = ni();
            for (int j = 0; j < m; j++) {
                edges[i].add(new Edge(u, ni(), ni()));
            }   
        }
        int[] d = dijkstra(n, edges, 0);
        
        for (int i = 0; i < n; i++) {
            System.out.println(i + " " + d[i]);
        }
    }
    //ダイクストラ法[単一始点最短経路(Single Source Shortest Path)]
    static int[] dijkstra(int n, List<Edge>[] edges, int s) {
        int[] distance = new int[n];        //始点からの最短距離

        Arrays.fill(distance, Integer.MAX_VALUE);    //各頂点までの距離を初期化(INF 値)
        distance[s] = 0;    //始点の距離は０

        Queue<Edge> q = new PriorityQueue<Edge>();
        q.add(new Edge(s, s, 0));     //始点を入れる

        while (!q.isEmpty()) {
            Edge e = q.poll();        //最小距離(cost)の頂点を取り出す
            if (distance[e.target] < e.cost) {
                continue;
            }

            //隣接している頂点の最短距離を更新する
            for (Edge v : edges[e.target]) {
                if (distance[v.target] > distance[e.target] + v.cost) {  //(始点～)接続元＋接続先までの距離    
                    distance[v.target] = distance[e.target] + v.cost;    //現在記録されている距離より小さければ更新
                    q.add(new Edge(e.target, v.target, distance[v.target]));  //始点～接続先までの距離    
                }
            }
        }

        return distance;    //到達できなかったときは、INF となる
    }

    static class Edge implements Comparable<Edge> {
        public int source = 0;    //接続元ノード
        public int target = 0;    //接続先ノード
        public int cost = 0;      //重み

        public Edge(int source, int target, int cost) {
            this.source = source;
            this.target = target;
            this.cost = cost;
        }

        @Override
        public int compareTo(Edge o) {
            return this.cost - o.cost;
        }

        @Override
        public String toString() {    //デバッグ用
            return "source = " + source + ", target = " + target + ", cost = " + cost;
        }
    }

    private static boolean hasNextByte() {
        if (ptr < buflen)
            return true;
        else {
            ptr = 0;
            try {
                buflen = IS.read(BUFFER);
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0)
                return false;
        }
        return true;
    }

    private static int readByte() {
        if (hasNextByte())
            return BUFFER[ptr++];
        else
            return -1;
    }

    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }

    public static boolean hasNext() {
        while (hasNextByte() && !isPrintableChar(BUFFER[ptr]))
            ptr++;
        return hasNextByte();
    }

    public static String n() {
        if (!hasNext())
            throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while (isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }

    public static long nl() {
        if (!hasNext())
            throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b)
            throw new NumberFormatException();
        while (true) {
            if ('0' <= b && b <= '9') {
                n *= 10;
                n += b - '0';
            } else if (b == -1 || !isPrintableChar(b))
                return minus ? -n : n;
            else
                throw new NumberFormatException();
            b = readByte();
        }
    }

    public static int ni() {
        long nl = nl();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)
            throw new NumberFormatException();
        return (int) nl;
    }

    public static double nextDouble() {
        return Double.parseDouble(n());
    }

    private static int[] nia(int n) {
        int[] a = new int[n];
        for (int i = 0; i < n; i++)
            a[i] = ni();
        return a;
    }

    private static long[] nla(int n) {
        long[] a = new long[n];
        for (int i = 0; i < n; i++)
            a[i] = nl();
        return a;
    }

    private static String[] na(int n) {
        String[] a = new String[n];
        for (int i = 0; i < n; i++)
            a[i] = n();
        return a;
    }

    private static int[][] nia2(int n, int m) {
        int[][] a = new int[n][m];
        for (int i = 0; i < n; i++)
            a[i] = nia(m);
        return a;
    }

    private static long[][] nla2(int n, int m) {
        long[][] a = new long[n][m];
        for (int i = 0; i < n; i++)
            a[i] = nla(m);
        return a;
    }

    private static char[][] nca2(int n) {
        char[][] a = new char[n][];
        for (int i = 0; i < n; i++)
            a[i] = n().toCharArray();
        return a;

    }
}


</source>
</class>

<class classid="44" nclones="4" nlines="136" similarity="100">
<source file="../hum_codes_raw/s050821645.java" startline="1" endline="153" pcid="1688">
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.util.Arrays;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        double INF = Double.MAX_VALUE / 2;
        while (true) {
            int n = sc.nextInt();
            if (n == 0)
                break;
            Circle[] cs = new Circle[n];
            for (int i = 0; i < n; i++) {
                cs[i] = new Circle(sc.nextInt(), sc.nextInt(), sc.nextInt());
            }
            Point[] ps = new Point[2 * n];
            ps[0] = new Point(cs[0].x, cs[0].y);
            ps[ps.length - 1] = new Point(cs[n - 1].x, cs[n - 1].y);
            int c = 1;
            Line[] ls = new Line[n - 1];
            for (int i = 1; i < n; i++) {
                Point[] cis = cs[i].circleInterSection(cs[i - 1]);
                ps[c++] = cis[0];
                ps[c++] = cis[1];
                ls[i - 1] = new Line(cis[0], cis[1]);
            }
            double[][] cost = new double[2 * n][2 * n];
            for (int i = 0; i < 2 * n; i++) {
                Arrays.fill(cost[i], INF);
            }
            for (int i = 0; i <= 2 * n - 4; i++) {
                for (int j = i + 1; j < 2 * n; j++) {
                    if (j % 2 == 0) {
                        Line l1 = new Line(ps[i], ps[j]);
                        boolean inCircle = true;
                        for (int k = i % 2 == 0 ? i / 2 : i / 2 + 1; k < j / 2 - 1; k++) {
                            Line l2 = ls[k];
                            if (!l2.intersectsLine(l1)) {
                                inCircle = false;
                                break;
                            }
                        }
                        if (inCircle) {
                            cost[i][j] = l1.length();
                        }
                    } else {
                        Line l1 = new Line(ps[i], ps[j]);
                        boolean inCircle = true;
                        for (int k = i % 2 == 0 ? i / 2 : i / 2 + 1; k < j / 2; k++) {
                            Line l2 = ls[k];
                            if (!l2.intersectsLine(l1)) {
                                inCircle = false;
                                break;
                            }
                        }
                        if (inCircle) {
                            cost[i][j] = l1.length();
                        }
                    }
                }
            }
            cost[2 * n - 3][2 * n - 1] = new Line(ps[2 * n - 3], ps[2 * n - 1])
                    .length();
            cost[2 * n - 2][2 * n - 1] = new Line(ps[2 * n - 2], ps[2 * n - 1])
                    .length();
            for (int k = 0; k < 2 * n; k++) {
                for (int i = 0; i < 2 * n; i++) {
                    if (k < i)
                        break;
                    for (int j = i + 1; j < 2 * n; j++) {
                        cost[i][j] = Math.min(cost[i][j], cost[i][k]
                                + cost[k][j]);
                    }
                }
            }
            System.out.printf("%.5f\n", cost[0][2 * n - 1]);
        }
    }
}

@SuppressWarnings("serial")
class Point extends Point2D.Double {
    Point(int x, int y) {
        super(x, y);
    }

    Point(double x, double y) {
        super(x, y);
    }
}

@SuppressWarnings("serial")
class Line extends Line2D.Double {

    Line(Point p1, Point p2) {
        super(p1, p2);
    }

    public double length() {
        return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
    }

    public double ip(Line l) {
        Point q1 = new Point(l.x1, l.y1);
        Point q2 = new Point(l.x2, l.y2);
        return (x2 - x1) * (q2.x - q1.x) + (y2 - y1) * (q2.y - q1.y);
    }

    public double ep(Line l) {
        Point q1 = new Point(l.x1, l.y1);
        Point q2 = new Point(l.x2, l.y2);
        return (x2 - x1) * (q2.y - q1.y) - (y2 - y1) * (q2.x - q1.x);
    }
}

class Circle {
    int x;
    int y;
    int r;

    Circle(int x, int y, int r) {
        this.x = x;
        this.y = y;
        this.r = r;
    }

    public Point[] circleInterSection(Circle c2) {
        Circle c1 = this;
        double a = c1.x;
        double b = c1.y;
        double r = c1.r;
        double c = c2.x;
        double d = c2.y;
        double s = c2.r;
        double norm = (c - a) * (c - a) + (d - b) * (d - b);
        double t = 0.5 * (norm + r * r - s * s) / Math.sqrt(norm);
        double th = Math.acos(t / r);
        double th0 = Math.atan2((d - b), (c - a));
        double p1 = a + r * Math.cos(th + th0);
        double q1 = b + r * Math.sin(th + th0);
        double p2 = a + r * Math.cos(-th + th0);
        double q2 = b + r * Math.sin(-th + th0);
        Point[] ps = { new Point(p1, q1), new Point(p2, q2) };
        return ps;
    }
    public String toString() {
        return "x,y,r " + x + " " + y + " " + r + " ";
    }
}

</source>
<source file="../hum_codes_raw/s224566516.java" startline="1" endline="162" pcid="7586">
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.util.Arrays;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        double INF = Double.MAX_VALUE / 2;
        while (true) {
            int n = sc.nextInt();
            if (n == 0)
                break;
            Circle[] cs = new Circle[n];
            for (int i = 0; i < n; i++) {
                cs[i] = new Circle(sc.nextInt(), sc.nextInt(), sc.nextInt());
            }
            Point[] ps = new Point[2 * n];
            ps[0] = new Point(cs[0].x, cs[0].y);
            ps[ps.length - 1] = new Point(cs[n - 1].x, cs[n - 1].y);
            int c = 1;
            Line[] ls = new Line[n - 1];
            for (int i = 1; i < n; i++) {
                Point[] cis = cs[i].circleInterSection(cs[i - 1]);
                ps[c++] = cis[0];
                ps[c++] = cis[1];
                ls[i - 1] = new Line(cis[0], cis[1]);
            }
            // System.out.println(Arrays.toString(ps));
            double[][] cost = new double[2 * n][2 * n];
            for (int i = 0; i < 2 * n; i++) {
                Arrays.fill(cost[i], INF);
            }
            for (int i = 0; i <= 2 * n - 4; i++) {
                for (int j = i + 1; j < 2 * n; j++) {
                    if (j % 2 == 0) {
                        Line l1 = new Line(ps[i], ps[j]);
                        boolean inCircle = true;
                        for (int k = i % 2 == 0 ? i / 2 : i / 2 + 1; k < j / 2 - 1; k++) {
                            Line l2 = ls[k];
                            if (!l2.intersectsLine(l1)) {
                                inCircle = false;
                                break;
                            }
                        }
                        if (inCircle) {
                            // System.out.println(i + " => " + j);
                            cost[i][j] = l1.length();
                        }
                    } else {
                        Line l1 = new Line(ps[i], ps[j]);
                        boolean inCircle = true;
                        for (int k = i % 2 == 0 ? i / 2 : i / 2 + 1; k < j / 2; k++) {
                            Line l2 = ls[k];
                            if (!l2.intersectsLine(l1)) {
                                inCircle = false;
                                break;
                            }
                        }
                        if (inCircle) {
                            // System.out.println(i + " => " + j);
                            cost[i][j] = l1.length();
                        }
                    }
                }
            }
            // for (int i = 0; i < 2 * n; i++) {
            // System.out.println(Arrays.toString(cost[i]));
            // }
            cost[2 * n - 3][2 * n - 1] = new Line(ps[2 * n - 3], ps[2 * n - 1])
                    .length();
            cost[2 * n - 2][2 * n - 1] = new Line(ps[2 * n - 2], ps[2 * n - 1])
                    .length();
            for (int k = 0; k < 2 * n; k++) {
                for (int i = 0; i < 2 * n; i++) {
                    if (k < i)
                        break;
                    for (int j = i + 1; j < 2 * n; j++) {
                        cost[i][j] = Math.min(cost[i][j], cost[i][k]
                                + cost[k][j]);
                    }
                }
            }
            System.out.printf("%.5f\n", cost[0][2 * n - 1]);
        }

    }
}

@SuppressWarnings("serial")
class Point extends Point2D.Double {
    Point(int x, int y) {
        super(x, y);
    }

    Point(double x, double y) {
        super(x, y);
    }
}

@SuppressWarnings("serial")
class Line extends Line2D.Double {

    Line(Point p1, Point p2) {
        super(p1, p2);
    }

    public double length() {
        return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
    }

    public double ip(Line l) {
        Point q1 = new Point(l.x1, l.y1);
        Point q2 = new Point(l.x2, l.y2);
        return (x2 - x1) * (q2.x - q1.x) + (y2 - y1) * (q2.y - q1.y);
    }

    public double ep(Line l) {
        Point q1 = new Point(l.x1, l.y1);
        Point q2 = new Point(l.x2, l.y2);
        return (x2 - x1) * (q2.y - q1.y) - (y2 - y1) * (q2.x - q1.x);
    }
}

class Circle {
    int x;
    int y;
    int r;

    Circle(int x, int y, int r) {
        this.x = x;
        this.y = y;
        this.r = r;
    }

    public Point[] circleInterSection(Circle c2) {
        Circle c1 = this;
        double a = c1.x;
        double b = c1.y;
        double r = c1.r;
        double c = c2.x;
        double d = c2.y;
        double s = c2.r;
        double norm = (c - a) * (c - a) + (d - b) * (d - b);
        double t = 0.5 * (norm + r * r - s * s) / Math.sqrt(norm);
        double th = Math.acos(t / r);
        double th0 = Math.atan2((d - b), (c - a));
        double p1 = a + r * Math.cos(th + th0);
        double q1 = b + r * Math.sin(th + th0);
        double p2 = a + r * Math.cos(-th + th0);
        double q2 = b + r * Math.sin(-th + th0);
        Point[] ps = { new Point(p1, q1), new Point(p2, q2) };
        return ps;
    }

    public String toString() {
        return "x,y,r " + x + " " + y + " " + r + " ";
    }

}

</source>
<source file="../hum_codes_raw/s799573041.java" startline="1" endline="153" pcid="26863">
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.util.Arrays;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        double INF = Double.MAX_VALUE / 2;
        while (true) {
            int n = sc.nextInt();
            if (n == 0)
                break;
            Circle[] cs = new Circle[n];
            for (int i = 0; i < n; i++) {
                cs[i] = new Circle(sc.nextInt(), sc.nextInt(), sc.nextInt());
            }
            Point[] ps = new Point[2 * n];
            ps[0] = new Point(cs[0].x, cs[0].y);
            ps[ps.length - 1] = new Point(cs[n - 1].x, cs[n - 1].y);
            int c = 1;
            Line[] ls = new Line[n - 1];
            for (int i = 1; i < n; i++) {
                Point[] cis = cs[i].circleInterSection(cs[i - 1]);
                ps[c++] = cis[0];
                ps[c++] = cis[1];
                ls[i - 1] = new Line(cis[0], cis[1]);
            }
            double[][] cost = new double[2 * n][2 * n];
            for (int i = 0; i < 2 * n; i++) {
                Arrays.fill(cost[i], INF);
            }
            for (int i = 0; i <= 2 * n - 4; i++) {
                for (int j = i + 1; j < 2 * n; j++) {
                    if (j % 2 == 0) {
                        Line l1 = new Line(ps[i], ps[j]);
                        boolean inCircle = true;
                        for (int k = i % 2 == 0 ? i / 2 : i / 2 + 1; k < j / 2 - 1; k++) {
                            Line l2 = ls[k];
                            if (!l2.intersectsLine(l1)) {
                                inCircle = false;
                                break;
                            }
                        }
                        if (inCircle) {
                            cost[i][j] = l1.length();
                        }
                    } else {
                        Line l1 = new Line(ps[i], ps[j]);
                        boolean inCircle = true;
                        for (int k = i % 2 == 0 ? i / 2 : i / 2 + 1; k < j / 2; k++) {
                            Line l2 = ls[k];
                            if (!l2.intersectsLine(l1)) {
                                inCircle = false;
                                break;
                            }
                        }
                        if (inCircle) {
                            cost[i][j] = l1.length();
                        }
                    }
                }
            }
            cost[2 * n - 3][2 * n - 1] = new Line(ps[2 * n - 3], ps[2 * n - 1])
                    .length();
            cost[2 * n - 2][2 * n - 1] = new Line(ps[2 * n - 2], ps[2 * n - 1])
                    .length();
            for (int k = 0; k < 2 * n; k++) {
                for (int i = 0; i < 2 * n; i++) {
                    if (k < i)
                        break;
                    for (int j = i + 1; j < 2 * n; j++) {
                        cost[i][j] = Math.min(cost[i][j], cost[i][k]
                                + cost[k][j]);
                    }
                }
            }
            System.out.printf("%.5f\n", cost[0][2 * n - 1]);
        }
    }
}

@SuppressWarnings("serial")
class Point extends Point2D.Double {
    Point(int x, int y) {
        super(x, y);
    }

    Point(double x, double y) {
        super(x, y);
    }
}

@SuppressWarnings("serial")
class Line extends Line2D.Double {

    Line(Point p1, Point p2) {
        super(p1, p2);
    }

    public double length() {
        return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
    }

    public double ip(Line l) {
        Point q1 = new Point(l.x1, l.y1);
        Point q2 = new Point(l.x2, l.y2);
        return (x2 - x1) * (q2.x - q1.x) + (y2 - y1) * (q2.y - q1.y);
    }

    public double ep(Line l) {
        Point q1 = new Point(l.x1, l.y1);
        Point q2 = new Point(l.x2, l.y2);
        return (x2 - x1) * (q2.y - q1.y) - (y2 - y1) * (q2.x - q1.x);
    }
}

class Circle {
    int x;
    int y;
    int r;

    Circle(int x, int y, int r) {
        this.x = x;
        this.y = y;
        this.r = r;
    }

    public Point[] circleInterSection(Circle c2) {
        Circle c1 = this;
        double a = c1.x;
        double b = c1.y;
        double r = c1.r;
        double c = c2.x;
        double d = c2.y;
        double s = c2.r;
        double norm = (c - a) * (c - a) + (d - b) * (d - b);
        double t = 0.5 * (norm + r * r - s * s) / Math.sqrt(norm);
        double th = Math.acos(t / r);
        double th0 = Math.atan2((d - b), (c - a));
        double p1 = a + r * Math.cos(th + th0);
        double q1 = b + r * Math.sin(th + th0);
        double p2 = a + r * Math.cos(-th + th0);
        double q2 = b + r * Math.sin(-th + th0);
        Point[] ps = { new Point(p1, q1), new Point(p2, q2) };
        return ps;
    }
    public String toString() {
        return "x,y,r " + x + " " + y + " " + r + " ";
    }
}

</source>
<source file="../hum_codes_raw/s639372154.java" startline="1" endline="153" pcid="21449">
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.util.Arrays;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        double INF = Double.MAX_VALUE / 2;
        while (true) {
            int n = sc.nextInt();
            if (n == 0)
                break;
            Circle[] cs = new Circle[n];
            for (int i = 0; i < n; i++) {
                cs[i] = new Circle(sc.nextInt(), sc.nextInt(), sc.nextInt());
            }
            Point[] ps = new Point[2 * n];
            ps[0] = new Point(cs[0].x, cs[0].y);
            ps[ps.length - 1] = new Point(cs[n - 1].x, cs[n - 1].y);
            int c = 1;
            Line[] ls = new Line[n - 1];
            for (int i = 1; i < n; i++) {
                Point[] cis = cs[i].circleInterSection(cs[i - 1]);
                ps[c++] = cis[0];
                ps[c++] = cis[1];
                ls[i - 1] = new Line(cis[0], cis[1]);
            }
            double[][] cost = new double[2 * n][2 * n];
            for (int i = 0; i < 2 * n; i++) {
                Arrays.fill(cost[i], INF);
            }
            for (int i = 0; i <= 2 * n - 4; i++) {
                for (int j = i + 1; j < 2 * n; j++) {
                    if (j % 2 == 0) {
                        Line l1 = new Line(ps[i], ps[j]);
                        boolean inCircle = true;
                        for (int k = i % 2 == 0 ? i / 2 : i / 2 + 1; k < j / 2 - 1; k++) {
                            Line l2 = ls[k];
                            if (!l2.intersectsLine(l1)) {
                                inCircle = false;
                                break;
                            }
                        }
                        if (inCircle) {
                            cost[i][j] = l1.length();
                        }
                    } else {
                        Line l1 = new Line(ps[i], ps[j]);
                        boolean inCircle = true;
                        for (int k = i % 2 == 0 ? i / 2 : i / 2 + 1; k < j / 2; k++) {
                            Line l2 = ls[k];
                            if (!l2.intersectsLine(l1)) {
                                inCircle = false;
                                break;
                            }
                        }
                        if (inCircle) {
                            cost[i][j] = l1.length();
                        }
                    }
                }
            }
            cost[2 * n - 3][2 * n - 1] = new Line(ps[2 * n - 3], ps[2 * n - 1])
                    .length();
            cost[2 * n - 2][2 * n - 1] = new Line(ps[2 * n - 2], ps[2 * n - 1])
                    .length();
            for (int k = 0; k < 2 * n; k++) {
                for (int i = 0; i < 2 * n; i++) {
                    if (k < i)
                        break;
                    for (int j = i + 1; j < 2 * n; j++) {
                        cost[i][j] = Math.min(cost[i][j], cost[i][k]
                                + cost[k][j]);
                    }
                }
            }
            System.out.printf("%.5f\n", cost[0][2 * n - 1]);
        }
    }
}

@SuppressWarnings("serial")
class Point extends Point2D.Double {
    Point(int x, int y) {
        super(x, y);
    }

    Point(double x, double y) {
        super(x, y);
    }
}

@SuppressWarnings("serial")
class Line extends Line2D.Double {

    Line(Point p1, Point p2) {
        super(p1, p2);
    }

    public double length() {
        return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
    }

    public double ip(Line l) {
        Point q1 = new Point(l.x1, l.y1);
        Point q2 = new Point(l.x2, l.y2);
        return (x2 - x1) * (q2.x - q1.x) + (y2 - y1) * (q2.y - q1.y);
    }

    public double ep(Line l) {
        Point q1 = new Point(l.x1, l.y1);
        Point q2 = new Point(l.x2, l.y2);
        return (x2 - x1) * (q2.y - q1.y) - (y2 - y1) * (q2.x - q1.x);
    }
}

class Circle {
    int x;
    int y;
    int r;

    Circle(int x, int y, int r) {
        this.x = x;
        this.y = y;
        this.r = r;
    }

    public Point[] circleInterSection(Circle c2) {
        Circle c1 = this;
        double a = c1.x;
        double b = c1.y;
        double r = c1.r;
        double c = c2.x;
        double d = c2.y;
        double s = c2.r;
        double norm = (c - a) * (c - a) + (d - b) * (d - b);
        double t = 0.5 * (norm + r * r - s * s) / Math.sqrt(norm);
        double th = Math.acos(t / r);
        double th0 = Math.atan2((d - b), (c - a));
        double p1 = a + r * Math.cos(th + th0);
        double q1 = b + r * Math.sin(th + th0);
        double p2 = a + r * Math.cos(-th + th0);
        double q2 = b + r * Math.sin(-th + th0);
        Point[] ps = { new Point(p1, q1), new Point(p2, q2) };
        return ps;
    }
    public String toString() {
        return "x,y,r " + x + " " + y + " " + r + " ";
    }
}

</source>
</class>

<class classid="45" nclones="2" nlines="135" similarity="100">
<source file="../hum_codes_raw/s054668339.java" startline="1" endline="171" pcid="1824">

import java.io.*;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.MathContext;
import java.text.DecimalFormat;
import java.util.*;

public class Main {


    static MyScanner sc;
    private static PrintWriter out;
    static long M = 1000000007;

    public static void main(String[] s) throws Exception {
//        sc = new MyScanner(new BufferedReader(new StringReader("8\n" +
//                "1 1 1 1 1 1 1 2")));
        sc = new MyScanner(System.in);


        out = new PrintWriter(new OutputStreamWriter(System.out));
        long t = System.currentTimeMillis();
        solve();
        out.flush();
    }


    private static void solve() {

        int a = sc.nextInt();
        int b = sc.nextInt();
        int c = sc.nextInt();
        int d = sc.nextInt();
        int e = sc.nextInt();
        int f = sc.nextInt();
        boolean[] cans = new boolean[3001];
        boolean[] canw = new boolean[3001];
        cans[0] = true;
        canw[0] = true;
        for (int i = 0; i < 3000; i++) {
            if (cans[i]) {
                if (i + c <= 3000) {
                    cans[i + c] = true;
                }

                if (i + d <= 3000) {
                    cans[i + d] = true;
                }
            }
        }
        for (int i = 0; i < 30; i++) {
            if (canw[i]) {
                if (i + b <= 30) {
                    canw[i + a] = true;
                }

                if (i + d <= 30) {
                    canw[i + b] = true;
                }
            }
        }


        int[] max = new int[]{0,  a};
        Comparator<int[]> rr = new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                return Double.compare(100.0 * o1[0] / (o1[0] + 100 * o1[1]), 100.0 * o2[0] / (o2[0] +  100 * o2[1]) );
            }
        };

        for (int i = 0 ; i <= 3000; i++) {
            for (int j = 1 ; j <= 30; j++) {
                if (i + j * 100 > f) continue;
                if (j * e < i) continue;
                if (!cans[i]) continue;
                if (!canw[j]) continue;
                if (rr.compare(max, new int[]{i, j}) < 0){
                    max = new int[]{i, j};
                };

            }
        }

        out.println((max[1] * 100 + max[0]) + " " + max[0]);
    }


    private static void solveT() {
        int t = sc.nextInt();
        while (t-- > 0) {
            solve();
        }
    }

    private static long gcd(long l, long l1) {
        if (l > l1) return gcd(l1, l);
        if (l == 0) return l1;
        return gcd(l1 % l, l);
    }

    private static long pow(long a, long b, long m) {
        if (b == 0) return 1;
        if (b == 1) return a;
        long pp = pow(a, b / 2, m);
        pp *= pp;
        pp %= m;
        return (pp * (b % 2 == 0 ? 1 : a)) % m;
    }


    static class MyScanner {
        BufferedReader br;
        StringTokenizer st;

        MyScanner(BufferedReader br) {
            this.br = br;
        }

        public MyScanner(InputStream in) {
            this(new BufferedReader(new InputStreamReader(in)));
        }

        void findToken() {
            while (st == null || !st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
        }

        String next() {
            findToken();
            return st.nextToken();
        }

        int[] na(int n) {
            int[] k = new int[n];
            for (int i = 0; i < n; i++) {
                k[i] = sc.nextInt();
            }
            return k;
        }

        long[] nl(int n) {
            long[] k = new long[n];
            for (int i = 0; i < n; i++) {
                k[i] = sc.nextLong();
            }
            return k;
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }
    }


}

</source>
<source file="../hum_codes_raw/s322425265.java" startline="1" endline="171" pcid="10803">

import java.io.*;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.MathContext;
import java.text.DecimalFormat;
import java.util.*;

public class Main {


    static MyScanner sc;
    private static PrintWriter out;
    static long M = 1000000007;

    public static void main(String[] s) throws Exception {
//        sc = new MyScanner(new BufferedReader(new StringReader("8\n" +
//                "1 1 1 1 1 1 1 2")));
        sc = new MyScanner(System.in);


        out = new PrintWriter(new OutputStreamWriter(System.out));
        long t = System.currentTimeMillis();
        solve();
        out.flush();
    }


    private static void solve() {

        int a = sc.nextInt();
        int b = sc.nextInt();
        int c = sc.nextInt();
        int d = sc.nextInt();
        int e = sc.nextInt();
        int f = sc.nextInt();
        boolean[] cans = new boolean[3001];
        boolean[] canw = new boolean[3001];
        cans[0] = true;
        canw[0] = true;
        for (int i = 0; i < 3000; i++) {
            if (cans[i]) {
                if (i + c <= 3000) {
                    cans[i + c] = true;
                }

                if (i + d <= 3000) {
                    cans[i + d] = true;
                }
            }
        }
        for (int i = 0; i < 30; i++) {
            if (canw[i]) {
                if (i + b <= 30) {
                    canw[i + a] = true;
                }

                if (i + d <= 30) {
                    canw[i + b] = true;
                }
            }
        }


        int[] max = new int[]{0,  a};
        Comparator<int[]> rr = new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                return Double.compare(100.0 * o1[0] / (o1[0] + 100 * o1[1]), 100.0 * o2[0] / (o2[0] +  100 * o2[1]) );
            }
        };

        for (int i = 0 ; i <= 3000; i++) {
            for (int j = 1 ; j <= 30; j++) {
                if (i + j * 100 > f) continue;
                if (j * e < i) continue;
                if (!cans[i]) continue;
                if (!canw[j]) continue;
                if (rr.compare(max, new int[]{i, j}) < 0){
                    max = new int[]{i, j};
                };

            }
        }

        out.println((max[1] * 100 + max[0]) + " " + max[0]);
    }


    private static void solveT() {
        int t = sc.nextInt();
        while (t-- > 0) {
            solve();
        }
    }

    private static long gcd(long l, long l1) {
        if (l > l1) return gcd(l1, l);
        if (l == 0) return l1;
        return gcd(l1 % l, l);
    }

    private static long pow(long a, long b, long m) {
        if (b == 0) return 1;
        if (b == 1) return a;
        long pp = pow(a, b / 2, m);
        pp *= pp;
        pp %= m;
        return (pp * (b % 2 == 0 ? 1 : a)) % m;
    }


    static class MyScanner {
        BufferedReader br;
        StringTokenizer st;

        MyScanner(BufferedReader br) {
            this.br = br;
        }

        public MyScanner(InputStream in) {
            this(new BufferedReader(new InputStreamReader(in)));
        }

        void findToken() {
            while (st == null || !st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
        }

        String next() {
            findToken();
            return st.nextToken();
        }

        int[] na(int n) {
            int[] k = new int[n];
            for (int i = 0; i < n; i++) {
                k[i] = sc.nextInt();
            }
            return k;
        }

        long[] nl(int n) {
            long[] k = new long[n];
            for (int i = 0; i < n; i++) {
                k[i] = sc.nextLong();
            }
            return k;
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }
    }


}

</source>
</class>

<class classid="46" nclones="2" nlines="193" similarity="100">
<source file="../hum_codes_raw/s057521857.java" startline="1" endline="229" pcid="1929">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.io.IOException;
import java.util.TreeSet;
import java.util.ArrayList;
import java.io.UncheckedIOException;
import java.util.List;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            DBlackAndWhiteTree solver = new DBlackAndWhiteTree();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class DBlackAndWhiteTree {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            Node[] nodes = new Node[n];
            for (int i = 0; i < n; i++) {
                nodes[i] = new Node();
                nodes[i].id = i;
            }
            for (int i = 0; i < n - 1; i++) {
                Node a = nodes[in.readInt() - 1];
                Node b = nodes[in.readInt() - 1];
                a.adj.add(b);
                b.adj.add(a);
                a.deg++;
                b.deg++;
            }

            TreeSet<Node> set = new TreeSet<>((a, b) -> a.deg == b.deg ? Integer.compare(a.id, b.id) : Integer.compare(a.deg, b.deg));
            set.addAll(Arrays.asList(nodes));
            while (!set.isEmpty()) {
                Node head = set.pollFirst();
                if (head.deg == 0) {
                    out.println("First");
                    return;
                }
                head.removed = true;
                Node nearby = null;
                for (Node node : head.adj) {
                    if (node.removed) {
                        continue;
                    }
                    nearby = node;
                    set.remove(nearby);
                }
                nearby.removed = true;
                for (Node node : nearby.adj) {
                    if (node.removed) {
                        continue;
                    }
                    set.remove(node);
                    node.deg--;
                    set.add(node);
                }
            }

            out.println("Second");
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(String c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(String c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class Node {
        List<Node> adj = new ArrayList<>();
        int deg;
        int id;
        boolean removed;

        public String toString() {
            return "" + (id + 1);
        }

    }
}


</source>
<source file="../hum_codes_raw/s781367822.java" startline="1" endline="229" pcid="26234">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.io.IOException;
import java.util.TreeSet;
import java.util.ArrayList;
import java.io.UncheckedIOException;
import java.util.List;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            DBlackAndWhiteTree solver = new DBlackAndWhiteTree();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class DBlackAndWhiteTree {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            Node[] nodes = new Node[n];
            for (int i = 0; i < n; i++) {
                nodes[i] = new Node();
                nodes[i].id = i;
            }
            for (int i = 0; i < n - 1; i++) {
                Node a = nodes[in.readInt() - 1];
                Node b = nodes[in.readInt() - 1];
                a.adj.add(b);
                b.adj.add(a);
                a.deg++;
                b.deg++;
            }

            TreeSet<Node> set = new TreeSet<>((a, b) -> a.deg == b.deg ? Integer.compare(a.id, b.id) : Integer.compare(a.deg, b.deg));
            set.addAll(Arrays.asList(nodes));
            while (!set.isEmpty()) {
                Node head = set.pollFirst();
                if (head.deg == 0) {
                    out.println("First");
                    return;
                }
                head.removed = true;
                Node nearby = null;
                for (Node node : head.adj) {
                    if (node.removed) {
                        continue;
                    }
                    nearby = node;
                    set.remove(nearby);
                }
                nearby.removed = true;
                for (Node node : nearby.adj) {
                    if (node.removed) {
                        continue;
                    }
                    set.remove(node);
                    node.deg--;
                    set.add(node);
                }
            }

            out.println("Second");
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(String c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(String c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class Node {
        List<Node> adj = new ArrayList<>();
        int deg;
        int id;
        boolean removed;

        public String toString() {
            return "" + (id + 1);
        }

    }
}


</source>
</class>

<class classid="47" nclones="4" nlines="59" similarity="100">
<source file="../hum_codes_raw/s058915520.java" startline="1" endline="71" pcid="1977">
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;

class Main {

	static int n;
	static double[] x1, y1, x2, y2;
	static double sx, sy, gx, gy;
	static ArrayList<Integer>[] g;

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int q = sc.nextInt();
		while (q-- > 0) {
			long x0, y0, x1, y1, x2, y2, x3, y3;
			x0 = sc.nextLong();
			y0 = sc.nextLong();
			x1 = sc.nextLong();
			y1 = sc.nextLong();
			x2 = sc.nextLong();
			y2 = sc.nextLong();
			x3 = sc.nextLong();
			y3 = sc.nextLong();
			Point p0 = new Point(x0, y0);
			Point p1 = new Point(x1, y1);
			Point p2 = new Point(x2, y2);
			Point p3 = new Point(x3, y3);
			if (linesIntersect(p0, p1, p2, p3)) {
				System.out.println(1);
			} else {
				System.out.println(0);
			}
		}

	}

	static class Point {
		long x, y;
		int id;

		public Point(long x, long y) {
			this.x = x;
			this.y = y;
		}
	}

	static boolean linesIntersect(Point s1, Point d1, Point s2, Point d2) {
		long prd1 = crossProduct(s1, d1, s1, d2) * crossProduct(s1, d1, s1, s2);
		long prd2 = crossProduct(s2, d2, s2, s1) * crossProduct(s2, d2, s2, d1);
		if (prd1 == 0 && prd2 == 0) {
			if (((s2.x - s1.x) * (s2.x - d1.x) <= 0 && (s2.y - s1.y) * (s2.y - d1.y) <= 0)
					|| ((d2.x - s1.x) * (d2.x - d1.x) <= 0 && (d2.y - s1.y) * (d2.y - d1.y) <= 0)
					|| ((s1.x - s2.x) * (s1.x - d2.x) <= 0 && (s1.y - s2.y) * (s1.y - d2.y) <= 0)
					|| ((d1.x - s2.x) * (d1.x - d2.x) <= 0 && (d1.y - s2.y) * (d1.y - d2.y) <= 0)) {
				return true;
			} else
				return false;
		} else
			return prd1 <= 0 && prd2 <= 0;
	}

	static long crossProduct(Point s1, Point d1, Point s2, Point d2) {
		return (d1.x - s1.x) * (d2.y - s2.y) - (d1.y - s1.y) * (d2.x - s2.x);
	}

	static void tr(Object... objects) {
		System.out.println(Arrays.deepToString(objects));
	}
}

</source>
<source file="../hum_codes_raw/s734381119.java" startline="1" endline="71" pcid="24685">
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;

class Main {

	static int n;
	static double[] x1, y1, x2, y2;
	static double sx, sy, gx, gy;
	static ArrayList<Integer>[] g;

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int q = sc.nextInt();
		while (q-- > 0) {
			long x0, y0, x1, y1, x2, y2, x3, y3;
			x0 = sc.nextLong();
			y0 = sc.nextLong();
			x1 = sc.nextLong();
			y1 = sc.nextLong();
			x2 = sc.nextLong();
			y2 = sc.nextLong();
			x3 = sc.nextLong();
			y3 = sc.nextLong();
			Point p0 = new Point(x0, y0);
			Point p1 = new Point(x1, y1);
			Point p2 = new Point(x2, y2);
			Point p3 = new Point(x3, y3);
			if (linesIntersect(p0, p1, p2, p3)) {
				System.out.println(1);
			} else {
				System.out.println(0);
			}
		}

	}

	static class Point {
		long x, y;
		int id;

		public Point(long x, long y) {
			this.x = x;
			this.y = y;
		}
	}

	static boolean linesIntersect(Point s1, Point d1, Point s2, Point d2) {
		long prd1 = crossProduct(s1, d1, s1, d2) * crossProduct(s1, d1, s1, s2);
		long prd2 = crossProduct(s2, d2, s2, s1) * crossProduct(s2, d2, s2, d1);
		if (prd1 == 0 && prd2 == 0) {
			if (((s2.x - s1.x) * (s2.x - d1.x) <= 0 && (s2.y - s1.y) * (s2.y - d1.y) <= 0)
					|| ((d2.x - s1.x) * (d2.x - d1.x) <= 0 && (d2.y - s1.y) * (d2.y - d1.y) <= 0)
					|| ((s1.x - s2.x) * (s1.x - d2.x) <= 0 && (s1.y - s2.y) * (s1.y - d2.y) <= 0)
					|| ((d1.x - s2.x) * (d1.x - d2.x) <= 0 && (d1.y - s2.y) * (d1.y - d2.y) <= 0)) {
				return true;
			} else
				return false;
		} else
			return prd1 <= 0 && prd2 <= 0;
	}

	static long crossProduct(Point s1, Point d1, Point s2, Point d2) {
		return (d1.x - s1.x) * (d2.y - s2.y) - (d1.y - s1.y) * (d2.x - s2.x);
	}

	static void tr(Object... objects) {
		System.out.println(Arrays.deepToString(objects));
	}
}

</source>
<source file="../hum_codes_raw/s703249395.java" startline="1" endline="71" pcid="23656">
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;

class Main {

	static int n;
	static double[] x1, y1, x2, y2;
	static double sx, sy, gx, gy;
	static ArrayList<Integer>[] g;

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int q = sc.nextInt();
		while (q-- > 0) {
			long x0, y0, x1, y1, x2, y2, x3, y3;
			x0 = sc.nextLong();
			y0 = sc.nextLong();
			x1 = sc.nextLong();
			y1 = sc.nextLong();
			x2 = sc.nextLong();
			y2 = sc.nextLong();
			x3 = sc.nextLong();
			y3 = sc.nextLong();
			Point p0 = new Point(x0, y0);
			Point p1 = new Point(x1, y1);
			Point p2 = new Point(x2, y2);
			Point p3 = new Point(x3, y3);
			if (linesIntersect(p0, p1, p2, p3)) {
				System.out.println(1);
			} else {
				System.out.println(0);
			}
		}

	}

	static class Point {
		long x, y;
		int id;

		public Point(long x, long y) {
			this.x = x;
			this.y = y;
		}
	}

	static boolean linesIntersect(Point s1, Point d1, Point s2, Point d2) {
		long prd1 = crossProduct(s1, d1, s1, d2) * crossProduct(s1, d1, s1, s2);
		long prd2 = crossProduct(s2, d2, s2, s1) * crossProduct(s2, d2, s2, d1);
		if (prd1 == 0 && prd2 == 0) {
			if (((s2.x - s1.x) * (s2.x - d1.x) <= 0 && (s2.y - s1.y) * (s2.y - d1.y) <= 0)
					|| ((d2.x - s1.x) * (d2.x - d1.x) <= 0 && (d2.y - s1.y) * (d2.y - d1.y) <= 0)
					|| ((s1.x - s2.x) * (s1.x - d2.x) <= 0 && (s1.y - s2.y) * (s1.y - d2.y) <= 0)
					|| ((d1.x - s2.x) * (d1.x - d2.x) <= 0 && (d1.y - s2.y) * (d1.y - d2.y) <= 0)) {
				return true;
			} else
				return false;
		} else
			return prd1 <= 0 && prd2 <= 0;
	}

	static long crossProduct(Point s1, Point d1, Point s2, Point d2) {
		return (d1.x - s1.x) * (d2.y - s2.y) - (d1.y - s1.y) * (d2.x - s2.x);
	}

	static void tr(Object... objects) {
		System.out.println(Arrays.deepToString(objects));
	}
}

</source>
<source file="../hum_codes_raw/s310504887.java" startline="1" endline="71" pcid="10450">
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;

class Main {

	static int n;
	static double[] x1, y1, x2, y2;
	static double sx, sy, gx, gy;
	static ArrayList<Integer>[] g;

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int q = sc.nextInt();
		while (q-- > 0) {
			long x0, y0, x1, y1, x2, y2, x3, y3;
			x0 = sc.nextLong();
			y0 = sc.nextLong();
			x1 = sc.nextLong();
			y1 = sc.nextLong();
			x2 = sc.nextLong();
			y2 = sc.nextLong();
			x3 = sc.nextLong();
			y3 = sc.nextLong();
			Point p0 = new Point(x0, y0);
			Point p1 = new Point(x1, y1);
			Point p2 = new Point(x2, y2);
			Point p3 = new Point(x3, y3);
			if (linesIntersect(p0, p1, p2, p3)) {
				System.out.println(1);
			} else {
				System.out.println(0);
			}
		}

	}

	static class Point {
		long x, y;
		int id;

		public Point(long x, long y) {
			this.x = x;
			this.y = y;
		}
	}

	static boolean linesIntersect(Point s1, Point d1, Point s2, Point d2) {
		long prd1 = crossProduct(s1, d1, s1, d2) * crossProduct(s1, d1, s1, s2);
		long prd2 = crossProduct(s2, d2, s2, s1) * crossProduct(s2, d2, s2, d1);
		if (prd1 == 0 && prd2 == 0) {
			if (((s2.x - s1.x) * (s2.x - d1.x) <= 0 && (s2.y - s1.y) * (s2.y - d1.y) <= 0)
					|| ((d2.x - s1.x) * (d2.x - d1.x) <= 0 && (d2.y - s1.y) * (d2.y - d1.y) <= 0)
					|| ((s1.x - s2.x) * (s1.x - d2.x) <= 0 && (s1.y - s2.y) * (s1.y - d2.y) <= 0)
					|| ((d1.x - s2.x) * (d1.x - d2.x) <= 0 && (d1.y - s2.y) * (d1.y - d2.y) <= 0)) {
				return true;
			} else
				return false;
		} else
			return prd1 <= 0 && prd2 <= 0;
	}

	static long crossProduct(Point s1, Point d1, Point s2, Point d2) {
		return (d1.x - s1.x) * (d2.y - s2.y) - (d1.y - s1.y) * (d2.x - s2.x);
	}

	static void tr(Object... objects) {
		System.out.println(Arrays.deepToString(objects));
	}
}

</source>
</class>

<class classid="48" nclones="2" nlines="30" similarity="100">
<source file="../hum_codes_raw/s059024828.java" startline="1" endline="44" pcid="1983">
import java.util.Arrays;
import java.util.Scanner;
public class Main
{
	public static void main(String arg[])
	{
		Scanner sc=new Scanner(System.in);
		boolean a[] =new boolean[10001];
		Arrays.fill(a, true);
		for(int i=2; i*i<=10000; i++)
		{
			if(!a[i])
				continue;
			for(int j=i*2; j<=10000; j+=i)
				a[j]=false;
		}
		while(sc.hasNext())
		{
			int n=sc.nextInt();
			if(n==0)
				return;
			int sum=0;
			int ans=0;
			for(int i=2; i<=n; i++)
			{
				sum =0;
				if(a[i])
					for(int j=i; j<=n; j++)
					{
						if(a[j])
						{
							sum+=j;
							if(n==sum)
								ans++;
						}
						if(sum>=n)
							break;
					}
			}
			System.out.println(ans);
		}
	}
}

</source>
<source file="../hum_codes_raw/s862432766.java" startline="1" endline="44" pcid="28998">
import java.util.Arrays;
import java.util.Scanner;
public class Main
{
    public static void main(String arg[])
    {
        Scanner sc=new Scanner(System.in);
        boolean a[] =new boolean[10001];
        Arrays.fill(a, true);
        for(int i=2; i*i<=10000; i++)
        {
            if(!a[i])
                continue;
            for(int j=i*2; j<=10000; j+=i)
                a[j]=false;
        }
        while(sc.hasNext())
        {
            int n=sc.nextInt();
            if(n==0)
                return;
            int sum=0;
            int ans=0;
            for(int i=2; i<=n; i++)
            {
                sum =0;
                if(a[i])
                    for(int j=i; j<=n; j++)
                    {
                        if(a[j])
                        {
                            sum+=j;
                            if(n==sum)
                                ans++;
                        }
                        if(sum>=n)
                            break;
                    }
            }
            System.out.println(ans);
        }
    }
}

</source>
</class>

<class classid="49" nclones="2" nlines="284" similarity="100">
<source file="../hum_codes_raw/s062380094.java" startline="1" endline="336" pcid="2083">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.io.UncheckedIOException;
import java.util.List;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            EGraph solver = new EGraph();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class EGraph {
        long val = Long.MIN_VALUE;
        boolean valid = true;

        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            int m = in.readInt();
            Node[] nodes = new Node[n];
            for (int i = 0; i < n; i++) {
                nodes[i] = new Node();
            }
            for (int i = 0; i < m; i++) {
                Node a = nodes[in.readInt() - 1];
                Node b = nodes[in.readInt() - 1];
                Edge e = new Edge();
                e.a = a;
                e.b = b;
                e.w = in.readInt() - 2;
                a.adj.add(e);
                b.adj.add(e);
            }

            dfs(nodes[0], null, new DoubleLinearFunction(1, 0));
            long l = 0;
            long r = Integer.MAX_VALUE;
            for (Node node : nodes) {
                DoubleLinearFunction df = node.func;
                if (df.a == 0) {
                    if (df.b < 0) {
                        valid = false;
                    }
                    continue;
                }
                if (df.a < 0) {
                    r = Math.min(r, DigitUtils.floorDiv((long) -df.b, (long) df.a));
                } else {
                    l = Math.max(l, DigitUtils.ceilDiv((long) -df.b, (long) df.a));
                }
            }

            if (l > r) {
                valid = false;
            }
            if (!valid) {
                out.println(0);
                return;
            }
            if (val != Long.MIN_VALUE) {
                if (val >= l && val <= r) {
                    out.println(1);
                } else {
                    out.println(0);
                }
                return;
            }

            out.println(r - l + 1);
        }

        public void dfs(Node root, Edge p, DoubleLinearFunction func) {
            if (root.func != null) {
                DoubleLinearFunction delta = DoubleLinearFunction.subtract(root.func, func);
                if (delta.a == 0) {
                    if (delta.b == 0) {
                        return;
                    }
                    valid = false;
                } else {
                    if (-(long) delta.b % (long) delta.a != 0) {
                        valid = false;
                    }
                    if (val != Long.MIN_VALUE && -(long) delta.b / (long) delta.a != val) {
                        valid = false;
                    }
                    val = -(long) delta.b / (long) delta.a;
                }
                return;
            }
            root.func = func;
            for (Edge e : root.adj) {
                if (e == p) {
                    continue;
                }
                dfs(e.other(root), e, DoubleLinearFunction.subtract(
                        new DoubleLinearFunction(0, e.w), root.func));
            }
        }

    }

    static class DigitUtils {
        private DigitUtils() {
        }

        public static long floorDiv(long a, long b) {
            return a < 0 ? -ceilDiv(-a, b) : a / b;
        }

        public static long ceilDiv(long a, long b) {
            if (a < 0) {
                return -floorDiv(-a, b);
            }
            long c = a / b;
            if (c * b < a) {
                return c + 1;
            }
            return c;
        }

    }

    static class Edge {
        Node a;
        Node b;
        int w;

        Node other(Node x) {
            return a == x ? b : a;
        }

    }

    static class DoubleLinearFunction {
        public final double a;
        public final double b;

        public DoubleLinearFunction(double a, double b) {
            this.a = a;
            this.b = b;
        }

        public static DoubleLinearFunction subtract(DoubleLinearFunction a, DoubleLinearFunction b) {
            return new DoubleLinearFunction(a.a - b.a, a.b - b.b);
        }

        public boolean equals(Object obj) {
            if (!(obj instanceof DoubleLinearFunction)) {
                return false;
            }
            DoubleLinearFunction function = (DoubleLinearFunction) obj;
            return function.a == a && function.b == b;
        }

        public int hashCode() {
            return Double.hashCode(a) * 31 + Double.hashCode(b);
        }

        public String toString() {
            if (b >= 0) {
                return a + "x+" + b;
            }
            return a + "x" + b;
        }

    }

    static class Node {
        List<Edge> adj = new ArrayList<>();
        DoubleLinearFunction func;

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(long c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println(long c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }
}


</source>
<source file="../hum_codes_raw/s087113353.java" startline="1" endline="336" pcid="2891">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.io.UncheckedIOException;
import java.util.List;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            EGraph solver = new EGraph();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class EGraph {
        long val = Long.MIN_VALUE;
        boolean valid = true;

        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            int m = in.readInt();
            Node[] nodes = new Node[n];
            for (int i = 0; i < n; i++) {
                nodes[i] = new Node();
            }
            for (int i = 0; i < m; i++) {
                Node a = nodes[in.readInt() - 1];
                Node b = nodes[in.readInt() - 1];
                Edge e = new Edge();
                e.a = a;
                e.b = b;
                e.w = in.readInt() - 2;
                a.adj.add(e);
                b.adj.add(e);
            }

            dfs(nodes[0], null, new DoubleLinearFunction(1, 0));
            long l = 0;
            long r = Integer.MAX_VALUE;
            for (Node node : nodes) {
                DoubleLinearFunction df = node.func;
                if (df.a == 0) {
                    if (df.b < 0) {
                        valid = false;
                    }
                    continue;
                }
                if (df.a < 0) {
                    r = Math.min(r, DigitUtils.floorDiv((long) -df.b, (long) df.a));
                } else {
                    l = Math.max(l, DigitUtils.ceilDiv((long) -df.b, (long) df.a));
                }
            }

            if (l > r) {
                valid = false;
            }
            if (!valid) {
                out.println(0);
                return;
            }
            if (val != Long.MIN_VALUE) {
                if (val >= l && val <= r) {
                    out.println(1);
                } else {
                    out.println(0);
                }
                return;
            }

            out.println(r - l + 1);
        }

        public void dfs(Node root, Edge p, DoubleLinearFunction func) {
            if (root.func != null) {
                DoubleLinearFunction delta = DoubleLinearFunction.subtract(root.func, func);
                if (delta.a == 0) {
                    if (delta.b == 0) {
                        return;
                    }
                    valid = false;
                } else {
                    if (-(long) delta.b % (long) delta.a != 0) {
                        valid = false;
                    }
                    if (val != Long.MIN_VALUE && -(long) delta.b / (long) delta.a != val) {
                        valid = false;
                    }
                    val = -(long) delta.b / (long) delta.a;
                }
                return;
            }
            root.func = func;
            for (Edge e : root.adj) {
                if (e == p) {
                    continue;
                }
                dfs(e.other(root), e, DoubleLinearFunction.subtract(
                        new DoubleLinearFunction(0, e.w), root.func));
            }
        }

    }

    static class DigitUtils {
        private DigitUtils() {
        }

        public static long floorDiv(long a, long b) {
            return a < 0 ? -ceilDiv(-a, b) : a / b;
        }

        public static long ceilDiv(long a, long b) {
            if (a < 0) {
                return -floorDiv(-a, b);
            }
            long c = a / b;
            if (c * b < a) {
                return c + 1;
            }
            return c;
        }

    }

    static class Edge {
        Node a;
        Node b;
        int w;

        Node other(Node x) {
            return a == x ? b : a;
        }

    }

    static class DoubleLinearFunction {
        public final double a;
        public final double b;

        public DoubleLinearFunction(double a, double b) {
            this.a = a;
            this.b = b;
        }

        public static DoubleLinearFunction subtract(DoubleLinearFunction a, DoubleLinearFunction b) {
            return new DoubleLinearFunction(a.a - b.a, a.b - b.b);
        }

        public boolean equals(Object obj) {
            if (!(obj instanceof DoubleLinearFunction)) {
                return false;
            }
            DoubleLinearFunction function = (DoubleLinearFunction) obj;
            return function.a == a && function.b == b;
        }

        public int hashCode() {
            return Double.hashCode(a) * 31 + Double.hashCode(b);
        }

        public String toString() {
            if (b >= 0) {
                return a + "x+" + b;
            }
            return a + "x" + b;
        }

    }

    static class Node {
        List<Edge> adj = new ArrayList<>();
        DoubleLinearFunction func;

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(long c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println(long c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }
}


</source>
</class>

<class classid="50" nclones="2" nlines="77" similarity="100">
<source file="../hum_codes_raw/s063720635.java" startline="1" endline="97" pcid="2130">
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		int n = sc.nextInt();
		long x[] = new long[n], y[] = new long[n];
		
		for(int i=0;i<n;i++){
			x[i] = sc.nextLong();
			y[i] = sc.nextLong();
		}
		
		long parity = Math.abs((x[0] + y[0]) % 2);
		
		boolean f = true;
		for(int i=1;i<n;i++){
			if(Math.abs((x[i]+y[i])%2) != parity)
				f = false;
		}
		
		if(f){
			long a[] = new long[31];
			
			a[0] = 1;
			for(int i=1;i<31;i++){
				a[i] = a[i-1]*2;
			}
			
			
			if(parity==0){
				System.out.println(32);
				System.out.print(1+" ");
			}
			else{
				System.out.println(31);
			}
			
			for(int i=30;i>=0;i--){
				System.out.print(i==30 ? a[i]:" "+a[i]);
			}
			System.out.println();
			
			
			for(int i=0;i<n;i++){
				if(parity==0){
					if(Math.abs(x[i]-1) + Math.abs(y[i]) <= (1L<<31) -1){
						x[i] -= 1;
						System.out.print("R");
					}
					else if(Math.abs(x[i]+1) + Math.abs(y[i]) <= (1L<<31) -1){
						x[i] += 1;
						System.out.print("L");
					}
					else if(Math.abs(x[i]) + Math.abs(y[i]-1) <= (1L<<31) -1){
						y[i] -=1;
						System.out.print("U");
					}
					else{
						y[i]+=1;
						System.out.print("D");
					}
				}
				
				
				for(int j=30;j>=0;j--){
					
					if(Math.abs(x[i]-a[j]) + Math.abs(y[i]) <= (1L<<j) -1){
						x[i] -= a[j];
						System.out.print("R");
					}
					else if(Math.abs(x[i]+a[j]) + Math.abs(y[i]) <= (1L<<j) -1){
						x[i] += a[j];
						System.out.print("L");
					}
					else if(Math.abs(x[i]) + Math.abs(y[i]-a[j]) <= (1L<<j) -1){
						y[i] -= a[j];
						System.out.print("U");
					}
					else{
						y[i] += a[j];
						System.out.print("D");
					}
				}
				System.out.println();
			}
			
		}
		else{
			System.out.println(-1);
		}
	}

}

</source>
<source file="../hum_codes_raw/s905058124.java" startline="1" endline="97" pcid="30460">
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		int n = sc.nextInt();
		long x[] = new long[n], y[] = new long[n];
		
		for(int i=0;i<n;i++){
			x[i] = sc.nextLong();
			y[i] = sc.nextLong();
		}
		
		long parity = Math.abs((x[0] + y[0]) % 2);
		
		boolean f = true;
		for(int i=1;i<n;i++){
			if(Math.abs((x[i]+y[i])%2) != parity)
				f = false;
		}
		
		if(f){
			long a[] = new long[31];
			
			a[0] = 1;
			for(int i=1;i<31;i++){
				a[i] = a[i-1]*2;
			}
			
			
			if(parity==0){
				System.out.println(32);
				System.out.print(1+" ");
			}
			else{
				System.out.println(31);
			}
			
			for(int i=30;i>=0;i--){
				System.out.print(i==30 ? a[i]:" "+a[i]);
			}
			System.out.println();
			
			
			for(int i=0;i<n;i++){
				if(parity==0){
					if(Math.abs(x[i]-1) + Math.abs(y[i]) <= (1L<<31) -1){
						x[i] -= 1;
						System.out.print("R");
					}
					else if(Math.abs(x[i]+1) + Math.abs(y[i]) <= (1L<<31) -1){
						x[i] += 1;
						System.out.print("L");
					}
					else if(Math.abs(x[i]) + Math.abs(y[i]-1) <= (1L<<31) -1){
						y[i] -=1;
						System.out.print("U");
					}
					else{
						y[i]+=1;
						System.out.print("D");
					}
				}
				
				
				for(int j=30;j>=0;j--){
					
					if(Math.abs(x[i]-a[j]) + Math.abs(y[i]) <= (1L<<j) -1){
						x[i] -= a[j];
						System.out.print("R");
					}
					else if(Math.abs(x[i]+a[j]) + Math.abs(y[i]) <= (1L<<j) -1){
						x[i] += a[j];
						System.out.print("L");
					}
					else if(Math.abs(x[i]) + Math.abs(y[i]-a[j]) <= (1L<<j) -1){
						y[i] -= a[j];
						System.out.print("U");
					}
					else{
						y[i] += a[j];
						System.out.print("D");
					}
				}
				System.out.println();
			}
			
		}
		else{
			System.out.println(-1);
		}
	}

}

</source>
</class>

<class classid="51" nclones="2" nlines="15" similarity="100">
<source file="../hum_codes_raw/s063975139.java" startline="1" endline="18" pcid="2141">
import java.util.Scanner;

public class Main {
	public static void main (String[] args) {
		Scanner sc = new Scanner(System.in);

		int a = sc.nextInt();
		int b = sc.nextInt();
		int c = sc.nextInt();
		
		if (a + b >= c){
			System.out.println("Yes");
		} else {
			System.out.println("No");
		}
	}
}

</source>
<source file="../hum_codes_raw/s401751248.java" startline="1" endline="19" pcid="13531">
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        int a=sc.nextInt();
        int b=sc.nextInt();
        int c=sc.nextInt();
        if(a+b>=c) {
            System.out.println("Yes");
        }else {
            System.out.println("No");
        }

    }

}

</source>
</class>

<class classid="52" nclones="2" nlines="436" similarity="100">
<source file="../hum_codes_raw/s064541745.java" startline="1" endline="488" pcid="2161">
import java.io.*;
import java.util.*;

public class Main {
  private static final int INF = 10_000_000;

  private static final UpdateRangeGetRangeSegmentTree.Operator<Integer, Integer> OPERATOR = new UpdateRangeGetRangeSegmentTree.Operator<>() {
    @Override
    public Integer multiplyLazyValue(Integer lazy, int count) {
      return lazy;
    }

    @Override
    public Integer applyOffset(Integer lazy, int offset) {
      return lazy + offset;
    }

    @Override
    public Integer mergeLazyValue(Integer oldLazy, Integer newLazy) {
      return newLazy;
    }

    @Override
    public Integer apply(Integer value, Integer lazy) {
      return lazy;
    }

    @Override
    public Integer mergeValue(Integer smallIndexValue, Integer largeIndexValue) {
      return Math.min(smallIndexValue, largeIndexValue);
    }

    @Override
    public Integer getUnitValue() {
      return INF;
    }
  };

  private static List<Integer> solve(int h, int w, int[][] abs) {
    Integer[] initialValues = new Integer[w + 1];
    Arrays.fill(initialValues, Integer.valueOf(0));
    initialValues[0] = INF;

    UpdateRangeGetRangeSegmentTree<Integer, Integer> segmentTree = new UpdateRangeGetRangeSegmentTree<>(OPERATOR, initialValues);
    List<Integer> answers = new ArrayList<>();
    for (int i = 0; i < h; i++) {
      int a = abs[i][0];
      int b = abs[i][1];
      int answer = segmentTree.getRange(0, a);
      if (b + 1 < w + 1) {
        answer = Math.min(answer, segmentTree.getRange(b + 1, w + 1));
      }
      if (answer < INF) {
        answers.add(answer + i + 1);
      } else {
        answers.add(-1);
      }
      int v = segmentTree.get(a - 1) - a + 1;
      segmentTree.update(a, b + 1, v);
    }
    return answers;
  }

  private static void execute(ContestReader reader, ContestWriter out) {
    int h = reader.nextInt();
    int w = reader.nextInt();
    int[][] abs = reader.nextInt(h, 2);
    out.printList(solve(h, w, abs));
  }
  
  public static void main(String[] args) {
    ContestReader reader = new ContestReader(System.in);
    ContestWriter out = new ContestWriter(System.out);
    execute(reader, out);
    out.flush();
  }
}

class UpdateRangeGetRangeSegmentTree<T, S> {
  public interface Operator<T, S> {
    T multiplyLazyValue(T lazy, int count);
//    T getUnitLazy();
    T applyOffset(T lazy, int offset);
    T mergeLazyValue(T oldLazy, T newLazy);
    S apply(S value, T lazy);
    S mergeValue(S smallIndexValue, S largeIndexValue);
    S getUnitValue();
  }
  
  private final Operator<T, S> operator;
  private final int n;
  private final List<T> lazies;
  private final List<S> values;
  
  public UpdateRangeGetRangeSegmentTree(Operator<T, S> operator, S[] initialValues) {
    this.operator = operator;
    
    int tempN = 1;
    while (tempN < initialValues.length) {
      tempN *= 2;
    }
    n = tempN;
    lazies = new ArrayList<>();
    values = new ArrayList<>();
    for (int i = 0; i < 2 * n - 1; i++) {
      lazies.add(null);
      values.add(null);
    }
    for (int i = 0; i < initialValues.length; i++) {
      values.set(i + n - 1, initialValues[i]);
    }
    for (int i = initialValues.length; i < n; i++) {
      values.set(i + n - 1, this.operator.getUnitValue());
    }
    for (int i = n - 2; i >= 0; i--) {
      values.set(i, this.operator.mergeValue(values.get(2 * i + 1), values.get(2 * i + 2)));
    }
  }
  
  private void eval(int k, int l, int r) {
    if (lazies.get(k) == null) {
      return;
    }
    values.set(k, operator.apply(values.get(k), operator.multiplyLazyValue(lazies.get(k), r - l)));
    if (r - l > 1) {
      lazies.set(2 * k + 1, operator.mergeLazyValue(lazies.get(2 * k + 1), lazies.get(k)));
      lazies.set(2 * k + 2, operator.mergeLazyValue(lazies.get(2 * k + 2), operator.applyOffset(lazies.get(k), (r - l) / 2)));
    }
    lazies.set(k, null);
  }
  
  private void update(int a, int b, T lazy, int k, int l, int r) {
    eval(k, l, r);
    if (b <= l || r <= a) {
      return;
    }
    if (a <= l && r <= b) {
      lazies.set(k, operator.mergeLazyValue(lazies.get(k), lazy));
      eval(k, l, r);
    } else {
      update(a, b, lazy, 2 * k + 1, l, (l + r) / 2);
      update(a, b, operator.applyOffset(lazy, (r - l) / 2), 2 * k + 2, (l + r) / 2, r);
      values.set(k, operator.mergeValue(values.get(2 * k + 1), values.get(2 * k + 2)));
    }
  }
  
  public void update(int a, int b, T lazy) {
    update(a, b, lazy, 0, 0, n);
  }
  
  public void update(int a, T lazy) {
    update(a, a + 1, lazy);
  }
  
  private S getRange(int a, int b, int k, int l, int r) {
    if (b <= l || r <= a) {
      return operator.getUnitValue();
    }
    eval(k, l, r);
    if (a <= l && r <= b) {
      return values.get(k);
    }
    S vl = getRange(a, b, 2 * k + 1, l, (l + r) / 2);
    S vr = getRange(a, b, 2 * k + 2, (l + r) / 2, r);
    return operator.mergeValue(vl, vr);
  }
  
  public S getRange(int a, int b) {
    return getRange(a, b, 0, 0, n);
  }
  
  public S get(int a) {
    return getRange(a, a + 1);
  }

  private void dump(List list) {
    int sum = 0;
    for (int i = 0; sum + (1 << i) <= 2 * n - 1; sum += 1 << i, i++) {
      for (int j = sum; j < sum + (1 << i); j++) {
        System.err.print(list.get(j));
        System.err.print(" ");
      }
      System.err.println();
    }
    System.err.println();
  }
  
  public void dump() {
    System.err.println("values: ");
    dump(values);
    System.err.println("lazies: ");
    dump(lazies);
  }
}

class ContestWriter extends PrintWriter {
  ContestWriter(PrintStream printStream) {
    super(printStream);
  }

  public void printList(List<? extends Object> list) {
    for (Object object : list) {
      println(object);
    }
  }

  public void printListOneLine(List<? extends Object> list) {
    List<String> stringList = new ArrayList<>();
    for (Object object : list) {
      stringList.add(object.toString());
    }
    println(String.join(" ", stringList));
  }
}

class ContestReader {
  private static final int BUFFER_SIZE = 1024;
  
  private final InputStream stream;
  private final byte[] buffer;
  private int pointer;
  private int bufferLength;
  
  ContestReader(InputStream stream) {
    this.stream = stream;
    this.buffer = new byte[BUFFER_SIZE];
    this.pointer = 0;
    this.bufferLength = 0;
  }
  
  private boolean hasNextByte() {
    if (pointer < bufferLength) {
      return true;
    }
    
    pointer = 0;
    try {
      bufferLength = stream.read(buffer);
    } catch (IOException e) {
      throw new RuntimeException(e);
    }
    return bufferLength > 0;
  }
  
  private int readByte() {
    if (hasNextByte()) {
      return buffer[pointer++];
    } else {
      return -1;
    }
  }
  
  private static boolean isPrintableChar(int c) {
    return 33 <= c && c <= 126;
  }
  
  public boolean hasNext() {
    while (hasNextByte() && !isPrintableChar(buffer[pointer])) {
      pointer++;
    }
    return hasNextByte();
  }
  
  public String next() {
    if (!hasNext()) {
      throw new NoSuchElementException();
    }
    StringBuilder sb = new StringBuilder();
    while(true) {
      int b = readByte();
      if (!isPrintableChar(b)) {
        break;
      }
      sb.appendCodePoint(b);
    }
    return sb.toString();
  }
  
  public String nextLine() {
    if (!hasNext()) {
      throw new NoSuchElementException();
    }
    StringBuilder sb = new StringBuilder();
    while(true) {
      int b = readByte();
      if (!isPrintableChar(b) && b != 0x20) {
        break;
      }
      sb.appendCodePoint(b);
    }
    return sb.toString();
  }
  
  public char nextChar() {
    return next().charAt(0);
  }
  
  public int nextInt() {
    if (!hasNext()) {
      throw new NoSuchElementException();
    }
    
    int n = 0;
    boolean minus = false;
    
    {
      int b = readByte();
      if (b == '-') {
        minus = true;
      } else if ('0' <= b && b <= '9') {
        n = b - '0';
      } else {
        throw new NumberFormatException();
      }
    }
    
    while(true){
      int b = readByte();
      if ('0' <= b && b <= '9') {
        n *= 10;
        n += b - '0';
      } else if (b == -1 || !isPrintableChar(b)) {
        return minus ? -n : n;
      } else {
        throw new NumberFormatException();
      }
    }
  }
  
  public long nextLong() {
    if (!hasNext()) {
      throw new NoSuchElementException();
    }
    
    long n = 0;
    boolean minus = false;
    
    {
      int b = readByte();
      if (b == '-') {
        minus = true;
      } else if ('0' <= b && b <= '9') {
        n = b - '0';
      } else {
        throw new NumberFormatException();
      }
    }
    
    while(true){
      int b = readByte();
      if ('0' <= b && b <= '9') {
        n *= 10;
        n += b - '0';
      } else if (b == -1 || !isPrintableChar(b)) {
        return minus ? -n : n;
      } else {
        throw new NumberFormatException();
      }
    }
  }
  
  public double nextDouble() {
    return Double.parseDouble(next());
  }
  
  public String[] next(int n) {
    String[] array = new String[n];
    for (int i = 0; i < n; i++) {
      array[i] = next();
    }
    return array;
  }
  
  public String[] nextLine(int n) {
    String[] array = new String[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextLine();
    }
    return array;
  }
  
  public char[] nextChar(int n) {
    char[] array = new char[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextChar();
    }
    return array;
  }
  
  public int[] nextInt(int n) {
    int[] array = new int[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextInt();
    }
    return array;
  }
  
  public long[] nextLong(int n) {
    long[] array = new long[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextLong();
    }
    return array;
  }
  
  public double[] nextDouble(int n) {
    double[] array = new double[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextDouble();
    }
    return array;
  }
  
  public char[] nextCharArray() {
    return next().toCharArray();
  }
  
  public String[][] next(int n, int m) {
    String[][] matrix = new String[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = next();
      }
    }
    return matrix;
  }
  
  public int[][] nextInt(int n, int m) {
    int[][] matrix = new int[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextInt();
      }
    }
    return matrix;
  }
  
  public char[][] nextChar(int n, int m) {
    char[][] matrix = new char[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextChar();
      }
    }
    return matrix;
  }
  
  public long[][] nextLong(int n, int m) {
    long[][] matrix = new long[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextLong();
      }
    }
    return matrix;
  }
  
  public double[][] nextDouble(int n, int m) {
    double[][] matrix = new double[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextDouble();
      }
    }
    return matrix;
  }
  
  public char[][] nextCharArray(int n) {
    char[][] matrix = new char[n][];
    for (int i = 0; i < n; i++) {
      matrix[i] = next().toCharArray();
    }
    return matrix;
  }
}

class MyAssert {
  public static void myAssert(boolean flag, String message) {
    if (!flag) {
      throw new RuntimeException(message);
    }
  }
 
  public static void myAssert(boolean flag) {
    myAssert(flag, "");
  }
}

</source>
<source file="../hum_codes_raw/s769774624.java" startline="1" endline="487" pcid="25845">
import java.io.*;
import java.util.*;

public class Main {
  private static final int INF = 10_000_000;

  private static final UpdateRangeGetRangeSegmentTree.Operator<Integer, Integer> OPERATOR = new UpdateRangeGetRangeSegmentTree.Operator<>() {
    @Override
    public Integer multiplyLazyValue(Integer lazy, int count) {
      return lazy;
    }

    @Override
    public Integer applyOffset(Integer lazy, int offset) {
      return lazy + offset;
    }

    @Override
    public Integer mergeLazyValue(Integer oldLazy, Integer newLazy) {
      return newLazy;
    }

    @Override
    public Integer apply(Integer value, Integer lazy) {
      return lazy;
    }

    @Override
    public Integer mergeValue(Integer smallIndexValue, Integer largeIndexValue) {
      return Math.min(smallIndexValue, largeIndexValue);
    }

    @Override
    public Integer getUnitValue() {
      return INF;
    }
  };

  private static List<Integer> solve(int h, int w, int[][] abs) {
    Integer[] initialValues = new Integer[w + 1];
    Arrays.fill(initialValues, Integer.valueOf(0));
    initialValues[0] = INF;

    UpdateRangeGetRangeSegmentTree<Integer, Integer> segmentTree = new UpdateRangeGetRangeSegmentTree<>(OPERATOR, initialValues);
    List<Integer> answers = new ArrayList<>();
    for (int i = 0; i < h; i++) {
      int a = abs[i][0];
      int b = abs[i][1];
      int answer = segmentTree.getRange(0, a);
      if (b + 1 < w + 1) {
        answer = Math.min(answer, segmentTree.getRange(b + 1, w + 1));
      }
      if (answer < INF) {
        answers.add(answer + i + 1);
      } else {
        answers.add(-1);
      }
      int v = segmentTree.get(a - 1) - a + 1;
      segmentTree.update(a, b + 1, v);
    }
    return answers;
  }

  private static void execute(ContestReader reader, ContestWriter out) {
    int h = reader.nextInt();
    int w = reader.nextInt();
    int[][] abs = reader.nextInt(h, 2);
    out.printList(solve(h, w, abs));
  }
  
  public static void main(String[] args) {
    ContestReader reader = new ContestReader(System.in);
    ContestWriter out = new ContestWriter(System.out);
    execute(reader, out);
    out.flush();
  }
}

class UpdateRangeGetRangeSegmentTree<T, S> {
  public interface Operator<T, S> {
    T multiplyLazyValue(T lazy, int count);
    T applyOffset(T lazy, int offset);
    T mergeLazyValue(T oldLazy, T newLazy);
    S apply(S value, T lazy);
    S mergeValue(S smallIndexValue, S largeIndexValue);
    S getUnitValue();
  }
  
  private final Operator<T, S> operator;
  private final int n;
  private final List<T> lazies;
  private final List<S> values;
  
  public UpdateRangeGetRangeSegmentTree(Operator<T, S> operator, S[] initialValues) {
    this.operator = operator;
    
    int tempN = 1;
    while (tempN < initialValues.length) {
      tempN *= 2;
    }
    n = tempN;
    lazies = new ArrayList<>();
    values = new ArrayList<>();
    for (int i = 0; i < 2 * n - 1; i++) {
      lazies.add(null);
      values.add(null);
    }
    for (int i = 0; i < initialValues.length; i++) {
      values.set(i + n - 1, initialValues[i]);
    }
    for (int i = initialValues.length; i < n; i++) {
      values.set(i + n - 1, this.operator.getUnitValue());
    }
    for (int i = n - 2; i >= 0; i--) {
      values.set(i, this.operator.mergeValue(values.get(2 * i + 1), values.get(2 * i + 2)));
    }
  }
  
  private void eval(int k, int l, int r) {
    if (lazies.get(k) == null) {
      return;
    }
    values.set(k, operator.apply(values.get(k), operator.multiplyLazyValue(lazies.get(k), r - l)));
    if (r - l > 1) {
      lazies.set(2 * k + 1, operator.mergeLazyValue(lazies.get(2 * k + 1), lazies.get(k)));
      lazies.set(2 * k + 2, operator.mergeLazyValue(lazies.get(2 * k + 2), operator.applyOffset(lazies.get(k), (r - l) / 2)));
    }
    lazies.set(k, null);
  }
  
  private void update(int a, int b, T lazy, int k, int l, int r) {
    eval(k, l, r);
    if (b <= l || r <= a) {
      return;
    }
    if (a <= l && r <= b) {
      lazies.set(k, operator.mergeLazyValue(lazies.get(k), lazy));
      eval(k, l, r);
    } else {
      update(a, b, lazy, 2 * k + 1, l, (l + r) / 2);
      update(a, b, operator.applyOffset(lazy, (r - l) / 2), 2 * k + 2, (l + r) / 2, r);
      values.set(k, operator.mergeValue(values.get(2 * k + 1), values.get(2 * k + 2)));
    }
  }
  
  public void update(int a, int b, T lazy) {
    update(a, b, lazy, 0, 0, n);
  }
  
  public void update(int a, T lazy) {
    update(a, a + 1, lazy);
  }
  
  private S getRange(int a, int b, int k, int l, int r) {
    if (b <= l || r <= a) {
      return operator.getUnitValue();
    }
    eval(k, l, r);
    if (a <= l && r <= b) {
      return values.get(k);
    }
    S vl = getRange(a, b, 2 * k + 1, l, (l + r) / 2);
    S vr = getRange(a, b, 2 * k + 2, (l + r) / 2, r);
    return operator.mergeValue(vl, vr);
  }
  
  public S getRange(int a, int b) {
    return getRange(a, b, 0, 0, n);
  }
  
  public S get(int a) {
    return getRange(a, a + 1);
  }

  private void dump(List list) {
    int sum = 0;
    for (int i = 0; sum + (1 << i) <= 2 * n - 1; sum += 1 << i, i++) {
      for (int j = sum; j < sum + (1 << i); j++) {
        System.err.print(list.get(j));
        System.err.print(" ");
      }
      System.err.println();
    }
    System.err.println();
  }
  
  public void dump() {
    System.err.println("values: ");
    dump(values);
    System.err.println("lazies: ");
    dump(lazies);
  }
}

class ContestWriter extends PrintWriter {
  ContestWriter(PrintStream printStream) {
    super(printStream);
  }

  public void printList(List<? extends Object> list) {
    for (Object object : list) {
      println(object);
    }
  }

  public void printListOneLine(List<? extends Object> list) {
    List<String> stringList = new ArrayList<>();
    for (Object object : list) {
      stringList.add(object.toString());
    }
    println(String.join(" ", stringList));
  }
}

class ContestReader {
  private static final int BUFFER_SIZE = 1024;
  
  private final InputStream stream;
  private final byte[] buffer;
  private int pointer;
  private int bufferLength;
  
  ContestReader(InputStream stream) {
    this.stream = stream;
    this.buffer = new byte[BUFFER_SIZE];
    this.pointer = 0;
    this.bufferLength = 0;
  }
  
  private boolean hasNextByte() {
    if (pointer < bufferLength) {
      return true;
    }
    
    pointer = 0;
    try {
      bufferLength = stream.read(buffer);
    } catch (IOException e) {
      throw new RuntimeException(e);
    }
    return bufferLength > 0;
  }
  
  private int readByte() {
    if (hasNextByte()) {
      return buffer[pointer++];
    } else {
      return -1;
    }
  }
  
  private static boolean isPrintableChar(int c) {
    return 33 <= c && c <= 126;
  }
  
  public boolean hasNext() {
    while (hasNextByte() && !isPrintableChar(buffer[pointer])) {
      pointer++;
    }
    return hasNextByte();
  }
  
  public String next() {
    if (!hasNext()) {
      throw new NoSuchElementException();
    }
    StringBuilder sb = new StringBuilder();
    while(true) {
      int b = readByte();
      if (!isPrintableChar(b)) {
        break;
      }
      sb.appendCodePoint(b);
    }
    return sb.toString();
  }
  
  public String nextLine() {
    if (!hasNext()) {
      throw new NoSuchElementException();
    }
    StringBuilder sb = new StringBuilder();
    while(true) {
      int b = readByte();
      if (!isPrintableChar(b) && b != 0x20) {
        break;
      }
      sb.appendCodePoint(b);
    }
    return sb.toString();
  }
  
  public char nextChar() {
    return next().charAt(0);
  }
  
  public int nextInt() {
    if (!hasNext()) {
      throw new NoSuchElementException();
    }
    
    int n = 0;
    boolean minus = false;
    
    {
      int b = readByte();
      if (b == '-') {
        minus = true;
      } else if ('0' <= b && b <= '9') {
        n = b - '0';
      } else {
        throw new NumberFormatException();
      }
    }
    
    while(true){
      int b = readByte();
      if ('0' <= b && b <= '9') {
        n *= 10;
        n += b - '0';
      } else if (b == -1 || !isPrintableChar(b)) {
        return minus ? -n : n;
      } else {
        throw new NumberFormatException();
      }
    }
  }
  
  public long nextLong() {
    if (!hasNext()) {
      throw new NoSuchElementException();
    }
    
    long n = 0;
    boolean minus = false;
    
    {
      int b = readByte();
      if (b == '-') {
        minus = true;
      } else if ('0' <= b && b <= '9') {
        n = b - '0';
      } else {
        throw new NumberFormatException();
      }
    }
    
    while(true){
      int b = readByte();
      if ('0' <= b && b <= '9') {
        n *= 10;
        n += b - '0';
      } else if (b == -1 || !isPrintableChar(b)) {
        return minus ? -n : n;
      } else {
        throw new NumberFormatException();
      }
    }
  }
  
  public double nextDouble() {
    return Double.parseDouble(next());
  }
  
  public String[] next(int n) {
    String[] array = new String[n];
    for (int i = 0; i < n; i++) {
      array[i] = next();
    }
    return array;
  }
  
  public String[] nextLine(int n) {
    String[] array = new String[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextLine();
    }
    return array;
  }
  
  public char[] nextChar(int n) {
    char[] array = new char[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextChar();
    }
    return array;
  }
  
  public int[] nextInt(int n) {
    int[] array = new int[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextInt();
    }
    return array;
  }
  
  public long[] nextLong(int n) {
    long[] array = new long[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextLong();
    }
    return array;
  }
  
  public double[] nextDouble(int n) {
    double[] array = new double[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextDouble();
    }
    return array;
  }
  
  public char[] nextCharArray() {
    return next().toCharArray();
  }
  
  public String[][] next(int n, int m) {
    String[][] matrix = new String[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = next();
      }
    }
    return matrix;
  }
  
  public int[][] nextInt(int n, int m) {
    int[][] matrix = new int[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextInt();
      }
    }
    return matrix;
  }
  
  public char[][] nextChar(int n, int m) {
    char[][] matrix = new char[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextChar();
      }
    }
    return matrix;
  }
  
  public long[][] nextLong(int n, int m) {
    long[][] matrix = new long[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextLong();
      }
    }
    return matrix;
  }
  
  public double[][] nextDouble(int n, int m) {
    double[][] matrix = new double[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextDouble();
      }
    }
    return matrix;
  }
  
  public char[][] nextCharArray(int n) {
    char[][] matrix = new char[n][];
    for (int i = 0; i < n; i++) {
      matrix[i] = next().toCharArray();
    }
    return matrix;
  }
}

class MyAssert {
  public static void myAssert(boolean flag, String message) {
    if (!flag) {
      throw new RuntimeException(message);
    }
  }
 
  public static void myAssert(boolean flag) {
    myAssert(flag, "");
  }
}

</source>
</class>

<class classid="53" nclones="2" nlines="20" similarity="100">
<source file="../hum_codes_raw/s065444897.java" startline="1" endline="27" pcid="2195">
import java.util.Arrays;
import java.util.Scanner;
import java.util.stream.IntStream;

/**
 * 解説どおりに作成したソースコード
 */
public class Main {

	public static void main(String[] args) {
		try (Scanner scanner = new Scanner(System.in)) {
			int n = scanner.nextInt(), m = scanner.nextInt(), q = scanner.nextInt();
			int[][] x = new int[n + 1][n + 1], c = new int[n + 1][n + 1];
			IntStream.range(0, n + 1).forEach(i -> Arrays.fill(x[i], 0));
			IntStream.range(0, m).forEach(i -> x[scanner.nextInt()][scanner.nextInt()]++);
			Arrays.fill(c[0], 0);
			IntStream.rangeClosed(1, n).forEach(i -> c[i][0] = 0);
			IntStream.rangeClosed(1, n)
					.forEach(i -> IntStream.rangeClosed(1, n).forEach(j -> c[i][j] = c[i][j - 1] + x[i][j]));
			IntStream.range(0, q).forEach(i -> {
				int l = scanner.nextInt(), r = scanner.nextInt();
				System.out.println(IntStream.rangeClosed(l, r).map(j -> c[j][r] - c[j][l - 1]).sum());
			});
		}
	}
}

</source>
<source file="../hum_codes_raw/s411025858.java" startline="1" endline="27" pcid="13819">
import java.util.Arrays;
import java.util.Scanner;
import java.util.stream.IntStream;

/**
 * 解説通りに作成したソースコード
 */
public class Main {

	public static void main(String[] args) {
		try (Scanner scanner = new Scanner(System.in)) {
			int n = scanner.nextInt(), m = scanner.nextInt(), q = scanner.nextInt();
			int[][] x = new int[n + 1][n + 1], c = new int[n + 1][n + 1];
			IntStream.range(0, n + 1).forEach(i -> Arrays.fill(x[i], 0));
			IntStream.range(0, m).forEach(i -> x[scanner.nextInt()][scanner.nextInt()]++);
			Arrays.fill(c[0], 0);
			IntStream.rangeClosed(1, n).forEach(i -> c[i][0] = 0);
			IntStream.rangeClosed(1, n)
					.forEach(i -> IntStream.rangeClosed(1, n).forEach(j -> c[i][j] = c[i][j - 1] + x[i][j]));
			IntStream.range(0, q).forEach(i -> {
				int l = scanner.nextInt(), r = scanner.nextInt();
				System.out.println(IntStream.rangeClosed(l, r).map(j -> c[j][r] - c[j][l - 1]).sum());
			});
		}
	}
}

</source>
</class>

<class classid="54" nclones="2" nlines="34" similarity="100">
<source file="../hum_codes_raw/s075686162.java" startline="1" endline="47" pcid="2530">
import java.util.Scanner;

public class Main
{
	public static void main(String[] args)
	{
		Scanner sc = new Scanner(System.in);
		for(;;)
		{
			int N = sc.nextInt(), P = sc.nextInt();
			if (N==0 && P==0) break;
			
			int[] s = new int[N];
			for (int n = 0; ; n = (n + 1) % N)
			{
				if (P != 0)
				{
					P--;
					s[n]++;
					if (P == 0)
					{
						boolean win = true;
						for (int i = 0; i < N; i++)
						{
							if (i != n && s[i] != 0)
							{
								win = false;
								break;
							}
						}
						if (win)
						{
							System.out.println(n);
							break;
						}
					}
				}
				else
				{
					P = s[n];
					s[n] = 0;
				}
			}
		}
	}
}

</source>
<source file="../hum_codes_raw/s762139857.java" startline="1" endline="47" pcid="25599">
import java.util.Scanner;
 
public class Main
{
    public static void main(String[] args)
    {
        Scanner sc = new Scanner(System.in);
        for(;;)
        {
            int N = sc.nextInt(), P = sc.nextInt();
            if (N==0 && P==0) break;
             
            int[] s = new int[N];
            for (int n = 0; ; n = (n + 1) % N)
            {
                if (P != 0)
                {
                    P--;
                    s[n]++;
                    if (P == 0)
                    {
                        boolean win = true;
                        for (int i = 0; i < N; i++)
                        {
                            if (i != n && s[i] != 0)
                            {
                                win = false;
                                break;
                            }
                        }
                        if (win)
                        {
                            System.out.println(n);
                            break;
                        }
                    }
                }
                else
                {
                    P = s[n];
                    s[n] = 0;
                }
            }
        }
    }
}

</source>
</class>

<class classid="55" nclones="2" nlines="18" similarity="100">
<source file="../hum_codes_raw/s079945584.java" startline="1" endline="18" pcid="2676">
import java.util.Scanner;
public class Main {
	public static void main(String[] args) throws java.io.IOException {
		Scanner scan = new Scanner(System.in);
		int i1 =scan.nextInt();
		int i5 =scan.nextInt();
		int i10 =scan.nextInt();
		int i50 =scan.nextInt();
		int i100 =scan.nextInt();
		int i500 =scan.nextInt();
		if(i1 + i5*5 + i10*10 + i50*50 + i100*100 + i500*500 >=1000){
			System.out.println(1);
		}else{
			System.out.println(0);
		}
	}
}

</source>
<source file="../hum_codes_raw/s955858894.java" startline="1" endline="18" pcid="32128">
import java.util.Scanner;
public class Main {
	public static void main(String[] args) throws java.io.IOException {
		Scanner scan = new Scanner(System.in);
		int i1 =scan.nextInt();
		int i5 =scan.nextInt();
		int i10 =scan.nextInt();
		int i50 =scan.nextInt();
		int i100 =scan.nextInt();
		int i500 =scan.nextInt();
		if(i1 + i5*5 + i10*10 + i50*50 + i100*100 + i500*500 >=1000){
			System.out.println(1);
		}else{
			System.out.println(0);
		}
	}
}

</source>
</class>

<class classid="56" nclones="2" nlines="1077" similarity="100">
<source file="../hum_codes_raw/s081663604.java" startline="1" endline="1232" pcid="2728">






import java.awt.Point;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.Locale;
import java.util.NoSuchElementException;
import java.util.Random;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.function.IntPredicate;

public class Main implements Runnable{

	private static final int LIMIT = 1800; // ループで回せる時間
	private static final int ESTIMATE_LOOP = 8192; // 1msで回ると予想する回数

	private static class Marathon implements MarathonInterface {
		private FastIO io;
		private FastRandom rnd;
		private long loop;
		private long score;

		private final int N;
		private final int[] A;
		private final int[] B;
		private final int[] swapB;
		private int[] ans;
		private Stop stop;
		private WantArray want;

		public Marathon(FastIO io) {
			this.io = io;
			rnd = new FastRandom();

			N = io.nextInt();
			A = io.nextInt(N);
			B = io.nextInt(N);
			swapB = new int[N];
		}
		/*
		 * author: 31536000
		 *
		 * 考察メモ
		 * ABC178Fを焼きなます！
		 */


		@Override
		public void init(Stop stop) {
			loop = 0;
			for (int i = 0;i < log.length;++ i) log[i] = Math.log(rnd.nextDouble());
			this.stop = stop;
			// ここから初期化
			greedy();
		}

		// 初期構築はここで
		public void greedy() {
			for (int i = 0;i < N;++ i) swapB[i] = B[(i + N / 2) % N];
			for (int i = 0;i < N;++ i) if (A[i] != swapB[i]) ++ score;
			if (score == N) {
				ans = Arrays.copyOf(swapB, N);
				stop.stop();
				return;
			}
			if (N == 1) stop.stop(); // 後で例外吐くのでどうにかする
			want = new WantArray(N, i -> A[i] == swapB[i]);
			int[] count = new int[200001];
			for (int j : A) ++ count[j];
			for (int j : B) ++ count[j];
			for (int j : count) if (j > N) stop.stop(); // 不可能
		}

		@Override
		public void delayUpdate(int delay) {
			temperature = temperature(delay);
			loop += ESTIMATE_LOOP;
			// ここから処理、デバッグ出力なんかもここの方が良さげ
		}

		private void swap(int i, int j) {
			int swap = swapB[i];
			swapB[i] = swapB[j];
			swapB[j] = swap;
		}

		private static final double START_TEMP = 0.1; // TODO 焼きなまし関数
		private static final double END_TEMP = 0.00001;
		private static final double DIFF = START_TEMP - END_TEMP;
		private static final double INV_LIMIT = 1.0 / LIMIT;
		private double temperature = START_TEMP;
		private static final int LOG_SIZE = 1 << 12;
		private static final int LOG_MASK = LOG_SIZE - 1;
		final double[] log = new double[LOG_SIZE];

		private static double temperature(int delay) {
			return DIFF * delay * INV_LIMIT + END_TEMP;
		}


		private boolean isChange(int change) {
//			return change >= 0; // 山登り法
			return change >= temperature * log[rnd.nextInt() & LOG_MASK]; // 焼きなまし法
		}

		@Override
		public void update() {
			int x = rnd.nextInt(want.want());
			int y = rnd.nextInt(N - 1);
			if (y >= x) ++ y;
			int x2 = want.get(x), y2 = want.get(y);
			int diff = 0;
			if (A[x2] != swapB[x2]) -- diff;
			if (A[x2] != swapB[y2]) ++ diff;
			if (A[y2] != swapB[y2]) -- diff;
			if (A[y2] != swapB[x2]) ++ diff;
			if (isChange(diff)) {
				swap(x2,y2);
				want.set(x, y, i -> A[i] == swapB[i]);
				score += diff;
				if (score == N && ans == null) {
					ans = Arrays.copyOf(swapB, N);
					stop.stop();
				}
			}
		}

		@Override
		public void terminate() {
			if (ans != null) {
				io.println("Yes");
				io.println(ans);
			} else {
				io.println("No");
			}
			// ここまで処理
			io.debugln(loop + "," + score);
			io.flush();
		}

		public long getLoop() {
			return loop;
		}

		public long getScore() {
			return score;
		}

	}

	public static class WantArray {
		private final int[] index;
		private int k = 0;
		public WantArray(int n, IntPredicate want) {
			index = new int[n];
			for (int i = 0;i < n;++ i) index[i] = i;
			set(want);
		}

		private void swap(int i, int j) {
			int swap = index[i];
			index[i] = index[j];
			index[j] = swap;
		}

		public int get(int i) {
			return index[i];
		}

		public void set(IntPredicate want) {
			k = 0;
			for (int i = index.length - 1;i >= k;) {
				if (want.test(index[i])) {
					swap(i, k);
					++ k;
				} else {
					-- i;
				}
			}
		}

		public void set(int i, boolean want) {
			if (i < k) {
				if (want) return;
				swap(i, k - 1);
				-- k;
			} else {
				if (want) {
					swap(i, k);
					++ k;
				} else return;
			}
		}

		public void set(int i, int j, IntPredicate want) {
			if (i < k) {
				if (!want.test(index[i])) {
					swap(i, k - 1);
					if (j == k - 1) j = i;
					-- k;
				}
			} else {
				if (want.test(index[i])) {
					swap(i, k);
					if (j == k) j = i;
					++ k;
				}
			}
			set(j, want.test(index[j]));
		}

		public int want() {
			return k;
		}
	}

	/** デバッグ用コードのお供に */
	private static boolean DEBUG = false;
	/** 確保するメモリの大きさ(単位: MB)*/
	private static final long MEMORY = 256;
	private final FastIO io;

	public static void main(String[] args) {
	        Thread.setDefaultUncaughtExceptionHandler((t, e) -> e.printStackTrace());
	        new Thread(null, new Main(), "", MEMORY * 1048576).start();
	}

	public Main() {
		this(new FastIO());
	}

	public Main(FastIO io) {
		this.io = io;
		if (DEBUG) {
			io.setAutoFlush(true);
			io.debugln("debug mode");
		}
	}

	@Override
	public void run() {
		solve(io);
		io.flush();
	}
	Marathon marathon;

	private void solve(FastIO io) {
		io.setAutoFlush(true);
		marathon = new Marathon(io);
		MarathonTimer timer = new MarathonTimer(marathon);
		timer.start(LIMIT);

	}

	public long getLoop() {
		return marathon.getLoop();
	}

	public long getScore() {
		return marathon.getScore();
	}

	// 以下、ライブラリ

	public static final class FastRandom extends Random{
		private static final long serialVersionUID = -302298413684195190L;
		private long rand;
		private static final float FLOAT_INV = 1f / (1 << 24);
		private static final double DOUBLE_INV = 1. / (1L << 53);
		public FastRandom() {
			this(new Random().nextLong());
		}
		public FastRandom(long seed) {
			rand = seed;
		}
		@Override
		public void setSeed(long seed) {
			this.rand = seed;
		}
		@Override
		protected int next(int bits) {
			return (int)nextLong() & (1 << bits) - 1;
		}
		@Override
		public int nextInt() {
			rand = rand ^ (rand << 7);
			rand = rand ^ (rand >>> 9);
			return (int)(rand & Integer.MAX_VALUE);
		}
		@Override
		public int nextInt(int bounds) {
			return nextInt() % bounds;
		}
		public int nextRange(int startInclusive, int endExclusive) {
			return nextInt(endExclusive - startInclusive) + startInclusive;
		}
		@Override
		public long nextLong() {
			rand = rand ^ (rand << 7);
			rand = rand ^ (rand >>> 9);
			return rand & Long.MAX_VALUE;
		}
		@Override
		public boolean nextBoolean() {
			rand = rand ^ (rand << 7);
			rand = rand ^ (rand >>> 9);
			return (rand & 1) != 0;
		}
		@Override
		public float nextFloat() {
			rand = rand ^ (rand << 7);
			rand = rand ^ (rand >>> 9);
			return ((int)(rand & 0x00FFFFFF)) * FLOAT_INV;
		}
		@Override
		public double nextDouble() {
			rand = rand ^ (rand << 7);
			rand = rand ^ (rand >>> 9);
			return (rand & 0x001FFFFFFFFFFFFFL) * DOUBLE_INV;
		}
	}

	private static interface MarathonInterface {
		/**
		 * 標準入力を受け取り、処理しやすいように加工する関数です。
		 */
		public void init(Stop stop);
		/**
		 * 残り時間に応じた処理や、少し重い前処理などを行う関数です・
		 * @param delay 残り時間
		 */
		public void delayUpdate(int delay);
		/**
		 * 近傍を探したりなど、毎回更新の処理を行う関数です。
		 */
		public void update();
		/**
		 * 求まった結果を出力する関数です。
		 */
		public void terminate();
	}

	private static interface Stop {
		public void stop();
	}

	private static class MarathonTimer implements Runnable {

		private MarathonInterface marathon;
		private volatile boolean loopFlag;
		private ScheduledExecutorService  threadPool;
		private ScheduledFuture<?> future;

		public MarathonTimer(Marathon marathon) {
			this.marathon = marathon;
			threadPool = Executors.newScheduledThreadPool(2);
		}

		public void start(int millis) {
			loopFlag = true;
			marathon.init(() -> {
				if (marathon != null) marathon.terminate();
				marathon = null;
			});
			if (marathon == null) {
				return;
			}
			future = threadPool.schedule(() -> loopFlag = false, millis, TimeUnit.MILLISECONDS);
			threadPool.execute(this);
			try {
				threadPool.awaitTermination(7, TimeUnit.DAYS);
			} catch (InterruptedException e) {
				// TODO 自動生成された catch ブロック
				e.printStackTrace();
			}
		}

		@Override
		public void run() {
			try {
				while(loopFlag) {
					int delay = (int)future.getDelay(TimeUnit.MILLISECONDS);
					if (delay <= 0) {
						loopFlag = false;
						break;
					}
					marathon.delayUpdate(delay);
					for (int i = 0;i < ESTIMATE_LOOP;++ i) marathon.update();
				}
				marathon.terminate();
			} catch (NullPointerException e) {
				// これは想定なので問題なし
			} catch (Throwable e) {
				e.printStackTrace();
			}
			future.cancel(true);
			threadPool.shutdown();
		}
	}

	/**
	 * 高速な入出力を提供します。
	 * @author 31536000
	 *
	 */
	public static class FastIO {
		private InputStream in;
		private final byte[] buffer = new byte[1024];
		private int read = 0;
		private int length = 0;
		private PrintWriter out;
		private PrintWriter err;
		private boolean autoFlush = false;

		public FastIO() {
			this(System.in, System.out, System.err);
		}

		public FastIO(InputStream in, PrintStream out, PrintStream err) {
			this.in = in;
			this.out = new PrintWriter(out, false);
			this.err = new PrintWriter(err, false);
		}

		public final void setInputStream(InputStream in) {
			this.in = in;
		}

		public final void setInputStream(File in) {
			try {
				this.in = new FileInputStream(in);
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
		}

		public final void setOutputStream(PrintStream out) {
			this.out = new PrintWriter(out, false);
		}

		public final void setOutputStream(File out) {
			try {
				this.out = new PrintWriter(new FileOutputStream(out), false);
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
		}

		public final void setErrorStream(PrintStream err) {
			this.err = new PrintWriter(err, false);
		}

		public final void setErrorStream(File err) {
			try {
				this.err = new PrintWriter(new FileOutputStream(err), false);
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
		}

		public final void setAutoFlush(boolean flush) {
			autoFlush = flush;
		}

		private boolean hasNextByte() {
			if (read < length) return true;
			read = 0;
			try {
				length = in.read(buffer);
			} catch (IOException e) {
				e.printStackTrace();
			}
			return length > 0;
		}

		private int readByte() {
			return hasNextByte() ? buffer[read++] : -1;
		}

		private static boolean isPrintableChar(int c) {
			return 33 <= c && c <= 126;
		}

		private static boolean isNumber(int c) {
			return '0' <= c && c <= '9';
		}

		public final boolean hasNext() {
			while (hasNextByte() && !isPrintableChar(buffer[read])) read++;
			return hasNextByte();
		}

		public final char nextChar() {
			if (!hasNextByte())  throw new NoSuchElementException();
			return (char)readByte();
		}

		public final char[][] nextChar(int height) {
			char[][] ret = new char[height][];
			for (int i = 0;i < ret.length;++ i) ret[i] = next().toCharArray();
			return ret;
		}

		public final String next() {
			if (!hasNext()) throw new NoSuchElementException();
			StringBuilder sb = new StringBuilder();
			int b;
			while (isPrintableChar(b = readByte())) sb.appendCodePoint(b);
			return sb.toString();
		}

		public final String nextLine() {
			StringBuilder sb = new StringBuilder();
			int b;
			while(!isPrintableChar(b = readByte()));
			do sb.appendCodePoint(b); while(isPrintableChar(b = readByte()) || b == ' ');
			return sb.toString();
		}

		public final long nextLong() {
			if (!hasNext()) throw new NoSuchElementException();
			long n = 0;
			boolean minus = false;
			int b = readByte();
			if (b == '-') {
				minus = true;
				b = readByte();
			}
			if (!isNumber(b)) throw new NumberFormatException();
			while (true) {
				if (isNumber(b)) {
					n *= 10;
					n += b - '0';
				} else if (b == -1 || !isPrintableChar(b)) return minus ? -n : n;
				else throw new NumberFormatException();
				b = readByte();
			}
		}

		public final int nextInt() {
			long nl = nextLong();
			if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
			return (int) nl;
		}

		public final double nextDouble() {
			return Double.parseDouble(next());
		}

		public final int[] nextInt(int width) {
			int[] ret = new int[width];
			for (int i = 0;i < width;++ i) ret[i] = nextInt();
			return ret;
		}

		public final int[] nextInts() {
			return nextInts(" ");
		}

		public final int[] nextInts(String parse) {
			String[] get = nextLine().split(parse);
			int[] ret = new int[get.length];
			for (int i = 0;i < ret.length;++ i) ret[i] = Integer.valueOf(get[i]);
			return ret;
		}

		public final long[] nextLong(int width) {
			long[] ret = new long[width];
			for (int i = 0;i < width;++ i) ret[i] = nextLong();
			return ret;
		}

		public final long[] nextLongs() {
			return nextLongs(" ");
		}

		public final long[] nextLongs(String parse) {
			String[] get = nextLine().split(parse);
			long[] ret = new long[get.length];
			for (int i = 0;i < ret.length;++ i) ret[i] = Long.valueOf(get[i]);
			return ret;
		}

		public final int[][] nextInt(int width, int height) {
			int[][] ret = new int[height][width];
			for (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[i][j] = nextInt();
			return ret;
		}

		public final long[][] nextLong(int width, int height) {
			long[][] ret = new long[height][width];
			for (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[j][i] = nextLong();
			return ret;
		}

		public final boolean[] nextBoolean(char T) {
			char[] s = next().toCharArray();
			boolean[] ret = new boolean[s.length];
			for (int i = 0;i < ret.length;++ i) ret[i] = s[i] == T;
			return ret;
		}

		public final boolean[][] nextBoolean(char T, int height) {
			boolean[][] ret = new boolean[height][];
			for (int i = 0;i < ret.length;++ i) {
				char[] s = next().toCharArray();
				ret[i] = new boolean[s.length];
				for (int j = 0;j < ret[i].length;++ j) ret[i][j] = s[j] == T;
			}
			return ret;
		}

		public final Point nextPoint() {
			return new Point(nextInt(), nextInt());
		}

		public final Point[] nextPoint(int width) {
			Point[] ret = new Point[width];
			for (int i = 0;i < width;++ i) ret[i] = nextPoint();
			return ret;
		}

		@Override
		protected void finalize() throws Throwable {
			try {
				super.finalize();
			} finally {
				in.close();
				out.close();
				err.close();
			}
		}

		public final boolean print(boolean b) {
			out.print(b);
			if (autoFlush) flush();
			return b;
		}

		public final Object print(boolean b, Object t, Object f) {
			return b ? print(t) : print(f);
		}

		public final char print(char c) {
			out.print(c);
			if (autoFlush) flush();
			return c;
		}

		public final char[] print(char[] s) {
			out.print(s);
			return s;
		}

		public final double print(double d) {
			out.print(d);
			if (autoFlush) flush();
			return d;
		}

		public final double print(double d, int length) {
			if (d < 0) {
				out.print('-');
				d = -d;
			}
			d += Math.pow(10, -length) / 2;
			out.print((long)d);
			out.print('.');
			d -= (long)d;
			for (int i = 0;i < length;++ i) {
				d *= 10;
				out.print((int)d);
				d -= (int)d;
			}
			if (autoFlush) flush();
			return d;
		}

		public final float print(float f) {
			out.print(f);
			if (autoFlush) flush();
			return f;
		}

		public final int print(int i) {
			out.print(i);
			if (autoFlush) flush();
			return i;
		}

		public final long print(long l) {
			out.print(l);
			if (autoFlush) flush();
			return l;
		}

		public final Object print(Object obj) {
			if (obj.getClass().isArray()) {
				if (obj instanceof boolean[][]) print(obj, "\n", " ");
				else if (obj instanceof byte[][]) print(obj, "\n", " ");
				else if (obj instanceof short[][]) print(obj, "\n", " ");
				else if (obj instanceof int[][]) print(obj, "\n", " ");
				else if (obj instanceof long[][]) print(obj, "\n", " ");
				else if (obj instanceof float[][]) print(obj, "\n", " ");
				else if (obj instanceof double[][]) print(obj, "\n", " ");
				else if (obj instanceof char[][]) print(obj, "\n", " ");
				else if (obj instanceof Object[][]) print(obj, "\n", " ");
				else print(obj, " ");
			} else {
				out.print(obj);
				if (autoFlush) flush();
			}
			return obj;
		}

		public final String print(String s) {
			out.print(s);
			if (autoFlush) flush();
			return s;
		}

		public final Object print(Object array, String... parse) {
			print(array, 0, parse);
			if (autoFlush) flush();
			return array;
		}

		private final Object print(Object array, int check, String... parse) {
			if (check >= parse.length) {
				if (array.getClass().isArray()) throw new IllegalArgumentException("not equal dimension");
				print(array);
				return array;
			}
			String str = parse[check];
			if (array instanceof Object[]) {
				Object[] obj = (Object[]) array;
				if (obj.length == 0) return array;
				print(obj[0], check + 1, parse);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i], check + 1, parse);
				}
				return array;
			}
			if (array instanceof Collection) {
				Iterator<?> iter = ((Collection<?>)array).iterator();
				if (!iter.hasNext()) return array;
				print(iter.next(), check + 1, parse);
				while(iter.hasNext()) {
					print(str);
					print(iter.next(), check + 1, parse);
				}
				return array;
			}
			if (!array.getClass().isArray()) throw new IllegalArgumentException("not equal dimension");
			if (check != parse.length - 1) throw new IllegalArgumentException("not equal dimension");
			if (array instanceof boolean[]) {
				boolean[] obj = (boolean[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
			} else if (array instanceof byte[]) {
				byte[] obj = (byte[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
				return array;
			} else if (array instanceof short[]) {
				short[] obj = (short[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
			} else if (array instanceof int[]) {
				int[] obj = (int[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
			} else if (array instanceof long[]) {
				long[] obj = (long[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
			} else if (array instanceof float[]) {
				float[] obj = (float[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
			} else if (array instanceof double[]) {
				double[] obj = (double[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
			} else if (array instanceof char[]) {
				char[] obj = (char[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
			} else throw new AssertionError();
			return array;
		}

		public final Object[] print(String parse, Object... args) {
			print(args[0]);
			for (int i = 1;i < args.length;++ i) {
				print(parse);
				print(args[i]);
			}
			return args;
		}

		public final Object[] printf(String format, Object... args) {
			out.printf(format, args);
			if (autoFlush) flush();
			return args;
		}

		public final Object printf(Locale l, String format, Object... args) {
			out.printf(l, format, args);
			if (autoFlush) flush();
			return args;
		}

		public final void println() {
			out.println();
			if (autoFlush) flush();
		}

		public final boolean println(boolean b) {
			out.println(b);
			if (autoFlush) flush();
			return b;
		}

		public final Object println(boolean b, Object t, Object f) {
			return b ? println(t) : println(f);
		}

		public final char println(char c) {
			out.println(c);
			if (autoFlush) flush();
			return c;
		}

		public final char[] println(char[] s) {
			out.println(s);
			if (autoFlush) flush();
			return s;
		}

		public final double println(double d) {
			out.println(d);
			if (autoFlush) flush();
			return d;
		}

		public final double println(double d, int length) {
			print(d, length);
			println();
			return d;
		}

		public final float println(float f) {
			out.println(f);
			if (autoFlush) flush();
			return f;
		}

		public final int println(int i) {
			out.println(i);
			if (autoFlush) flush();
			return i;
		}

		public final long println(long l) {
			out.println(l);
			if (autoFlush) flush();
			return l;
		}

		public final Object println(Object obj) {
			print(obj);
			println();
			return obj;
		}

		public final String println(String s) {
			out.println(s);
			if (autoFlush) flush();
			return s;
		}

		public final Object println(Object array, String... parse) {
			print(array, parse);
			println();
			return array;
		}

		public final boolean debug(boolean b) {
			err.print(b);
			if (autoFlush) flush();
			return b;
		}

		public final Object debug(boolean b, Object t, Object f) {
			return b ? debug(t) : debug(f);
		}

		public final char debug(char c) {
			err.print(c);
			if (autoFlush) flush();
			return c;
		}

		public final char[] debug(char[] s) {
			err.print(s);
			return s;
		}

		public final double debug(double d) {
			err.print(d);
			if (autoFlush) flush();
			return d;
		}

		public final double debug(double d, int length) {
			if (d < 0) {
				err.print('-');
				d = -d;
			}
			d += Math.pow(10, -length) / 2;
			err.print((long)d);
			err.print('.');
			d -= (long)d;
			for (int i = 0;i < length;++ i) {
				d *= 10;
				err.print((int)d);
				d -= (int)d;
			}
			if (autoFlush) flush();
			return d;
		}

		public final float debug(float f) {
			err.print(f);
			if (autoFlush) flush();
			return f;
		}

		public final int debug(int i) {
			err.print(i);
			if (autoFlush) flush();
			return i;
		}

		public final long debug(long l) {
			err.print(l);
			if (autoFlush) flush();
			return l;
		}

		public final Object debug(Object obj) {
			if (obj.getClass().isArray()) {
				if (obj instanceof boolean[][]) debug(obj, "\n", " ");
				else if (obj instanceof byte[][]) debug(obj, "\n", " ");
				else if (obj instanceof short[][]) debug(obj, "\n", " ");
				else if (obj instanceof int[][]) debug(obj, "\n", " ");
				else if (obj instanceof long[][]) debug(obj, "\n", " ");
				else if (obj instanceof float[][]) debug(obj, "\n", " ");
				else if (obj instanceof double[][]) debug(obj, "\n", " ");
				else if (obj instanceof char[][]) debug(obj, "\n", " ");
				else if (obj instanceof Object[][]) debug(obj, "\n", " ");
				else debug(obj, " ");
			} else {
				err.print(obj);
				if (autoFlush) flush();
			}
			return obj;
		}

		public final String debug(String s) {
			err.print(s);
			if (autoFlush) flush();
			return s;
		}

		public final Object debug(Object array, String... parse) {
			debug(array, 0, parse);
			if (autoFlush) flush();
			return array;
		}

		private final Object debug(Object array, int check, String... parse) {
			if (check >= parse.length) {
				if (array.getClass().isArray()) throw new IllegalArgumentException("not equal dimension");
				debug(array);
				return array;
			}
			String str = parse[check];
			if (array instanceof Object[]) {
				Object[] obj = (Object[]) array;
				if (obj.length == 0) return array;
				debug(obj[0], check + 1, parse);
				for (int i = 1;i < obj.length;++ i) {
					debug(str);
					debug(obj[i], check + 1, parse);
				}
				return array;
			}
			if (array instanceof Collection) {
				Iterator<?> iter = ((Collection<?>)array).iterator();
				if (!iter.hasNext()) return array;
				debug(iter.next(), check + 1, parse);
				while(iter.hasNext()) {
					debug(str);
					debug(iter.next(), check + 1, parse);
				}
				return array;
			}
			if (!array.getClass().isArray()) throw new IllegalArgumentException("not equal dimension");
			if (check != parse.length - 1) throw new IllegalArgumentException("not equal dimension");
			if (array instanceof boolean[]) {
				boolean[] obj = (boolean[]) array;
				if (obj.length == 0) return array;
				debug(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					debug(str);
					debug(obj[i]);
				}
			} else if (array instanceof byte[]) {
				byte[] obj = (byte[]) array;
				if (obj.length == 0) return array;
				debug(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					debug(str);
					debug(obj[i]);
				}
				return array;
			} else if (array instanceof short[]) {
				short[] obj = (short[]) array;
				if (obj.length == 0) return array;
				debug(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					debug(str);
					debug(obj[i]);
				}
			} else if (array instanceof int[]) {
				int[] obj = (int[]) array;
				if (obj.length == 0) return array;
				debug(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					debug(str);
					debug(obj[i]);
				}
			} else if (array instanceof long[]) {
				long[] obj = (long[]) array;
				if (obj.length == 0) return array;
				debug(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					debug(str);
					debug(obj[i]);
				}
			} else if (array instanceof float[]) {
				float[] obj = (float[]) array;
				if (obj.length == 0) return array;
				debug(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					debug(str);
					debug(obj[i]);
				}
			} else if (array instanceof double[]) {
				double[] obj = (double[]) array;
				if (obj.length == 0) return array;
				debug(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					debug(str);
					debug(obj[i]);
				}
			} else if (array instanceof char[]) {
				char[] obj = (char[]) array;
				if (obj.length == 0) return array;
				debug(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					debug(str);
					debug(obj[i]);
				}
			} else throw new AssertionError();
			return array;
		}

		public final Object[] debug(String parse, Object... args) {
			debug(args[0]);
			for (int i = 1;i < args.length;++ i) {
				debug(parse);
				debug(args[i]);
			}
			return args;
		}

		public final Object[] debugf(String format, Object... args) {
			err.printf(format, args);
			if (autoFlush) flush();
			return args;
		}

		public final Object debugf(Locale l, String format, Object... args) {
			err.printf(l, format, args);
			if (autoFlush) flush();
			return args;
		}

		public final void debugln() {
			err.println();
			if (autoFlush) flush();
		}

		public final boolean debugln(boolean b) {
			err.println(b);
			if (autoFlush) flush();
			return b;
		}

		public final Object debugln(boolean b, Object t, Object f) {
			return b ? debugln(t) : debugln(f);
		}

		public final char debugln(char c) {
			err.println(c);
			if (autoFlush) flush();
			return c;
		}

		public final char[] debugln(char[] s) {
			err.println(s);
			if (autoFlush) flush();
			return s;
		}

		public final double debugln(double d) {
			err.println(d);
			if (autoFlush) flush();
			return d;
		}

		public final double debugln(double d, int length) {
			debug(d, length);
			debugln();
			return d;
		}

		public final float debugln(float f) {
			err.println(f);
			if (autoFlush) flush();
			return f;
		}

		public final int debugln(int i) {
			err.println(i);
			if (autoFlush) flush();
			return i;
		}

		public final long debugln(long l) {
			err.println(l);
			if (autoFlush) flush();
			return l;
		}

		public final Object debugln(Object obj) {
			debug(obj);
			debugln();
			return obj;
		}

		public final String debugln(String s) {
			err.println(s);
			if (autoFlush) flush();
			return s;
		}

		public final Object debugln(Object array, String... parse) {
			debug(array, parse);
			debugln();
			return array;
		}

		public final void flush() {
			out.flush();
			err.flush();
		}
	}
}

</source>
<source file="../hum_codes_raw/s496837774.java" startline="1" endline="1232" pcid="16674">






import java.awt.Point;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.Locale;
import java.util.NoSuchElementException;
import java.util.Random;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.function.IntPredicate;

public class Main implements Runnable{

	private static final int LIMIT = 1800; // ループで回せる時間
	private static final int ESTIMATE_LOOP = 8192; // 1msで回ると予想する回数

	private static class Marathon implements MarathonInterface {
		private FastIO io;
		private FastRandom rnd;
		private long loop;
		private long score;

		private final int N;
		private final int[] A;
		private final int[] B;
		private final int[] swapB;
		private int[] ans;
		private Stop stop;
		private WantArray want;

		public Marathon(FastIO io) {
			this.io = io;
			rnd = new FastRandom();

			N = io.nextInt();
			A = io.nextInt(N);
			B = io.nextInt(N);
			swapB = new int[N];
		}
		/*
		 * author: 31536000
		 *
		 * 考察メモ
		 * ABC178Fを焼きなます！
		 */


		@Override
		public void init(Stop stop) {
			loop = 0;
			for (int i = 0;i < log.length;++ i) log[i] = Math.log(rnd.nextDouble());
			this.stop = stop;
			// ここから初期化
			greedy();
		}

		// 初期構築はここで
		public void greedy() {
			for (int i = 0;i < N;++ i) swapB[i] = B[(i + N / 2) % N];
			for (int i = 0;i < N;++ i) if (A[i] != swapB[i]) ++ score;
			if (score == N) {
				ans = Arrays.copyOf(swapB, N);
				stop.stop();
				return;
			}
			if (N == 1) stop.stop(); // 後で例外吐くのでどうにかする
			want = new WantArray(N, i -> A[i] == swapB[i]);
			int[] count = new int[200001];
			for (int j : A) ++ count[j];
			for (int j : B) ++ count[j];
			for (int j : count) if (j > N) stop.stop(); // 不可能
		}

		@Override
		public void delayUpdate(int delay) {
			temperature = temperature(delay);
			loop += ESTIMATE_LOOP;
			// ここから処理、デバッグ出力なんかもここの方が良さげ
		}

		private void swap(int i, int j) {
			int swap = swapB[i];
			swapB[i] = swapB[j];
			swapB[j] = swap;
		}

		private static final double START_TEMP = 0.1; // TODO 焼きなまし関数
		private static final double END_TEMP = 0.00001;
		private static final double DIFF = START_TEMP - END_TEMP;
		private static final double INV_LIMIT = 1.0 / LIMIT;
		private double temperature = START_TEMP;
		private static final int LOG_SIZE = 1 << 12;
		private static final int LOG_MASK = LOG_SIZE - 1;
		final double[] log = new double[LOG_SIZE];

		private static double temperature(int delay) {
			return DIFF * delay * INV_LIMIT + END_TEMP;
		}


		private boolean isChange(int change) {
//			return change >= 0; // 山登り法
			return change >= temperature * log[rnd.nextInt() & LOG_MASK]; // 焼きなまし法
		}

		@Override
		public void update() {
			int x = rnd.nextInt(want.want());
			int y = rnd.nextInt(N - 1);
			if (y >= x) ++ y;
			int x2 = want.get(x), y2 = want.get(y);
			int diff = 0;
			if (A[x2] != swapB[x2]) -- diff;
			if (A[x2] != swapB[y2]) ++ diff;
			if (A[y2] != swapB[y2]) -- diff;
			if (A[y2] != swapB[x2]) ++ diff;
			if (isChange(diff)) {
				swap(x2,y2);
				want.set(x, y, i -> A[i] == swapB[i]);
				score += diff;
				if (score == N && ans == null) {
					ans = Arrays.copyOf(swapB, N);
					stop.stop();
				}
			}
		}

		@Override
		public void terminate() {
			if (ans != null) {
				io.println("Yes");
				io.println(ans);
			} else {
				io.println("No");
			}
			// ここまで処理
			io.debugln(loop + "," + score);
			io.flush();
		}

		public long getLoop() {
			return loop;
		}

		public long getScore() {
			return score;
		}

	}

	public static class WantArray {
		private final int[] index;
		private int k = 0;
		public WantArray(int n, IntPredicate want) {
			index = new int[n];
			for (int i = 0;i < n;++ i) index[i] = i;
			set(want);
		}

		private void swap(int i, int j) {
			int swap = index[i];
			index[i] = index[j];
			index[j] = swap;
		}

		public int get(int i) {
			return index[i];
		}

		public void set(IntPredicate want) {
			k = 0;
			for (int i = index.length - 1;i >= k;) {
				if (want.test(index[i])) {
					swap(i, k);
					++ k;
				} else {
					-- i;
				}
			}
		}

		public void set(int i, boolean want) {
			if (i < k) {
				if (want) return;
				swap(i, k - 1);
				-- k;
			} else {
				if (want) {
					swap(i, k);
					++ k;
				} else return;
			}
		}

		public void set(int i, int j, IntPredicate want) {
			if (i < k) {
				if (!want.test(index[i])) {
					swap(i, k - 1);
					if (j == k - 1) j = i;
					-- k;
				}
			} else {
				if (want.test(index[i])) {
					swap(i, k);
					if (j == k) j = i;
					++ k;
				}
			}
			set(j, want.test(index[j]));
		}

		public int want() {
			return k;
		}
	}

	/** デバッグ用コードのお供に */
	private static boolean DEBUG = false;
	/** 確保するメモリの大きさ(単位: MB)*/
	private static final long MEMORY = 256;
	private final FastIO io;

	public static void main(String[] args) {
	        Thread.setDefaultUncaughtExceptionHandler((t, e) -> e.printStackTrace());
	        new Thread(null, new Main(), "", MEMORY * 1048576).start();
	}

	public Main() {
		this(new FastIO());
	}

	public Main(FastIO io) {
		this.io = io;
		if (DEBUG) {
			io.setAutoFlush(true);
			io.debugln("debug mode");
		}
	}

	@Override
	public void run() {
		solve(io);
		io.flush();
	}
	Marathon marathon;

	private void solve(FastIO io) {
		io.setAutoFlush(true);
		marathon = new Marathon(io);
		MarathonTimer timer = new MarathonTimer(marathon);
		timer.start(LIMIT);

	}

	public long getLoop() {
		return marathon.getLoop();
	}

	public long getScore() {
		return marathon.getScore();
	}

	// 以下、ライブラリ

	public static final class FastRandom extends Random{
		private static final long serialVersionUID = -302298413684195190L;
		private long rand;
		private static final float FLOAT_INV = 1f / (1 << 24);
		private static final double DOUBLE_INV = 1. / (1L << 53);
		public FastRandom() {
			this(new Random().nextLong());
		}
		public FastRandom(long seed) {
			rand = seed;
		}
		@Override
		public void setSeed(long seed) {
			this.rand = seed;
		}
		@Override
		protected int next(int bits) {
			return (int)nextLong() & (1 << bits) - 1;
		}
		@Override
		public int nextInt() {
			rand = rand ^ (rand << 7);
			rand = rand ^ (rand >>> 9);
			return (int)(rand & Integer.MAX_VALUE);
		}
		@Override
		public int nextInt(int bounds) {
			return nextInt() % bounds;
		}
		public int nextRange(int startInclusive, int endExclusive) {
			return nextInt(endExclusive - startInclusive) + startInclusive;
		}
		@Override
		public long nextLong() {
			rand = rand ^ (rand << 7);
			rand = rand ^ (rand >>> 9);
			return rand & Long.MAX_VALUE;
		}
		@Override
		public boolean nextBoolean() {
			rand = rand ^ (rand << 7);
			rand = rand ^ (rand >>> 9);
			return (rand & 1) != 0;
		}
		@Override
		public float nextFloat() {
			rand = rand ^ (rand << 7);
			rand = rand ^ (rand >>> 9);
			return ((int)(rand & 0x00FFFFFF)) * FLOAT_INV;
		}
		@Override
		public double nextDouble() {
			rand = rand ^ (rand << 7);
			rand = rand ^ (rand >>> 9);
			return (rand & 0x001FFFFFFFFFFFFFL) * DOUBLE_INV;
		}
	}

	private static interface MarathonInterface {
		/**
		 * 標準入力を受け取り、処理しやすいように加工する関数です。
		 */
		public void init(Stop stop);
		/**
		 * 残り時間に応じた処理や、少し重い前処理などを行う関数です・
		 * @param delay 残り時間
		 */
		public void delayUpdate(int delay);
		/**
		 * 近傍を探したりなど、毎回更新の処理を行う関数です。
		 */
		public void update();
		/**
		 * 求まった結果を出力する関数です。
		 */
		public void terminate();
	}

	private static interface Stop {
		public void stop();
	}

	private static class MarathonTimer implements Runnable {

		private MarathonInterface marathon;
		private volatile boolean loopFlag;
		private ScheduledExecutorService  threadPool;
		private ScheduledFuture<?> future;

		public MarathonTimer(Marathon marathon) {
			this.marathon = marathon;
			threadPool = Executors.newScheduledThreadPool(2);
		}

		public void start(int millis) {
			loopFlag = true;
			marathon.init(() -> {
				if (marathon != null) marathon.terminate();
				marathon = null;
			});
			if (marathon == null) {
				return;
			}
			future = threadPool.schedule(() -> loopFlag = false, millis, TimeUnit.MILLISECONDS);
			threadPool.execute(this);
			try {
				threadPool.awaitTermination(7, TimeUnit.DAYS);
			} catch (InterruptedException e) {
				// TODO 自動生成された catch ブロック
				e.printStackTrace();
			}
		}

		@Override
		public void run() {
			try {
				while(loopFlag) {
					int delay = (int)future.getDelay(TimeUnit.MILLISECONDS);
					if (delay <= 0) {
						loopFlag = false;
						break;
					}
					marathon.delayUpdate(delay);
					for (int i = 0;i < ESTIMATE_LOOP;++ i) marathon.update();
				}
				marathon.terminate();
			} catch (NullPointerException e) {
				// これは想定なので問題なし
			} catch (Throwable e) {
				e.printStackTrace();
			}
			future.cancel(true);
			threadPool.shutdown();
		}
	}

	/**
	 * 高速な入出力を提供します。
	 * @author 31536000
	 *
	 */
	public static class FastIO {
		private InputStream in;
		private final byte[] buffer = new byte[1024];
		private int read = 0;
		private int length = 0;
		private PrintWriter out;
		private PrintWriter err;
		private boolean autoFlush = false;

		public FastIO() {
			this(System.in, System.out, System.err);
		}

		public FastIO(InputStream in, PrintStream out, PrintStream err) {
			this.in = in;
			this.out = new PrintWriter(out, false);
			this.err = new PrintWriter(err, false);
		}

		public final void setInputStream(InputStream in) {
			this.in = in;
		}

		public final void setInputStream(File in) {
			try {
				this.in = new FileInputStream(in);
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
		}

		public final void setOutputStream(PrintStream out) {
			this.out = new PrintWriter(out, false);
		}

		public final void setOutputStream(File out) {
			try {
				this.out = new PrintWriter(new FileOutputStream(out), false);
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
		}

		public final void setErrorStream(PrintStream err) {
			this.err = new PrintWriter(err, false);
		}

		public final void setErrorStream(File err) {
			try {
				this.err = new PrintWriter(new FileOutputStream(err), false);
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
		}

		public final void setAutoFlush(boolean flush) {
			autoFlush = flush;
		}

		private boolean hasNextByte() {
			if (read < length) return true;
			read = 0;
			try {
				length = in.read(buffer);
			} catch (IOException e) {
				e.printStackTrace();
			}
			return length > 0;
		}

		private int readByte() {
			return hasNextByte() ? buffer[read++] : -1;
		}

		private static boolean isPrintableChar(int c) {
			return 33 <= c && c <= 126;
		}

		private static boolean isNumber(int c) {
			return '0' <= c && c <= '9';
		}

		public final boolean hasNext() {
			while (hasNextByte() && !isPrintableChar(buffer[read])) read++;
			return hasNextByte();
		}

		public final char nextChar() {
			if (!hasNextByte())  throw new NoSuchElementException();
			return (char)readByte();
		}

		public final char[][] nextChar(int height) {
			char[][] ret = new char[height][];
			for (int i = 0;i < ret.length;++ i) ret[i] = next().toCharArray();
			return ret;
		}

		public final String next() {
			if (!hasNext()) throw new NoSuchElementException();
			StringBuilder sb = new StringBuilder();
			int b;
			while (isPrintableChar(b = readByte())) sb.appendCodePoint(b);
			return sb.toString();
		}

		public final String nextLine() {
			StringBuilder sb = new StringBuilder();
			int b;
			while(!isPrintableChar(b = readByte()));
			do sb.appendCodePoint(b); while(isPrintableChar(b = readByte()) || b == ' ');
			return sb.toString();
		}

		public final long nextLong() {
			if (!hasNext()) throw new NoSuchElementException();
			long n = 0;
			boolean minus = false;
			int b = readByte();
			if (b == '-') {
				minus = true;
				b = readByte();
			}
			if (!isNumber(b)) throw new NumberFormatException();
			while (true) {
				if (isNumber(b)) {
					n *= 10;
					n += b - '0';
				} else if (b == -1 || !isPrintableChar(b)) return minus ? -n : n;
				else throw new NumberFormatException();
				b = readByte();
			}
		}

		public final int nextInt() {
			long nl = nextLong();
			if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
			return (int) nl;
		}

		public final double nextDouble() {
			return Double.parseDouble(next());
		}

		public final int[] nextInt(int width) {
			int[] ret = new int[width];
			for (int i = 0;i < width;++ i) ret[i] = nextInt();
			return ret;
		}

		public final int[] nextInts() {
			return nextInts(" ");
		}

		public final int[] nextInts(String parse) {
			String[] get = nextLine().split(parse);
			int[] ret = new int[get.length];
			for (int i = 0;i < ret.length;++ i) ret[i] = Integer.valueOf(get[i]);
			return ret;
		}

		public final long[] nextLong(int width) {
			long[] ret = new long[width];
			for (int i = 0;i < width;++ i) ret[i] = nextLong();
			return ret;
		}

		public final long[] nextLongs() {
			return nextLongs(" ");
		}

		public final long[] nextLongs(String parse) {
			String[] get = nextLine().split(parse);
			long[] ret = new long[get.length];
			for (int i = 0;i < ret.length;++ i) ret[i] = Long.valueOf(get[i]);
			return ret;
		}

		public final int[][] nextInt(int width, int height) {
			int[][] ret = new int[height][width];
			for (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[i][j] = nextInt();
			return ret;
		}

		public final long[][] nextLong(int width, int height) {
			long[][] ret = new long[height][width];
			for (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[j][i] = nextLong();
			return ret;
		}

		public final boolean[] nextBoolean(char T) {
			char[] s = next().toCharArray();
			boolean[] ret = new boolean[s.length];
			for (int i = 0;i < ret.length;++ i) ret[i] = s[i] == T;
			return ret;
		}

		public final boolean[][] nextBoolean(char T, int height) {
			boolean[][] ret = new boolean[height][];
			for (int i = 0;i < ret.length;++ i) {
				char[] s = next().toCharArray();
				ret[i] = new boolean[s.length];
				for (int j = 0;j < ret[i].length;++ j) ret[i][j] = s[j] == T;
			}
			return ret;
		}

		public final Point nextPoint() {
			return new Point(nextInt(), nextInt());
		}

		public final Point[] nextPoint(int width) {
			Point[] ret = new Point[width];
			for (int i = 0;i < width;++ i) ret[i] = nextPoint();
			return ret;
		}

		@Override
		protected void finalize() throws Throwable {
			try {
				super.finalize();
			} finally {
				in.close();
				out.close();
				err.close();
			}
		}

		public final boolean print(boolean b) {
			out.print(b);
			if (autoFlush) flush();
			return b;
		}

		public final Object print(boolean b, Object t, Object f) {
			return b ? print(t) : print(f);
		}

		public final char print(char c) {
			out.print(c);
			if (autoFlush) flush();
			return c;
		}

		public final char[] print(char[] s) {
			out.print(s);
			return s;
		}

		public final double print(double d) {
			out.print(d);
			if (autoFlush) flush();
			return d;
		}

		public final double print(double d, int length) {
			if (d < 0) {
				out.print('-');
				d = -d;
			}
			d += Math.pow(10, -length) / 2;
			out.print((long)d);
			out.print('.');
			d -= (long)d;
			for (int i = 0;i < length;++ i) {
				d *= 10;
				out.print((int)d);
				d -= (int)d;
			}
			if (autoFlush) flush();
			return d;
		}

		public final float print(float f) {
			out.print(f);
			if (autoFlush) flush();
			return f;
		}

		public final int print(int i) {
			out.print(i);
			if (autoFlush) flush();
			return i;
		}

		public final long print(long l) {
			out.print(l);
			if (autoFlush) flush();
			return l;
		}

		public final Object print(Object obj) {
			if (obj.getClass().isArray()) {
				if (obj instanceof boolean[][]) print(obj, "\n", " ");
				else if (obj instanceof byte[][]) print(obj, "\n", " ");
				else if (obj instanceof short[][]) print(obj, "\n", " ");
				else if (obj instanceof int[][]) print(obj, "\n", " ");
				else if (obj instanceof long[][]) print(obj, "\n", " ");
				else if (obj instanceof float[][]) print(obj, "\n", " ");
				else if (obj instanceof double[][]) print(obj, "\n", " ");
				else if (obj instanceof char[][]) print(obj, "\n", " ");
				else if (obj instanceof Object[][]) print(obj, "\n", " ");
				else print(obj, " ");
			} else {
				out.print(obj);
				if (autoFlush) flush();
			}
			return obj;
		}

		public final String print(String s) {
			out.print(s);
			if (autoFlush) flush();
			return s;
		}

		public final Object print(Object array, String... parse) {
			print(array, 0, parse);
			if (autoFlush) flush();
			return array;
		}

		private final Object print(Object array, int check, String... parse) {
			if (check >= parse.length) {
				if (array.getClass().isArray()) throw new IllegalArgumentException("not equal dimension");
				print(array);
				return array;
			}
			String str = parse[check];
			if (array instanceof Object[]) {
				Object[] obj = (Object[]) array;
				if (obj.length == 0) return array;
				print(obj[0], check + 1, parse);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i], check + 1, parse);
				}
				return array;
			}
			if (array instanceof Collection) {
				Iterator<?> iter = ((Collection<?>)array).iterator();
				if (!iter.hasNext()) return array;
				print(iter.next(), check + 1, parse);
				while(iter.hasNext()) {
					print(str);
					print(iter.next(), check + 1, parse);
				}
				return array;
			}
			if (!array.getClass().isArray()) throw new IllegalArgumentException("not equal dimension");
			if (check != parse.length - 1) throw new IllegalArgumentException("not equal dimension");
			if (array instanceof boolean[]) {
				boolean[] obj = (boolean[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
			} else if (array instanceof byte[]) {
				byte[] obj = (byte[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
				return array;
			} else if (array instanceof short[]) {
				short[] obj = (short[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
			} else if (array instanceof int[]) {
				int[] obj = (int[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
			} else if (array instanceof long[]) {
				long[] obj = (long[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
			} else if (array instanceof float[]) {
				float[] obj = (float[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
			} else if (array instanceof double[]) {
				double[] obj = (double[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
			} else if (array instanceof char[]) {
				char[] obj = (char[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
			} else throw new AssertionError();
			return array;
		}

		public final Object[] print(String parse, Object... args) {
			print(args[0]);
			for (int i = 1;i < args.length;++ i) {
				print(parse);
				print(args[i]);
			}
			return args;
		}

		public final Object[] printf(String format, Object... args) {
			out.printf(format, args);
			if (autoFlush) flush();
			return args;
		}

		public final Object printf(Locale l, String format, Object... args) {
			out.printf(l, format, args);
			if (autoFlush) flush();
			return args;
		}

		public final void println() {
			out.println();
			if (autoFlush) flush();
		}

		public final boolean println(boolean b) {
			out.println(b);
			if (autoFlush) flush();
			return b;
		}

		public final Object println(boolean b, Object t, Object f) {
			return b ? println(t) : println(f);
		}

		public final char println(char c) {
			out.println(c);
			if (autoFlush) flush();
			return c;
		}

		public final char[] println(char[] s) {
			out.println(s);
			if (autoFlush) flush();
			return s;
		}

		public final double println(double d) {
			out.println(d);
			if (autoFlush) flush();
			return d;
		}

		public final double println(double d, int length) {
			print(d, length);
			println();
			return d;
		}

		public final float println(float f) {
			out.println(f);
			if (autoFlush) flush();
			return f;
		}

		public final int println(int i) {
			out.println(i);
			if (autoFlush) flush();
			return i;
		}

		public final long println(long l) {
			out.println(l);
			if (autoFlush) flush();
			return l;
		}

		public final Object println(Object obj) {
			print(obj);
			println();
			return obj;
		}

		public final String println(String s) {
			out.println(s);
			if (autoFlush) flush();
			return s;
		}

		public final Object println(Object array, String... parse) {
			print(array, parse);
			println();
			return array;
		}

		public final boolean debug(boolean b) {
			err.print(b);
			if (autoFlush) flush();
			return b;
		}

		public final Object debug(boolean b, Object t, Object f) {
			return b ? debug(t) : debug(f);
		}

		public final char debug(char c) {
			err.print(c);
			if (autoFlush) flush();
			return c;
		}

		public final char[] debug(char[] s) {
			err.print(s);
			return s;
		}

		public final double debug(double d) {
			err.print(d);
			if (autoFlush) flush();
			return d;
		}

		public final double debug(double d, int length) {
			if (d < 0) {
				err.print('-');
				d = -d;
			}
			d += Math.pow(10, -length) / 2;
			err.print((long)d);
			err.print('.');
			d -= (long)d;
			for (int i = 0;i < length;++ i) {
				d *= 10;
				err.print((int)d);
				d -= (int)d;
			}
			if (autoFlush) flush();
			return d;
		}

		public final float debug(float f) {
			err.print(f);
			if (autoFlush) flush();
			return f;
		}

		public final int debug(int i) {
			err.print(i);
			if (autoFlush) flush();
			return i;
		}

		public final long debug(long l) {
			err.print(l);
			if (autoFlush) flush();
			return l;
		}

		public final Object debug(Object obj) {
			if (obj.getClass().isArray()) {
				if (obj instanceof boolean[][]) debug(obj, "\n", " ");
				else if (obj instanceof byte[][]) debug(obj, "\n", " ");
				else if (obj instanceof short[][]) debug(obj, "\n", " ");
				else if (obj instanceof int[][]) debug(obj, "\n", " ");
				else if (obj instanceof long[][]) debug(obj, "\n", " ");
				else if (obj instanceof float[][]) debug(obj, "\n", " ");
				else if (obj instanceof double[][]) debug(obj, "\n", " ");
				else if (obj instanceof char[][]) debug(obj, "\n", " ");
				else if (obj instanceof Object[][]) debug(obj, "\n", " ");
				else debug(obj, " ");
			} else {
				err.print(obj);
				if (autoFlush) flush();
			}
			return obj;
		}

		public final String debug(String s) {
			err.print(s);
			if (autoFlush) flush();
			return s;
		}

		public final Object debug(Object array, String... parse) {
			debug(array, 0, parse);
			if (autoFlush) flush();
			return array;
		}

		private final Object debug(Object array, int check, String... parse) {
			if (check >= parse.length) {
				if (array.getClass().isArray()) throw new IllegalArgumentException("not equal dimension");
				debug(array);
				return array;
			}
			String str = parse[check];
			if (array instanceof Object[]) {
				Object[] obj = (Object[]) array;
				if (obj.length == 0) return array;
				debug(obj[0], check + 1, parse);
				for (int i = 1;i < obj.length;++ i) {
					debug(str);
					debug(obj[i], check + 1, parse);
				}
				return array;
			}
			if (array instanceof Collection) {
				Iterator<?> iter = ((Collection<?>)array).iterator();
				if (!iter.hasNext()) return array;
				debug(iter.next(), check + 1, parse);
				while(iter.hasNext()) {
					debug(str);
					debug(iter.next(), check + 1, parse);
				}
				return array;
			}
			if (!array.getClass().isArray()) throw new IllegalArgumentException("not equal dimension");
			if (check != parse.length - 1) throw new IllegalArgumentException("not equal dimension");
			if (array instanceof boolean[]) {
				boolean[] obj = (boolean[]) array;
				if (obj.length == 0) return array;
				debug(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					debug(str);
					debug(obj[i]);
				}
			} else if (array instanceof byte[]) {
				byte[] obj = (byte[]) array;
				if (obj.length == 0) return array;
				debug(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					debug(str);
					debug(obj[i]);
				}
				return array;
			} else if (array instanceof short[]) {
				short[] obj = (short[]) array;
				if (obj.length == 0) return array;
				debug(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					debug(str);
					debug(obj[i]);
				}
			} else if (array instanceof int[]) {
				int[] obj = (int[]) array;
				if (obj.length == 0) return array;
				debug(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					debug(str);
					debug(obj[i]);
				}
			} else if (array instanceof long[]) {
				long[] obj = (long[]) array;
				if (obj.length == 0) return array;
				debug(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					debug(str);
					debug(obj[i]);
				}
			} else if (array instanceof float[]) {
				float[] obj = (float[]) array;
				if (obj.length == 0) return array;
				debug(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					debug(str);
					debug(obj[i]);
				}
			} else if (array instanceof double[]) {
				double[] obj = (double[]) array;
				if (obj.length == 0) return array;
				debug(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					debug(str);
					debug(obj[i]);
				}
			} else if (array instanceof char[]) {
				char[] obj = (char[]) array;
				if (obj.length == 0) return array;
				debug(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					debug(str);
					debug(obj[i]);
				}
			} else throw new AssertionError();
			return array;
		}

		public final Object[] debug(String parse, Object... args) {
			debug(args[0]);
			for (int i = 1;i < args.length;++ i) {
				debug(parse);
				debug(args[i]);
			}
			return args;
		}

		public final Object[] debugf(String format, Object... args) {
			err.printf(format, args);
			if (autoFlush) flush();
			return args;
		}

		public final Object debugf(Locale l, String format, Object... args) {
			err.printf(l, format, args);
			if (autoFlush) flush();
			return args;
		}

		public final void debugln() {
			err.println();
			if (autoFlush) flush();
		}

		public final boolean debugln(boolean b) {
			err.println(b);
			if (autoFlush) flush();
			return b;
		}

		public final Object debugln(boolean b, Object t, Object f) {
			return b ? debugln(t) : debugln(f);
		}

		public final char debugln(char c) {
			err.println(c);
			if (autoFlush) flush();
			return c;
		}

		public final char[] debugln(char[] s) {
			err.println(s);
			if (autoFlush) flush();
			return s;
		}

		public final double debugln(double d) {
			err.println(d);
			if (autoFlush) flush();
			return d;
		}

		public final double debugln(double d, int length) {
			debug(d, length);
			debugln();
			return d;
		}

		public final float debugln(float f) {
			err.println(f);
			if (autoFlush) flush();
			return f;
		}

		public final int debugln(int i) {
			err.println(i);
			if (autoFlush) flush();
			return i;
		}

		public final long debugln(long l) {
			err.println(l);
			if (autoFlush) flush();
			return l;
		}

		public final Object debugln(Object obj) {
			debug(obj);
			debugln();
			return obj;
		}

		public final String debugln(String s) {
			err.println(s);
			if (autoFlush) flush();
			return s;
		}

		public final Object debugln(Object array, String... parse) {
			debug(array, parse);
			debugln();
			return array;
		}

		public final void flush() {
			out.flush();
			err.flush();
		}
	}
}

</source>
</class>

<class classid="57" nclones="3" nlines="74" similarity="100">
<source file="../hum_codes_raw/s084168880.java" startline="1" endline="117" pcid="2806">


import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

public class Main {

	/*
	 * ????????°???????????¨?????????????????????
	 */
	public static void main(String[] args) throws NumberFormatException, IOException {

		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		// ??????????????°
		int set = Integer.parseInt(br.readLine());
		// ?????¬?????????????????????????????????
		Player isono = new Player("Isono-kun");
		Player nakajima = new Player("Nakajima-kun");

		// ??????????????????????????????????????????????´?
		for (int cnt = 0; cnt < set; cnt++)
			isono.getGesture().add(Action.valueOf(br.readLine()));
		for (int cnt = 0; cnt < set; cnt++)
			nakajima.getGesture().add(Action.valueOf(br.readLine()));
		// ?????????
		for (int turn = 0; turn < set; turn++) {
			for (int swap = 0; swap < 2; swap++) {
				Player p1 = swap == 0 ? isono : nakajima;
				Player p2 = swap == 0 ? nakajima : isono;

				// ?????????????????????p1???????????????????????????????????????
				// p2????????????0??§???????????¢
				if (p2.getGesture().get(turn) == Action.kougekida && p2.getForce() == 0) {
					// p1????????????0??§???????????¢??§??????
					if (!(p1.getGesture().get(turn) == Action.kougekida)) {
						System.out.println(p1.getPlayerName());
						return;
					}
				}

				// p1????????????1??\?????§???????????¢
				if (p1.getGesture().get(turn) == Action.kougekida && p1.getForce() > 0) {
					if (p1.getForce() >= 5 || (p2.getGesture().get(turn) != Action.mamoru
							&& p2.getGesture().get(turn) != Action.kougekida)) {
						System.out.println(p1.getPlayerName());
						return;
					}
					// ????????¨??????????????¢???????????¨
					if (p2.getGesture().get(turn) == Action.kougekida) {
						if (p1.getForce() > p2.getForce()) {
							System.out.println(p1.getPlayerName());
							return;
						}
					}
				}
			}
			// ???????????¢?????¨??£?????´??????????????????0?????????
			if (isono.getGesture().get(turn) == Action.kougekida)
				isono.setForce(0);
			if (nakajima.getGesture().get(turn) == Action.kougekida)
				nakajima.setForce(0);
			// ?????????
			if (isono.getGesture().get(turn) == Action.tameru)
				isono.setForce(isono.getForce() + 1);
			if (nakajima.getGesture().get(turn) == Action.tameru)
				nakajima.setForce(nakajima.getForce() + 1);
		} // for?????????????????????
		System.out.println("Hikiwake-kun");
	}// ?????????????????????????????????
}// ??????????????????????????????

enum Action {
	kougekida, tameru, mamoru
}// Action?????????????????????

/**
 * ?????¬??????????????¶???
 *
 * @author ?????????????????§???
 */
class Player {
	private int force = 0;
	private String PlayerName;
	private List<Action> gesture = new ArrayList<Action>();

	public List<Action> getGesture() {
		return gesture;
	}

	public void setGesture(List<Action> gesture) {
		this.gesture = gesture;
	}

	public String getPlayerName() {
		return PlayerName;
	}

	public void setPlayerName(String playerName) {
		PlayerName = playerName;
	}

	public int getForce() {
		return force;
	}

	public void setForce(int force) {
		this.force = force;
	}

	Player(String name) {
		this.PlayerName = name;
	}
}// Player?????????????????????

</source>
<source file="../hum_codes_raw/s709835362.java" startline="1" endline="118" pcid="23872">


import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

public class Main{

	/*
	 * ????????°???????????¨?????????????????????
	 */
	public static void main(String[] args) throws NumberFormatException, IOException {

		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		// ??????????????°
		int set = Integer.parseInt(br.readLine());
		// ?????¬?????????????????????????????????
		Player isono = new Player("Isono-kun");
		Player nakajima = new Player("Nakajima-kun");

		// ??????????????????????????????????????????????´?
		for (int cnt = 0; cnt < set; cnt++)
			isono.getGesture().add(Action.valueOf(br.readLine()));
		for (int cnt = 0; cnt < set; cnt++)
			nakajima.getGesture().add(Action.valueOf(br.readLine()));

		// ????????????????????????????????????
		for (int turn = 0; turn < set; turn++) {
			// ???????????\????????????2???????????????
			for (int swap = 0; swap < 2; swap++) {
				Player p1 = swap == 0 ? isono : nakajima;
				Player p2 = swap == 0 ? nakajima : isono;
				// ?????????????????????p1???????????????????????????????????????

				// p2????????????0??§???????????¢
				if (p2.getGesture().get(turn) == Action.kougekida && p2.getForce() == 0) {
					// p1????????????0??§???????????¢??§??????
					if (!(p1.getGesture().get(turn) == Action.kougekida)) {
						System.out.println(p1.getPlayerName());
						return;
					}
				}
				// p1????????????1??\?????§???????????¢
				if (p1.getGesture().get(turn) == Action.kougekida && p1.getForce() > 0) {
					if (p1.getForce() >= 5 || (p2.getGesture().get(turn) != Action.mamoru
							&& p2.getGesture().get(turn) != Action.kougekida)) {
						System.out.println(p1.getPlayerName());
						return;
					}
					// ????????¬???????????????????????¢?????????
					if (p2.getGesture().get(turn) == Action.kougekida) {
						if (p1.getForce() > p2.getForce()) {
							System.out.println(p1.getPlayerName());
							return;
						}
					}
				}
			}
			// ???????????¢?????¨??£?????´??????????????????0?????????
			if (isono.getGesture().get(turn) == Action.kougekida)
				isono.setForce(0);
			if (nakajima.getGesture().get(turn) == Action.kougekida)
				nakajima.setForce(0);
			// ?????????
			if (isono.getGesture().get(turn) == Action.tameru)
				isono.setForce(isono.getForce() + 1);
			if (nakajima.getGesture().get(turn) == Action.tameru)
				nakajima.setForce(nakajima.getForce() + 1);
		} // for?????????????????????
		System.out.println("Hikiwake-kun");
	}// ?????????????????????????????????
}// ??????????????????????????????

enum Action {
	kougekida, tameru, mamoru
}// Action?????????????????????

/**
 * ?????¬??????????????¶???
 *
 * @author ?????????????????§???
 */
class Player {
	private int force = 0;
	private String PlayerName;
	private List<Action> gesture = new ArrayList<Action>();

	public List<Action> getGesture() {
		return gesture;
	}

	public void setGesture(List<Action> gesture) {
		this.gesture = gesture;
	}

	public String getPlayerName() {
		return PlayerName;
	}

	public void setPlayerName(String playerName) {
		PlayerName = playerName;
	}

	public int getForce() {
		return force;
	}

	public void setForce(int force) {
		this.force = force;
	}

	Player(String name) {
		this.PlayerName = name;
	}
}// Player?????????????????????

</source>
<source file="../hum_codes_raw/s621658693.java" startline="1" endline="118" pcid="20874">


import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

public class Main{

	/*
	 * ????????°???????????¨?????????????????????
	 */
	public static void main(String[] args) throws NumberFormatException, IOException {

		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		// ??????????????°
		int set = Integer.parseInt(br.readLine());
		// ?????¬?????????????????????????????????
		Player isono = new Player("Isono-kun");
		Player nakajima = new Player("Nakajima-kun");

		// ??????????????????????????????????????????????´?
		for (int cnt = 0; cnt < set; cnt++)
			isono.getGesture().add(Action.valueOf(br.readLine()));
		for (int cnt = 0; cnt < set; cnt++)
			nakajima.getGesture().add(Action.valueOf(br.readLine()));

		// ????????????????????????????????????
		for (int turn = 0; turn < set; turn++) {
			// ???????????\????????????2???????????????
			for (int swap = 0; swap < 2; swap++) {
				Player p1 = swap == 0 ? isono : nakajima;
				Player p2 = swap == 0 ? nakajima : isono;
				// ?????????????????????p1???????????????????????????????????????

				// p2????????????0??§???????????¢
				if (p2.getGesture().get(turn) == Action.kougekida && p2.getForce() == 0) {
					// p1????????????0??§???????????¢??§??????
					if (!(p1.getGesture().get(turn) == Action.kougekida)) {
						System.out.println(p1.getPlayerName());
						return;
					}
				}
				// p1????????????1??\?????§???????????¢
				if (p1.getGesture().get(turn) == Action.kougekida && p1.getForce() > 0) {
					if (p1.getForce() >= 5 || (p2.getGesture().get(turn) != Action.mamoru
							&& p2.getGesture().get(turn) != Action.kougekida)) {
						System.out.println(p1.getPlayerName());
						return;
					}
					// ????????¬???????????????????????¢?????????
					if (p2.getGesture().get(turn) == Action.kougekida) {
						if (p1.getForce() > p2.getForce()) {
							System.out.println(p1.getPlayerName());
							return;
						}
					}
				}
			}
			// ???????????¢?????¨??£?????´??????????????????0?????????
			if (isono.getGesture().get(turn) == Action.kougekida)
				isono.setForce(0);
			if (nakajima.getGesture().get(turn) == Action.kougekida)
				nakajima.setForce(0);
			// ?????????
			if (isono.getGesture().get(turn) == Action.tameru)
				isono.setForce(isono.getForce() + 1);
			if (nakajima.getGesture().get(turn) == Action.tameru)
				nakajima.setForce(nakajima.getForce() + 1);
		} // for?????????????????????
		System.out.println("Hikiwake-kun");
	}// ?????????????????????????????????
}// ??????????????????????????????

enum Action {
	kougekida, tameru, mamoru
}// Action?????????????????????

/**
 * ?????¬??????????????¶???
 *
 * @author ?????????????????§???
 */
class Player {
	private int force = 0;
	private String PlayerName;
	private List<Action> gesture = new ArrayList<Action>();

	public List<Action> getGesture() {
		return gesture;
	}

	public void setGesture(List<Action> gesture) {
		this.gesture = gesture;
	}

	public String getPlayerName() {
		return PlayerName;
	}

	public void setPlayerName(String playerName) {
		PlayerName = playerName;
	}

	public int getForce() {
		return force;
	}

	public void setForce(int force) {
		this.force = force;
	}

	Player(String name) {
		this.PlayerName = name;
	}
}// Player?????????????????????

</source>
</class>

<class classid="58" nclones="2" nlines="60" similarity="100">
<source file="../hum_codes_raw/s088292499.java" startline="1" endline="68" pcid="2932">
import java.util.*;
import java.util.stream.*;

public class Main {

	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		int n = in.nextInt();
		int[] arr = new int[n];
		for (int i = 0; i < n; i++) {
			arr[i] = in.nextInt();
		}
		int[] copy = Arrays.copyOf(arr, arr.length);
		Arrays.sort(copy);

		int left = 0, right = n;
		long x = (long)n * (long)(n + 1) / 4;
		while(left + 1 < right) {
			int mid = (left + right) / 2;
			int am = copy[mid];
			int[] s = new int[n + 1];
			for (int i = 0; i < n; i++) {
				s[i + 1] = am <= arr[i] ? 1 : -1;
			}
			for (int i = 1; i < n + 1; i++) {
				s[i] += s[i - 1];
			}
			BIT bit = new BIT(2 * n + 1);
			long sum = 0;
			for (int i = 0; i < n + 1; i++) {
				sum += bit.sum(s[i] + n);
				bit.add(s[i] + n, 1);
			}
			if(x <= sum) {
				left = mid;
			} else {
				right = mid;
			}
		}
		System.out.println(copy[left]);
	}
}

class BIT {
	private long[] bit;
 
    public BIT(int size){
        bit = new long[size];
    }
 
    public long sum(int i){
        long s = 0;
        while(0 < i){
            s += bit[i];
            i -= i & -i;
        }
        return s;
    }
 
    public void add(int i, long x){
        while(i < bit.length){
            bit[i] += x;
            i += i & -i;
        }
    }
}


</source>
<source file="../hum_codes_raw/s978370901.java" startline="1" endline="68" pcid="33732">
import java.util.*;
import java.util.stream.*;

public class Main {

	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		int n = in.nextInt();
		int[] arr = new int[n];
		for (int i = 0; i < n; i++) {
			arr[i] = in.nextInt();
		}
		int[] copy = Arrays.copyOf(arr, arr.length);
		Arrays.sort(copy);

		int left = 0, right = n;
		long x = (long)n * (long)(n + 1) / 4;
		while(left + 1 < right) {
			int mid = (left + right) / 2;
			int am = copy[mid];
			int[] s = new int[n + 1];
			for (int i = 0; i < n; i++) {
				s[i + 1] = am <= arr[i] ? 1 : -1;
			}
			for (int i = 1; i < n + 1; i++) {
				s[i] += s[i - 1];
			}
			BIT bit = new BIT(2 * n + 1);
			long sum = 0;
			for (int i = 0; i < n + 1; i++) {
				sum += bit.sum(s[i] + n);
				bit.add(s[i] + n, 1);
			}
			if(x <= sum) {
				left = mid;
			} else {
				right = mid;
			}
		}
		System.out.println(copy[left]);
	}
}

class BIT {
	private long[] bit;
 
    public BIT(int size){
        bit = new long[size];
    }
 
    public long sum(int i){
        long s = 0;
        while(0 < i){
            s += bit[i];
            i -= i & -i;
        }
        return s;
    }
 
    public void add(int i, long x){
        while(i < bit.length){
            bit[i] += x;
            i += i & -i;
        }
    }
}


</source>
</class>

<class classid="59" nclones="2" nlines="71" similarity="100">
<source file="../hum_codes_raw/s094370522.java" startline="1" endline="84" pcid="3132">
import java.util.*;
public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();
		long M = sc.nextLong();
		int A[] = new int[N];
		for(int i=0;i<N;i++)A[i]=sc.nextInt();
 		sc.close();
 		
 		rsort(A);
 		
 		//２数の和がKを越えるものだけ使うことにする。
 		int R = 2*100000 + 100;
 		int L = 0;
 		while(L+1<R) {		
 			int C = (L+R)/2;//このcが実現できるか調べるK
 			long subsum = 0;
 			for(int i=0;i<N;i++) {
 				int base = A[i];
 				int r = N;
 				int l = i-1;
 				while(l+1<r) {
 					int c = (l + r)/2;
 					if(base + A[c]>=C)l=c;
 					else r = c;
 				}
 				if(l-i<0)continue;
 				subsum += 1 + 2*(l-i);
 			}
 			if(subsum>=M) L = C;
 			else R = C;
 		}
 		//Lが最大のK
 		
 		long memosum = 0;
 		int min = Integer.MAX_VALUE;
 		int memo[] = new int[N];
 		for(int i=0;i<N;i++) {
				int base = A[i];
				int r = N;
				int l = i-1;
				while(l+1<r) {
					int c = (l + r)/2;
					if(base + A[c]>=L)l=c;
					else r = c;
				}
				memo[i]=l-i; 
				
				if(l-i>=0) {
					memosum += 2*(l-i)+1;
					min = Math.min(min,base+A[l]);
				}
				
			}
 		
 		
 		
 		long sum[] = new long[N+1];
 		for(int i=0;i<N;i++)sum[i+1]=sum[i]+ A[i];
 		
 		long ans = 0;
 		for(int i=0;i<N;i++) {
 			if(memo[i]<0)break;
			int last = i+memo[i];
			long tmp = ((long)last-i+1)*2*A[i]+2*(sum[last+1]-sum[i+1]);
			ans += tmp;
 		}
 		long mul = Math.max(0,memosum-M);
 		ans -= mul*min;
 		System.out.println(ans);
	}
	
	static void rsort(int[] x) {
		Arrays.sort(x);
		int len = x.length;
		for(int i=0;i<len/2;i++) {
			int tmp = x[i];
			x[i]=x[len-1-i];
			x[len-1-i]=tmp;
		}
	}
}

</source>
<source file="../hum_codes_raw/s526440712.java" startline="1" endline="84" pcid="17705">
import java.util.*;
public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();
		long M = sc.nextLong();
		int A[] = new int[N];
		for(int i=0;i<N;i++)A[i]=sc.nextInt();
 		sc.close();
 		
 		rsort(A);
 		
 		//２数の和がKを越えるものだけ使うことにする。
 		int R = 2*100000 + 100;
 		int L = 0;
 		while(L+1<R) {		
 			int C = (L+R)/2;//このcが実現できるか調べるK
 			long subsum = 0;
 			for(int i=0;i<N;i++) {
 				int base = A[i];
 				int r = N;
 				int l = i-1;
 				while(l+1<r) {
 					int c = (l + r)/2;
 					if(base + A[c]>=C)l=c;
 					else r = c;
 				}
 				if(l-i<0)continue;
 				subsum += 1 + 2*(l-i);
 			}
 			if(subsum>=M) L = C;
 			else R = C;
 		}
 		//Lが最小のX
 		
 		long memosum = 0;
 		int min = Integer.MAX_VALUE;
 		int memo[] = new int[N];
 		for(int i=0;i<N;i++) {
				int base = A[i];
				int r = N;
				int l = i-1;
				while(l+1<r) {
					int c = (l + r)/2;
					if(base + A[c]>=L)l=c;
					else r = c;
				}
				memo[i]=l-i; //到着要素番号が入ってる
				
				if(l-i>=0) {
					memosum += 2*(l-i)+1;
					min = Math.min(min,base+A[l]);
				}
				
			}
 		
 		
 		
 		long sum[] = new long[N+1];
 		for(int i=0;i<N;i++)sum[i+1]=sum[i]+ A[i];
 		
 		long ans = 0;
 		for(int i=0;i<N;i++) {
 			if(memo[i]<0)break;
			int last = i+memo[i];
			long tmp = ((long)last-i+1)*2*A[i]+2*(sum[last+1]-sum[i+1]);
			ans += tmp;
 		}
 		long mul = Math.max(0,memosum-M);
 		ans -= mul*min;
 		System.out.println(ans);
	}
	
	static void rsort(int[] x) {
		Arrays.sort(x);
		int len = x.length;
		for(int i=0;i<len/2;i++) {
			int tmp = x[i];
			x[i]=x[len-1-i];
			x[len-1-i]=tmp;
		}
	}
}

</source>
</class>

<class classid="60" nclones="3" nlines="13" similarity="100">
<source file="../hum_codes_raw/s096359768.java" startline="1" endline="15" pcid="3200">
import java.util.Scanner;

public class Main {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        String s = sc.next();
        if (s.equals("ABC")) {
            System.out.println("ARC");
        }
        else {
            System.out.println("ABC");
        }
    }
}

</source>
<source file="../hum_codes_raw/s526399829.java" startline="1" endline="21" pcid="17703">
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        // 整数の入力
        String s = sc.next();

        if (s.equals("ABC")) {
            System.out.println("ARC");
        } else {
            System.out.println("ABC");
        }



    }
}

</source>
<source file="../hum_codes_raw/s228573371.java" startline="1" endline="15" pcid="7721">
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		String s = sc.next();
		if(s.equals("ABC")) {
			System.out.println("ARC");
		}else {
			System.out.println("ABC");
		}

	}
}

</source>
</class>

<class classid="61" nclones="2" nlines="18" similarity="100">
<source file="../hum_codes_raw/s098211726.java" startline="1" endline="24" pcid="3264">
import  java.util.Scanner;

public class Main {
	
	void run(){
		Scanner sc = new Scanner(System.in);
		char[] s = sc.next().toCharArray();
		int[] c = new int[4];
		for(int i=0;i<s.length;i++) {
			if(s[i]=='K')c[0]++;
			if(s[i]=='U')c[1]++;
			if(s[i]=='P')c[2]++;
			if(s[i]=='C')c[3]++;
		}
		System.out.println(Math.min(c[0], Math.min(c[1], Math.min(c[2], c[3]))));
	}

	public static void main(String[] args) {
		new Main().run();
	}

}


</source>
<source file="../hum_codes_raw/s725029473.java" startline="1" endline="22" pcid="24382">
import java.util.Scanner;

public class Main{

	void run(){
		Scanner sc = new Scanner(System.in);
		char[] s = sc.next().toCharArray();
		int[] c = new int[4];
		for(int i=0;i<s.length;i++){
			if(s[i]=='K')c[0]++;
			if(s[i]=='U')c[1]++;
			if(s[i]=='P')c[2]++;
			if(s[i]=='C')c[3]++;
		}
		System.out.println(Math.min(c[0], Math.min(c[1], Math.min(c[2], c[3]))));
	}
	
	public static void main(String[] args) {
		new Main().run();
	}
}

</source>
</class>

<class classid="62" nclones="2" nlines="17" similarity="100">
<source file="../hum_codes_raw/s098592178.java" startline="1" endline="23" pcid="3275">
import java.util.Scanner;

//Room Numbers of a Hospital
public class Main{

	static int[] t = {0,1,2,3,5,7,8,9};
	
	static void f(int n){
		if(n>=8)f(n/8);
		System.out.print(t[n%8]);
	}
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int n = sc.nextInt();
			if(n==0)break;
			f(n);
			System.out.println();
		}
	}
}

</source>
<source file="../hum_codes_raw/s933896254.java" startline="1" endline="23" pcid="31403">
import java.util.Scanner;

//Room Numbers of a Hospital
public class Main {

	static int[] t = {0,1,2,3,5,7,8,9};
	
	static void f(int n){
		if(n>=8)f(n/8);
		System.out.print(t[n%8]);
	}
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int n = sc.nextInt();
			if(n==0)break;
			f(n);
			System.out.println();
		}
	}
}

</source>
</class>

<class classid="63" nclones="2" nlines="88" similarity="100">
<source file="../hum_codes_raw/s098922862.java" startline="1" endline="96" pcid="3291">
import java.util.*;

public class Main{
    int N,M,L,K,A,H;
    int[] d;
    List<Edge>[] adj;
    int INF = 1000000000;
    boolean[] cancold;

    public static void main(String[] args){
	new Main().solve();
    }

    class Edge{
	int t, c;
	public Edge(int t, int c) {
	    this.t = t;
	    this.c = c;
	}
    }

    @SuppressWarnings("unchecked")
    void solve(){
	Scanner sc = new Scanner(System.in);
	N = sc.nextInt();
	while(N!=0){
	    M = sc.nextInt();
	    L = sc.nextInt();
	    K = sc.nextInt();
	    A = sc.nextInt();
	    H = sc.nextInt();
	    cancold = new boolean[N];
	    for(int i=0; i<L; i++){
		cancold[sc.nextInt()] = true;
	    }
	    cancold[A] = true; cancold[H] = true;
	    
	    adj = new List[N];
	    for(int i=0; i<N; i++)adj[i] = new ArrayList<Edge>();
	    for(int i=0; i<K; i++){
		int x = sc.nextInt();
		int y = sc.nextInt();
		int t = sc.nextInt();
		adj[x].add(new Edge(y,t));
		adj[y].add(new Edge(x,t));
	    }

	    d = new int[N*(M+1)];

	    dijkstra(A);

	    if(d[H*(M+1)+M]==INF){
		System.out.println("Help!");
	    }else{
		System.out.println(d[H*(M+1)+M]+Math.max(0,d[H*(M+1)+M]-M));
	    }

	    N = sc.nextInt();
	}
    }

    void dijkstra(int s){
	Arrays.fill(d,INF);
	d[s*(M+1)+M] = 0;
	PriorityQueue<Integer> q = new PriorityQueue<Integer>(N, new Comparator<Integer>() {
		public int compare(Integer o1, Integer o2) {
		    return d[o1]-d[o2];
		}
	    });

	q.add(s*(M+1)+M);
	while(!q.isEmpty()){
	    int v = q.poll();
	    int town = v/(M+1);
	    int left = v%(M+1);
	    for(Edge e:adj[town]){
		if(left-e.c<0)continue;
		int w = d[town*(M+1)+left]+e.c;
		if(cancold[e.t]){
		    if(w<d[e.t*(M+1)+M]){
			q.remove(e.t*(M+1)+M); 
			d[e.t*(M+1)+M] = w; 
			q.add(e.t*(M+1)+M);
		    }
		}else{
		    if(w<d[e.t*(M+1)+left-e.c]){
			q.remove(e.t*(M+1)+left-e.c); 
			d[e.t*(M+1)+left-e.c] = w; 
			q.add(e.t*(M+1)+left-e.c);
		    }
		}
	    }
	}
    }
}

</source>
<source file="../hum_codes_raw/s694646836.java" startline="1" endline="96" pcid="23370">
import java.util.*;

public class Main{
    int N,M,L,K,A,H;
    int[] d;
    List<Edge>[] adj;
    int INF = 1000000000;
    boolean[] cancold;

    public static void main(String[] args){
	new Main().solve();
    }

    class Edge{
	int t, c;
	public Edge(int t, int c) {
	    this.t = t;
	    this.c = c;
	}
    }

    @SuppressWarnings("unchecked")
    void solve(){
	Scanner sc = new Scanner(System.in);
	N = sc.nextInt();
	while(N!=0){
	    M = sc.nextInt();
	    L = sc.nextInt();
	    K = sc.nextInt();
	    A = sc.nextInt();
	    H = sc.nextInt();
	    cancold = new boolean[N];
	    for(int i=0; i<L; i++){
		cancold[sc.nextInt()] = true;
	    }
	    cancold[A] = true; cancold[H] = true;
	    
	    adj = new List[N];
	    for(int i=0; i<N; i++)adj[i] = new ArrayList<Edge>();
	    for(int i=0; i<K; i++){
		int x = sc.nextInt();
		int y = sc.nextInt();
		int t = sc.nextInt();
		adj[x].add(new Edge(y,t));
		adj[y].add(new Edge(x,t));
	    }

	    d = new int[N*(M+1)];

	    dijkstra(A);

	    if(d[H*(M+1)+M]==INF){
		System.out.println("Help!");
	    }else{
		System.out.println(d[H*(M+1)+M]+Math.max(0,d[H*(M+1)+M]-M));
	    }

	    N = sc.nextInt();
	}
    }

    void dijkstra(int s){
	Arrays.fill(d,INF);
	d[s*(M+1)+M] = 0;
	PriorityQueue<Integer> q = new PriorityQueue<Integer>(N, new Comparator<Integer>() {
		public int compare(Integer o1, Integer o2) {
		    return d[o1]-d[o2];
		}
	    });

	q.add(s*(M+1)+M);
	while(!q.isEmpty()){
	    int v = q.poll();
	    int town = v/(M+1);
	    int left = v%(M+1);
	    for(Edge e:adj[town]){
		if(left-e.c<0)continue;
		int w = d[town*(M+1)+left]+e.c;
		if(cancold[e.t]){
		    if(w<d[e.t*(M+1)+M]){
			q.remove(e.t*(M+1)+M); 
			d[e.t*(M+1)+M] = w; 
			q.add(e.t*(M+1)+M);
		    }
		}else{
		    if(w<d[e.t*(M+1)+left-e.c]){
			q.remove(e.t*(M+1)+left-e.c); 
			d[e.t*(M+1)+left-e.c] = w; 
			q.add(e.t*(M+1)+left-e.c);
		    }
		}
	    }
	}
    }
}

</source>
</class>

<class classid="64" nclones="2" nlines="40" similarity="100">
<source file="../hum_codes_raw/s100508872.java" startline="1" endline="57" pcid="3352">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

  public static void main(String[] args) {
    
    new Main().run();
  }

  private void run() {

    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      int heapSize = Integer.parseInt(br.readLine());
      String[] keys = br.readLine().split(" ");
      int[] mHeap = new int[heapSize+1];
      mHeap[0] = heapSize;
      for(int i=1; i<=heapSize; i++)
        mHeap[i] = Integer.parseInt( keys[i-1] );

      buildMaxHeap(mHeap);

      StringBuilder buf = new StringBuilder();
      for(int i=1; i<mHeap.length; i++) 
        buf.append(" ").append(mHeap[i]);

      System.out.println(buf);
    } catch(IOException e) {
      System.out.println("IOException!");
    }
  }
  private void buildMaxHeap(int[] heap) {
    for(int i= heap[0]/2; i>0; i--)
      maxHeapify(heap, i);
  }
  private void maxHeapify(int[] heap, int node) {
    int t,left,right,largest;
    left  = node*2;
    right = left+1;

    if( (left <= heap[0]) && (heap[left] > heap[node]) )
      largest = left;
    else
      largest = node;
    if( (right <= heap[0]) && (heap[right] > heap[largest]) )
      largest = right;

    if( largest != node ) {
      t = heap[node]; heap[node] = heap[largest]; heap[largest] = t;

      maxHeapify(heap, largest);
    }
  }
}

</source>
<source file="../hum_codes_raw/s983166256.java" startline="1" endline="57" pcid="33063">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

  public static void main(String[] args) {
    
    new Main().run();
  }

  private void run() {

    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      int heapSize = Integer.parseInt(br.readLine());
      String[] keys = br.readLine().split(" ");
      int[] mHeap = new int[heapSize+1];
      mHeap[0] = heapSize;
      for(int i=1; i<=heapSize; i++)
        mHeap[i] = Integer.parseInt( keys[i-1] );

      buildMaxHeap(mHeap);

      StringBuilder buf = new StringBuilder();
      for(int i=1; i<mHeap.length; i++) 
        buf.append(" ").append(mHeap[i]);

      System.out.println(buf);
    } catch(IOException e) {
      System.out.println("IOException!");
    }
  }
  private void buildMaxHeap(int[] heap) {
    for(int i= heap[0]/2; i>0; i--)
      maxHeapify(heap, i);
  }
  private void maxHeapify(int[] heap, int node) {
    int t,left,right,largest;
    left  = node*2;
    right = left+1;

    if( (left <= heap[0]) && (heap[left] > heap[node]) )
      largest = left;
    else
      largest = node;
    if( (right <= heap[0]) && (heap[right] > heap[largest]) )
      largest = right;

    if( largest != node ) {
      t = heap[node]; heap[node] = heap[largest]; heap[largest] = t;

      maxHeapify(heap, largest);
    }
  }
}

</source>
</class>

<class classid="65" nclones="3" nlines="16" similarity="100">
<source file="../hum_codes_raw/s102867034.java" startline="1" endline="23" pcid="3426">
import java.util.*;

public class Main{
  static final double EPS = 0.00001;

  public static void main(String[] args){
    Scanner sc = new Scanner(System.in);

    while(true){
      double q = sc.nextInt();
      if(q < 0) break;

      double x = q / 2.0;

      while(Math.abs(x * x * x - q) >= EPS * q){
        x = x - (x * x * x - q) / (3 * x * x);
      }

      System.out.printf("%.6f\n", x);
    }
  }
}

</source>
<source file="../hum_codes_raw/s466374966.java" startline="1" endline="24" pcid="15652">
import java.util.*;

public class Main {
    static final double EPS = 0.00001;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        while (true) {
            double q = sc.nextInt();
            if (q < 0)
                break;

            double x = q / 2.0;

            while (Math.abs(x * x * x - q) >= EPS * q) {
                x = x - (x * x * x - q) / (3 * x * x);
            }

            System.out.printf("%.6f\n", x);
        }
    }
}

</source>
<source file="../hum_codes_raw/s853953365.java" startline="1" endline="23" pcid="28705">
import java.util.*;
 
public class Main{
  static final double EPS = 0.00001;
 
  public static void main(String[] args){
    Scanner sc = new Scanner(System.in);
 
    while(true){
      double q = sc.nextInt();
      if(q < 0) break;
 
      double x = q / 2.0;
 
      while(Math.abs(x * x * x - q) >= EPS * q){
        x = x - (x * x * x - q) / (3 * x * x);
      }
 
      System.out.printf("%.6f\n", x);
    }
  }
}

</source>
</class>

<class classid="66" nclones="2" nlines="242" similarity="100">
<source file="../hum_codes_raw/s106468442.java" startline="1" endline="282" pcid="3546">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.Arrays;

public class Main {

	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		MyInput in = new MyInput(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		TaskX solver = new TaskX();
		solver.solve(1, in, out);
		out.close();
	}

	static int INF = 1 << 30;
	static long LINF = 1L << 55;
	static int MOD = 1000000007;
	static int[] mh4 = { 0, -1, 1, 0 };
	static int[] mw4 = { -1, 0, 0, 1 };
	static int[] mh8 = { -1, -1, -1, 0, 0, 1, 1, 1 };
	static int[] mw8 = { -1, 0, 1, -1, 1, -1, 0, 1 };

	static class TaskX {

		int n, q;
		long[] a;
		public void solve(int testNumber, MyInput in, PrintWriter out) {

			n = in.nextInt(); q = in.nextInt();
			a = in.nextLongArray(n);
			long[] sum = new long[n], odd = new long[n], even = new long[n];
			for (int i = 0; i < n; i++) {
				sum[i] = (i-1 >= 0 ? sum[i-1] : 0) + a[i];
				even[i] = (i-1 >= 0 ? even[i-1] : 0) + (i % 2 == 0 ? a[i] : 0);
				odd[i] = (i-1 >= 0 ? odd[i-1] : 0) + (i % 2 == 1 ? a[i] : 0);
			}

			while (q-- > 0) {
				long x = in.nextLong();
				int ok = 1, ng = n;
				while (ng - ok > 1) {
					int k = (ok + ng) / 2;
					if (check(k, x)) {
						ok = k;
					} else {
						ng = k;
					}
				}

				long ans = sum[n - 1] - sum[n - ok - 1];
				if (n % 2 == 0) {
					ans += n - 2*ok - 1 >= 0 ? odd[n - 2*ok - 1] : 0;
				} else {
					ans += n - 2*ok - 1 >= 0 ? even[n - 2*ok - 1] : 0;
				}

				out.println(ans);
			}

		}

		// 高橋くんが上からk枚とることができるかどうか
		boolean check(int k, long x) {
			if (k > n) return false;
			long d = a[n-k] - x;
			int s = lowerBound(a, x - d);

			// 青木くんが a[n-k] を選ぶのが何番目になるか。
			// 閉区間 [a[n-k] - x, a[n-k] + x] に含まれる数をすべて選ぶので、その個数番目
			int m = (n - 1 - k + 1) - (s - 1);

			// 高橋くんが a[n-k] 番目を選ぶ場合に青木くんが k 番目以上に選ぶのであれば
			// まだ a[n-k] は残っているので上から k 枚をとることが可能
			return m >= k;
		}
	}

	public static int lowerBound(long[] a, long obj) {
		int l = 0, r = a.length - 1;
		while (r - l >= 0) {
			int c = (l + r) / 2;
			if (obj <= a[c]) {
				r = c - 1;
			} else {
				l = c + 1;
			}
		}
		return l;
	}

	static class MyInput {
		private final BufferedReader in;
		private static int pos;
		private static int readLen;
		private static final char[] buffer = new char[1024 * 8];
		private static char[] str = new char[500 * 8 * 2];
		private static boolean[] isDigit = new boolean[256];
		private static boolean[] isSpace = new boolean[256];
		private static boolean[] isLineSep = new boolean[256];

		static {
			for (int i = 0; i < 10; i++) {
				isDigit['0' + i] = true;
			}
			isDigit['-'] = true;
			isSpace[' '] = isSpace['\r'] = isSpace['\n'] = isSpace['\t'] = true;
			isLineSep['\r'] = isLineSep['\n'] = true;
		}

		public MyInput(InputStream is) {
			in = new BufferedReader(new InputStreamReader(is));
		}

		public int read() {
			if (pos >= readLen) {
				pos = 0;
				try {
					readLen = in.read(buffer);
				} catch (IOException e) {
					throw new RuntimeException();
				}
				if (readLen <= 0) {
					throw new MyInput.EndOfFileRuntimeException();
				}
			}
			return buffer[pos++];
		}

		public int nextInt() {
			int len = 0;
			str[len++] = nextChar();
			len = reads(len, isSpace);
			int i = 0;
			int ret = 0;
			if (str[0] == '-') {
				i = 1;
			}
			for (; i < len; i++)
				ret = ret * 10 + str[i] - '0';
			if (str[0] == '-') {
				ret = -ret;
			}
			return ret;
		}

		public long nextLong() {
			int len = 0;
			str[len++] = nextChar();
			len = reads(len, isSpace);
			int i = 0;
			long ret = 0;
			if (str[0] == '-') {
				i = 1;
			}
			for (; i < len; i++)
				ret = ret * 10 + str[i] - '0';
			if (str[0] == '-') {
				ret = -ret;
			}
			return ret;
		}

		public char nextChar() {
			while (true) {
				final int c = read();
				if (!isSpace[c]) {
					return (char) c;
				}
			}
		}

		public String nextString() {
			return new String(nextChars());
		}

		public char[] nextChars() {
			int len = 0;
			str[len++] = nextChar();
			len = reads(len, isSpace);
			return Arrays.copyOf(str, len);
		}

		public char[][] next2DChars(int h, int w) {
			char[][] s = new char[h][w];
			for (int i = 0; i < h; i++) {
				s[i] = nextChars();
			}
			return s;
		}

		int reads(int len, boolean[] accept) {
			try {
				while (true) {
					final int c = read();
					if (accept[c]) {
						break;
					}
					if (str.length == len) {
						char[] rep = new char[str.length * 3 / 2];
						System.arraycopy(str, 0, rep, 0, str.length);
						str = rep;
					}
					str[len++] = (char) c;
				}
			} catch (MyInput.EndOfFileRuntimeException e) {
			}
			return len;
		}

		public int[] nextIntArray(final int n) {
			final int[] res = new int[n];
			for (int i = 0; i < n; i++) {
				res[i] = nextInt();
			}
			return res;
		}

		public int[] nextIntArray1Index(final int n) {
			final int[] res = new int[n + 1];
			for (int i = 1; i < n + 1; i++) {
				res[i] = nextInt();
			}
			return res;
		}

		public int[] nextIntArrayDec(final int n) {
			final int[] res = new int[n];
			for (int i = 0; i < n; i++) {
				res[i] = nextInt() - 1;
			}
			return res;
		}

		public long[] nextLongArray(final int n) {
			final long[] res = new long[n];
			for (int i = 0; i < n; i++) {
				res[i] = nextLong();
			}
			return res;
		}

		public long[] nextLongArray1Index(final int n) {
			final long[] res = new long[n + 1];
			for (int i = 1; i < n + 1; i++) {
				res[i] = nextLong();
			}
			return res;
		}

		public long[] nextLongArrayDec(final int n) {
			final long[] res = new long[n];
			for (int i = 0; i < n; i++) {
				res[i] = nextLong() - 1;
			}
			return res;
		}

		public double nextDouble() {
			return Double.parseDouble(nextString());
		}

		public double[] nextDoubleArray(int n) {
			double[] res = new double[n];
			for (int i = 0; i < n; i++) {
				res[i] = nextDouble();
			}
			return res;
		}

		static class EndOfFileRuntimeException extends RuntimeException {
		}

	}

}

</source>
<source file="../hum_codes_raw/s723652719.java" startline="1" endline="282" pcid="24336">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.Arrays;

public class Main {

	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		MyInput in = new MyInput(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		TaskX solver = new TaskX();
		solver.solve(1, in, out);
		out.close();
	}

	static int INF = 1 << 30;
	static long LINF = 1L << 55;
	static int MOD = 1000000007;
	static int[] mh4 = { 0, -1, 1, 0 };
	static int[] mw4 = { -1, 0, 0, 1 };
	static int[] mh8 = { -1, -1, -1, 0, 0, 1, 1, 1 };
	static int[] mw8 = { -1, 0, 1, -1, 1, -1, 0, 1 };

	static class TaskX {

		int n, q;
		long[] a;
		public void solve(int testNumber, MyInput in, PrintWriter out) {

			n = in.nextInt(); q = in.nextInt();
			a = in.nextLongArray(n);
			long[] sum = new long[n], odd = new long[n], even = new long[n];
			for (int i = 0; i < n; i++) {
				sum[i] = (i-1 >= 0 ? sum[i-1] : 0) + a[i];
				even[i] = (i-1 >= 0 ? even[i-1] : 0) + (i % 2 == 0 ? a[i] : 0);
				odd[i] = (i-1 >= 0 ? odd[i-1] : 0) + (i % 2 == 1 ? a[i] : 0);
			}

			while (q-- > 0) {
				long x = in.nextLong();
				int ok = 1, ng = n;
				while (ng - ok > 1) {
					int k = (ok + ng) / 2;
					if (check(k, x)) {
						ok = k;
					} else {
						ng = k;
					}
				}

				long ans = sum[n - 1] - sum[n - ok - 1];
				if (n % 2 == 0) {
					ans += n - 2*ok - 1 >= 0 ? odd[n - 2*ok - 1] : 0;
				} else {
					ans += n - 2*ok - 1 >= 0 ? even[n - 2*ok - 1] : 0;
				}

				out.println(ans);
			}

		}

		// 高橋くんが上からk枚とることができるかどうか
		boolean check(int k, long x) {
			if (k > n) return false;
			long d = a[n-k] - x;
			int s = lowerBound(a, x - d);

			// 青木くんが a[n-k] を選ぶのが何番目になるか。
			// 閉区間 [x - d, x + d] に含まれる数をすべて選ぶので、その個数番目
			int m = (n - 1 - k + 1) - (s - 1);

			// 高橋くんが a[n-k] 番目を選ぶ場合に青木くんが k 番目以上に選ぶのであれば
			// まだ a[n-k] は残っているので上から k 枚をとることが可能
			return m >= k;
		}
	}

	public static int lowerBound(long[] a, long obj) {
		int l = 0, r = a.length - 1;
		while (r - l >= 0) {
			int c = (l + r) / 2;
			if (obj <= a[c]) {
				r = c - 1;
			} else {
				l = c + 1;
			}
		}
		return l;
	}

	static class MyInput {
		private final BufferedReader in;
		private static int pos;
		private static int readLen;
		private static final char[] buffer = new char[1024 * 8];
		private static char[] str = new char[500 * 8 * 2];
		private static boolean[] isDigit = new boolean[256];
		private static boolean[] isSpace = new boolean[256];
		private static boolean[] isLineSep = new boolean[256];

		static {
			for (int i = 0; i < 10; i++) {
				isDigit['0' + i] = true;
			}
			isDigit['-'] = true;
			isSpace[' '] = isSpace['\r'] = isSpace['\n'] = isSpace['\t'] = true;
			isLineSep['\r'] = isLineSep['\n'] = true;
		}

		public MyInput(InputStream is) {
			in = new BufferedReader(new InputStreamReader(is));
		}

		public int read() {
			if (pos >= readLen) {
				pos = 0;
				try {
					readLen = in.read(buffer);
				} catch (IOException e) {
					throw new RuntimeException();
				}
				if (readLen <= 0) {
					throw new MyInput.EndOfFileRuntimeException();
				}
			}
			return buffer[pos++];
		}

		public int nextInt() {
			int len = 0;
			str[len++] = nextChar();
			len = reads(len, isSpace);
			int i = 0;
			int ret = 0;
			if (str[0] == '-') {
				i = 1;
			}
			for (; i < len; i++)
				ret = ret * 10 + str[i] - '0';
			if (str[0] == '-') {
				ret = -ret;
			}
			return ret;
		}

		public long nextLong() {
			int len = 0;
			str[len++] = nextChar();
			len = reads(len, isSpace);
			int i = 0;
			long ret = 0;
			if (str[0] == '-') {
				i = 1;
			}
			for (; i < len; i++)
				ret = ret * 10 + str[i] - '0';
			if (str[0] == '-') {
				ret = -ret;
			}
			return ret;
		}

		public char nextChar() {
			while (true) {
				final int c = read();
				if (!isSpace[c]) {
					return (char) c;
				}
			}
		}

		public String nextString() {
			return new String(nextChars());
		}

		public char[] nextChars() {
			int len = 0;
			str[len++] = nextChar();
			len = reads(len, isSpace);
			return Arrays.copyOf(str, len);
		}

		public char[][] next2DChars(int h, int w) {
			char[][] s = new char[h][w];
			for (int i = 0; i < h; i++) {
				s[i] = nextChars();
			}
			return s;
		}

		int reads(int len, boolean[] accept) {
			try {
				while (true) {
					final int c = read();
					if (accept[c]) {
						break;
					}
					if (str.length == len) {
						char[] rep = new char[str.length * 3 / 2];
						System.arraycopy(str, 0, rep, 0, str.length);
						str = rep;
					}
					str[len++] = (char) c;
				}
			} catch (MyInput.EndOfFileRuntimeException e) {
			}
			return len;
		}

		public int[] nextIntArray(final int n) {
			final int[] res = new int[n];
			for (int i = 0; i < n; i++) {
				res[i] = nextInt();
			}
			return res;
		}

		public int[] nextIntArray1Index(final int n) {
			final int[] res = new int[n + 1];
			for (int i = 1; i < n + 1; i++) {
				res[i] = nextInt();
			}
			return res;
		}

		public int[] nextIntArrayDec(final int n) {
			final int[] res = new int[n];
			for (int i = 0; i < n; i++) {
				res[i] = nextInt() - 1;
			}
			return res;
		}

		public long[] nextLongArray(final int n) {
			final long[] res = new long[n];
			for (int i = 0; i < n; i++) {
				res[i] = nextLong();
			}
			return res;
		}

		public long[] nextLongArray1Index(final int n) {
			final long[] res = new long[n + 1];
			for (int i = 1; i < n + 1; i++) {
				res[i] = nextLong();
			}
			return res;
		}

		public long[] nextLongArrayDec(final int n) {
			final long[] res = new long[n];
			for (int i = 0; i < n; i++) {
				res[i] = nextLong() - 1;
			}
			return res;
		}

		public double nextDouble() {
			return Double.parseDouble(nextString());
		}

		public double[] nextDoubleArray(int n) {
			double[] res = new double[n];
			for (int i = 0; i < n; i++) {
				res[i] = nextDouble();
			}
			return res;
		}

		static class EndOfFileRuntimeException extends RuntimeException {
		}

	}

}

</source>
</class>

<class classid="67" nclones="2" nlines="81" similarity="100">
<source file="../hum_codes_raw/s112957949.java" startline="1" endline="97" pcid="3756">
import java.util.*;
import java.lang.*;
import java.math.*;
import java.io.*;
import static java.lang.Math.*;
import static java.util.Arrays.*;
import static java.util.Collections.*;

public class Main{
	Scanner sc=new Scanner(System.in);

	int INF=1<<28;
	double EPS=1e-12;

	int n;
	int[] pow;
	String[] names;
	HashSet<String>[] sets;

	@SuppressWarnings("unchecked")
	void run(){
		for(;;){
			n=sc.nextInt();
			if(n==0){
				break;
			}
			names=new String[n];
			pow=new int[n];
			sets=new HashSet[n];
			for(int j=0; j<n; j++){
				names[j]=sc.next();
				pow[j]=sc.nextInt();
				sets[j]=new HashSet<String>();
				int m=sc.nextInt();
				for(int i=0; i<m; i++){
					sets[j].add(sc.next());
				}
			}
			solve();
		}
	}

	long[] g;
	int ans;

	void solve(){
		HashMap<String, Integer> map=new HashMap<String, Integer>();
		for(int i=0; i<n; i++){
			map.put(names[i], i);
		}
		g=new long[n];
		for(int i=0; i<n; i++){
			for(String s : sets[i]){
				int j=map.get(s);
				g[i]|=1L<<j;
			}
		}
		ans=0;
		mis(1, 1, pow[0]);
		println(ans+"");
	}

	void mis(int k, long choosed, int sum){
		if(k==n){
			// TODO
			ans=max(ans, sum);
			return;
		}
		if((choosed&g[k])==0){
			mis(k+1, choosed|(1L<<k), sum+pow[k]);
			long rem=0;
			for(int i=k+1; i<n; i++)
				if((choosed&g[i])==0)
					rem|=g[i];
			if((rem>>>k&1)==0)
				return;
		}
		mis(k+1, choosed, sum);
	}

	void debug(Object... os){
		System.err.println(Arrays.deepToString(os));
	}

	void print(String s){
		System.out.print(s);
	}

	void println(String s){
		System.out.println(s);
	}

	public static void main(String[] args){
		new Main().run();
	}
}

</source>
<source file="../hum_codes_raw/s285786399.java" startline="1" endline="97" pcid="9584">
import java.util.*;
import java.lang.*;
import java.math.*;
import java.io.*;
import static java.lang.Math.*;
import static java.util.Arrays.*;
import static java.util.Collections.*;

public class Main{
	Scanner sc=new Scanner(System.in);

	int INF=1<<28;
	double EPS=1e-12;

	int n;
	int[] pow;
	String[] names;
	HashSet<String>[] sets;

	@SuppressWarnings("unchecked")
	void run(){
		for(;;){
			n=sc.nextInt();
			if(n==0){
				break;
			}
			names=new String[n];
			pow=new int[n];
			sets=new HashSet[n];
			for(int j=0; j<n; j++){
				names[j]=sc.next();
				pow[j]=sc.nextInt();
				sets[j]=new HashSet<String>();
				int m=sc.nextInt();
				for(int i=0; i<m; i++){
					sets[j].add(sc.next());
				}
			}
			solve();
		}
	}

	long[] g;
	int ans;

	void solve(){
		HashMap<String, Integer> map=new HashMap<String, Integer>();
		for(int i=0; i<n; i++){
			map.put(names[i], i);
		}
		g=new long[n];
		for(int i=0; i<n; i++){
			for(String s : sets[i]){
				int j=map.get(s);
				g[i]|=1L<<j;
			}
		}
		ans=0;
		mis(1, 1, pow[0]);
		println(ans+"");
	}

	void mis(int k, long choosed, int sum){
		if(k==n){
			// TODO
			ans=max(ans, sum);
			return;
		}
		if((choosed&g[k])==0){
			mis(k+1, choosed|(1L<<k), sum+pow[k]);
			long rem=0;
			for(int i=k+1; i<n; i++)
				if((choosed&g[i])==0)
					rem|=g[i];
			if((rem>>>k&1)==0)
				return;
		}
		mis(k+1, choosed, sum);
	}

	void debug(Object... os){
		System.err.println(Arrays.deepToString(os));
	}

	void print(String s){
		System.out.print(s);
	}

	void println(String s){
		System.out.println(s);
	}

	public static void main(String[] args){
		new Main().run();
	}
}

</source>
</class>

<class classid="68" nclones="2" nlines="125" similarity="100">
<source file="../hum_codes_raw/s117325689.java" startline="1" endline="158" pcid="3918">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
 
public class Main {
	private	static	BufferedReader	br = null;
	private	static	double[][]		cd = null;
	private	static	int[]			rr = { Integer.MAX_VALUE, Integer.MIN_VALUE };

	static {
		br = new BufferedReader(new InputStreamReader(System.in));
	}
 
    /**
     * @param args
     */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int		size = 0;
		Data	data = null;
		DataTbl	tbl  = new DataTbl();
		
		while ((data = parseData()) != null) {
			tbl.add(data);
		}

		calcDist();

		size = tbl.size();
		for (int i = 0; i < size; i++) {
			data = tbl.get(i);
			System.out.println(solve(data));
		}
	}

	public static String solve(Data data) {
		String	res = "NA";
		double	min = Double.MAX_VALUE;
		double	tmp = 0.0;

		do {
			tmp = (double)data.cr[0]+(double)data.cr[data.cr.length-1];
			for (int i = 0; i < data.cr.length-1; i++) {
				tmp += cd[data.cr[i]-rr[0]][data.cr[i+1]-rr[0]];
			}
			min = Math.min(min, tmp);

			if (min <= data.wi) {
				res = "OK";
				break;
			}
		} while(next_perm(data.cr));

		return res;
	}

	static boolean next_perm(int[] cr) {
		int		i;
		int		j;
		int		t;
		int		l = cr.length;
		boolean	r = false;
	    
		if (l > 0) {
			for(i = l - 1; i > 0 && cr[i-1] >= cr[i]; i--);

			if (i > 0) {
				for(j = l - 1; j > i && cr[i-1] >= cr[j]; j--);

				// swap(p,j,i-1);
				t = cr[j];
				cr[j] = cr[i-1];
				cr[i-1] = t;

				for(j=l-1; i < j; i++, j--){
					// swap(p,i,j);
					t = cr[i];
					cr[i] = cr[j];
					cr[j] = t;
				}

				r = true;
			}
		}

		return r;
	}

	public static void calcDist() {
		int	sz = rr[1]-rr[0];

		cd = new double[sz+1][sz+1];
		for (int i = 0; i <= sz; i++) {
			for (int j = i; j <= sz; j++) {
				double	d = 0.0;
				if (i == j) {
					d = (double)((rr[0]+i)*2);
				} else {
					d = Math.sqrt(Math.pow((double)(rr[0]*2+j+i), 2.0)-Math.pow((double)(j-i), 2.0));
				}
				cd[i][j] = d;
				cd[j][i] = d;
			}
		}
	}

	private static Data parseData() {
		Data	data  = null;
		String	stdin  = null;

		if ((stdin = parseStdin()) != null) {
			String[]	lines = stdin.split(" ");

			data = new Data(lines.length-1);
			for(int i = 0; i < lines.length; i++) {
				if (i == 0) {
					data.wi = Integer.parseInt(lines[i]);
				} else {
					data.cr[i-1] = Integer.parseInt(lines[i]);
					rr[0] = Math.min(rr[0], data.cr[i-1]);
					rr[1] = Math.max(rr[1], data.cr[i-1]);
				}
			}
			Arrays.sort(data.cr);
		}

		return data;
	}

	private static String parseStdin() {
		String  stdin = null;

		try {
			String  tmp = br.readLine();
			if (tmp != null) {
				if (!tmp.isEmpty()) stdin = tmp;
			}
		}
		catch (IOException e) {}

		return stdin;
	}
}

class DataTbl extends ArrayList<Data> {
}

class Data {
	int			wi = 0;
	int[]		cr = null;

	Data (int cc) {
		cr = new int[cc];
	}
}

</source>
<source file="../hum_codes_raw/s138854748.java" startline="1" endline="158" pcid="4639">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
  
public class Main {
    private static  BufferedReader  br = null;
    private static  double[][]      cd = null;
    private static  int[]           rr = { Integer.MAX_VALUE, Integer.MIN_VALUE };
 
    static {
        br = new BufferedReader(new InputStreamReader(System.in));
    }
  
    /**
     * @param args
     */
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        int     size = 0;
        Data    data = null;
        DataTbl tbl  = new DataTbl();
         
        while ((data = parseData()) != null) {
            tbl.add(data);
        }
 
        calcDist();
 
        size = tbl.size();
        for (int i = 0; i < size; i++) {
            data = tbl.get(i);
            System.out.println(solve(data));
        }
    }
 
    public static String solve(Data data) {
        String  res = "NA";
        double  min = Double.MAX_VALUE;
        double  tmp = 0.0;
 
        do {
            tmp = (double)data.cr[0]+(double)data.cr[data.cr.length-1];
            for (int i = 0; i < data.cr.length-1; i++) {
                tmp += cd[data.cr[i]-rr[0]][data.cr[i+1]-rr[0]];
            }
            min = Math.min(min, tmp);
 
            if (min <= data.wi) {
                res = "OK";
                break;
            }
        } while(next_perm(data.cr));
 
        return res;
    }
 
    static boolean next_perm(int[] cr) {
        int     i;
        int     j;
        int     t;
        int     l = cr.length;
        boolean r = false;
         
        if (l > 0) {
            for(i = l - 1; i > 0 && cr[i-1] >= cr[i]; i--);
 
            if (i > 0) {
                for(j = l - 1; j > i && cr[i-1] >= cr[j]; j--);
 
                // swap(p,j,i-1);
                t = cr[j];
                cr[j] = cr[i-1];
                cr[i-1] = t;
 
                for(j=l-1; i < j; i++, j--){
                    // swap(p,i,j);
                    t = cr[i];
                    cr[i] = cr[j];
                    cr[j] = t;
                }
 
                r = true;
            }
        }
 
        return r;
    }
 
    public static void calcDist() {
        int sz = rr[1]-rr[0];
 
        cd = new double[sz+1][sz+1];
        for (int i = 0; i <= sz; i++) {
            for (int j = i; j <= sz; j++) {
                double  d = 0.0;
                if (i == j) {
                    d = (double)((rr[0]+i)*2);
                } else {
                    d = Math.sqrt(Math.pow((double)(rr[0]*2+j+i), 2.0)-Math.pow((double)(j-i), 2.0));
                }
                cd[i][j] = d;
                cd[j][i] = d;
            }
        }
    }
 
    private static Data parseData() {
        Data    data  = null;
        String  stdin  = null;
 
        if ((stdin = parseStdin()) != null) {
            String[]    lines = stdin.split(" ");
 
            data = new Data(lines.length-1);
            for(int i = 0; i < lines.length; i++) {
                if (i == 0) {
                    data.wi = Integer.parseInt(lines[i]);
                } else {
                    data.cr[i-1] = Integer.parseInt(lines[i]);
                    rr[0] = Math.min(rr[0], data.cr[i-1]);
                    rr[1] = Math.max(rr[1], data.cr[i-1]);
                }
            }
            Arrays.sort(data.cr);
        }
 
        return data;
    }
 
    private static String parseStdin() {
        String  stdin = null;
 
        try {
            String  tmp = br.readLine();
            if (tmp != null) {
                if (!tmp.isEmpty()) stdin = tmp;
            }
        }
        catch (IOException e) {}
 
        return stdin;
    }
}
 
class DataTbl extends ArrayList<Data> {
}
 
class Data {
    int         wi = 0;
    int[]       cr = null;
 
    Data (int cc) {
        cr = new int[cc];
    }
}

</source>
</class>

<class classid="69" nclones="2" nlines="161" similarity="100">
<source file="../hum_codes_raw/s119112870.java" startline="1" endline="207" pcid="3984">
import java.io.*;
import java.util.*;

public class Main {
	FastScanner in = new FastScanner(System.in);
	PrintWriter out = new PrintWriter(System.out);

	class State implements Comparable<State> {
		int cnt;
		String s;

		State(int cnt, String s) {
			this.cnt = cnt;
			this.s = s;
		}

		public int compareTo(State s) {
			return cnt - s.cnt;
		}
	}
	
	public void run() {
		int N = in.nextInt(), M = in.nextInt();
		String base = "";
		for (int i = 0; i < N; i++) {
			base += in.nextInt();
		}
		
		String target1 = "", target2 = "";
		for (int i = 0; i < M; i++) {
			int p = in.nextInt();
			for (int j = 0; j < p; j++) {
				target1 += (i % 2 == 0) ? 1 : 0;
				target2 += (i % 2 == 0) ? 0 : 1;
			}
		}
		
		HashMap<String, Integer> map = new HashMap<String, Integer>();
		map.put(base, 0);
		
		
		PriorityQueue<State> pq = new PriorityQueue<State>();
		pq.add(new State(0, base));
		
		while (!pq.isEmpty()) {
			State st = pq.poll();
			ArrayList<String> list = new ArrayList<String>();
			for (int i = 0; i < N - 1; i++) {
				char[] next = st.s.toCharArray();
				char temp = next[i];
				next[i] = next[i+1];
				next[i+1] = temp;
				list.add(new String(next));
			}
			
			for (String next : list) {
				if (map.containsKey(next)) {
					int pvalue = map.get(next);
					if (st.cnt + 1 < pvalue) {
						map.put(next, st.cnt + 1);
						pq.add(new State(st.cnt + 1, next));	
					}
				} else {
					map.put(next, st.cnt + 1);
					pq.add(new State(st.cnt + 1, next));
				}
			}
		}
		
		int res = Integer.MAX_VALUE;
		if (map.containsKey(target1))
			res = Math.min(res, map.get(target1));
		if (map.containsKey(target2))
			res = Math.min(res, map.get(target2));
		System.out.println(res);
		
		out.close();
	}

	public static void main(String[] args) {
		new Main().run();
	}

	public void mapDebug(int[][] a) {
		System.out.println("--------map display---------");

		for (int i = 0; i < a.length; i++) {
			for (int j = 0; j < a[i].length; j++) {
				System.out.printf("%3d ", a[i][j]);
			}
			System.out.println();
		}

		System.out.println("----------------------------");
		System.out.println();
	}

	public void debug(Object... obj) {
		System.out.println(Arrays.deepToString(obj));
	}

	class FastScanner {
		private InputStream stream;
		private byte[] buf = new byte[1024];
		private int curChar;
		private int numChars;

		public FastScanner(InputStream stream) {
			this.stream = stream;
			//stream = new FileInputStream(new File("dec.in"));

		}

		int read() {
			if (numChars == -1)
				throw new InputMismatchException();
			if (curChar >= numChars) {
				curChar = 0;
				try {
					numChars = stream.read(buf);
				} catch (IOException e) {
					throw new InputMismatchException();
				}
				if (numChars <= 0)
					return -1;
			}
			return buf[curChar++];
		}

		boolean isSpaceChar(int c) {
			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
		}

		boolean isEndline(int c) {
			return c == '\n' || c == '\r' || c == -1;
		}

		int nextInt() {
			return Integer.parseInt(next());
		}

		int[] nextIntArray(int n) {
			int[] array = new int[n];
			for (int i = 0; i < n; i++)
				array[i] = nextInt();

			return array;
		}

		long nextLong() {
			return Long.parseLong(next());
		}

		long[] nextLongArray(int n) {
			long[] array = new long[n];
			for (int i = 0; i < n; i++)
				array[i] = nextLong();

			return array;
		}

		double nextDouble() {
			return Double.parseDouble(next());
		}

		double[] nextDoubleArray(int n) {
			double[] array = new double[n];
			for (int i = 0; i < n; i++)
				array[i] = nextDouble();

			return array;
		}

		String next() {
			int c = read();
			while (isSpaceChar(c))
				c = read();
			StringBuilder res = new StringBuilder();
			do {
				res.appendCodePoint(c);
				c = read();
			} while (!isSpaceChar(c));
			return res.toString();
		}

		String[] nextStringArray(int n) {
			String[] array = new String[n];
			for (int i = 0; i < n; i++)
				array[i] = next();

			return array;
		}

		String nextLine() {
			int c = read();
			while (isEndline(c))
				c = read();
			StringBuilder res = new StringBuilder();
			do {
				res.appendCodePoint(c);
				c = read();
			} while (!isEndline(c));
			return res.toString();
		}
	}
}

</source>
<source file="../hum_codes_raw/s739849216.java" startline="1" endline="209" pcid="24854">


import java.io.*;
import java.util.*;

public class Main {
	FastScanner in = new FastScanner(System.in);
	PrintWriter out = new PrintWriter(System.out);

	class State implements Comparable<State> {
		int cnt;
		String s;

		State(int cnt, String s) {
			this.cnt = cnt;
			this.s = s;
		}

		public int compareTo(State s) {
			return cnt - s.cnt;
		}
	}
	
	public void run() {
		int N = in.nextInt(), M = in.nextInt();
		String base = "";
		for (int i = 0; i < N; i++) {
			base += in.nextInt();
		}
		
		String target1 = "", target2 = "";
		for (int i = 0; i < M; i++) {
			int p = in.nextInt();
			for (int j = 0; j < p; j++) {
				target1 += (i % 2 == 0) ? 1 : 0;
				target2 += (i % 2 == 0) ? 0 : 1;
			}
		}
		
		HashMap<String, Integer> map = new HashMap<String, Integer>();
		map.put(base, 0);
		
		
		PriorityQueue<State> pq = new PriorityQueue<State>();
		pq.add(new State(0, base));
		
		while (!pq.isEmpty()) {
			State st = pq.poll();
			ArrayList<String> list = new ArrayList<String>();
			for (int i = 0; i < N - 1; i++) {
				char[] next = st.s.toCharArray();
				char temp = next[i];
				next[i] = next[i+1];
				next[i+1] = temp;
				list.add(new String(next));
			}
			
			for (String next : list) {
				if (map.containsKey(next)) {
					int pvalue = map.get(next);
					if (st.cnt + 1 < pvalue) {
						map.put(next, st.cnt + 1);
						pq.add(new State(st.cnt + 1, next));	
					}
				} else {
					map.put(next, st.cnt + 1);
					pq.add(new State(st.cnt + 1, next));
				}
			}
		}
		
		int res = Integer.MAX_VALUE;
		if (map.containsKey(target1))
			res = Math.min(res, map.get(target1));
		if (map.containsKey(target2))
			res = Math.min(res, map.get(target2));
		System.out.println(res);
		
		out.close();
	}

	public static void main(String[] args) {
		new Main().run();
	}

	public void mapDebug(int[][] a) {
		System.out.println("--------map display---------");

		for (int i = 0; i < a.length; i++) {
			for (int j = 0; j < a[i].length; j++) {
				System.out.printf("%3d ", a[i][j]);
			}
			System.out.println();
		}

		System.out.println("----------------------------");
		System.out.println();
	}

	public void debug(Object... obj) {
		System.out.println(Arrays.deepToString(obj));
	}

	class FastScanner {
		private InputStream stream;
		private byte[] buf = new byte[1024];
		private int curChar;
		private int numChars;

		public FastScanner(InputStream stream) {
			this.stream = stream;
			//stream = new FileInputStream(new File("dec.in"));

		}

		int read() {
			if (numChars == -1)
				throw new InputMismatchException();
			if (curChar >= numChars) {
				curChar = 0;
				try {
					numChars = stream.read(buf);
				} catch (IOException e) {
					throw new InputMismatchException();
				}
				if (numChars <= 0)
					return -1;
			}
			return buf[curChar++];
		}

		boolean isSpaceChar(int c) {
			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
		}

		boolean isEndline(int c) {
			return c == '\n' || c == '\r' || c == -1;
		}

		int nextInt() {
			return Integer.parseInt(next());
		}

		int[] nextIntArray(int n) {
			int[] array = new int[n];
			for (int i = 0; i < n; i++)
				array[i] = nextInt();

			return array;
		}

		long nextLong() {
			return Long.parseLong(next());
		}

		long[] nextLongArray(int n) {
			long[] array = new long[n];
			for (int i = 0; i < n; i++)
				array[i] = nextLong();

			return array;
		}

		double nextDouble() {
			return Double.parseDouble(next());
		}

		double[] nextDoubleArray(int n) {
			double[] array = new double[n];
			for (int i = 0; i < n; i++)
				array[i] = nextDouble();

			return array;
		}

		String next() {
			int c = read();
			while (isSpaceChar(c))
				c = read();
			StringBuilder res = new StringBuilder();
			do {
				res.appendCodePoint(c);
				c = read();
			} while (!isSpaceChar(c));
			return res.toString();
		}

		String[] nextStringArray(int n) {
			String[] array = new String[n];
			for (int i = 0; i < n; i++)
				array[i] = next();

			return array;
		}

		String nextLine() {
			int c = read();
			while (isEndline(c))
				c = read();
			StringBuilder res = new StringBuilder();
			do {
				res.appendCodePoint(c);
				c = read();
			} while (!isEndline(c));
			return res.toString();
		}
	}
}

</source>
</class>

<class classid="70" nclones="2" nlines="111" similarity="100">
<source file="../hum_codes_raw/s121471839.java" startline="1" endline="148" pcid="4051">
import java.util.*;
import java.lang.*;

class Main {

	public static void main(String[] args) {
		new Main().surprise();
	}

	public void surprise() {
		Scanner scanner = new Scanner(System.in);
		int numOps = scanner.nextInt();
		int key, pri;
		Node root = null;

		for(int i = 0; i < numOps; i++) {
			String op = scanner.next();

			if(op.equals("insert")) {
				key = scanner.nextInt();
				pri = scanner.nextInt();
				root = insert(root, key, pri);
			} else if(op.equals("find")) {
				key = scanner.nextInt();
				System.out.println(find(root, key) ? "yes" : "no");
			} else if(op.equals("delete")) {
				key = scanner.nextInt();
				root = erase(root, key);
			} else if(op.equals("print")) {
				printTreap(root);
			}
		}
	}

	public Node rightRotate(Node t) {
		Node s = t.left;
		t.left = s.right;
		s.right = t;
		return s;
	}

	public Node leftRotate(Node t) {
		Node s = t.right;
		t.right = s.left;
		s.left = t;
		return s;
	}

	public Node insert(Node t, int key, int pri) {
		if(t == null)
			return new Node(key, pri);

		if(key == t.key)
			return t;

		if(key < t.key) {
			t.left = insert(t.left, key, pri);
			if(t.pri < t.left.pri)
				t = rightRotate(t);
		} else {
			t.right = insert(t.right, key, pri);
			if(t.pri < t.right.pri)
				t = leftRotate(t);
		}

		return t;
	}

	public Node erase(Node t, int key) {
		if(t == null)
			return null;

		if(key == t.key) {
			if(t.left == null && t.right == null)
				return null;
			else if(t.left == null)
				t = leftRotate(t);
			else if(t.right == null)
				t = rightRotate(t);
			else {
				if(t.left.pri > t.right.pri)
					t = rightRotate(t);
				else 
					t = leftRotate(t);
			}

			return erase(t, key);
		}

		if(key < t.key)
			t.left = erase(t.left, key);
		else
			t.right = erase(t.right, key);

		return t;
	}

	public boolean find(Node root, int target) {
		if(root == null)
			return false;

		if(root.key == target)
			return true;
		else if(root.key < target)
			return find(root.right, target);
		else
			return find(root.left, target);
	}

	public void printTreap(Node root) {
		inorderTraverse(root);
		System.out.println();
		preorderTraverse(root);
		System.out.println();
	}

	private void inorderTraverse(Node root) {
		if(root != null) {
			inorderTraverse(root.left);
			System.out.print(" " + root.key);
			inorderTraverse(root.right);
		}
	}

	private void preorderTraverse(Node root) {
		if(root != null) {
			System.out.print(" " + root.key);
			preorderTraverse(root.left);
			preorderTraverse(root.right);
		}
	}

	class Node {
		int key;
		int pri;
		Node left;
		Node right;

		public Node(int k, int p) {
			key = k;
			pri = p;
			left = null;
			right = null;
		}
	}
}


</source>
<source file="../hum_codes_raw/s432137159.java" startline="1" endline="147" pcid="14511">
import java.util.*;
import java.lang.*;

class Main {

	public static void main(String[] args) {
		new Main().surprise();
	}

	public void surprise() {
		Scanner scanner = new Scanner(System.in);
		int numOps = scanner.nextInt();
		int key, pri;
		Node root = null;

		for(int i = 0; i < numOps; i++) {
			String op = scanner.next();

			if(op.equals("insert")) {
				key = scanner.nextInt();
				pri = scanner.nextInt();
				root = insert(root, key, pri);
			} else if(op.equals("find")) {
				key = scanner.nextInt();
				System.out.println(find(root, key) ? "yes" : "no");
			} else if(op.equals("delete")) {
				key = scanner.nextInt();
				root = erase(root, key);
			} else if(op.equals("print")) {
				printTreap(root);
			}
		}
	}

	public Node rightRotate(Node t) {
		Node s = t.left;
		t.left = s.right;
		s.right = t;
		return s;
	}

	public Node leftRotate(Node t) {
		Node s = t.right;
		t.right = s.left;
		s.left = t;
		return s;
	}

	public Node insert(Node t, int key, int pri) {
		if(t == null)
			return new Node(key, pri);

		if(key == t.key)
			return t;

		if(key < t.key) {
			t.left = insert(t.left, key, pri);
			if(t.pri < t.left.pri)
				t = rightRotate(t);
		} else {
			t.right = insert(t.right, key, pri);
			if(t.pri < t.right.pri)
				t = leftRotate(t);
		}

		return t;
	}

	public Node erase(Node t, int key) {
		if(t == null)
			return null;

		if(key == t.key) {
			if(t.left == null && t.right == null)
				return null;
			else if(t.left == null)
				t = leftRotate(t);
			else if(t.right == null)
				t = rightRotate(t);
			else {
				if(t.left.pri > t.right.pri)
					t = rightRotate(t);
				else 
					t = leftRotate(t);
			}

			return erase(t, key);
		}

		if(key < t.key)
			t.left = erase(t.left, key);
		else
			t.right = erase(t.right, key);

		return t;
	}

	public boolean find(Node root, int target) {
		if(root == null)
			return false;

		if(root.key == target)
			return true;
		else if(root.key < target)
			return find(root.right, target);
		else
			return find(root.left, target);
	}

	public void printTreap(Node root) {
		inorderTraverse(root);
		System.out.println();
		preorderTraverse(root);
		System.out.println();
	}

	private void inorderTraverse(Node root) {
		if(root != null) {
			inorderTraverse(root.left);
			System.out.print(" " + root.key);
			inorderTraverse(root.right);
		}
	}

	private void preorderTraverse(Node root) {
		if(root != null) {
			System.out.print(" " + root.key);
			preorderTraverse(root.left);
			preorderTraverse(root.right);
		}
	}

	class Node {
		int key;
		int pri;
		Node left;
		Node right;

		public Node(int k, int p) {
			key = k;
			pri = p;
			left = null;
			right = null;
		}
	}
}

</source>
</class>

<class classid="71" nclones="2" nlines="17" similarity="100">
<source file="../hum_codes_raw/s122330494.java" startline="1" endline="20" pcid="4069">
import java.util.Scanner;

public class Main {
	static int max(int a, int b, int c) {
		return Math.max(Math.max(a, b),c);
	}
	static int min(int a, int b, int c) {
		return Math.min(Math.min(a, b),c);
	}
	public static void main(String[] args) {
		try(Scanner sc = new Scanner(System.in)) {
			int a = sc.nextInt();
			int b = sc.nextInt();
			int c = sc.nextInt();
			System.out.println(min(a,b,c) + " " + max(a,b,c));
			
		}
	}
}

</source>
<source file="../hum_codes_raw/s773187572.java" startline="1" endline="21" pcid="25960">
import java.util.Scanner;

public class Main {
	static int max(int a, int b, int c) {
		return Math.max(Math.max(a, b),c);
	}
	static int min(int a, int b, int c) {
		return Math.min(Math.min(a, b),c);
	}
	public static void main(String[] args) {
		try(Scanner sc = new Scanner(System.in)) {
			int a = sc.nextInt();
			int b = sc.nextInt();
			int c = sc.nextInt();
			System.out.println(min(a,b,c) + " " + max(a,b,c));

		}
	}
}


</source>
</class>

<class classid="72" nclones="3" nlines="13" similarity="100">
<source file="../hum_codes_raw/s122353815.java" startline="1" endline="17" pcid="4070">
import java.util.*;
public class Main{
  public static void main(String[] args){
    Scanner sc = new Scanner(System.in);
    int x = sc.nextInt();
    if(x<1200){
      System.out.println("ABC");
    }else{
      System.out.println("ARC");
    }

  }
  

  
}

</source>
<source file="../hum_codes_raw/s351618051.java" startline="1" endline="13" pcid="11799">
import java.util.*;
public class Main{
	public static void main(String[] args){
    	Scanner sc = new Scanner(System.in);
      	int x = sc.nextInt();
      	if(x < 1200){
        	System.out.println("ABC");
        }else{
        	System.out.println("ARC");
        }
    }
}

</source>
<source file="../hum_codes_raw/s630000050.java" startline="1" endline="14" pcid="21131">
import java.util.*;

public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int x = sc.nextInt();
        if(x < 1200){
            System.out.println("ABC");
        }else{
            System.out.println("ARC");
        }
    }
}

</source>
</class>

<class classid="73" nclones="2" nlines="20" similarity="100">
<source file="../hum_codes_raw/s124268953.java" startline="1" endline="24" pcid="4145">
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        String S = sc.next();
        int x = 0;
        int max = 0;
        for (int i = 0 ; i < N ; i++ ) {
            if (S.charAt(i) == 'I') {
                x++;
            } else if (S.charAt(i) == 'D') {
                x--;
            }
            max = Math.max(max, x);

        }
        System.out.println(max);
    }

}

</source>
<source file="../hum_codes_raw/s282464824.java" startline="1" endline="22" pcid="9460">
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();
		String S = sc.next();
		int x = 0;
		int max = 0;
		for (int i = 0 ; i < N ; i++) {
			if (S.charAt(i) == 'I') {
				x++;
			} else if (S.charAt(i) == 'D') {
				x--;
			}
			max = Math.max(max, x);
		}
		System.out.println(max);
	}
}

</source>
</class>

<class classid="74" nclones="2" nlines="126" similarity="100">
<source file="../hum_codes_raw/s125047483.java" startline="1" endline="149" pcid="4175">
import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;
public class Main {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		for(;sc.hasNext();){
			String s = sc.next();
			String t = sc.next();
			SuffixArray sa = new SuffixArray(s);
			int left=-1,right=t.length()+1;
			while(left<right-1){
				int len= (left+right)/2;
				boolean f = false;
				for(int i=0;i<t.length();i++){
					if(i+len>t.length())break;
					String sub = t.substring(i,i+len);
					if(sa.contain(sub)){
						f=true;
						break;
					}
				}
				if(f){
					left=len;
				}
				else{
					right=len;
				}
					
			}
			System.out.println(left);			
		}

	}

	static class SuffixArray {
		int n,k=1;
		Integer[] sa,rank,tmp;
		String s;

		SuffixArray(String _s) {
			s=_s;
			n = s.length();
			String[] S = new String[n+1];
			S[n]="";
			for(int i=n-1;i>=0;i--){
				S[i] = s.charAt(i)+S[i+1];
			}
			rank=new Integer[n+1];
			sa=new Integer[n+1];
			tmp=new Integer[n+1];
			for(int i=0;i<n;i++){
				sa[i]=i;
				rank[i]=(int) s.charAt(i);
			}
			sa[n]=n;
			rank[n]=-1;

			for(k=1;k<=n;k<<=1){
				Arrays.sort(sa,new Comparator<Integer>(){
					@Override
					public int compare(Integer o1, Integer o2) {
						int r1=rank[o1];
						int r2=rank[o2];
						if(r1!=r2)return (r1-r2);
						int r11=o1+k <= n ? rank[o1+k] : -1;
						int r22=o2+k <= n ? rank[o2+k] : -1;
						return (r11-r22);
					}
				});
				tmp[sa[0]]=0;
				for(int i=1;i<=n;i++){
					tmp[sa[i]]=tmp[sa[i-1]]+ (compare(sa[i-1],sa[i])!=0?1:0);
				}
				for(int i=0;i<=n;i++){
					rank[i]=tmp[i];
				}
			}
		}
		boolean contain(String t){
			return contain(s,sa,t);
		} 
		private boolean contain(String s,Integer[] sa,String t){
			int a=0,b=s.length();
			while(b-a>1){
				int c = (a+b)/2;
				int com = compare(s,sa[c], Math.min(sa[c]+t.length(), s.length()),t);
				if(com<0){
					a=c;
				}
				else{
					b=c;
				}
			}
			return compare(s,sa[b], Math.min(sa[b]+t.length(), s.length()),t)==0;
		}
		/*
		 * s.substring(i1,i2).compare(t)と同じ。メモリ節約
		 */
		private int compare(String s,int i1,int i2,String t){
//			if(true)
//				return s.substring(i1,i2).compareTo(t);
					
			for(int i=i1;i<i2;i++){
				if(i-i1>=t.length()){
					return 1;
				}
				if(s.charAt(i)!=t.charAt(i-i1)){
					return s.charAt(i)-t.charAt(i-i1);
				}
			}
			return (i2-i1)-t.length();
		}

		/*
		 * s.substring(i1,i2).compare(t.substring(j1,j2)と同じ。メモリ節約
		 */
		private int compare(String s,int i1,int i2,String t,int j1,int j2){
			int slen=i2-i1;
			int tlen=j2-j1;
			for(int i=0;i<slen;i++){
				if(i>=tlen){
					return 1;
				}
				if(s.charAt(i+i1)!=t.charAt(i+j1)){
					return s.charAt(i+i1)-t.charAt(i+j1);
				}
			}
			return slen-tlen;
		}

		private int compare(Integer o1, Integer o2) {
			int r1=rank[o1];
			int r2=rank[o2];
			if(r1!=r2)return (r1-r2);
			int r11=o1+k <= n ? rank[o1+k] : -1;
			int r22=o2+k <= n ? rank[o2+k] : -1;

			return (r11-r22);
		}

	}

}

</source>
<source file="../hum_codes_raw/s521951523.java" startline="1" endline="165" pcid="17551">
import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;
public class Main {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		for(;sc.hasNext();){
			String s = sc.next();
			String t = sc.next();
			SuffixArray sa = new SuffixArray(s);
			int left=-1,right=t.length()+1;
			while(left<right-1){
				int len= (left+right)/2;
				
//				System.out.println(left+" "+right+" "+len);
				boolean f = false;
				for(int i=0;i<t.length();i++){
					if(i+len>t.length())break;
					String sub = t.substring(i,i+len);
					if(sa.contain(sub)){
						f=true;
						break;
					}
				}
				if(f){
					left=len;
				}
				else{
					right=len;
				}
					
			}
			System.out.println(left);			
		}

	}

	static class SuffixArray {
		int n,k=1;
		Integer[] sa,rank,tmp;
		String s;

		SuffixArray(String _s) {
			s=_s;
			n = s.length();
			String[] S = new String[n+1];
			S[n]="";
			for(int i=n-1;i>=0;i--){
				S[i] = s.charAt(i)+S[i+1];
			}
			rank=new Integer[n+1];
			sa=new Integer[n+1];
			tmp=new Integer[n+1];
			for(int i=0;i<n;i++){
				sa[i]=i;
				rank[i]=(int) s.charAt(i);
			}
			sa[n]=n;
			rank[n]=-1;

			for(k=1;k<=n;k<<=1){
				Arrays.sort(sa,new Comparator<Integer>(){
					@Override
					public int compare(Integer o1, Integer o2) {
						int r1=rank[o1];
						int r2=rank[o2];
						if(r1!=r2)return (r1-r2);
						int r11=o1+k <= n ? rank[o1+k] : -1;
						int r22=o2+k <= n ? rank[o2+k] : -1;

						return (r11-r22);
					}
				});
				tmp[sa[0]]=0;
				for(int i=1;i<=n;i++){
					tmp[sa[i]]=tmp[sa[i-1]]+ (compare(sa[i-1],sa[i])!=0?1:0);
				}
				for(int i=0;i<=n;i++){
					rank[i]=tmp[i];
				}
			}
		}
		boolean contain(String t){
			return contain(s,sa,t);
		} 
		private boolean contain(String s,Integer[] sa,String t){
			int a=0,b=s.length();
			while(b-a>1){
				int c = (a+b)/2;
//				String sub = s.substring(sa[c], Math.min(sa[c]+t.length(), s.length()));
				//			System.out.println(sub);
				//			System.out.println(a+" "+c+" "+b);
				
				int com = compare(s,sa[c], Math.min(sa[c]+t.length(), s.length()),t);
//				int com = compare(s,sa[c], sa[c]+t.length()< s.length() ? sa[c]+t.length():s.length(),t);
//				if(sub.compareTo(t)<0 != com < 0){
//					System.out.println(sub.compareTo(t)+" "+com);
//					System.out.println(sa[c]+" "+sa[c]+" "+t.length()+" "+s.length());
//					System.out.println(sub+" "+t);
//				}
//				if(sub.compareTo(t)<0){
				if(com<0){
					a=c;
				}
				else{
					b=c;
				}
			}
//			return s.substring(sa[b], Math.min(sa[b]+t.length(), s.length())).compareTo(t)==0;
//			return compare(s,sa[b], sa[b]+t.length()< s.length() ? sa[b]+t.length():s.length(),t)==0;
			return compare(s,sa[b], Math.min(sa[b]+t.length(), s.length()),t)==0;
		}
		/*
		 * s.substring(i1,i2).compare(t)と同じ。メモリ節約
		 */
		private int compare(String s,int i1,int i2,String t){
//			if(true)
//				return s.substring(i1,i2).compareTo(t);
					
			for(int i=i1;i<i2;i++){
				if(i-i1>=t.length()){
					return 1;
				}
				if(s.charAt(i)!=t.charAt(i-i1)){
					return s.charAt(i)-t.charAt(i-i1);
				}
			}
			return (i2-i1)-t.length();
		}

		/*
		 * s.substring(i1,i2).compare(t.substring(j1,j2)と同じ。メモリ節約
		 */
		private int compare(String s,int i1,int i2,String t,int j1,int j2){
			int slen=i2-i1;
			int tlen=j2-j1;
			for(int i=0;i<slen;i++){
				if(i>=tlen){
					return 1;
				}
				if(s.charAt(i+i1)!=t.charAt(i+j1)){
					return s.charAt(i+i1)-t.charAt(i+j1);
				}
			}
			return slen-tlen;
		}

		private int compare(Integer o1, Integer o2) {
			int r1=rank[o1];
			int r2=rank[o2];
			if(r1!=r2)return (r1-r2);
			int r11=o1+k <= n ? rank[o1+k] : -1;
			int r22=o2+k <= n ? rank[o2+k] : -1;

			return (r11-r22);
		}

	}

}

</source>
</class>

<class classid="75" nclones="2" nlines="35" similarity="100">
<source file="../hum_codes_raw/s126567478.java" startline="1" endline="48" pcid="4226">
import java.util.*;

public class Main {    
    
  public static void main(String[] args) {              
     Scanner sc = new Scanner(System.in);
     
     String S = sc.next();
     
     int N = S.length();                              
     int current = N;
     
     
     while(current > 0){
         
             if(current >= 7){
                 String sub = S.substring(current-7,current);
                 if(sub.equals("dreamer")){
                     current -= 7;
                     continue;
                 }             
             }
             
             if(current >= 6){
                 String sub = S.substring(current - 6,current);
                 if(sub.equals("eraser")){
                     current -= 6;
                     continue;
                 }
             }
         
             if(current >= 5){
                 String sub = S.substring(current - 5,current);
                 if(sub.equals("dream") || sub.equals("erase")){
                     current -= 5;
                     continue;
                 }                                  
             }
                       
             System.out.println("NO");
             return;                                   
     }
     
     System.out.println("YES");     
     
  }          
}

</source>
<source file="../hum_codes_raw/s420320317.java" startline="1" endline="50" pcid="14125">
import java.util.*;

public class Main {    
    public static void main(String[] args){

       Scanner sc = new Scanner(System.in);
                
        String S = sc.next();
		int N = S.length();
	
		int current = N;
	
		while(current > 0){
			if(current >= 7){
				String sub = S.substring(current-7, current);
				if(sub.equals("dreamer")){
					current -= 7;
					continue;
				}
			}
			
			if(current >= 6){
				String sub = S.substring(current-6, current);
				if(sub.equals("eraser")){
					current -= 6;
					continue;
				}
			}
			
			if(current >= 5){
				String sub = S.substring(current-5, current);
				if(sub.equals("dream") || sub.equals("erase")){
					current -= 5;
					continue;
				}
			}
			
			System.out.println("NO");
                        return;
		}
		
		System.out.println("YES");      
                
      
  }                                      
}
        
        
        

</source>
</class>

<class classid="76" nclones="2" nlines="83" similarity="100">
<source file="../hum_codes_raw/s134378982.java" startline="1" endline="96" pcid="4487">
import java.util.*;
public class Main {
	Scanner in = new Scanner(System.in);
	public static void main(String[] args) {
		new Main();
	}

	public Main(){
		new A().doIt();
	}
	
	class A{
		int n,m;
		int[] result;
		int zero,one;
		boolean calc(int target){
			int index = 0,num = 1;
			int c = ((target>>0)%2);
			for(int i=1;i<n;i++){
				if(c == (target>>i)%2)num++;
				else{
					if(result[m-index-1]!=num)return false;
					index++;
					num = 1;
					c = (target>>i)%2;
				}
			}
			if(result[m-index-1]!=num)return false;
			int z = 0;
			int o = 0;
			for(int i=0;i<n;i++){
				if((target>>i)%2==0)z++;
				else o++;
			}
			if(zero==z&&one==o)return true;
			return false;
		}
		
		int solve(ArrayList<Integer> kouho,char[] to){
			int result = Integer.MAX_VALUE/2;
			ArrayList<String> list = new ArrayList<String>();
			for(int i=0;i<kouho.size();i++){
				String a = "";
				for(int s=n-1;s>=0;s--)a+=((kouho.get(i)>>s)%2);
				list.add(a);
			}
//			System.out.println(list);
			
			for(int i=0;i<list.size();i++){
				int cnt = 0;
				boolean[] sw = new boolean[n];
				String target = list.get(i);
//				System.out.println(target);
				for(int s=0;s<n;s++)if(target.charAt(s)=='1'){
					for(int j=0;j<n;j++){
//						System.out.println(s+" "+j+" "+target.charAt(s)+" "+to[j]);
						if(to[j]==target.charAt(s)&&!sw[j]){
							sw[j] = true;
							cnt += Math.abs(j-s);
							break;
						}
//						System.out.println(Arrays.toString(sw));
					}
				}
				result = Math.min(cnt, result);
			}
			
			return result;
		}
		
		void doIt(){
			n = in.nextInt();
			m = in.nextInt();
			zero = 0;one = 0;
			char[] input = new char[n];
			for(int i=0;i<n;i++)input[i] = in.next().charAt(0);
			String input2 = "";
			for(int i=0;i<n;i++)input2+=input[i];
			result = new int[m];
			for(int i=0;i<m;i++)result[i] = in.nextInt();
			for(int i=0;i<n;i++){
				if(input[i]=='0')zero++;
				else one++;
			}
			ArrayList<Integer> kouho = new ArrayList<Integer>();
			for(int i=0;i<(1<<n);i++){
				if(calc(i))kouho.add(i);
			}
//			System.out.println(kouho);
//			for(int i=0;i<kouho.size();i++)System.out.println(Integer.toBinaryString(kouho.get(i)));
			System.out.println(solve(kouho,input));
		}
	}
	
}

</source>
<source file="../hum_codes_raw/s760553625.java" startline="1" endline="96" pcid="25556">
import java.util.*;
public class Main {
	Scanner in = new Scanner(System.in);
	public static void main(String[] args) {
		new Main();
	}

	public Main(){
		new A().doIt();
	}
	
	class A{
		int n,m;
		int[] result;
		int zero,one;
		boolean calc(int target){
			int index = 0,num = 1;
			int c = ((target>>0)%2);
			for(int i=1;i<n;i++){
				if(c == (target>>i)%2)num++;
				else{
					if(result[m-index-1]!=num)return false;
					index++;
					num = 1;
					c = (target>>i)%2;
				}
			}
			if(result[m-index-1]!=num)return false;
			int z = 0;
			int o = 0;
			for(int i=0;i<n;i++){
				if((target>>i)%2==0)z++;
				else o++;
			}
			if(zero==z&&one==o)return true;
			return false;
		}
		
		int solve(ArrayList<Integer> kouho,char[] to){
			int result = Integer.MAX_VALUE/2;
			ArrayList<String> list = new ArrayList<String>();
			for(int i=0;i<kouho.size();i++){
				String a = "";
				for(int s=n-1;s>=0;s--)a+=((kouho.get(i)>>s)%2);
				list.add(a);
			}
//			System.out.println(list);
			
			for(int i=0;i<list.size();i++){
				int cnt = 0;
				boolean[] sw = new boolean[n];
				String target = list.get(i);
//				System.out.println(target);
				for(int s=0;s<n;s++)if(target.charAt(s)=='1'){
					for(int j=0;j<n;j++){
//						System.out.println(s+" "+j+" "+target.charAt(s)+" "+to[j]);
						if(to[j]==target.charAt(s)&&!sw[j]){
							sw[j] = true;
							cnt += Math.abs(j-s);
							break;
						}
//						System.out.println(Arrays.toString(sw));
					}
				}
				result = Math.min(cnt, result);
			}
			
			return result;
		}
		
		void doIt(){
			n = in.nextInt();
			m = in.nextInt();
			zero = 0;one = 0;
			char[] input = new char[n];
			for(int i=0;i<n;i++)input[i] = in.next().charAt(0);
			String input2 = "";
			for(int i=0;i<n;i++)input2+=input[i];
			result = new int[m];
			for(int i=0;i<m;i++)result[i] = in.nextInt();
			for(int i=0;i<n;i++){
				if(input[i]=='0')zero++;
				else one++;
			}
			ArrayList<Integer> kouho = new ArrayList<Integer>();
			for(int i=0;i<(1<<n);i++){
				if(calc(i))kouho.add(i);
			}
//			System.out.println(kouho);
//			for(int i=0;i<kouho.size();i++)System.out.println(Integer.toBinaryString(kouho.get(i)));
			System.out.println(solve(kouho,input));
		}
	}
	
}

</source>
</class>

<class classid="77" nclones="2" nlines="56" similarity="100">
<source file="../hum_codes_raw/s135223040.java" startline="1" endline="64" pcid="4520">
import java.util.Scanner;

//Smart Calculator
public class Main {

	static char[] s;
	static int id;
	
	static int exp(){
		int r = term();
		while(true){
			char c = s[id++];
			if(c=='+')r+=term();
			else if(c=='-')r-=term();
			else break;
		}
		return r;
	}
	
	static int term(){
		int r = fact();
		while(true){
			char c = s[id++];
			if(c=='*') r*=fact();
			else if(c=='/')r/=fact();
			else break;
		}
		id--;
		return r;
	}
	
	static int fact(){
		char c = s[id++];
		if(c=='(')return exp();
		if(c=='-'){
			return -fact();
		}
		if(c=='+'){
			return fact();
		}
		int x = c-'0';
		while(true){
			c = s[id++];
			if(Character.isDigit(c)){
				x *= 10;
				x += c-'0';
			}
			else break;
		}
		id--;
		return x;
	}
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int t = sc.nextInt();
		while(t--!=0){
			s = sc.next().toCharArray();
			id = 0;
			System.out.println(exp());
		}
	}
}

</source>
<source file="../hum_codes_raw/s943957762.java" startline="1" endline="64" pcid="31732">
import java.util.Scanner;

//Smart Calculator
public class Main {

        static char[] s;
        static int id;

        static int exp(){
                int r = term();
                while(true){
                        char c = s[id++];
                        if(c=='+')r+=term();
                        else if(c=='-')r-=term();
                        else break;
                }
                return r;
        }

        static int term(){
                int r = fact();
                while(true){
                        char c = s[id++];
                        if(c=='*') r*=fact();
                        else if(c=='/')r/=fact();
                        else break;
                }
                id--;
                return r;
        }

        static int fact(){
                char c = s[id++];
                if(c=='(')return exp();
                if(c=='-'){
                        return -fact();
                }
                if(c=='+'){
                        return fact();
                }
                int x = c-'0';
                while(true){
                        c = s[id++];
                        if(Character.isDigit(c)){
                                x *= 10;
                                x += c-'0';
                        }
                        else break;
                }
                id--;
                return x;
        }

        public static void main(String[] args) {
                Scanner sc = new Scanner(System.in);
                int t = sc.nextInt();
                while(t--!=0){
                        s = sc.next().toCharArray();
                        id = 0;
                        System.out.println(exp());
                }
        }
}

</source>
</class>

<class classid="78" nclones="2" nlines="15" similarity="100">
<source file="../hum_codes_raw/s136337930.java" startline="1" endline="18" pcid="4556">
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int a = scan.nextInt();
		int b = scan.nextInt();
		int c = scan.nextInt();
		//????????¶????????\???
		if(a < b && b < c){ //??????????¨???°????????????
			System.out.println("Yes");
		} else {
			System.out.println("No");
		}
	}
}

</source>
<source file="../hum_codes_raw/s227320733.java" startline="1" endline="15" pcid="7685">
import java.util.Scanner;
public class Main {
	public static void main(String[] args){
		Scanner scan=new Scanner(System.in);
		int a=scan.nextInt();
		int b=scan.nextInt();
		int c=scan.nextInt();
		if(a<b&&b<c){
			System.out.println("Yes");
		}else{
			System.out.println("No");
		}
	}
}

</source>
</class>

<class classid="79" nclones="2" nlines="51" similarity="100">
<source file="../hum_codes_raw/s136786538.java" startline="1" endline="72" pcid="4578">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Collections;
import java.util.InputMismatchException;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.StringTokenizer;

public class Main {
	
	static class Priorityqueue {
		public void priorityqueue (InputReader ir) {
			
			Queue<Integer> pq = new PriorityQueue<> (Collections.reverseOrder());;
			StringBuilder sb = new StringBuilder ();
			
			while (true) {
				
				String ord = ir.nextString();
				
				if (ord.equals("end")) break;
				
				if (ord.equals("insert")) pq.add(ir.nextInt());
				else if (ord.equals("extract")) sb.append(pq.poll()).append("\n"); 
				
			}
			
			System.out.print(sb);
			
		}
	}

	static class InputReader {
		BufferedReader br;
		StringTokenizer st;
		
		public String nextString() {
			
			 while (!st.hasMoreTokens()) {
	                try {
	                    st = new StringTokenizer(br.readLine(), " ");
	                } catch (IOException e) {
	                    throw new InputMismatchException();
	                }
	            }
			return st.nextToken();
		}
		
		public int nextInt() {
			return Integer.parseInt(nextString());
		}
					
		public InputReader (InputStream inputStream) {
			br = new BufferedReader (new InputStreamReader (inputStream));
			st = new StringTokenizer ("");
		}
		
	}
	
	public static void main (String[] args) {
		InputStream inputStream = System.in;
		InputReader in = new InputReader (inputStream);
		Priorityqueue obj = new Priorityqueue ();
		obj.priorityqueue (in);
	}
	
	
}


</source>
<source file="../hum_codes_raw/s589090521.java" startline="1" endline="72" pcid="19776">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Collections;
import java.util.InputMismatchException;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.StringTokenizer;

public class Main {
	
	static class Priorityqueue {
		public void priorityqueue (InputReader ir) {
			
			Queue<Integer> pq = new PriorityQueue<> (Collections.reverseOrder());;
			StringBuilder sb = new StringBuilder ();
			
			while (true) {
				
				String ord = ir.nextString();
				
				if (ord.equals("end")) break;
				
				if (ord.equals("insert")) pq.add(ir.nextInt());
				else if (ord.equals("extract")) sb.append(pq.poll()).append("\n"); 
				
			}
			
			System.out.print(sb);
			
		}
	}

	static class InputReader {
		BufferedReader br;
		StringTokenizer st;
		
		public String nextString() {
			
			 while (!st.hasMoreTokens()) {
	                try {
	                    st = new StringTokenizer(br.readLine(), " ");
	                } catch (IOException e) {
	                    throw new InputMismatchException();
	                }
	            }
			return st.nextToken();
		}
		
		public int nextInt() {
			return Integer.parseInt(nextString());
		}
					
		public InputReader (InputStream inputStream) {
			br = new BufferedReader (new InputStreamReader (inputStream));
			st = new StringTokenizer ("");
		}
		
	}
	
	public static void main (String[] args) {
		InputStream inputStream = System.in;
		InputReader in = new InputReader (inputStream);
		Priorityqueue obj = new Priorityqueue ();
		obj.priorityqueue (in);
	}
	
	
}


</source>
</class>

<class classid="80" nclones="2" nlines="113" similarity="100">
<source file="../hum_codes_raw/s137158279.java" startline="1" endline="151" pcid="4590">
import java.awt.Point;
import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Scanner;
import java.util.Stack;

public class Main {

	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(System.in);
		int INF = 1 << 28;
		while (true) {
			int n = sc.nextInt();
			if (n == 0)
				break;
			// }
			// 1行目 ビルの数ｎ（整数）
			// 2行目 第1のビル情報 b1 x1 y1（それぞれ整数；半角空白区切り）
			// b1：ビル番号
			// x1：ビルのx座標
			// y1：ビルのy座標
			// 3行目 第2のビル情報 b2 x2 y2（それぞれ整数；半角空白区切り）
			// ：
			// n+1行目 第nのビル情報 bn xn yn（それぞれ整数；半角空白区切り）
			Point2D.Double[] bs = new Point2D.Double[n + 1];
			for (int i = 1; i <= n; i++) {
				int b = sc.nextInt();
				int x = sc.nextInt();
				int y = sc.nextInt();
				bs[b] = new Point2D.Double(x, y);
			}
			@SuppressWarnings("unchecked")
			ArrayList<Edge> es[] = new ArrayList[n + 1];
			for (int i = 1; i <= n; i++) {
				es[i] = new ArrayList<Edge>();
				for (int j = 1; j <= n; j++) {
					if (i == j)
						continue;
//					int dis = (bs[i].x - bs[j].x) * (bs[i].x - bs[j].x)
//							+ (bs[i].y - bs[j].y) * (bs[i].y - bs[j].y);
					double dis = Math.hypot(bs[i].x-bs[j].x, bs[i].y-bs[j].y);
					if (dis <= 50)
						es[i].add(new Edge(j, dis));
				}
			}
//			for (int i = 1; i <= n; i++) {
//				System.out.print(i + " : ");
//				System.out.println(es[i]);
//			}
			int m = sc.nextInt();
			for (int i = 0; i < m; i++) {
				int prev[] = new int[n + 1];
				double d[] = new double[n + 1];
				Arrays.fill(d, INF);
				Arrays.fill(prev, -1);
				Queue<Pair> q = new PriorityQueue<Pair>();
				int s = sc.nextInt();
				d[s] = 0;
				int g = sc.nextInt();
				q.offer(new Pair(0, s));
				while (!q.isEmpty()) {
					Pair p = q.poll();
					int v = p.v;
					if (d[v] < p.d)
						continue;
					for (int j = 0; j < es[v].size(); j++) {
						Edge e = es[v].get(j);
						if (d[e.to] > d[v] + e.cost) {
							prev[e.to] = v;
							d[e.to] = d[v] + e.cost;
							q.offer(new Pair(d[e.to], e.to));
						}
					}
				}
				if (d[g] == INF) {
					System.out.println("NA");

				} else {
					boolean init = true;
					int j = g;
					Stack<String> ans = new Stack<String>();
					while (true) {
						if (init) {
							init = false;
						} else {
							ans.add(" ");
						}
						ans.add(Integer.toString(j));
						if (j == s) {
							break;
						}
						j = prev[j];
					}
					while (!ans.isEmpty()) {
						System.out.print(ans.pop());
					}
					System.out.println();
				}
			}
			// n+2行目 移動情報の個数m（整数）
			// n+3行目 第1 の移動情報 s1 g1（それぞれ整数；半角空白区切り）
			// s1 スパイダー人の移動開始ビル番号
			// g1 スパイダー人の目的地ビル番号
			// n+4行目 第2 の移動情報 s2 g2（それぞれ整数；半角空白区切り）
			// ：
			// n+m+2行目 第m の移動情報 sm gm（それぞれ整数；半角空白区切り）
		}
	}
}

class Edge {
	public int to;
	public double cost;

	Edge(int to, double dis) {
		this.to = to;
		this.cost = dis;
	}

	public String toString() {
		return "to: " + to + " cost: " + cost;
	}
}

class Pair implements Comparable<Pair> {
	double d;
	int v;

	Pair(double d2, int v) {
		this.d = d2;
		this.v = v;
	}

	@Override
	public int compareTo(Pair p) {
		if (d - p.d < 0)
			return -1;
		else if (d - p.d > 0)
			return 1;
		else
			return 0;
	}

	public String toString() {
		return "d : " + d + " " + "v : " + v;
	}
}

</source>
<source file="../hum_codes_raw/s723032876.java" startline="1" endline="151" pcid="24309">
import java.awt.Point;
import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Scanner;
import java.util.Stack;

public class Main {

	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(System.in);
		int INF = 1 << 28;
		while (true) {
			int n = sc.nextInt();
			if (n == 0)
				break;
			// }
			// 1行目 ビルの数ｎ（整数）
			// 2行目 第1のビル情報 b1 x1 y1（それぞれ整数；半角空白区切り）
			// b1：ビル番号
			// x1：ビルのx座標
			// y1：ビルのy座標
			// 3行目 第2のビル情報 b2 x2 y2（それぞれ整数；半角空白区切り）
			// ：
			// n+1行目 第nのビル情報 bn xn yn（それぞれ整数；半角空白区切り）
			Point2D.Double[] bs = new Point2D.Double[n + 1];
			for (int i = 1; i <= n; i++) {
				int b = sc.nextInt();
				int x = sc.nextInt();
				int y = sc.nextInt();
				bs[b] = new Point2D.Double(x, y);
			}
			@SuppressWarnings("unchecked")
			ArrayList<Edge> es[] = new ArrayList[n + 1];
			for (int i = 1; i <= n; i++) {
				es[i] = new ArrayList<Edge>();
				for (int j = 1; j <= n; j++) {
					if (i == j)
						continue;
//					int dis = (bs[i].x - bs[j].x) * (bs[i].x - bs[j].x)
//							+ (bs[i].y - bs[j].y) * (bs[i].y - bs[j].y);
					double dis = Math.hypot(bs[i].x-bs[j].x, bs[i].y-bs[j].y);
					if (dis <= 50)
						es[i].add(new Edge(j, dis));
				}
			}
//			for (int i = 1; i <= n; i++) {
//				System.out.print(i + " : ");
//				System.out.println(es[i]);
//			}
			int m = sc.nextInt();
			for (int i = 0; i < m; i++) {
				int prev[] = new int[n + 1];
				double d[] = new double[n + 1];
				Arrays.fill(d, INF);
				Arrays.fill(prev, -1);
				Queue<Pair> q = new PriorityQueue<Pair>();
				int s = sc.nextInt();
				d[s] = 0;
				int g = sc.nextInt();
				q.offer(new Pair(0, s));
				while (!q.isEmpty()) {
					Pair p = q.poll();
					int v = p.v;
					if (d[v] < p.d)
						continue;
					for (int j = 0; j < es[v].size(); j++) {
						Edge e = es[v].get(j);
						if (d[e.to] > d[v] + e.cost) {
							prev[e.to] = v;
							d[e.to] = d[v] + e.cost;
							q.offer(new Pair(d[e.to], e.to));
						}
					}
				}
				if (d[g] == INF) {
					System.out.println("NA");

				} else {
					boolean init = true;
					int j = g;
					Stack<String> ans = new Stack<String>();
					while (true) {
						if (init) {
							init = false;
						} else {
							ans.add(" ");
						}
						ans.add(Integer.toString(j));
						if (j == s) {
							break;
						}
						j = prev[j];
					}
					while (!ans.isEmpty()) {
						System.out.print(ans.pop());
					}
					System.out.println();
				}
			}
			// n+2行目 移動情報の個数m（整数）
			// n+3行目 第1 の移動情報 s1 g1（それぞれ整数；半角空白区切り）
			// s1 スパイダー人の移動開始ビル番号
			// g1 スパイダー人の目的地ビル番号
			// n+4行目 第2 の移動情報 s2 g2（それぞれ整数；半角空白区切り）
			// ：
			// n+m+2行目 第m の移動情報 sm gm（それぞれ整数；半角空白区切り）
		}
	}
}

class Edge {
	public int to;
	public double cost;

	Edge(int to, double dis) {
		this.to = to;
		this.cost = dis;
	}

	public String toString() {
		return "to: " + to + " cost: " + cost;
	}
}

class Pair implements Comparable<Pair> {
	double d;
	int v;

	Pair(double d2, int v) {
		this.d = d2;
		this.v = v;
	}

	@Override
	public int compareTo(Pair p) {
		if (d - p.d < 0)
			return -1;
		else if (d - p.d > 0)
			return 1;
		else
			return 0;
	}

	public String toString() {
		return "d : " + d + " " + "v : " + v;
	}
}

</source>
</class>

<class classid="81" nclones="2" nlines="22" similarity="100">
<source file="../hum_codes_raw/s137266061.java" startline="1" endline="28" pcid="4595">

import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);

		int A = sc.nextInt();
		int B = sc.nextInt();
		int C = sc.nextInt();
		int coin = 0;
		int day = 0;
		while (coin < C) {
			day++;
			coin += A;
			if (day % 7 == 0) {
				coin += B;
			}
			if (coin >= C) {
				break;
			}
		}
		System.out.println(day);
	}

}


</source>
<source file="../hum_codes_raw/s685966054.java" startline="1" endline="27" pcid="23047">
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);

		int A = sc.nextInt();
		int B = sc.nextInt();
		int C = sc.nextInt();
		int coin = 0;
		int day = 0;
		while (coin < C) {
			day++;
			coin += A;
			if (day % 7 == 0) {
				coin += B;
			}
			if (coin >= C) {
				break;
			}
		}
		System.out.println(day);
	}

}


</source>
</class>

<class classid="82" nclones="2" nlines="22" similarity="100">
<source file="../hum_codes_raw/s141112005.java" startline="1" endline="24" pcid="4706">
import java.util.Scanner;
public class Main {
	public static void main(String[] args) {
		 Scanner sc = new Scanner(System.in);
		 while(sc.hasNext()) {
			int a = sc.nextInt();
			int b = sc.nextInt();
			int c = sc.nextInt();
			int d = sc.nextInt();
			int e = sc.nextInt();
			int ans = 0;
			if(a<0) {
				ans = d + Math.abs(a)*c + b*e;
			}
			else {
				if(a==0)
					ans += d;
				ans += (b-a)*e;
			}
			System.out.println(ans);
	  }	 
	}
}

</source>
<source file="../hum_codes_raw/s967294600.java" startline="1" endline="24" pcid="32526">
import java.util.Scanner;
public class Main {
	public static void main(String[] args) {
		 Scanner sc = new Scanner(System.in);
		 while(sc.hasNext()) {
			int a = sc.nextInt();
			int b = sc.nextInt();
			int c = sc.nextInt();
			int d = sc.nextInt();
			int e = sc.nextInt();
			int ans = 0;
			if(a<0) {
				ans = d + Math.abs(a)*c + b*e;
			}
			else {
				if(a==0)
					ans += d;
				ans += (b-a)*e;
			}
			System.out.println(ans);
	  }	 
	}
}

</source>
</class>

<class classid="83" nclones="2" nlines="127" similarity="100">
<source file="../hum_codes_raw/s142354620.java" startline="1" endline="146" pcid="4766">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.Arrays;
import java.util.Scanner;
import java.util.StringTokenizer;

public class Main {

	public static class WeightedUnionFind{
	    int[] par; // 親の番号
	    int[] ws;  // 親との重みの差
	    
	    public WeightedUnionFind(int n){
	        par = new int[n];
	        ws  = new int[n];
	        for(int i = 0; i < n; i++){ 
	        	par[i] = -1;
	        }
	    }
	    
	    public int find(int x){
	    	if(par[x] < 0){
	    		return x;
	    	}else{
	    		final int parent = find(par[x]);
	    		ws[x] += ws[par[x]];
	    		par[x] = parent;
	    		return parent;
	    	}
	    }
	    
	    public int weight(int x){
	    	find(x);
	    	return ws[x];
	    }
	    
	    public boolean union(int x, int y, int w){ // x <-(w)- y (x + w = y)
	    	w += weight(x);
	    	w -= weight(y);
	        x = find(x);
	        y = find(y);
	        
	        if(x != y){
	            if(par[y] < par[x]) {  // 多い方が根になるようにスワップする.
	                int tmp = x; x = y; y = tmp;
	                w = -w;
	            }
	            par[x] += par[y];
	            par[y] = x;
	            ws[y] = w;
	            
	            return true;
	        }else{
	            return false;
	        }
	    }
	    
	    public boolean same(int x, int y){
	        return find(x) == find(y);
	    }
	    
	    public Integer diff(int x, int y){ // x - y を求める. 比較不能ならnull.
	    	if(!same(x, y)){
	    		return null;
	    	}else{
	    		return this.weight(x) - this.weight(y);
	    	}
	    }
	    
	    public int size(int x){
	        return -par[find(x)];
	    }
	}
	
	public static void main(String[] args) throws IOException {
		Scanner sc = new Scanner(System.in);

		while(true){
			final int n = sc.nextInt();
			final int m = sc.nextInt();
			
			if(n == 0 && m == 0){
				break;
			}
			
			WeightedUnionFind uf = new WeightedUnionFind(n);
			
			for(int i = 0; i < m; i++){
				final String ops = sc.next();
				
				if("?".equals(ops)){
					final int r = sc.nextInt() - 1;
					final int l = sc.nextInt() - 1;
					
					if(!uf.same(r, l)){
						System.out.println("UNKNOWN");
					}else{
						System.out.println(uf.weight(l) - uf.weight(r));
					}
				}else{
					final int r = sc.nextInt() - 1;
					final int l = sc.nextInt() - 1;
					final int w = sc.nextInt();
					
					uf.union(r, l, w);
				}
			}
		}
		
		sc.close();
	}
	
	public static class Scanner {
	    private BufferedReader br;
	    private StringTokenizer tok;

	    public Scanner(InputStream is) throws IOException {
	        br = new BufferedReader(new InputStreamReader(is));
	    }

	    private void getLine() throws IOException {
	        while (!hasNext()) { tok = new StringTokenizer(br.readLine()); }
	    }

	    private boolean hasNext() {
	        return tok != null && tok.hasMoreTokens();
	    }

	    public String next() throws IOException {
	        getLine(); return tok.nextToken();
	    }

	    public int nextInt() throws IOException {
	        return Integer.parseInt(next());
	    }
	    // 他のnextXXXもXXX.parseXXX()メソッドを使って作れるので省略
	    
	    public void close() throws IOException {
	        br.close();
	    }
	}
}

</source>
<source file="../hum_codes_raw/s519233826.java" startline="1" endline="146" pcid="17448">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.Arrays;
import java.util.Scanner;
import java.util.StringTokenizer;

public class Main {

	public static class WeightedUnionFind{
	    int[] par; // 親の番号
	    int[] ws;  // 親との重みの差
	    
	    public WeightedUnionFind(int n){
	        par = new int[n];
	        ws  = new int[n];
	        for(int i = 0; i < n; i++){ 
	        	par[i] = -1;
	        }
	    }
	    
	    public int find(int x){
	    	if(par[x] < 0){
	    		return x;
	    	}else{
	    		final int parent = find(par[x]);
	    		ws[x] += ws[par[x]];
	    		par[x] = parent;
	    		return parent;
	    	}
	    }
	    
	    public int weight(int x){
	    	find(x);
	    	return ws[x];
	    }
	    
	    public boolean union(int x, int y, int w){ // x <-(w)- y (x + w = y)
	    	w += weight(x);
	    	w -= weight(y);
	        x = find(x);
	        y = find(y);
	        
	        if(x != y){
	            if(par[y] < par[x]) {  // 多い方が根になるようにスワップする.
	                int tmp = x; x = y; y = tmp;
	                w = -w;
	            }
	            par[x] += par[y];
	            par[y] = x;
	            ws[y] = w;
	            
	            return true;
	        }else{
	            return false;
	        }
	    }
	    
	    public boolean same(int x, int y){
	        return find(x) == find(y);
	    }
	    
	    public Integer diff(int x, int y){ // x - y を求める. 比較不能ならnull.
	    	if(!same(x, y)){
	    		return null;
	    	}else{
	    		return this.weight(x) - this.weight(y);
	    	}
	    }
	    
	    public int size(int x){
	        return -par[find(x)];
	    }
	}
	
	public static void main(String[] args) throws IOException {
		Scanner sc = new Scanner(System.in);

		while(true){
			final int n = sc.nextInt();
			final int m = sc.nextInt();
			
			if(n == 0 && m == 0){
				break;
			}
			
			WeightedUnionFind uf = new WeightedUnionFind(n);
			
			for(int i = 0; i < m; i++){
				final String ops = sc.next();
				
				if("?".equals(ops)){
					final int r = sc.nextInt() - 1;
					final int l = sc.nextInt() - 1;
					
					if(!uf.same(r, l)){
						System.out.println("UNKNOWN");
					}else{
						System.out.println(uf.weight(l) - uf.weight(r));
					}
				}else{
					final int r = sc.nextInt() - 1;
					final int l = sc.nextInt() - 1;
					final int w = sc.nextInt();
					
					uf.union(r, l, w);
				}
			}
		}
		
		sc.close();
	}
	
	public static class Scanner {
	    private BufferedReader br;
	    private StringTokenizer tok;

	    public Scanner(InputStream is) throws IOException {
	        br = new BufferedReader(new InputStreamReader(is));
	    }

	    private void getLine() throws IOException {
	        while (!hasNext()) { tok = new StringTokenizer(br.readLine()); }
	    }

	    private boolean hasNext() {
	        return tok != null && tok.hasMoreTokens();
	    }

	    public String next() throws IOException {
	        getLine(); return tok.nextToken();
	    }

	    public int nextInt() throws IOException {
	        return Integer.parseInt(next());
	    }
	    // 他のnextXXXもXXX.parseXXX()メソッドを使って作れるので省略
	    
	    public void close() throws IOException {
	        br.close();
	    }
	}
}

</source>
</class>

<class classid="84" nclones="2" nlines="36" similarity="100">
<source file="../hum_codes_raw/s143124304.java" startline="1" endline="40" pcid="4790">
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		ArrayList<List<Integer>> A = new ArrayList<>();
		for (int i = 0; i < n; i++) {
			ArrayList<Integer> B = new ArrayList<>();
			A.add(B);
		}
		int q = sc.nextInt();
		for (int i = 0; i < q; i++) {
			int x = sc.nextInt();
			if (x == 0) {
				int y = sc.nextInt();
				int z = sc.nextInt();
				A.get(y).add(z);
			} else if (x == 1) {
				int y = sc.nextInt();
				if (A.get(y).size() != 0) {
					System.out.println(A.get(y).get(A.get(y).size() - 1));
				}
			} else if (x == 2) {
				int y = sc.nextInt();
				if (A.get(y).size() != 0) {
					A.get(y).remove(A.get(y).size() - 1);
				}
			}
		}
		sc.close();

	}

}



</source>
<source file="../hum_codes_raw/s724292859.java" startline="1" endline="46" pcid="24362">


import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);

		int n = sc.nextInt();
		ArrayList<List<Integer>> A = new ArrayList<>();
		for (int i = 0; i < n; i++) {
			ArrayList<Integer> B = new ArrayList<>();
			A.add(B);
		}
		int q = sc.nextInt();

		for (int i = 0; i < q; i++) {
			int x = sc.nextInt();
			if (x == 0) {
				int y = sc.nextInt();
				int z = sc.nextInt();
				A.get(y).add(z);

			} else if (x == 1) {
				int y = sc.nextInt();
				if (A.get(y).size() != 0) {
					System.out.println(A.get(y).get(A.get(y).size() - 1));
				}

			} else if (x == 2) {
				int y = sc.nextInt();
				if (A.get(y).size() != 0) {
					A.get(y).remove(A.get(y).size() - 1);
				}
			}
		}
		sc.close();

	}

}


</source>
</class>

<class classid="85" nclones="2" nlines="21" similarity="100">
<source file="../hum_codes_raw/s145256498.java" startline="1" endline="26" pcid="4868">
import java.util.Scanner;

class Main {
	public static void main(String[] args) {
		try (Scanner sc = new Scanner (System.in)){
			int n = sc.nextInt();
			long[] array = new long[n];
			for (int i=0; i<n; i++) array[i] = sc.nextLong();
			int times = sc.nextInt();  //queryの数
			for (int i=0; i<times; i++) {
				int start = sc.nextInt();
				int end = sc.nextInt();
				int target = sc.nextInt();
				//count(start,end,target)
				int count = 0;
				for (int j=start; j<end; j++) {
					if (array[j] == target) count++;
				}
				System.out.println(count);
			}
		}
	}
}



</source>
<source file="../hum_codes_raw/s190641646.java" startline="1" endline="25" pcid="6426">
import java.util.Scanner;

class Main {
	public static void main(String[] args) {
		try (Scanner sc = new Scanner (System.in)){
			int n = sc.nextInt();
			long[] array = new long[n];
			for (int i=0; i<n; i++) array[i] = sc.nextLong();
			int times = sc.nextInt();  //queryの数
			for (int i=0; i<times; i++) {
				int start = sc.nextInt();
				int end = sc.nextInt();
				int target = sc.nextInt();
				//count(start,end,target)
				int count = 0;
				for (int j=start; j<end; j++) {
					if (array[j] == target) count++;
				}
				System.out.println(count);
			}
		}
	}
}


</source>
</class>

<class classid="86" nclones="2" nlines="33" similarity="100">
<source file="../hum_codes_raw/s146622168.java" startline="1" endline="40" pcid="4901">
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int N = sc.nextInt();
        int A = sc.nextInt();
        int[] x = new int[N + 1];
        for (int i = 1; i <= N; ++i) {
            x[i] = sc.nextInt();
        }

        long[][][] dp = new long[N + 1][N + 1][N * A + 1];
        for (int i = 0; i < N; ++i) {
            dp[i][0][0] = 1;
        }

        for (int i = 1; i <= N; ++i) {
            for (int j = 1; j <= i; ++j) {
                for (int k = 1; k <= N * A; ++k) {
                    if (k < x[i]) {
                        dp[i][j][k] = dp[i - 1][j][k];
                    } else {
                        dp[i][j][k] = dp[i - 1][j][k] + dp[i - 1][j - 1][k - x[i]];
                    }
                }
            }
        }

        long ans = 0;
        for (int j = 1; j <= N; ++j) {
            ans += dp[N][j][j * A];
        }

        System.out.println(ans);

    }
}

</source>
<source file="../hum_codes_raw/s413840969.java" startline="1" endline="39" pcid="13913">
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int N = sc.nextInt();
        int A = sc.nextInt();
        int[] x = new int[N + 1];
        for (int i = 1; i <= N; ++i) {
            x[i] = sc.nextInt();
        }

        long[][][] dp = new long[N + 1][N + 1][N * A + 1];
        for (int i = 0; i < N; ++i) {
            dp[i][0][0] = 1;
        }

        for (int i = 1; i <= N; ++i) {
            for (int j = 1; j <= i; ++j) {
                for (int k = 1; k <= N * A; ++k) {
                    if (k < x[i]) {
                        dp[i][j][k] = dp[i - 1][j][k];
                    } else {
                        dp[i][j][k] = dp[i - 1][j][k] + dp[i - 1][j - 1][k - x[i]];
                    }
                }
            }
        }

        long ans = 0;
        for (int j = 1; j <= N; ++j) {
            ans += dp[N][j][j * A];
        }

        System.out.println(ans);
    }
}

</source>
</class>

<class classid="87" nclones="3" nlines="52" similarity="100">
<source file="../hum_codes_raw/s147924630.java" startline="1" endline="64" pcid="4943">
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int n = sc.nextInt();
			if(n == 0){
				break;
			}
			int[][] students = new int[n][n];
			int[][] x = new int[n][n];
			for(int i = 0; i < n; i++){
				for(int j = 0; j < n; j++){
					students[i][j] = sc.nextInt();
				}
			}
			
			for(int i = 0; i < n; i++){
				int columnMax = -1;
				for(int j = 0; j < n; j++){
					if(columnMax < students[j][i])
						columnMax = students[j][i];
				}
				for(int j = 0; j < n; j++){
					if(columnMax == students[j][i])
						x[j][i] |= 2;
				}
			}
			for(int i = 0; i < n; i++){
				int rowMin = Integer.MAX_VALUE;
				for(int j = 0; j < n; j++){
					if(rowMin > students[i][j])
						rowMin = students[i][j];
				}
				for(int j = 0; j < n; j++){
					if(rowMin == students[i][j])
						x[i][j] |= 1;
				}
			}
			
			Set<Integer> both = new HashSet<Integer>();
            for(int i = 0;i < n;i++)
                for(int j = 0;j < n;j++)
                    if(x[i][j] == 3)
                        both.add(students[i][j]);
			
            if(both.size() == 1){
            	StringBuilder sb = new StringBuilder();
                for(int v : both){
                    sb.append(v + " ");
                }
                sb.deleteCharAt(sb.length() - 1);
                System.out.println(sb);
            }else{
            	System.out.println(0);
            }
		}
	}
}

</source>
<source file="../hum_codes_raw/s650556080.java" startline="1" endline="64" pcid="21836">
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int n = sc.nextInt();
			if(n == 0){
				break;
			}
			int[][] students = new int[n][n];
			int[][] x = new int[n][n];
			for(int i = 0; i < n; i++){
				for(int j = 0; j < n; j++){
					students[i][j] = sc.nextInt();
				}
			}
			
			for(int i = 0; i < n; i++){
				int columnMax = -1;
				for(int j = 0; j < n; j++){
					if(columnMax < students[j][i])
						columnMax = students[j][i];
				}
				for(int j = 0; j < n; j++){
					if(columnMax == students[j][i])
						x[j][i] |= 2;
				}
			}
			for(int i = 0; i < n; i++){
				int rowMin = Integer.MAX_VALUE;
				for(int j = 0; j < n; j++){
					if(rowMin > students[i][j])
						rowMin = students[i][j];
				}
				for(int j = 0; j < n; j++){
					if(rowMin == students[i][j])
						x[i][j] |= 1;
				}
			}
			
			Set<Integer> both = new HashSet<Integer>();
            for(int i = 0;i < n;i++)
                for(int j = 0;j < n;j++)
                    if(x[i][j] == 3)
                        both.add(students[i][j]);
			
            if(both.size() == 1){
            	StringBuilder sb = new StringBuilder();
                for(int v : both){
                    sb.append(v + " ");
                }
                sb.deleteCharAt(sb.length() - 1);
                System.out.println(sb);
            }else{
            	System.out.println(0);
            }
		}
	}
}

</source>
<source file="../hum_codes_raw/s673267797.java" startline="1" endline="64" pcid="22618">
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int n = sc.nextInt();
			if(n == 0){
				break;
			}
			int[][] students = new int[n][n];
			int[][] x = new int[n][n];
			for(int i = 0; i < n; i++){
				for(int j = 0; j < n; j++){
					students[i][j] = sc.nextInt();
				}
			}
			
			for(int i = 0; i < n; i++){
				int columnMax = -1;
				for(int j = 0; j < n; j++){
					if(columnMax < students[j][i])
						columnMax = students[j][i];
				}
				for(int j = 0; j < n; j++){
					if(columnMax == students[j][i])
						x[j][i] |= 2;
				}
			}
			for(int i = 0; i < n; i++){
				int rowMin = Integer.MAX_VALUE;
				for(int j = 0; j < n; j++){
					if(rowMin > students[i][j])
						rowMin = students[i][j];
				}
				for(int j = 0; j < n; j++){
					if(rowMin == students[i][j])
						x[i][j] |= 1;
				}
			}
			
			Set<Integer> both = new HashSet<Integer>();
            for(int i = 0;i < n;i++)
                for(int j = 0;j < n;j++)
                    if(x[i][j] == 3)
                        both.add(students[i][j]);
			
            if(both.size() == 1){
            	StringBuilder sb = new StringBuilder();
                for(int v : both){
                    sb.append(v + " ");
                }
                sb.deleteCharAt(sb.length() - 1);
                System.out.println(sb);
            }else{
            	System.out.println(0);
            }
		}
	}
}

</source>
</class>

<class classid="88" nclones="3" nlines="121" similarity="100">
<source file="../hum_codes_raw/s148459095.java" startline="1" endline="183" pcid="4956">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

/**
 * 
 * @author DemonSong
 * 
 *         2170.Marked Ancestor
 * 
 *         Problem F: Marked Ancestor You are given a tree T that consists of N
 *         nodes. Each node is numbered from 1 to N, and node 1 is always the
 *         root node of T. Consider the following two operations on T:
 * 
 *         M v: (Mark) Mark node v. Q v: (Query) Print the index of the nearest
 *         marked ancestor of node v which is nearest to it. Initially, only the
 *         root node is marked. Your job is to write a program that performs a
 *         sequence of these operations on a given tree and calculates the value
 *         that each Q operation will print. To avoid too large output file,
 *         your program is requested to print the sum of the outputs of all
 *         query operations. Note that the judges confirmed that it is possible
 *         to calculate every output of query operations in a given sequence.
 * 
 *         Input The input consists of multiple datasets. Each dataset has the
 *         following format:
 * 
 *         The first line of the input contains two integers N and Q, which
 *         denotes the number of nodes in the tree T and the number of
 *         operations, respectively. These numbers meet the following
 *         conditions: 1 ??? N ??? 100000 and 1 ??? Q ??? 100000.
 * 
 *         The following N - 1 lines describe the configuration of the tree T.
 *         Each line contains a single integer pi (i = 2, ... , N), which
 *         represents the index of the parent of i-th node.
 * 
 *         The next Q lines contain operations in order. Each operation is
 *         formatted as "M v" or "Q v", where v is the index of a node.
 * 
 *         The last dataset is followed by a line containing two zeros. This
 *         line is not a part of any dataset and should not be processed.
 * 
 *         Output For each dataset, print the sum of the outputs of all query
 *         operations in one line.
 * 
 *         Sample Input 6 3 1 1 2 3 3 Q 5 M 3 Q 5 0 0 Output for the Sample
 *         Input 4
 *
 */
public class Main{
	
	static class Union{
		int[] id;
		int[] sz;
		
		public Union(int size){
			id = new int[size];
			sz = new int[size];
			for (int i = 0; i < size; ++i){
				id[i] = i;
				sz[i] = 1;
			}
		}
		
		public int find(int i){
			while(id[i] != i){
				i = id[i];
			}
			return i;
		}
		
		public boolean same(int i, int j){
			return find(i) == find(j);
		}
		
		public void union(int i, int j){
			int p = find(i);
			int q = find(j);
			
			if (p == q) return;
			
			if (sz[p] < sz[q]){
				id[p] = q;
				sz[q] += sz[p];
			}
			else{
				id[q] = p;
				sz[p] += sz[q];
			}
		}
	}
	
	public static void main(String[] args) throws IOException {
		Scanner in = new Scanner(System.in);
		while (true){
			int N = in.nextInt();
			int Q = in.nextInt();
			if (N == 0 && Q == 0) break;
			
			int[] id = new int[N];
			for (int i = 1; i < N; ++i){
				int p = in.nextInt() - 1;
				id[i] = p;
			}
			
			long sum = 0;
			for (int i = 0; i < Q; ++i){
				String opera = in.next();
				int c = in.nextInt() - 1;
				if (opera.equals("Q")){
					while (c != id[c]){
						c = id[c];
					}
					sum += (c + 1);
				}
				else{
					id[c] = c;
				}
			}
			System.out.println(sum);
		}
		
	}
	
	static class Scanner {

		private BufferedReader br;
		private StringTokenizer tok;

		public Scanner(InputStream is) throws IOException {
			br = new BufferedReader(new InputStreamReader(is));
			getLine();
		}

		private void getLine() throws IOException {
			while (tok == null || !tok.hasMoreTokens()) {
				tok = new StringTokenizer(br.readLine());
			}
		}

		private boolean hasNext() {
			return tok.hasMoreTokens();
		}

		public String next() throws IOException {
			if (hasNext()) {
				return tok.nextToken();
			} else {
				getLine();
				return tok.nextToken();
			}
		}

		public int nextInt() throws IOException {
			if (hasNext()) {
				return Integer.parseInt(tok.nextToken());
			} else {
				getLine();
				return Integer.parseInt(tok.nextToken());
			}
		}

		public long nextLong() throws IOException {
			if (hasNext()) {
				return Long.parseLong(tok.nextToken());
			} else {
				getLine();
				return Long.parseLong(tok.nextToken());
			}
		}

		public double nextDouble() throws IOException {
			if (hasNext()) {
				return Double.parseDouble(tok.nextToken());
			} else {
				getLine();
				return Double.parseDouble(tok.nextToken());
			}
		}
	}
}

</source>
<source file="../hum_codes_raw/s951882746.java" startline="1" endline="183" pcid="31973">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

/**
 * 
 * @author DemonSong
 * 
 *         2170.Marked Ancestor
 * 
 *         Problem F: Marked Ancestor You are given a tree T that consists of N
 *         nodes. Each node is numbered from 1 to N, and node 1 is always the
 *         root node of T. Consider the following two operations on T:
 * 
 *         M v: (Mark) Mark node v. Q v: (Query) Print the index of the nearest
 *         marked ancestor of node v which is nearest to it. Initially, only the
 *         root node is marked. Your job is to write a program that performs a
 *         sequence of these operations on a given tree and calculates the value
 *         that each Q operation will print. To avoid too large output file,
 *         your program is requested to print the sum of the outputs of all
 *         query operations. Note that the judges confirmed that it is possible
 *         to calculate every output of query operations in a given sequence.
 * 
 *         Input The input consists of multiple datasets. Each dataset has the
 *         following format:
 * 
 *         The first line of the input contains two integers N and Q, which
 *         denotes the number of nodes in the tree T and the number of
 *         operations, respectively. These numbers meet the following
 *         conditions: 1 ??? N ??? 100000 and 1 ??? Q ??? 100000.
 * 
 *         The following N - 1 lines describe the configuration of the tree T.
 *         Each line contains a single integer pi (i = 2, ... , N), which
 *         represents the index of the parent of i-th node.
 * 
 *         The next Q lines contain operations in order. Each operation is
 *         formatted as "M v" or "Q v", where v is the index of a node.
 * 
 *         The last dataset is followed by a line containing two zeros. This
 *         line is not a part of any dataset and should not be processed.
 * 
 *         Output For each dataset, print the sum of the outputs of all query
 *         operations in one line.
 * 
 *         Sample Input 6 3 1 1 2 3 3 Q 5 M 3 Q 5 0 0 Output for the Sample
 *         Input 4
 *
 */
public class Main{
	
	static class Union{
		int[] id;
		int[] sz;
		
		public Union(int size){
			id = new int[size];
			sz = new int[size];
			for (int i = 0; i < size; ++i){
				id[i] = i;
				sz[i] = 1;
			}
		}
		
		public int find(int i){
			while(id[i] != i){
				i = id[i];
			}
			return i;
		}
		
		public boolean same(int i, int j){
			return find(i) == find(j);
		}
		
		public void union(int i, int j){
			int p = find(i);
			int q = find(j);
			
			if (p == q) return;
			
			if (sz[p] < sz[q]){
				id[p] = q;
				sz[q] += sz[p];
			}
			else{
				id[q] = p;
				sz[p] += sz[q];
			}
		}
	}
	
	public static void main(String[] args) throws IOException {
		Scanner in = new Scanner(System.in);
		while (true){
			int N = in.nextInt();
			int Q = in.nextInt();
			if (N == 0 && Q == 0) break;
			
			int[] id = new int[N];
			for (int i = 1; i < N; ++i){
				int p = in.nextInt() - 1;
				id[i] = p;
			}
			
			long sum = 0;
			for (int i = 0; i < Q; ++i){
				String opera = in.next();
				int c = in.nextInt() - 1;
				if (opera.equals("Q")){
					while (c != id[c]){
						c = id[c];
					}
					sum += (c + 1);
				}
				else{
					id[c] = c;
				}
			}
			System.out.println(sum);
		}
		
	}
	
	static class Scanner {

		private BufferedReader br;
		private StringTokenizer tok;

		public Scanner(InputStream is) throws IOException {
			br = new BufferedReader(new InputStreamReader(is));
			getLine();
		}

		private void getLine() throws IOException {
			while (tok == null || !tok.hasMoreTokens()) {
				tok = new StringTokenizer(br.readLine());
			}
		}

		private boolean hasNext() {
			return tok.hasMoreTokens();
		}

		public String next() throws IOException {
			if (hasNext()) {
				return tok.nextToken();
			} else {
				getLine();
				return tok.nextToken();
			}
		}

		public int nextInt() throws IOException {
			if (hasNext()) {
				return Integer.parseInt(tok.nextToken());
			} else {
				getLine();
				return Integer.parseInt(tok.nextToken());
			}
		}

		public long nextLong() throws IOException {
			if (hasNext()) {
				return Long.parseLong(tok.nextToken());
			} else {
				getLine();
				return Long.parseLong(tok.nextToken());
			}
		}

		public double nextDouble() throws IOException {
			if (hasNext()) {
				return Double.parseDouble(tok.nextToken());
			} else {
				getLine();
				return Double.parseDouble(tok.nextToken());
			}
		}
	}
}

</source>
<source file="../hum_codes_raw/s258318295.java" startline="1" endline="184" pcid="8680">

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

/**
 * 
 * @author DemonSong
 * 
 *         2170.Marked Ancestor
 * 
 *         Problem F: Marked Ancestor You are given a tree T that consists of N
 *         nodes. Each node is numbered from 1 to N, and node 1 is always the
 *         root node of T. Consider the following two operations on T:
 * 
 *         M v: (Mark) Mark node v. Q v: (Query) Print the index of the nearest
 *         marked ancestor of node v which is nearest to it. Initially, only the
 *         root node is marked. Your job is to write a program that performs a
 *         sequence of these operations on a given tree and calculates the value
 *         that each Q operation will print. To avoid too large output file,
 *         your program is requested to print the sum of the outputs of all
 *         query operations. Note that the judges confirmed that it is possible
 *         to calculate every output of query operations in a given sequence.
 * 
 *         Input The input consists of multiple datasets. Each dataset has the
 *         following format:
 * 
 *         The first line of the input contains two integers N and Q, which
 *         denotes the number of nodes in the tree T and the number of
 *         operations, respectively. These numbers meet the following
 *         conditions: 1 ??? N ??? 100000 and 1 ??? Q ??? 100000.
 * 
 *         The following N - 1 lines describe the configuration of the tree T.
 *         Each line contains a single integer pi (i = 2, ... , N), which
 *         represents the index of the parent of i-th node.
 * 
 *         The next Q lines contain operations in order. Each operation is
 *         formatted as "M v" or "Q v", where v is the index of a node.
 * 
 *         The last dataset is followed by a line containing two zeros. This
 *         line is not a part of any dataset and should not be processed.
 * 
 *         Output For each dataset, print the sum of the outputs of all query
 *         operations in one line.
 * 
 *         Sample Input 6 3 1 1 2 3 3 Q 5 M 3 Q 5 0 0 Output for the Sample
 *         Input 4
 *
 */
public class Main{
	
	static class Union{
		int[] id;
		int[] sz;
		
		public Union(int size){
			id = new int[size];
			sz = new int[size];
			for (int i = 0; i < size; ++i){
				id[i] = i;
				sz[i] = 1;
			}
		}
		
		public int find(int i){
			while(id[i] != i){
				i = id[i];
			}
			return i;
		}
		
		public boolean same(int i, int j){
			return find(i) == find(j);
		}
		
		public void union(int i, int j){
			int p = find(i);
			int q = find(j);
			
			if (p == q) return;
			
			if (sz[p] < sz[q]){
				id[p] = q;
				sz[q] += sz[p];
			}
			else{
				id[q] = p;
				sz[p] += sz[q];
			}
		}
	}
	
	public static void main(String[] args) throws IOException {
		Scanner in = new Scanner(System.in);
		while (true){
			int N = in.nextInt();
			int Q = in.nextInt();
			if (N == 0 && Q == 0) break;
			
			int[] id = new int[N];
			for (int i = 1; i < N; ++i){
				int p = in.nextInt() - 1;
				id[i] = p;
			}
			
			long sum = 0;
			for (int i = 0; i < Q; ++i){
				String opera = in.next();
				int c = in.nextInt() - 1;
				if (opera.equals("Q")){
					while (c != id[c]){
						c = id[c];
					}
					sum += (c + 1);
				}
				else{
					id[c] = c;
				}
			}
			System.out.println(sum);
		}
		
	}
	
	static class Scanner {

		private BufferedReader br;
		private StringTokenizer tok;

		public Scanner(InputStream is) throws IOException {
			br = new BufferedReader(new InputStreamReader(is));
			getLine();
		}

		private void getLine() throws IOException {
			while (tok == null || !tok.hasMoreTokens()) {
				tok = new StringTokenizer(br.readLine());
			}
		}

		private boolean hasNext() {
			return tok.hasMoreTokens();
		}

		public String next() throws IOException {
			if (hasNext()) {
				return tok.nextToken();
			} else {
				getLine();
				return tok.nextToken();
			}
		}

		public int nextInt() throws IOException {
			if (hasNext()) {
				return Integer.parseInt(tok.nextToken());
			} else {
				getLine();
				return Integer.parseInt(tok.nextToken());
			}
		}

		public long nextLong() throws IOException {
			if (hasNext()) {
				return Long.parseLong(tok.nextToken());
			} else {
				getLine();
				return Long.parseLong(tok.nextToken());
			}
		}

		public double nextDouble() throws IOException {
			if (hasNext()) {
				return Double.parseDouble(tok.nextToken());
			} else {
				getLine();
				return Double.parseDouble(tok.nextToken());
			}
		}
	}
}

</source>
</class>

<class classid="89" nclones="2" nlines="26" similarity="100">
<source file="../hum_codes_raw/s150255228.java" startline="1" endline="33" pcid="5021">
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;

class Main{
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        int n = Integer.parseInt(br.readLine());
        String[] input = br.readLine().split(" ");

        int max = 0;
        boolean onCheck = false;
        int cl = 1; // current length

        for(String x : input){
            if(x.equals("1")){
                cl++;
                onCheck = true;
            }else if(onCheck){
                max = Math.max(cl,max);
                cl = 1;
                onCheck = false;
            }
        }

        max = Math.max(cl,max);

        System.out.println(max);
    }
}


</source>
<source file="../hum_codes_raw/s836953497.java" startline="1" endline="32" pcid="28096">
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;

class Main{
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        int n = Integer.parseInt(br.readLine());
        String[] input = br.readLine().split(" ");

        int max = 0;
        boolean onCheck = false;
        int cl = 1; // current length

        for(String x : input){
            if(x.equals("1")){
                cl++;
                onCheck = true;
            }else if(onCheck){
                max = Math.max(cl,max);
                cl = 1;
                onCheck = false;
            }
        }

        max = Math.max(cl,max);

        System.out.println(max);
    }
}

</source>
</class>

<class classid="90" nclones="2" nlines="113" similarity="100">
<source file="../hum_codes_raw/s153560595.java" startline="1" endline="143" pcid="5149">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.PriorityQueue;
import java.util.Queue;

public class Main {

  public static void main(String[] args) {
    
    new Main().run();
  }

  public void run() {

    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      int n = Integer.parseInt(br.readLine());
      Graph graph = new Graph(n);
      String[] vInfo;
      int id,degree,key,val;
      IntTuple[] ajacent;

      for(int i=0; i<n; i++) {
        vInfo = br.readLine().split(" ");
        id     = Integer.parseInt(vInfo[0]);
        degree = Integer.parseInt(vInfo[1]);
        ajacent = new IntTuple[degree];
        for (int j=0,k=2; j<degree; j++) {
          key = Integer.parseInt(vInfo[k++]);
          val = Integer.parseInt(vInfo[k++]);
          ajacent[j] = new IntTuple(key, val);
        }
        graph.setVertex(id, ajacent);
      }

      graph.calcSSSPWeightSum();

      StringBuilder buf = new StringBuilder();
      for (Vertex v : graph.vertices) {
        buf.append(v.id).append(" ").append(v.minPathCost)
           .append("\n");
      }
      System.out.print(buf);
    }
    catch (IOException e) {
      System.err.println(e);
    }
  }


  class Graph {

    Vertex[] vertices;
    Queue<IntTuple> queue;

    public Graph(int size ) {
      vertices  = new Vertex[size];
      queue = new PriorityQueue<>(size);
    }

    public void setVertex(int id) {
      vertices[id] = new Vertex(id);
    }
    public void setVertex(int id, IntTuple[] ajacent) {
      setVertex(id);
      setAjacent(id, ajacent);
    }
    public void setAjacent(int id, IntTuple[] ajasent) {
      vertices[id].ajacent = ajasent;
    }

    public void calcSSSPWeightSum() {
      algorithmDijkstra(0);
    }

    private void algorithmDijkstra(int s) {
      vertices[s].minPathCost = 0;
      Vertex current,next;
      queue.offer(new IntTuple(vertices[s].id, vertices[s].minPathCost));
      vertices[s].state = Vertex.GRAY;

      IntTuple v;
      while( (v = queue.poll()) != null ) {
        vertices[v.key].state = Vertex.BLACK;

        if(vertices[v.key].minPathCost < v.val) continue;
        
        current = vertices[v.key];
        for (IntTuple w: current.ajacent) {
          next = vertices[w.key];
          if( (next.state != Vertex.BLACK) &&
              (current.minPathCost + w.val < next.minPathCost) ) {
            next.minPathCost = current.minPathCost + w.val;
            queue.offer(new IntTuple(next.id, next.minPathCost));
            next.state = Vertex.GRAY;
          }
        }
        continue;
      }
    }
  }

  class Vertex {

    static final int NILL  =-1;
    static final int WHITE = 0;
    static final int GRAY  = 1;
    static final int BLACK = 2;
    int id;
    int state;
    int minPathCost;
    IntTuple[] ajacent;

    public Vertex(int id) {
      this.id = id;
      state = WHITE;
      minPathCost = Integer.MAX_VALUE;
    }
  }

  class IntTuple implements Comparable<IntTuple> {
    public int key;
    public int val;

    public IntTuple(int key, int val) {
      this.key = key;
      this.val = val;
    }

    @Override
    public String toString() {
      return "[" + key + "," + val + "]";
    }
    @Override
    public int compareTo(IntTuple obj) {
      if(this.val == obj.val) return 0;

      return this.val > obj.val ? 1 : -1;
    }
  }
}

</source>
<source file="../hum_codes_raw/s739900039.java" startline="1" endline="143" pcid="24856">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.PriorityQueue;
import java.util.Queue;

public class Main {

  public static void main(String[] args) {
    
    new Main().run();
  }

  public void run() {

    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      int n = Integer.parseInt(br.readLine());
      Graph graph = new Graph(n);
      String[] vInfo;
      int id,degree,key,val;
      IntTuple[] ajacent;

      for(int i=0; i<n; i++) {
        vInfo = br.readLine().split(" ");
        id     = Integer.parseInt(vInfo[0]);
        degree = Integer.parseInt(vInfo[1]);
        ajacent = new IntTuple[degree];
        for (int j=0,k=2; j<degree; j++) {
          key = Integer.parseInt(vInfo[k++]);
          val = Integer.parseInt(vInfo[k++]);
          ajacent[j] = new IntTuple(key, val);
        }
        graph.setVertex(id, ajacent);
      }

      graph.calcSSSPWeightSum();

      StringBuilder buf = new StringBuilder();
      for (Vertex v : graph.vertices) {
        buf.append(v.id).append(" ").append(v.minPathCost)
           .append("\n");
      }
      System.out.print(buf);
    }
    catch (IOException e) {
      System.err.println(e);
    }
  }


  class Graph {

    Vertex[] vertices;
    Queue<IntTuple> queue;

    public Graph(int size ) {
      vertices  = new Vertex[size];
      queue = new PriorityQueue<>(size);
    }

    public void setVertex(int id) {
      vertices[id] = new Vertex(id);
    }
    public void setVertex(int id, IntTuple[] ajacent) {
      setVertex(id);
      setAjacent(id, ajacent);
    }
    public void setAjacent(int id, IntTuple[] ajasent) {
      vertices[id].ajacent = ajasent;
    }

    public void calcSSSPWeightSum() {
      algorithmDijkstra(0);
    }

    private void algorithmDijkstra(int s) {
      vertices[s].minPathCost = 0;
      Vertex current,next;
      queue.offer(new IntTuple(vertices[s].id, vertices[s].minPathCost));
      vertices[s].state = Vertex.GRAY;

      IntTuple v;
      while( (v = queue.poll()) != null ) {
        vertices[v.key].state = Vertex.BLACK;

        if(vertices[v.key].minPathCost < v.val) continue;
        
        current = vertices[v.key];
        for (IntTuple w: current.ajacent) {
          next = vertices[w.key];
          if( (next.state != Vertex.BLACK) &&
              (current.minPathCost + w.val < next.minPathCost) ) {
            next.minPathCost = current.minPathCost + w.val;
            queue.offer(new IntTuple(next.id, next.minPathCost));
            next.state = Vertex.GRAY;
          }
        }
        continue;
      }
    }
  }

  class Vertex {

    static final int NILL  =-1;
    static final int WHITE = 0;
    static final int GRAY  = 1;
    static final int BLACK = 2;
    int id;
    int state;
    int minPathCost;
    IntTuple[] ajacent;

    public Vertex(int id) {
      this.id = id;
      state = WHITE;
      minPathCost = Integer.MAX_VALUE;
    }
  }

  class IntTuple implements Comparable<IntTuple> {
    public int key;
    public int val;

    public IntTuple(int key, int val) {
      this.key = key;
      this.val = val;
    }

    @Override
    public String toString() {
      return "[" + key + "," + val + "]";
    }
    @Override
    public int compareTo(IntTuple obj) {
      if(this.val == obj.val) return 0;

      return this.val > obj.val ? 1 : -1;
    }
  }
}

</source>
</class>

<class classid="91" nclones="3" nlines="38" similarity="100">
<source file="../hum_codes_raw/s154166749.java" startline="1" endline="41" pcid="5164">
import java.util.Scanner;
 
public class Main {
    public static void main(String[] args) {
        try(Scanner sc = new Scanner(System.in)){
        	while(true) {
        		int m = sc.nextInt();
        		int n = sc.nextInt();
        		if(m==0 && n==0) break;
        		int w [] = new int[n];
        		int sum = 0;
        		int max = 0;
        		for(int i=0;i<n;i++) {
        			w[i] = sc.nextInt();
        			sum += w[i];
        			max = Math.max(w[i], max);
        		}
        		max = Math.max(max, sum/m);
        		
        		for(int i=max;;i++) {
        			sum = 0;
        			int count = 0;
        			for(int j=0;j<n;j++) {
        				sum += w[j];
        				if(sum>i) {
        					j--;
        					count++;
        					sum = 0;
        				}
        				if(count==m) break;
        			}
        			if(count<m) {
        			System.out.println(i);
        			break;
        			}
        		}
        	}	
        }
    }
}

</source>
<source file="../hum_codes_raw/s660414641.java" startline="1" endline="42" pcid="22175">
import java.util.Scanner;
 
public class Main {
    public static void main(String[] args) {
        try(Scanner sc = new Scanner(System.in)){
        	while(true) {
        		int m = sc.nextInt();
        		int n = sc.nextInt();
        		if(m==0 && n==0) break;
        		int w [] = new int[n];
        		int sum = 0;
        		int max = 0;
        		for(int i=0;i<n;i++) {
        			w[i] = sc.nextInt();
        			sum += w[i];
        			max = Math.max(w[i], max);
        		}
        		max = Math.max(max, sum/m);
        		
        		for(int i=max;;i++) {
        			sum = 0;
        			int count = 0;
        			for(int j=0;j<n;j++) {
        				sum += w[j];
        				if(sum>i) {
        					j--;
        					count++;
        					sum = 0;
        				}
        				if(count==m) break;
        			}
        			if(count<m) {
        			System.out.println(i);
        			break;
        			}
        		}
        	}	
        }
    }
}


</source>
<source file="../hum_codes_raw/s766888933.java" startline="1" endline="42" pcid="25755">
import java.util.Scanner;
 
public class Main {
    public static void main(String[] args) {
        try(Scanner sc = new Scanner(System.in)){
        	while(true) {
        		int m = sc.nextInt();
        		int n = sc.nextInt();
        		if(m==0 && n==0) break;
        		int w [] = new int[n];
        		int sum = 0;
        		int max = 0;
        		for(int i=0;i<n;i++) {
        			w[i] = sc.nextInt();
        			sum += w[i];
        			max = Math.max(w[i], max);
        		}
        		max = Math.max(max, sum/m);
        		
        		for(int i=max;;i++) {
        			sum = 0;
        			int count = 0;
        			for(int j=0;j<n;j++) {
        				sum += w[j];
        				if(sum>i) {
        					j--;
        					count++;
        					sum = 0;
        				}
        				if(count==m) break;
        			}
        			if(count<m) {
        			System.out.println(i);
        			break;
        			}
        		}
        	}	
        }
    }
}


</source>
</class>

<class classid="92" nclones="2" nlines="19" similarity="100">
<source file="../hum_codes_raw/s156731543.java" startline="1" endline="23" pcid="5256">
import java.util.Scanner;

//Patrol
public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(sc.hasNext()){
			int[] a = new int[101];
			while(true){
				int s = sc.nextInt();
				int t = sc.nextInt();
				if((s|t)==0)break;
				a[s]++;
				a[t]++;
			}
			int o = 0;
			for(int s:a)if(s%2==1)o++;
			System.out.println(o!=2?"NG":a[1]%2==1&&a[2]%2==1?"OK":"NG");
		}
	}
}

</source>
<source file="../hum_codes_raw/s277078962.java" startline="1" endline="23" pcid="9270">
import java.util.Scanner;

//Patrol
public class Main{

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(sc.hasNext()){
			int[] a = new int[101];
			while(true){
				int s = sc.nextInt();
				int t = sc.nextInt();
				if((s|t)==0)break;
				a[s]++;
				a[t]++;
			}
			int o = 0;
			for(int s:a)if(s%2==1)o++;
			System.out.println(o!=2?"NG":a[1]%2==1&&a[2]%2==1?"OK":"NG");
		}
	}
}

</source>
</class>

<class classid="93" nclones="2" nlines="22" similarity="100">
<source file="../hum_codes_raw/s157691451.java" startline="1" endline="33" pcid="5292">
import java.util.*;
/**
 * @author afterCmidday
 *
 */
class Main {
 
    /**
     * @param args
     */
    public static void main(String[] args) {
        // TODO 自動生成されたメソッド・スタブ
        final double eps = 1e-10;
        int n;
        Scanner scan = new Scanner(System.in);
        n = scan.nextInt();
        for(int i = 0;i < n;i++){
            double x1 = scan.nextDouble(), y1 = scan.nextDouble(), x2 = scan.nextDouble(), y2 = scan.nextDouble();
            double a = x2 - x1, b = y2 - y1;
            double x3 = scan.nextDouble(), y3 = scan.nextDouble(), x4 = scan.nextDouble(), y4 = scan.nextDouble();
            double c = x4 - x3, d = y4 - y3;
            double e = a * d - b * c;
            if(Math.abs(e) < eps){
                System.out.println("YES");
            }else{
                System.out.println("NO");
            }
        }
 
    }
 
}

</source>
<source file="../hum_codes_raw/s790607735.java" startline="1" endline="36" pcid="26559">
/**
 * 
 */
import java.util.*;
/**
 * @author afterCmidday
 *
 */
class Main {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO 自動生成されたメソッド・スタブ
		final double eps = 1e-10;
		int n;
		Scanner scan = new Scanner(System.in);
		n = scan.nextInt();
		for(int i = 0;i < n;i++){
			double x1 = scan.nextDouble(), y1 = scan.nextDouble(), x2 = scan.nextDouble(), y2 = scan.nextDouble();
			double a = x2 - x1, b = y2 - y1;
			double x3 = scan.nextDouble(), y3 = scan.nextDouble(), x4 = scan.nextDouble(), y4 = scan.nextDouble();
			double c = x4 - x3, d = y4 - y3;
			double e = a * d - b * c;
			if(Math.abs(e) < eps){
				System.out.println("YES");
			}else{
				System.out.println("NO");
			}
		}

	}

}

</source>
</class>

<class classid="94" nclones="2" nlines="13" similarity="100">
<source file="../hum_codes_raw/s157938525.java" startline="1" endline="19" pcid="5302">
import java.util.Scanner;

public class Main {
	Scanner sc = new Scanner(System.in);
	
	public static void main(String[] args) {
		Main m = new Main();
		m.run();
	}
	
	void run() {
		int n = sc.nextInt();
		int k = sc.nextInt();
		
		System.out.println(n-k+1);
		
	}
}

</source>
<source file="../hum_codes_raw/s168074770.java" startline="1" endline="19" pcid="5634">
import java.util.Scanner;

public class Main {
	Scanner sc = new Scanner(System.in);
	
	public static void main(String[] args) {
		Main m = new Main();
		m.run();
	}
	
	void run() {
		int n = sc.nextInt();
		int k = sc.nextInt();
		
		System.out.println(n-k+1);
		
	}
}

</source>
</class>

<class classid="95" nclones="2" nlines="44" similarity="100">
<source file="../hum_codes_raw/s160342270.java" startline="1" endline="46" pcid="5380">
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Main main = new Main();
        main.solve();
    }
    public void solve() {
        Scanner scan = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int N = scan.nextInt();
        long C = scan.nextLong();
        long K = scan.nextLong();
        long[] l = new long[N];
        for (int i = 0; i < N; i++) {
            l[i] = scan.nextLong();
        }
        Arrays.sort(l);
        long[] r = new long[N];
        for (int i = 0; i < N; i++) {
            r[i] = l[i] + K;
        }
        int answer = 0;
        long current = Long.MAX_VALUE;
        long number_of_people = 0;
        for (int i = N-1; 0 <= i; i--) {
            if (number_of_people == C) {
                answer += 1;
                number_of_people = 0;
                current = l[i];
            }
            if (r[i] < current) {
                answer += (number_of_people + (C-1))/C;
                number_of_people = 1;
                current = l[i];
                continue;
            }
            number_of_people += 1;
        }
        answer += (number_of_people + (C - 1)) / C;
        System.out.println(answer);
    }
}

</source>
<source file="../hum_codes_raw/s295257878.java" startline="1" endline="46" pcid="9900">
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Main main = new Main();
        main.solve();
    }
    public void solve() {
        Scanner scan = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int N = scan.nextInt();
        long C = scan.nextLong();
        long K = scan.nextLong();
        long[] l = new long[N];
        for (int i = 0; i < N; i++) {
            l[i] = scan.nextLong();
        }
        Arrays.sort(l);
        long[] r = new long[N];
        for (int i = 0; i < N; i++) {
            r[i] = l[i] + K;
        }
        int answer = 0;
        long current = Long.MAX_VALUE;
        long number_of_people = 0;
        for (int i = N-1; 0 <= i; i--) {
            if (number_of_people == C) {
                answer += 1;
                number_of_people = 0;
                current = l[i];
            }
            if (r[i] < current) {
                answer += (number_of_people + (C-1))/C;
                number_of_people = 1;
                current = l[i];
                continue;
            }
            number_of_people += 1;
        }
        answer += (number_of_people + (C - 1)) / C;
        System.out.println(answer);
    }
}

</source>
</class>

<class classid="96" nclones="4" nlines="169" similarity="100">
<source file="../hum_codes_raw/s161310507.java" startline="1" endline="249" pcid="5407">
import java.util.ArrayList;
import java.util.Scanner;
import java.io.PrintWriter;

class Main {
    static Scanner sc = new Scanner(System.in);
    static PrintWriter out = new PrintWriter(System.out);
    static RUQ d = new RUQ(100005, (1 << 31) - 1);
    static int n, q;
    static int com;
    static int indx;
    static int s, t, x;
    
    public static void main(String[] args) {
        n = sc.nextInt();
        q = sc.nextInt();
        
        for (int i = 0; i < q; i++) {

            com = sc.nextInt();
            if (com == 0) {

                s = sc.nextInt();
                t = sc.nextInt();
                x = sc.nextInt();
                d.update(s, t + 1, x);
            }
            else {
                indx = sc.nextInt();
                out.println(d.query(indx, indx + 1));
            }
        }
        
        out.flush();
    }
}

class RUQ extends LazySqrtDecomposition<Integer> {

    public RUQ(int n, int e) {
        super(n, e);
    }
    
    @Override
    protected Integer f(Integer x, Integer y) {
        return y;
    }
    
    @Override
    protected Integer g(Integer x, Integer y, int t) {
        return y;
    }
    
    @Override
    protected Integer h(Integer x, Integer y) {
        return y;
    }

}

/**
 * @author ei1710
 * @version 1.00
 */

//package toyama.ei1710.DataStructures;
/**
 * モノイドを乗せられる平方分割の抽象クラス.<br>
 * operatorメソッドをオーバライドすることで二項演算を定義する<br>
 * データの区間更新、区間に対する質問クエリをO(sqrt(N))で行う
 *
 * 更新<br>
 * 更新する区間が、bucket_iの管理する区間を完全に含むなら、lazy_iに値を入れる<br>
 * 交差している場合は、対象部分のデータを更新してから、bucket_iを更新する<br>
 *
 * クエリ<br>
 * 質問の対象区間が、bucket_iを完全に含む場合、bucket_iとlazy_iをマージして返す
 * 交差していて、かつlazy_iに値がある場合、その区間のデータを更新後、bucket_iを更新する
 * すると、通常の平方分割と同じになる
 *
 */
abstract class LazySqrtDecomposition<T> {
    /** 生データ */
    protected ArrayList<T> raw_data;
    /** バケットごとに事前に演算した結果を保持 */
    protected ArrayList<T> bucket;
    /** バケット範囲に一様に作用させる値 */
    protected ArrayList<T> lazy;
    
    /** lazyにデータはあるかな？ */
    protected boolean[] lazy_flag;
    /** 単位元 */
    protected T e;
    /** データ数 */
    protected int N;

    protected int sqrtN;

    /** バケットの数 */
    protected int K;
    
    /** 要素と要素の合成 */
    abstract protected T f(T x, T y);

    /** 要素と作用素の合成 bucketとlazyのマージに使うよ */
    abstract protected T g(T x, T y, int t);

    /** 作用素と作用素の合成 lazyにデータが入ってるときに使うよ*/
    abstract protected T h(T x, T y);
    
    /** 単位元eを初期値として要素数nmembの平方分割 */
    public LazySqrtDecomposition(int nmemb, T e) {
        this.e = e;
        N = nmemb;
        sqrtN = 1;
        while (sqrtN * sqrtN < N) sqrtN++;
        
        K = (N + sqrtN - 1) / sqrtN;
        
        raw_data = new ArrayList<T>(N);
        bucket = new ArrayList<T>(K);
        lazy = new ArrayList<T>(K);
        lazy_flag = new boolean[K];
        
        build();
    }
    
    private void build() {

        for (int i = 0; i < N; i++) {
            raw_data.add(e);
        }

        for (int i = 0; i < K; i++) {
            bucket.add(e);
            lazy.add(e);
            lazy_flag[i] = false;
        }
    }
    
    /** bucket[k]の区間に対して、lazy[k]を適用したりbucket[k]を再計算したりする */
    protected void eval(int k) {
        
        T x = e;
        for (int i = k * sqrtN; i < Math.min(N, (k + 1) * sqrtN); i++) {
            if (lazy_flag[k]) {
                raw_data.set(i, g(raw_data.get(i), lazy.get(k), 1));
            }
            x = f(x, raw_data.get(i));
        }
        
        lazy_flag[k] = false;
        bucket.set(k, x);
    }

    
    /** [l, r)区間をdatで更新するよ O(sqrt(N)) */
    public void update(int l, int r, T dat) {
        int s = l / sqrtN;
        int t = (r + sqrtN - 1) / sqrtN;

        int bucket_l, bucket_r;
        
        for (int i = s; i < t; i++) {
            bucket_l = i * sqrtN;
            bucket_r = (i + 1) * sqrtN;
            
            if (l <= bucket_l && bucket_r <= r) {
                if (lazy_flag[i]) {
                    lazy.set(i, h(lazy.get(i), dat));
                }
                else {
                    lazy.set(i, dat);
                }
                lazy_flag[i] = true;
            }
            else {
                eval(i);
                for (int j = Math.max(bucket_l, l); j < Math.min(bucket_r, r); j++) {
                    raw_data.set(j, g(raw_data.get(j), dat, 1));
                }
            }
        }
    }

    /** [l, r)の区間クエリに答える O(sqrt(N)) */
    public T query(int l, int r) {
        int s = l / sqrtN;
        int t = (r + sqrtN - 1) / sqrtN;
        int bucket_l, bucket_r;
        T x = e;
        
        for (int i = s; i < t; i++) {
            bucket_l = i * sqrtN;
            bucket_r = (i + 1) * sqrtN;
            if (l <= bucket_l && bucket_r <= r) {
                if (lazy_flag[i]) {
                    x = f(x, g(bucket.get(i), lazy.get(i), 1));
                }
                else {
                    x = f(x, bucket.get(i));
                }
            }
            else {
                eval(i);
                
                for (int j = Math.max(bucket_l, l); j < Math.min(bucket_r, r); j++) {
                    x = f(x, raw_data.get(j));
                }
            }
        }
        return x;
    }
    
    /** デバッグ情報の印字 */
    public void debugPrint() {
        
        System.err.println("-lazy-");
        for (int i = 0; i < lazy.size(); i++) {
            if (!lazy_flag[i]) {
                System.err.print(" --  ");
            }
            else {
                System.err.print(lazy.get(i));
                System.err.print(' ');
            }
        }
        System.err.print('\n');
        
        System.err.println("-bucket-");
        for (T p : bucket) {
            System.err.print(p);
            System.err.print(' ');
        }
        System.err.print('\n');

        System.err.println("-raw_data-");
        for (T q : raw_data) {
            System.err.print(q);
            System.err.print(' ');
        }
        System.err.print('\n');

        System.err.println("-other data-");
        System.err.printf("N: %d, sqrtN: %d, K: %d\n", N, sqrtN, K);
    }
}


</source>
<source file="../hum_codes_raw/s220987916.java" startline="1" endline="249" pcid="7473">
import java.util.ArrayList;
import java.util.Scanner;
import java.io.PrintWriter;

class Main {
    static Scanner sc = new Scanner(System.in);
    static PrintWriter out = new PrintWriter(System.out);
    static RUQ d = new RUQ(100005, (1 << 31) - 1);
    static int n, q;
    static int com;
    static int indx;
    static int s, t, x;
    
    public static void main(String[] args) {
        n = sc.nextInt();
        q = sc.nextInt();
        
        for (int i = 0; i < q; i++) {

            com = sc.nextInt();
            if (com == 0) {

                s = sc.nextInt();
                t = sc.nextInt();
                x = sc.nextInt();
                d.update(s, t + 1, x);
            }
            else {
                indx = sc.nextInt();
                out.println(d.query(indx, indx + 1));
            }
        }
        
        out.flush();
    }
}

class RUQ extends LazySqrtDecomposition<Integer> {

    public RUQ(int n, int e) {
        super(n, e);
    }
    
    @Override
    protected Integer f(Integer x, Integer y) {
        return y;
    }
    
    @Override
    protected Integer g(Integer x, Integer y, int t) {
        return y;
    }
    
    @Override
    protected Integer h(Integer x, Integer y) {
        return y;
    }

}

/**
 * @author ei1710
 * @version 1.00
 */

//package toyama.ei1710.DataStructures;
/**
 * モノイドを乗せられる平方分割の抽象クラス.<br>
 * operatorメソッドをオーバライドすることで二項演算を定義する<br>
 * データの区間更新、区間に対する質問クエリをO(sqrt(N))で行う
 *
 * 更新<br>
 * 更新する区間が、bucket_iの管理する区間を完全に含むなら、lazy_iに値を入れる<br>
 * 交差している場合は、対象部分のデータを更新してから、bucket_iを更新する<br>
 *
 * クエリ<br>
 * 質問の対象区間が、bucket_iを完全に含む場合、bucket_iとlazy_iをマージして返す
 * 交差していて、かつlazy_iに値がある場合、その区間のデータを更新後、bucket_iを更新する
 * すると、通常の平方分割と同じになる
 *
 */
abstract class LazySqrtDecomposition<T> {
    /** 生データ */
    protected ArrayList<T> raw_data;
    /** バケットごとに事前に演算した結果を保持 */
    protected ArrayList<T> bucket;
    /** バケット範囲に一様に作用させる値 */
    protected ArrayList<T> lazy;
    
    /** lazyにデータはあるかな？ */
    protected boolean[] lazy_flag;
    /** 単位元 */
    protected T e;
    /** データ数 */
    protected int N;

    protected int sqrtN;

    /** バケットの数 */
    protected int K;
    
    /** 要素と要素の合成 */
    abstract protected T f(T x, T y);

    /** 要素と作用素の合成 bucketとlazyのマージに使うよ */
    abstract protected T g(T x, T y, int t);

    /** 作用素と作用素の合成 lazyにデータが入ってるときに使うよ*/
    abstract protected T h(T x, T y);
    
    /** 単位元eを初期値として要素数nmembの平方分割 */
    public LazySqrtDecomposition(int nmemb, T e) {
        this.e = e;
        N = nmemb;
        sqrtN = 1;
        while (sqrtN * sqrtN < N) sqrtN++;
        
        K = (N + sqrtN - 1) / sqrtN;
        
        raw_data = new ArrayList<T>(N);
        bucket = new ArrayList<T>(K);
        lazy = new ArrayList<T>(K);
        lazy_flag = new boolean[K];
        
        build();
    }
    
    private void build() {

        for (int i = 0; i < N; i++) {
            raw_data.add(e);
        }

        for (int i = 0; i < K; i++) {
            bucket.add(e);
            lazy.add(e);
            lazy_flag[i] = false;
        }
    }
    
    /** bucket[k]の区間に対して、lazy[k]を適用したりbucket[k]を再計算したりする */
    protected void eval(int k) {
        
        T x = e;
        for (int i = k * sqrtN; i < Math.min(N, (k + 1) * sqrtN); i++) {
            if (lazy_flag[k]) {
                raw_data.set(i, g(raw_data.get(i), lazy.get(k), 1));
            }
            x = f(x, raw_data.get(i));
        }
        
        lazy_flag[k] = false;
        bucket.set(k, x);
    }

    
    /** [l, r)区間をdatで更新するよ O(sqrt(N)) */
    public void update(int l, int r, T dat) {
        int s = l / sqrtN;
        int t = (r + sqrtN - 1) / sqrtN;

        int bucket_l, bucket_r;
        
        for (int i = s; i < t; i++) {
            bucket_l = i * sqrtN;
            bucket_r = (i + 1) * sqrtN;
            
            if (l <= bucket_l && bucket_r <= r) {
                if (lazy_flag[i]) {
                    lazy.set(i, h(lazy.get(i), dat));
                }
                else {
                    lazy.set(i, dat);
                }
                lazy_flag[i] = true;
            }
            else {
                eval(i);
                for (int j = Math.max(bucket_l, l); j < Math.min(bucket_r, r); j++) {
                    raw_data.set(j, g(raw_data.get(j), dat, 1));
                }
            }
        }
    }

    /** [l, r)の区間クエリに答える O(sqrt(N)) */
    public T query(int l, int r) {
        int s = l / sqrtN;
        int t = (r + sqrtN - 1) / sqrtN;
        int bucket_l, bucket_r;
        T x = e;
        
        for (int i = s; i < t; i++) {
            bucket_l = i * sqrtN;
            bucket_r = (i + 1) * sqrtN;
            if (l <= bucket_l && bucket_r <= r) {
                if (lazy_flag[i]) {
                    x = f(x, g(bucket.get(i), lazy.get(i), 1));
                }
                else {
                    x = f(x, bucket.get(i));
                }
            }
            else {
                eval(i);
                
                for (int j = Math.max(bucket_l, l); j < Math.min(bucket_r, r); j++) {
                    x = f(x, raw_data.get(j));
                }
            }
        }
        return x;
    }
    
    /** デバッグ情報の印字 */
    public void debugPrint() {
        
        System.err.println("-lazy-");
        for (int i = 0; i < lazy.size(); i++) {
            if (!lazy_flag[i]) {
                System.err.print(" --  ");
            }
            else {
                System.err.print(lazy.get(i));
                System.err.print(' ');
            }
        }
        System.err.print('\n');
        
        System.err.println("-bucket-");
        for (T p : bucket) {
            System.err.print(p);
            System.err.print(' ');
        }
        System.err.print('\n');

        System.err.println("-raw_data-");
        for (T q : raw_data) {
            System.err.print(q);
            System.err.print(' ');
        }
        System.err.print('\n');

        System.err.println("-other data-");
        System.err.printf("N: %d, sqrtN: %d, K: %d\n", N, sqrtN, K);
    }
}


</source>
<source file="../hum_codes_raw/s218869781.java" startline="1" endline="249" pcid="7383">
import java.util.ArrayList;
import java.util.Scanner;
import java.io.PrintWriter;

class Main {
    static Scanner sc = new Scanner(System.in);
    static PrintWriter out = new PrintWriter(System.out);
    static RUQ d = new RUQ(100005, (1 << 31) - 1);
    static int n, q;
    static int com;
    static int indx;
    static int s, t, x;
    
    public static void main(String[] args) {
        n = sc.nextInt();
        q = sc.nextInt();
        
        for (int i = 0; i < q; i++) {

            com = sc.nextInt();
            if (com == 0) {

                s = sc.nextInt();
                t = sc.nextInt();
                x = sc.nextInt();
                d.update(s, t + 1, x);
            }
            else {
                indx = sc.nextInt();
                out.println(d.query(indx, indx + 1));
            }
        }
        
        out.flush();
    }
}

class RUQ extends LazySqrtDecomposition<Integer> {

    public RUQ(int n, int e) {
        super(n, e);
    }
    
    @Override
    protected Integer f(Integer x, Integer y) {
        return y;
    }
    
    @Override
    protected Integer g(Integer x, Integer y, int t) {
        return y;
    }
    
    @Override
    protected Integer h(Integer x, Integer y) {
        return y;
    }

}

/**
 * @author ei1710
 * @version 1.00
 */

//package toyama.ei1710.DataStructures;
/**
 * モノイドを乗せられる平方分割の抽象クラス.<br>
 * operatorメソッドをオーバライドすることで二項演算を定義する<br>
 * データの区間更新、区間に対する質問クエリをO(sqrt(N))で行う
 *
 * 更新<br>
 * 更新する区間が、bucket_iの管理する区間を完全に含むなら、lazy_iに値を入れる<br>
 * 交差している場合は、対象部分のデータを更新してから、bucket_iを更新する<br>
 *
 * クエリ<br>
 * 質問の対象区間が、bucket_iを完全に含む場合、bucket_iとlazy_iをマージして返す
 * 交差していて、かつlazy_iに値がある場合、その区間のデータを更新後、bucket_iを更新する
 * すると、通常の平方分割と同じになる
 *
 */
abstract class LazySqrtDecomposition<T> {
    /** 生データ */
    protected ArrayList<T> raw_data;
    /** バケットごとに事前に演算した結果を保持 */
    protected ArrayList<T> bucket;
    /** バケット範囲に一様に作用させる値 */
    protected ArrayList<T> lazy;
    
    /** lazyにデータはあるかな？ */
    protected boolean[] lazy_flag;
    /** 単位元 */
    protected T e;
    /** データ数 */
    protected int N;

    protected int sqrtN;

    /** バケットの数 */
    protected int K;
    
    /** 要素と要素の合成 */
    abstract protected T f(T x, T y);

    /** 要素と作用素の合成 bucketとlazyのマージに使うよ */
    abstract protected T g(T x, T y, int t);

    /** 作用素と作用素の合成 lazyにデータが入ってるときに使うよ*/
    abstract protected T h(T x, T y);
    
    /** 単位元eを初期値として要素数nmembの平方分割 */
    public LazySqrtDecomposition(int nmemb, T e) {
        this.e = e;
        N = nmemb;
        sqrtN = 1;
        while (sqrtN * sqrtN < N) sqrtN++;
        
        K = (N + sqrtN - 1) / sqrtN;
        
        raw_data = new ArrayList<T>(N);
        bucket = new ArrayList<T>(K);
        lazy = new ArrayList<T>(K);
        lazy_flag = new boolean[K];
        
        build();
    }
    
    private void build() {

        for (int i = 0; i < N; i++) {
            raw_data.add(e);
        }

        for (int i = 0; i < K; i++) {
            bucket.add(e);
            lazy.add(e);
            lazy_flag[i] = false;
        }
    }
    
    /** bucket[k]の区間に対して、lazy[k]を適用したりbucket[k]を再計算したりする */
    protected void eval(int k) {
        
        T x = e;
        for (int i = k * sqrtN; i < Math.min(N, (k + 1) * sqrtN); i++) {
            if (lazy_flag[k]) {
                raw_data.set(i, g(raw_data.get(i), lazy.get(k), 1));
            }
            x = f(x, raw_data.get(i));
        }
        
        lazy_flag[k] = false;
        bucket.set(k, x);
    }

    
    /** [l, r)区間をdatで更新するよ O(sqrt(N)) */
    public void update(int l, int r, T dat) {
        int s = l / sqrtN;
        int t = (r + sqrtN - 1) / sqrtN;

        int bucket_l, bucket_r;
        
        for (int i = s; i < t; i++) {
            bucket_l = i * sqrtN;
            bucket_r = (i + 1) * sqrtN;
            
            if (l <= bucket_l && bucket_r <= r) {
                if (lazy_flag[i]) {
                    lazy.set(i, h(lazy.get(i), dat));
                }
                else {
                    lazy.set(i, dat);
                }
                lazy_flag[i] = true;
            }
            else {
                eval(i);
                for (int j = Math.max(bucket_l, l); j < Math.min(bucket_r, r); j++) {
                    raw_data.set(j, g(raw_data.get(j), dat, 1));
                }
            }
        }
    }

    /** [l, r)の区間クエリに答える O(sqrt(N)) */
    public T query(int l, int r) {
        int s = l / sqrtN;
        int t = (r + sqrtN - 1) / sqrtN;
        int bucket_l, bucket_r;
        T x = e;
        
        for (int i = s; i < t; i++) {
            bucket_l = i * sqrtN;
            bucket_r = (i + 1) * sqrtN;
            if (l <= bucket_l && bucket_r <= r) {
                if (lazy_flag[i]) {
                    x = f(x, g(bucket.get(i), lazy.get(i), 1));
                }
                else {
                    x = f(x, bucket.get(i));
                }
            }
            else {
                eval(i);
                
                for (int j = Math.max(bucket_l, l); j < Math.min(bucket_r, r); j++) {
                    x = f(x, raw_data.get(j));
                }
            }
        }
        return x;
    }
    
    /** デバッグ情報の印字 */
    public void debugPrint() {
        
        System.err.println("-lazy-");
        for (int i = 0; i < lazy.size(); i++) {
            if (!lazy_flag[i]) {
                System.err.print(" --  ");
            }
            else {
                System.err.print(lazy.get(i));
                System.err.print(' ');
            }
        }
        System.err.print('\n');
        
        System.err.println("-bucket-");
        for (T p : bucket) {
            System.err.print(p);
            System.err.print(' ');
        }
        System.err.print('\n');

        System.err.println("-raw_data-");
        for (T q : raw_data) {
            System.err.print(q);
            System.err.print(' ');
        }
        System.err.print('\n');

        System.err.println("-other data-");
        System.err.printf("N: %d, sqrtN: %d, K: %d\n", N, sqrtN, K);
    }
}


</source>
<source file="../hum_codes_raw/s441715290.java" startline="1" endline="249" pcid="14801">
import java.util.ArrayList;
import java.util.Scanner;
import java.io.PrintWriter;

class Main {
    static Scanner sc = new Scanner(System.in);
    static PrintWriter out = new PrintWriter(System.out);
    static RUQ d = new RUQ(100005, (1 << 31) - 1);
    static int n, q;
    static int com;
    static int indx;
    static int s, t, x;
    
    public static void main(String[] args) {
        n = sc.nextInt();
        q = sc.nextInt();
        
        for (int i = 0; i < q; i++) {

            com = sc.nextInt();
            if (com == 0) {

                s = sc.nextInt();
                t = sc.nextInt();
                x = sc.nextInt();
                d.update(s, t + 1, x);
            }
            else {
                indx = sc.nextInt();
                out.println(d.query(indx, indx + 1));
            }
        }
        
        out.flush();
    }
}

class RUQ extends LazySqrtDecomposition<Integer> {

    public RUQ(int n, int e) {
        super(n, e);
    }
    
    @Override
    protected Integer f(Integer x, Integer y) {
        return y;
    }
    
    @Override
    protected Integer g(Integer x, Integer y, int t) {
        return y;
    }
    
    @Override
    protected Integer h(Integer x, Integer y) {
        return y;
    }

}

/**
 * @author ei1710
 * @version 1.00
 */

//package toyama.ei1710.DataStructures;
/**
 * モノイドを乗せられる平方分割の抽象クラス.<br>
 * operatorメソッドをオーバライドすることで二項演算を定義する<br>
 * データの区間更新、区間に対する質問クエリをO(sqrt(N))で行う
 *
 * 更新<br>
 * 更新する区間が、bucket_iの管理する区間を完全に含むなら、lazy_iに値を入れる<br>
 * 交差している場合は、対象部分のデータを更新してから、bucket_iを更新する<br>
 *
 * クエリ<br>
 * 質問の対象区間が、bucket_iを完全に含む場合、bucket_iとlazy_iをマージして返す
 * 交差していて、かつlazy_iに値がある場合、その区間のデータを更新後、bucket_iを更新する
 * すると、通常の平方分割と同じになる
 *
 */
abstract class LazySqrtDecomposition<T> {
    /** 生データ */
    protected ArrayList<T> raw_data;
    /** バケットごとに事前に演算した結果を保持 */
    protected ArrayList<T> bucket;
    /** バケット範囲に一様に作用させる値 */
    protected ArrayList<T> lazy;
    
    /** lazyにデータはあるかな？ */
    protected boolean[] lazy_flag;
    /** 単位元 */
    protected T e;
    /** データ数 */
    protected int N;

    protected int sqrtN;

    /** バケットの数 */
    protected int K;
    
    /** 要素と要素の合成 */
    abstract protected T f(T x, T y);

    /** 要素と作用素の合成 bucketとlazyのマージに使うよ */
    abstract protected T g(T x, T y, int t);

    /** 作用素と作用素の合成 lazyにデータが入ってるときに使うよ*/
    abstract protected T h(T x, T y);
    
    /** 単位元eを初期値として要素数nmembの平方分割 */
    public LazySqrtDecomposition(int nmemb, T e) {
        this.e = e;
        N = nmemb;
        sqrtN = 1;
        while (sqrtN * sqrtN < N) sqrtN++;
        
        K = (N + sqrtN - 1) / sqrtN;
        
        raw_data = new ArrayList<T>(N);
        bucket = new ArrayList<T>(K);
        lazy = new ArrayList<T>(K);
        lazy_flag = new boolean[K];
        
        build();
    }
    
    private void build() {

        for (int i = 0; i < N; i++) {
            raw_data.add(e);
        }

        for (int i = 0; i < K; i++) {
            bucket.add(e);
            lazy.add(e);
            lazy_flag[i] = false;
        }
    }
    
    /** bucket[k]の区間に対して、lazy[k]を適用したりbucket[k]を再計算したりする */
    protected void eval(int k) {
        
        T x = e;
        for (int i = k * sqrtN; i < Math.min(N, (k + 1) * sqrtN); i++) {
            if (lazy_flag[k]) {
                raw_data.set(i, g(raw_data.get(i), lazy.get(k), 1));
            }
            x = f(x, raw_data.get(i));
        }
        
        lazy_flag[k] = false;
        bucket.set(k, x);
    }

    
    /** [l, r)区間をdatで更新するよ O(sqrt(N)) */
    public void update(int l, int r, T dat) {
        int s = l / sqrtN;
        int t = (r + sqrtN - 1) / sqrtN;

        int bucket_l, bucket_r;
        
        for (int i = s; i < t; i++) {
            bucket_l = i * sqrtN;
            bucket_r = (i + 1) * sqrtN;
            
            if (l <= bucket_l && bucket_r <= r) {
                if (lazy_flag[i]) {
                    lazy.set(i, h(lazy.get(i), dat));
                }
                else {
                    lazy.set(i, dat);
                }
                lazy_flag[i] = true;
            }
            else {
                eval(i);
                for (int j = Math.max(bucket_l, l); j < Math.min(bucket_r, r); j++) {
                    raw_data.set(j, g(raw_data.get(j), dat, 1));
                }
            }
        }
    }

    /** [l, r)の区間クエリに答える O(sqrt(N)) */
    public T query(int l, int r) {
        int s = l / sqrtN;
        int t = (r + sqrtN - 1) / sqrtN;
        int bucket_l, bucket_r;
        T x = e;
        
        for (int i = s; i < t; i++) {
            bucket_l = i * sqrtN;
            bucket_r = (i + 1) * sqrtN;
            if (l <= bucket_l && bucket_r <= r) {
                if (lazy_flag[i]) {
                    x = f(x, g(bucket.get(i), lazy.get(i), 1));
                }
                else {
                    x = f(x, bucket.get(i));
                }
            }
            else {
                eval(i);
                
                for (int j = Math.max(bucket_l, l); j < Math.min(bucket_r, r); j++) {
                    x = f(x, raw_data.get(j));
                }
            }
        }
        return x;
    }
    
    /** デバッグ情報の印字 */
    public void debugPrint() {
        
        System.err.println("-lazy-");
        for (int i = 0; i < lazy.size(); i++) {
            if (!lazy_flag[i]) {
                System.err.print(" --  ");
            }
            else {
                System.err.print(lazy.get(i));
                System.err.print(' ');
            }
        }
        System.err.print('\n');
        
        System.err.println("-bucket-");
        for (T p : bucket) {
            System.err.print(p);
            System.err.print(' ');
        }
        System.err.print('\n');

        System.err.println("-raw_data-");
        for (T q : raw_data) {
            System.err.print(q);
            System.err.print(' ');
        }
        System.err.print('\n');

        System.err.println("-other data-");
        System.err.printf("N: %d, sqrtN: %d, K: %d\n", N, sqrtN, K);
    }
}


</source>
</class>

<class classid="97" nclones="2" nlines="46" similarity="100">
<source file="../hum_codes_raw/s165602118.java" startline="1" endline="49" pcid="5545">
import java.util.Scanner;

public class Main {
	static Scanner sc = new Scanner(System.in);
	
	static boolean search(String tar , String str){//２つの引数の文字列で看板が作れるかどうか判定するクラスメソッド
		boolean f = false;
		for(int j=0;j<str.length();j++){
			if(tar.equals(str))return true;
			if(tar.charAt(0)==str.charAt(j)){
				int cnt=0;
				for(int i=j+1;i<str.length();i++){
					cnt++;
					if(str.length()<j+cnt)continue;
					if(tar.charAt(1)==str.charAt(i)){
						if((j+tar.length()-1*cnt)>str.length())break;//
						for(int k=2;k<tar.length();k++){
							if(j+k*cnt>=str.length()){f=false;break;}//
							if(tar.charAt(k)==str.charAt(j+k*cnt))f = true;
							else {
								f = false;
								break;
							}
						}
						if(f==true) return f;
					}
				}
			}
		}		
		return f;
	}
	
	void doIt(){//クラス変数scに対しての操作を決めるメソッド
		int n = sc.nextInt();
		int ans = 0;
		String tar = sc.next();
		for(int i=0;i<n;++i){
			String s = sc.next();
			if(search(tar,s))ans++;
		}
		System.out.println(ans);
	}

	public static void main(String[] args) {
		new Main().doIt();
	}

}

</source>
<source file="../hum_codes_raw/s181026918.java" startline="1" endline="49" pcid="6100">
import java.util.Scanner;
 
public class Main {
    static Scanner sc = new Scanner(System.in);
     
    static boolean search(String tar , String str){//２つの引数の文字列で看板が作れるかどうか判定するクラスメソッド
        boolean f = false;
        for(int j=0;j<str.length();j++){
            if(tar.equals(str))return true;
            if(tar.charAt(0)==str.charAt(j)){
                int cnt=0;
                for(int i=j+1;i<str.length();i++){
                    cnt++;
                    if(str.length()<j+cnt)continue;
                    if(tar.charAt(1)==str.charAt(i)){
                        if((j+tar.length()-1*cnt)>str.length())break;//
                        for(int k=2;k<tar.length();k++){
                            if(j+k*cnt>=str.length()){f=false;break;}//
                            if(tar.charAt(k)==str.charAt(j+k*cnt))f = true;
                            else {
                                f = false;
                                break;
                            }
                        }
                        if(f==true) return f;
                    }
                }
            }
        }       
        return f;
    }
     
    void doIt(){//クラス変数scに対しての操作を決めるメソッド
        int n = sc.nextInt();
        int ans = 0;
        String tar = sc.next();
        for(int i=0;i<n;++i){
            String s = sc.next();
            if(search(tar,s))ans++;
        }
        System.out.println(ans);
    }
 
    public static void main(String[] args) {
        new Main().doIt();
    }
 
}

</source>
</class>

<class classid="98" nclones="2" nlines="165" similarity="100">
<source file="../hum_codes_raw/s165832489.java" startline="1" endline="187" pcid="5556">
import java.io.*;
import java.util.*;

public class Main {
  private static int dropBit(int n, int index) {
    int higher = (n >> (index + 1)) << index;
    int lower = (n & ((1 << index) - 1));
    return higher | lower;
  }
  
  private static int insertBit(int n, int index, int v) {
    int higher = ((n >> index) << (index + 1));
    int lower = (n & ((1 << index) - 1));
    return higher | lower | v;
  }
  
  private static List<Integer> solveSub(int n, int a, int b) {
    if (n == 1) {
      if (a != b) {
        return Arrays.asList(a, b);
      } else {
        return null;
      }
    }
    
    for (int i = 0; i < n; i++) {
      int aBit = (a >> i) & 1;
      int bBit = (b >> i) & 1;
      if (aBit != bBit) {
        int aDash = dropBit(a, i);
        int bDash = dropBit(b, i);
        int c = aDash ^ 1;
        List<Integer> path1 = solveSub(n - 1, aDash, c);
        List<Integer> path2 = solveSub(n - 1, c, bDash);
        if (path1 != null && path2 != null) {
          List<Integer> path = new ArrayList<>();
          for (int v : path1) {
            path.add(insertBit(v, i, aBit << i));
          }
          for (int v : path2) {
            path.add(insertBit(v, i, bBit << i));
          }
          return path;
        }
        return null;
      }
    }
    return null;
  }
  
  private static List<String> solve(int n, int a, int b) {
    List<Integer> path = solveSub(n, a, b);
    if (path == null) {
      return Arrays.asList("NO");
    }
    StringBuffer sb = new StringBuffer();
    sb.append(path.get(0));
    for (int i = 1; i < path.size(); i++) {
      sb.append(" ");
      sb.append(path.get(i));
    }
    return Arrays.asList("YES", sb.toString());
  }
  
  private static void execute(ContestReader reader, PrintWriter out) {
    int n = reader.nextInt();
    int a = reader.nextInt();
    int b = reader.nextInt();
    for (String line : solve(n, a, b)) {
      out.println(line);
    }
  }
  
  public static void main(String[] args) {
    ContestReader reader = new ContestReader(System.in);
    PrintWriter out = new PrintWriter(System.out);
    execute(reader, out);
    out.flush();
  }
}

class ContestReader {
  private BufferedReader reader;
  private StringTokenizer tokenizer;
  
  ContestReader(InputStream in) {
    reader = new BufferedReader(new InputStreamReader(in));
  }
  
  public String next() {
    while (tokenizer == null || !tokenizer.hasMoreTokens()) {
      try {
        tokenizer = new java.util.StringTokenizer(reader.readLine());
      } catch (Exception e) {
        throw new RuntimeException(e);
      }
    }
    return tokenizer.nextToken();
  }
  
  public int nextInt() {
    return Integer.parseInt(next());
  }
  
  public long nextLong() {
    return Long.parseLong(next());
  }
  
  public double nextDouble() {
    return Double.parseDouble(next());
  }
  
  public String[] next(int n) {
    String[] array = new String[n];
    for (int i = 0; i < n; i++) {
      array[i] = next();
    }
    return array;
  }
  
  public int[] nextInt(int n) {
    int[] array = new int[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextInt();
    }
    return array;
  }
  
  public long[] nextLong(int n) {
    long[] array = new long[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextLong();
    }
    return array;
  }
  
  public double[] nextDouble(int n) {
    double[] array = new double[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextDouble();
    }
    return array;
  }
  
  public char[] nextCharArray() {
    return next().toCharArray();
  }
  
  public int[][] nextInt(int n, int m) {
    int[][] matrix = new int[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextInt();
      }
    }
    return matrix;
  }
  
  public long[][] nextLong(int n, int m) {
    long[][] matrix = new long[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextLong();
      }
    }
    return matrix;
  }
  
  public double[][] nextDouble(int n, int m) {
    double[][] matrix = new double[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextDouble();
      }
    }
    return matrix;
  }
  
  public char[][] nextCharArray(int n) {
    char[][] matrix = new char[n][];
    for (int i = 0; i < n; i++) {
      matrix[i] = next().toCharArray();
    }
    return matrix;
  }
}

</source>
<source file="../hum_codes_raw/s569121349.java" startline="1" endline="190" pcid="19140">
import java.io.*;
import java.util.*;

public class Main {
  private static int dropBit(int n, int index) {
    int higher = (n >> (index + 1)) << index;
    int lower = (n & ((1 << index) - 1));
//    System.err.printf("n: %d, index: %d, higher: %d, lower: %d\n", n, index, higher, lower);
    return higher | lower;
  }
  
  private static int insertBit(int n, int index, int v) {
    int higher = ((n >> index) << (index + 1));
    int lower = (n & ((1 << index) - 1));
    return higher | lower | v;
  }
  
  private static List<Integer> solveSub(int n, int a, int b) {
//    System.err.printf("n: %d, a: %d, b: %d\n", n, a, b);
    if (n == 1) {
      if (a != b) {
        return Arrays.asList(a, b);
      } else {
        return null;
      }
    }
    
    for (int i = 0; i < n; i++) {
      int aBit = (a >> i) & 1;
      int bBit = (b >> i) & 1;
      if (aBit != bBit) {
        int aDash = dropBit(a, i);
        int bDash = dropBit(b, i);
//        System.err.printf("i: %d, aDash: %d, bDash: %d\n", i, aDash, bDash);
        int c = aDash ^ 1;
        List<Integer> path1 = solveSub(n - 1, aDash, c);
        List<Integer> path2 = solveSub(n - 1, c, bDash);
        if (path1 != null && path2 != null) {
          List<Integer> path = new ArrayList<>();
          for (int v : path1) {
            path.add(insertBit(v, i, aBit << i));
          }
          for (int v : path2) {
            path.add(insertBit(v, i, bBit << i));
          }
          return path;
        }
        return null;
      }
    }
    return null;
  }
  
  private static List<String> solve(int n, int a, int b) {
    List<Integer> path = solveSub(n, a, b);
    if (path == null) {
      return Arrays.asList("NO");
    }
    StringBuffer sb = new StringBuffer();
    sb.append(path.get(0));
    for (int i = 1; i < path.size(); i++) {
      sb.append(" ");
      sb.append(path.get(i));
    }
    return Arrays.asList("YES", sb.toString());
  }
  
  private static void execute(ContestReader reader, PrintWriter out) {
    int n = reader.nextInt();
    int a = reader.nextInt();
    int b = reader.nextInt();
    for (String line : solve(n, a, b)) {
      out.println(line);
    }
  }
  
  public static void main(String[] args) {
    ContestReader reader = new ContestReader(System.in);
    PrintWriter out = new PrintWriter(System.out);
    execute(reader, out);
    out.flush();
  }
}

class ContestReader {
  private BufferedReader reader;
  private StringTokenizer tokenizer;
  
  ContestReader(InputStream in) {
    reader = new BufferedReader(new InputStreamReader(in));
  }
  
  public String next() {
    while (tokenizer == null || !tokenizer.hasMoreTokens()) {
      try {
        tokenizer = new java.util.StringTokenizer(reader.readLine());
      } catch (Exception e) {
        throw new RuntimeException(e);
      }
    }
    return tokenizer.nextToken();
  }
  
  public int nextInt() {
    return Integer.parseInt(next());
  }
  
  public long nextLong() {
    return Long.parseLong(next());
  }
  
  public double nextDouble() {
    return Double.parseDouble(next());
  }
  
  public String[] next(int n) {
    String[] array = new String[n];
    for (int i = 0; i < n; i++) {
      array[i] = next();
    }
    return array;
  }
  
  public int[] nextInt(int n) {
    int[] array = new int[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextInt();
    }
    return array;
  }
  
  public long[] nextLong(int n) {
    long[] array = new long[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextLong();
    }
    return array;
  }
  
  public double[] nextDouble(int n) {
    double[] array = new double[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextDouble();
    }
    return array;
  }
  
  public char[] nextCharArray() {
    return next().toCharArray();
  }
  
  public int[][] nextInt(int n, int m) {
    int[][] matrix = new int[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextInt();
      }
    }
    return matrix;
  }
  
  public long[][] nextLong(int n, int m) {
    long[][] matrix = new long[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextLong();
      }
    }
    return matrix;
  }
  
  public double[][] nextDouble(int n, int m) {
    double[][] matrix = new double[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextDouble();
      }
    }
    return matrix;
  }
  
  public char[][] nextCharArray(int n) {
    char[][] matrix = new char[n][];
    for (int i = 0; i < n; i++) {
      matrix[i] = next().toCharArray();
    }
    return matrix;
  }
}

</source>
</class>

<class classid="99" nclones="2" nlines="21" similarity="100">
<source file="../hum_codes_raw/s167771213.java" startline="1" endline="24" pcid="5627">
import java.util.*;

class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        Integer a[] = new Integer[N];
        for (int i=0; i<N; i++) {
            a[i] = sc.nextInt();
        }
        Arrays.sort(a, Comparator.reverseOrder());

        int Alice = 0;
        int Bob   = 0;
        for (int i=0; i<N; i+=2) {
            Alice += a[i];
        }
        for (int i=1; i<N; i+=2) {
            Bob += a[i];
        }
        System.out.println(Alice - Bob);
    }
}

</source>
<source file="../hum_codes_raw/s456003682.java" startline="1" endline="24" pcid="15297">
import java.util.*;

class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int N=sc.nextInt();
        Integer a[]=new Integer[N];
        for(int i=0;i<N;i++){
            a[i]=sc.nextInt();
        }
        Arrays.sort(a,Comparator.reverseOrder());

        int Alice=0;
        int Bob=0;
        for(int i=0;i<N;i+=2){
            Alice+=a[i];
        }
        for(int i=1;i<N;i+=2){
            Bob+=a[i];
        }
        System.out.println(Alice-Bob);
    }
}

</source>
</class>

<class classid="100" nclones="2" nlines="25" similarity="100">
<source file="../hum_codes_raw/s170645507.java" startline="1" endline="26" pcid="5735">
import java.util.Scanner;
public class Main {
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		int L=sc.nextInt();
		int A=sc.nextInt();
		int B=sc.nextInt();
		int C=sc.nextInt();
		int D=sc.nextInt();
		int kokugoday=A/C;
		int sansuday=B/D;
		if(A%C!=0){
			kokugoday++;
		}
		if(B%D!=0){
			sansuday++;
		}
		if(kokugoday<sansuday){
			System.out.println(L-sansuday);
		}
		else{
			System.out.println(L-kokugoday);
		}
	}
}

</source>
<source file="../hum_codes_raw/s685662628.java" startline="1" endline="26" pcid="23033">
import java.util.Scanner;
public class Main {
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		int L=sc.nextInt();
		int A=sc.nextInt();
		int B=sc.nextInt();
		int C=sc.nextInt();
		int D=sc.nextInt();
		int kokugoday=A/C;
		int sansuday=B/D;
		if(A%C!=0){
			kokugoday++;
		}
		if(B%D!=0){
			sansuday++;
		}
		if(kokugoday<sansuday){
			System.out.println(L-sansuday);
		}
		else{
			System.out.println(L-kokugoday);
		}
	}
}

</source>
</class>

<class classid="101" nclones="2" nlines="19" similarity="100">
<source file="../hum_codes_raw/s171383036.java" startline="1" endline="25" pcid="5767">
import java.util.Scanner;

//0609
class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(), m = sc.nextInt(), l[] = new int[m], r[] = new int[n];
        for (int i = 0; i < m; i++)
            l[i] = sc.nextInt();
        for (int i = 0; i < m; i++) {
            int s = 0;
            for (int j = 0; j < n; j++) {
                if (sc.nextInt() == l[i]) {
                    r[j]++;
                    s++;
                }
            }
            r[l[i] - 1] += n - s;
        }
        for (int i : r)
            System.out.println(i);
    }
}


</source>
<source file="../hum_codes_raw/s584967724.java" startline="1" endline="24" pcid="19633">
import java.util.Scanner;
 

class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(), m = sc.nextInt(), l[] = new int[m], r[] = new int[n];
        for (int i = 0; i < m; i++)
            l[i] = sc.nextInt();
        for (int i = 0; i < m; i++) {
            int s = 0;
            for (int j = 0; j < n; j++) {
                if (sc.nextInt() == l[i]) {
                    r[j]++;
                    s++;
                }
            }
            r[l[i] - 1] += n - s;
        }
        for (int i : r)
            System.out.println(i);
    }
}

</source>
</class>

<class classid="102" nclones="2" nlines="27" similarity="100">
<source file="../hum_codes_raw/s182127508.java" startline="1" endline="34" pcid="6140">
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		boolean ok = true;
		int a = 0;
		int b = 0;
		int c = 0;
		int d = 0;
		while(sc.hasNext()) {
			int[] list = new int[3];
			for(int i = 0; i < 3; i++) {
				list[i] = sc.nextInt();
			}
			if(!ok) continue;
			Arrays.sort(list);
			if(list[0] + list[1] <= list[2]) ok = false;
			else {
				a++;
				if(list[0]*list[0] + list[1] * list[1] < list[2] * list[2])c++;
				else if(list[0]*list[0] + list[1] * list[1] > list[2] * list[2]) d++;
				else b++;
			}
		}
		System.out.println(a + " " + b + " " + d + " " + c);

	}



}

</source>
<source file="../hum_codes_raw/s398975488.java" startline="1" endline="34" pcid="13415">
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		boolean ok = true;
		int a = 0;
		int b = 0;
		int c = 0;
		int d = 0;
		while(sc.hasNext()) {
			int[] list = new int[3];
			for(int i = 0; i < 3; i++) {
				list[i] = sc.nextInt();
			}
			if(!ok) continue;
			Arrays.sort(list);
			if(list[0] + list[1] <= list[2]) ok = false;
			else {
				a++;
				if(list[0]*list[0] + list[1] * list[1] < list[2] * list[2])c++;
				else if(list[0]*list[0] + list[1] * list[1] > list[2] * list[2]) d++;
				else b++;
			}
		}
		System.out.println(a + " " + b + " " + d + " " + c);

	}



}

</source>
</class>

<class classid="103" nclones="2" nlines="21" similarity="100">
<source file="../hum_codes_raw/s184441056.java" startline="1" endline="23" pcid="6214">
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        for (;;) {
            int n = sc.nextInt();
            if(n==0)break;
            double u=2000001;
            int p=0;
            for(int i=0;i<n;i++) {
                int a=sc.nextInt(),b=sc.nextInt();
                double t=Math.abs(22-(double)sc.nextInt()*10000/b/b);
                if(u>t) {
                    u=t;
                    p=a;
                }
            }
            System.out.println(p);
        }
    }
}

</source>
<source file="../hum_codes_raw/s558855756.java" startline="1" endline="23" pcid="18834">
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        for (;;) {
            int n = sc.nextInt();
            if(n==0)break;
            double u=2000001;
            int p=0;
            for(int i=0;i<n;i++) {
                int a=sc.nextInt(),b=sc.nextInt();
                double t=Math.abs(22-(double)sc.nextInt()*10000/b/b);
                if(u>t) {
                    u=t;
                    p=a;
                }
            }
            System.out.println(p);
        }
    }
}

</source>
</class>

<class classid="104" nclones="2" nlines="29" similarity="100">
<source file="../hum_codes_raw/s187784404.java" startline="1" endline="33" pcid="6320">
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		List<Integer> list = new ArrayList<>();
		for (int i = 0; i < n; i++) {
			list.add(sc.nextInt());
		}
		int q = sc.nextInt();
		for (int i = 0; i < q; i++) {
			switch (sc.nextInt()) {
				case 0:
					int b  = sc.nextInt();
					int e = sc.nextInt();
					System.out.println(Collections.min(list.subList(b, e)));
					break;
				case 1:
					b  = sc.nextInt();
					e = sc.nextInt();
					System.out.println(Collections.max(list.subList(b, e)));
					break;
			}
		}
	}
}



</source>
<source file="../hum_codes_raw/s892475806.java" startline="1" endline="32" pcid="30017">
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		List<Integer> list = new ArrayList<>();
		for (int i = 0; i < n; i++) {
			list.add(sc.nextInt());
		}
		int q = sc.nextInt();
		for (int i = 0; i < q; i++) {
			switch (sc.nextInt()) {
				case 0:
					int b  = sc.nextInt();
					int e = sc.nextInt();
					System.out.println(Collections.min(list.subList(b, e)));
					break;
				case 1:
					b  = sc.nextInt();
					e = sc.nextInt();
					System.out.println(Collections.max(list.subList(b, e)));
					break;
			}
		}
	}
}


</source>
</class>

<class classid="105" nclones="3" nlines="10" similarity="100">
<source file="../hum_codes_raw/s189048146.java" startline="1" endline="16" pcid="6368">
import java.util.*;
public class Main {
	public static void main(String[] args) {
		Scanner sc =new Scanner(System.in);
		
		
		int a=sc.nextInt();
		int b=sc.nextInt();
		int h=sc.nextInt();
		
		
		System.out.println((a+b)*h/2);

}
}

</source>
<source file="../hum_codes_raw/s597822515.java" startline="1" endline="13" pcid="20059">
import java.util.*;

public class Main {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int a = sc.nextInt();
    int b = sc.nextInt();
    int h = sc.nextInt();
    
    System.out.println((a+b)*h/2);
  }
}

</source>
<source file="../hum_codes_raw/s811477541.java" startline="1" endline="11" pcid="27264">
import java.util.*;
public class Main{
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int a = sc.nextInt();
    int b = sc.nextInt();
    int h = sc.nextInt();
    System.out.println((a+b)*h/2);
  }
}

</source>
</class>

<class classid="106" nclones="2" nlines="53" similarity="100">
<source file="../hum_codes_raw/s189078226.java" startline="1" endline="63" pcid="6371">
import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;

public class Main {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		Scanner cin = new Scanner(System.in);
		for(;;){
			int N=Integer.parseInt(cin.nextLine());
			if(N==0)break;
			
			int[][] a = new int[N][2];
			for(int i=0;i<N;i++){
				String[] s =cin.nextLine().split(" ");
				int[] b = new int[s.length-1];
				a[i][0]=Integer.parseInt(s[0]);
				int frame=1;
				for(int j=1;j<s.length;j++){
					b[j-1]=Integer.parseInt(s[j]);
				}
				for(int j=0;j<b.length;){
					if(frame==10){
						a[i][1]+=b[j];
						j++;
						continue;
					}
					a[i][1]+=b[j]+b[j+1];
					if(b[j]==10){
						a[i][1]+=b[j+2];
						j++;
					}
					else{
						if(b[j]+b[j+1]==10){
							a[i][1]+=b[j+2];
						}
						j+=2;

					}
					frame++;
				}
//				System.out.println(a[i][1]);
			}
			Arrays.sort(a,new Comparator<int[]>(){
				public int compare(int[] a,int[] b){
					if(a[1]==b[1]){
						return a[0]-b[0];
					}
					return b[1]-a[1];
				}
			});
			
			for(int i=0;i<N;i++){
				System.out.println(a[i][0]+ " " + a[i][1]);
			}
		}
	}
	
}

</source>
<source file="../hum_codes_raw/s366179451.java" startline="1" endline="63" pcid="12302">
import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;

public class Main {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		Scanner cin = new Scanner(System.in);
		for(;;){
			int N=Integer.parseInt(cin.nextLine());
			if(N==0)break;
			
			int[][] a = new int[N][2];
			for(int i=0;i<N;i++){
				String[] s =cin.nextLine().split(" ");
				int[] b = new int[s.length-1];
				a[i][0]=Integer.parseInt(s[0]);
				int frame=1;
				for(int j=1;j<s.length;j++){
					b[j-1]=Integer.parseInt(s[j]);
				}
				for(int j=0;j<b.length;){
					if(frame==10){
						a[i][1]+=b[j];
						j++;
						continue;
					}
					a[i][1]+=b[j]+b[j+1];
					if(b[j]==10){
						a[i][1]+=b[j+2];
						j++;
					}
					else{
						if(b[j]+b[j+1]==10){
							a[i][1]+=b[j+2];
						}
						j+=2;

					}
					frame++;
				}
//				System.out.println(a[i][1]);
			}
			Arrays.sort(a,new Comparator<int[]>(){
				public int compare(int[] a,int[] b){
					if(a[1]==b[1]){
						return a[0]-b[0];
					}
					return b[1]-a[1];
				}
			});
			
			for(int i=0;i<N;i++){
				System.out.println(a[i][0]+ " " + a[i][1]);
			}
		}
	}
	
}

</source>
</class>

<class classid="107" nclones="2" nlines="36" similarity="100">
<source file="../hum_codes_raw/s190038159.java" startline="1" endline="43" pcid="6407">

import java.util.Scanner;

//Persistence
public class Main {

	static int[] w;
	static int n, m;
	
	static boolean f(int W){
		int need = 1;
		int s = 0;
		for(int i=0;i<n;i++){
			if(w[i]>W)return false;
			if(s+w[i]>W){
				need++;
				s = 0;
			}
			s+=w[i];
		}
		return need <= m;
	}
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			m = sc.nextInt();
			n = sc.nextInt();
			if((m|n)==0)break;
			w = new int[n];
			for(int i=0;i<n;i++)w[i]=sc.nextInt();
			int l = 1;
			int r = 1500000;
			while(r-l>1){
				int mid = (l+r)/2;
				if(f(mid))r = mid;
				else l = mid;
			}
			System.out.println(f(l)?l:r);
		}
	}
}

</source>
<source file="../hum_codes_raw/s227668620.java" startline="1" endline="42" pcid="7702">
import java.util.Scanner;

//Persistence
public class Main {

	static int[] w;
	static int n, m;
	
	static boolean f(int W){
		int need = 1;
		int s = 0;
		for(int i=0;i<n;i++){
			if(w[i]>W)return false;
			if(s+w[i]>W){
				need++;
				s = 0;
			}
			s+=w[i];
		}
		return need <= m;
	}
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			m = sc.nextInt();
			n = sc.nextInt();
			if((m|n)==0)break;
			w = new int[n];
			for(int i=0;i<n;i++)w[i]=sc.nextInt();
			int l = 1;
			int r = 1500000;
			while(r-l>1){
				int mid = (l+r)/2;
				if(f(mid))r = mid;
				else l = mid;
			}
			System.out.println(f(l)?l:r);
		}
	}
}

</source>
</class>

<class classid="108" nclones="3" nlines="133" similarity="100">
<source file="../hum_codes_raw/s192571646.java" startline="1" endline="143" pcid="6480">
import java.util.*;
import java.io.*;

public class Main {
    private static IO io = new IO();
    private static List<ArrayList<int[]>> g = new ArrayList<>();
    private static int cost[] = new int[10001];
    private static int min[] = new int[10001];
    private static int INF = 1145141919;
    private static PriorityQueue<int[]> que = new PriorityQueue<>(10001, new Comparator<int[]>() {
        public int compare (int a[], int b[]) {
            return a[0]-b[0];
        }
    });
    public static void main(String[] args) {
        while (true) {
            int n = io.nextInt();
            int m = io.nextInt();
            if (n==0 && m==0) break;
            g.clear();
            for (int i=0; i<=n; i++) g.add(new ArrayList<>());
            Arrays.fill(min, INF);
            Arrays.fill(cost, INF);
            min[1] = 0;
            cost[1] = 0;
            for (int i = 0; i < m; i++) {
                int ui = io.nextInt();
                int vi = io.nextInt();
                int di = io.nextInt();
                int ci = io.nextInt();
                g.get(ui).add(new int[] {vi, di, ci});
                g.get(vi).add(new int[] {ui, di, ci});
            }
            int ans = 0;
            que.offer(new int[] {0,0,1});
            while (!que.isEmpty()) {
                int poll[] = que.poll();
                int dis = poll[0];
                int cos = poll[1];
                int now = poll[2];
                if (min[now]<dis) continue;
                for (int i = 0; i < g.get(now).size(); i++) {
                    int go = g.get(now).get(i)[0];
                    int god = g.get(now).get(i)[1];
                    int goc = g.get(now).get(i)[2];
                    if (dis+god<min[go]) {
                        cost[go] = cos + goc;
                        min[go] = dis + god;
                        que.offer(new int[] {min[go], 0, go});
                    } else if (dis+god==min[go]) {
                        cost[go] = Math.min(cost[go], cos + goc);
                        que.offer(new int[] {min[go], 0, go});
                    }
                }
            }
            for (int i = 2; i <= n; i++) ans += cost[i];
            System.out.println(ans);
        }
    }

    static class IO extends PrintWriter {
        private final InputStream in;
        private final byte[] buffer = new byte[1024];
        private int ptr = 0;
        private int buflen = 0;

        IO() {
            this(System.in);
        }

        IO(InputStream source) {
            super(System.out);
            this.in = source;
        }

        boolean hasNextByte() {
            if (ptr < buflen) return true;
            else {
                ptr = 0;
                try {
                    buflen = in.read(buffer);
                } catch (IOException e) {
                    e.printStackTrace();
                }
                if (buflen <= 0) return false;
            }
            return true;
        }

        int readByte() {
            if (hasNextByte()) return buffer[ptr++];
            else return -1;
        }

        boolean isPrintableChar(int c) {
            return 33 <= c && c <= 126;
        }

        void skipUnprintable() {
            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        }

        boolean hasNext() {
            skipUnprintable();
            return hasNextByte();
        }

        long nextLong() {
            if (!hasNext()) throw new NoSuchElementException();
            long n = 0;
            boolean minus = false;
            int b = readByte();
            if (b == '-') {
                minus = true;
                b = readByte();
            }
            if (b < '0' || '9' < b) throw new NumberFormatException();
            while (true) {
                if ('0' <= b && b <= '9') {
                    n *= 10;
                    n += b - '0';
                } else if (b == -1 || !isPrintableChar(b)) return minus ? -n : n;
                else throw new NumberFormatException();
                b = readByte();
            }
        }

        int nextInt() {
            long nl = nextLong();
            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
            return (int) nl;
        }

        public void close() {
            super.close();
            try {
                in.close();
            } catch (IOException ignored) {
            }
        }
    }
}

</source>
<source file="../hum_codes_raw/s698904588.java" startline="1" endline="151" pcid="23504">
import java.util.*;
import java.io.*;

public class Main {
    private static IO io = new IO();
    private static List<ArrayList<int[]>> g = new ArrayList<>();
    private static int cost[] = new int[10001]; // ????????????????°??????????
    private static int min[] = new int[10001];  // ???1,i?????????????????¢
    private static int INF = 1145141919;
    // ?????¢?????????????????????
    private static PriorityQueue<int[]> que = new PriorityQueue<>(10001, new Comparator<int[]>() {
        public int compare (int a[], int b[]) {
            return a[0]-b[0];
        }
    });
    public static void main(String[] args) {
        while (true) {

            int n = io.nextInt();
            int m = io.nextInt();
            if (n==0 && m==0) break;
            // ?????????
            g.clear();
            for (int i=0; i<=n; i++) g.add(new ArrayList<>());
            Arrays.fill(min, INF);
            Arrays.fill(cost, INF);
            min[1] = 0;
            cost[1] = 0;
            // ??\???
            for (int i = 0; i < m; i++) {
                int ui = io.nextInt();
                int vi = io.nextInt();
                int di = io.nextInt();
                int ci = io.nextInt();
                g.get(ui).add(new int[] {vi, di, ci});
                g.get(vi).add(new int[] {ui, di, ci});
            }
            // ???????????????????????§???????????¢&????°???????????????????????±???????
            int ans = 0;
            que.offer(new int[] {0,0,1});
            while (!que.isEmpty()) {
                int poll[] = que.poll();
                int dis = poll[0];
                int cos = poll[1];
                int now = poll[2];
                // ???????????¢??????????????£??????????????????
                if (min[now]<dis) continue;
                // ???????????¢??\????????£?????????????????¢??¨????°???????????????´??°??????????????????????????????
                // ???????????¨???????????????????????????????????????????????¨????????????????????????2????????????????????????????????????
                for (int i = 0; i < g.get(now).size(); i++) {
                    int go = g.get(now).get(i)[0];
                    int god = g.get(now).get(i)[1];
                    int goc = g.get(now).get(i)[2];
                    if (dis+god<min[go]) {
                        cost[go] = cos + goc;
                        min[go] = dis + god;
                        que.offer(new int[] {min[go], 0, go});
                    } else if (dis+god==min[go]) {
                        cost[go] = Math.min(cost[go], cos + goc);
                        que.offer(new int[] {min[go], 0, go});
                    }
                }
            }
            for (int i = 2; i <= n; i++) ans += cost[i];
            System.out.println(ans);
        }
    }

    static class IO extends PrintWriter {
        private final InputStream in;
        private final byte[] buffer = new byte[1024];
        private int ptr = 0;
        private int buflen = 0;

        IO() {
            this(System.in);
        }

        IO(InputStream source) {
            super(System.out);
            this.in = source;
        }

        boolean hasNextByte() {
            if (ptr < buflen) return true;
            else {
                ptr = 0;
                try {
                    buflen = in.read(buffer);
                } catch (IOException e) {
                    e.printStackTrace();
                }
                if (buflen <= 0) return false;
            }
            return true;
        }

        int readByte() {
            if (hasNextByte()) return buffer[ptr++];
            else return -1;
        }

        boolean isPrintableChar(int c) {
            return 33 <= c && c <= 126;
        }

        void skipUnprintable() {
            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        }

        boolean hasNext() {
            skipUnprintable();
            return hasNextByte();
        }

        long nextLong() {
            if (!hasNext()) throw new NoSuchElementException();
            long n = 0;
            boolean minus = false;
            int b = readByte();
            if (b == '-') {
                minus = true;
                b = readByte();
            }
            if (b < '0' || '9' < b) throw new NumberFormatException();
            while (true) {
                if ('0' <= b && b <= '9') {
                    n *= 10;
                    n += b - '0';
                } else if (b == -1 || !isPrintableChar(b)) return minus ? -n : n;
                else throw new NumberFormatException();
                b = readByte();
            }
        }

        int nextInt() {
            long nl = nextLong();
            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
            return (int) nl;
        }

        public void close() {
            super.close();
            try {
                in.close();
            } catch (IOException ignored) {
            }
        }
    }
}

</source>
<source file="../hum_codes_raw/s708674639.java" startline="1" endline="156" pcid="23826">
import java.util.*;
import java.io.*;

public class Main {
    private static IO io = new IO();
    private static List<ArrayList<int[]>> g = new ArrayList<>();
    private static int cost[] = new int[10001]; // ????????????????°??????????
    private static int min[] = new int[10001];  // ???1,i?????????????????¢
    private static int INF = 1145141919;
    // ?????¢?????????????????????
    private static PriorityQueue<int[]> que = new PriorityQueue<>(10001, new Comparator<int[]>() {
        public int compare (int a[], int b[]) {
            return a[0]-b[0];	// ?¬¬1????????§???????????????
        }
    });
    public static void main(String[] args) {
        while (true) {

            int n = io.nextInt();
            int m = io.nextInt();
            if (n==0 && m==0) break;
            // ?????????
            g.clear();
            for (int i=0; i<=n; i++) g.add(new ArrayList<>());
            Arrays.fill(min, INF);
            Arrays.fill(cost, INF);
            min[1] = 0;
            cost[1] = 0;
            // input
            for (int i = 0; i < m; i++) {
                int ui = io.nextInt();
                int vi = io.nextInt();
                int di = io.nextInt();
                int ci = io.nextInt();
                g.get(ui).add(new int[] {vi, di, ci});
                g.get(vi).add(new int[] {ui, di, ci});
            }
            // ???????????????????????§???????????¢&????°???????????????????????±???????
            int ans = 0;
            que.offer(new int[] {0,0,1});
            while (!que.isEmpty()) {
                int poll[] = que.poll();
                int dis = poll[0];
                int cos = poll[1];
                int now = poll[2];
                // ???????????¢??????????????£??????????????????
                if (min[now]<dis) continue;
                // ???????????¢??\????????£?????????????????¢??¨????°???????????????´??°??????????????????????????????
                // ???????????¨???????????????????????????????????????????????¨????????????????????????2????????????????????????????????????
                for (int i = 0; i < g.get(now).size(); i++) {
                    int go = g.get(now).get(i)[0];
                    int god = g.get(now).get(i)[1];
                    int goc = g.get(now).get(i)[2];
                    if (dis+god<min[go]) {
                        cost[go] = cos + goc;
                        min[go] = dis + god;
                        que.offer(new int[] {min[go], 0, go});
                        //System.out.println(now + "??????" + go + "?????????");
                        //System.out.println("1???" + go + "???????????????" + cost[go] + "?????´??°??????");
                    } else if (dis+god==min[go]) {
                        cost[go] = Math.min(cost[go], cos + goc);
                        que.offer(new int[] {min[go], 0, go});
                        //System.out.println(now + "??????" + go + "?????????");
                        //System.out.println("1???" + go + "???????????????" + cost[go] + "?????´??°??????");
                    }
                }
            }
            for (int i = 2; i <= n; i++) ans += cost[i];
            System.out.println(ans);
            //System.out.println(Arrays.toString(cost));
        }
    }

    static class IO extends PrintWriter {
        private final InputStream in;
        private final byte[] buffer = new byte[1024];
        private int ptr = 0;
        private int buflen = 0;

        IO() {
            this(System.in);
        }

        IO(InputStream source) {
            super(System.out);
            this.in = source;
        }

        boolean hasNextByte() {
            if (ptr < buflen) return true;
            else {
                ptr = 0;
                try {
                    buflen = in.read(buffer);
                } catch (IOException e) {
                    e.printStackTrace();
                }
                if (buflen <= 0) return false;
            }
            return true;
        }

        int readByte() {
            if (hasNextByte()) return buffer[ptr++];
            else return -1;
        }

        boolean isPrintableChar(int c) {
            return 33 <= c && c <= 126;
        }

        void skipUnprintable() {
            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        }

        boolean hasNext() {
            skipUnprintable();
            return hasNextByte();
        }

        long nextLong() {
            if (!hasNext()) throw new NoSuchElementException();
            long n = 0;
            boolean minus = false;
            int b = readByte();
            if (b == '-') {
                minus = true;
                b = readByte();
            }
            if (b < '0' || '9' < b) throw new NumberFormatException();
            while (true) {
                if ('0' <= b && b <= '9') {
                    n *= 10;
                    n += b - '0';
                } else if (b == -1 || !isPrintableChar(b)) return minus ? -n : n;
                else throw new NumberFormatException();
                b = readByte();
            }
        }

        int nextInt() {
            long nl = nextLong();
            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
            return (int) nl;
        }

        public void close() {
            super.close();
            try {
                in.close();
            } catch (IOException ignored) {
            }
        }
    }
}

</source>
</class>

<class classid="109" nclones="2" nlines="14" similarity="100">
<source file="../hum_codes_raw/s192590654.java" startline="1" endline="15" pcid="6481">
import java.util.Scanner;
 
public class Main {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int a = sc.nextInt();
        int b = sc.nextInt();
        if (a%3 == 0 || b%3 == 0 || (a+b) % 3 == 0) {
            System.out.println("Possible");
        } else {
            System.out.println("Impossible");
        }
    }
}

</source>
<source file="../hum_codes_raw/s574808787.java" startline="1" endline="17" pcid="19321">
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int a = sc.nextInt();
        int b = sc.nextInt();

        if (a % 3 == 0 || b % 3 == 0 || (a + b) % 3 == 0) {
            System.out.println("Possible");
        } else {
            System.out.println("Impossible");
        }
    }
}

</source>
</class>

<class classid="110" nclones="2" nlines="45" similarity="100">
<source file="../hum_codes_raw/s194476548.java" startline="1" endline="48" pcid="6548">
import java.util.Scanner;

//Altair and Vega
public class Main{

	public static class Point {
		public double x;
		public double y;
		public Point(double x_, double y_) {
			x = x_; y=y_;
		}
	}
	public static Point sub(Point p1, Point p2) {
		return new Point(p1.x-p2.x, p1.y-p2.y);
	}
	public static double extp(Point p1, Point p2) {
		return p1.x*p2.y - p2.x*p1.y;
	}
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int t = sc.nextInt();
		while(t--!=0){
			Point[] p = new Point[3];
			for(int i=0;i<3;i++)p[i]=new Point(sc.nextDouble(), sc.nextDouble());
			Point p1 = new Point(sc.nextDouble(), sc.nextDouble());
			Point p2 = new Point(sc.nextDouble(), sc.nextDouble());
			boolean in1 = false;
			boolean in2 = false;
			boolean right = true;
			boolean left = true;
			boolean right2 = true;
			boolean left2 = true;
			for(int i=0;i<3;i++){
				Point base = sub(p[(i+1)%3], p[i]);
				Point bec = sub(p1, p[i]);
				Point bec2 = sub(p2, p[i]);
				if(extp(base, bec)<0) left = false;
				else right = false;
				if(extp(base, bec2)<0) left2 = false;
				else right2 = false;
			}
			in1 = left|right;
			in2 = left2|right2;
			System.out.println(in1!=in2?"OK":"NG");
		}
	}
}

</source>
<source file="../hum_codes_raw/s544941511.java" startline="1" endline="48" pcid="18362">
import java.util.Scanner;

//Altair and Vega
public class Main {

	public static class Point {
		public double x;
		public double y;
		public Point(double x_, double y_) {
			x = x_; y=y_;
		}
	}
	public static Point sub(Point p1, Point p2) {
		return new Point(p1.x-p2.x, p1.y-p2.y);
	}
	public static double extp(Point p1, Point p2) {
		return p1.x*p2.y - p2.x*p1.y;
	}
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int t = sc.nextInt();
		while(t--!=0){
			Point[] p = new Point[3];
			for(int i=0;i<3;i++)p[i]=new Point(sc.nextDouble(), sc.nextDouble());
			Point p1 = new Point(sc.nextDouble(), sc.nextDouble());
			Point p2 = new Point(sc.nextDouble(), sc.nextDouble());
			boolean in1 = false;
			boolean in2 = false;
			boolean right = true;
			boolean left = true;
			boolean right2 = true;
			boolean left2 = true;
			for(int i=0;i<3;i++){
				Point base = sub(p[(i+1)%3], p[i]);
				Point bec = sub(p1, p[i]);
				Point bec2 = sub(p2, p[i]);
				if(extp(base, bec)<0) left = false;
				else right = false;
				if(extp(base, bec2)<0) left2 = false;
				else right2 = false;
			}
			in1 = left|right;
			in2 = left2|right2;
			System.out.println(in1!=in2?"OK":"NG");
		}
	}
}

</source>
</class>

<class classid="111" nclones="2" nlines="81" similarity="100">
<source file="../hum_codes_raw/s196089839.java" startline="1" endline="87" pcid="6612">
import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;
 
class Main {
	public static void main(String[] args) {
		new Main().run();
	}
 
	void run() {
		Scanner sc = new Scanner(System.in);
		long[] p1 = { sc.nextLong(), sc.nextLong() };
		long[] p2 = { sc.nextLong(), sc.nextLong() };
		if (p1[0] > p2[0]) {
			long[] tmp = p1;
			p1 = p2;
			p2=tmp;
		}
		int coe = 1;
		if (p1[1] > p2[1]) {
			coe = -1;
			p1[1] *= coe;
			p2[1] *= coe;
		}
		int n = sc.nextInt();
		long[][] p = new long[n][2];
		for (int i = 0; i < n; ++i) {
			p[i][0] = sc.nextLong();
			p[i][1] = sc.nextLong() * coe;
		}
		Arrays.sort(p, new Comparator<long[]>() {
			@Override
			public int compare(long[] o1, long[] o2) {
				return Long.compare(o1[0], o2[0]);
			}
		});
		int sz = 0;
		for (int i = 0; i < n; ++i) {
			if (p1[0] <= p[i][0] && p[i][0] <= p2[0] && p1[1] <= p[i][1] && p[i][1] <= p2[1])
				++sz;
		}
		long[] a = new long[sz];
		sz = 0;
		for (int i = 0; i < n; ++i) {
			if (p1[0] <= p[i][0] && p[i][0] <= p2[0] && p1[1] <= p[i][1] && p[i][1] <= p2[1]) {
				a[sz++] = p[i][1];
			}
		}
		long lis = LIS(a.length, a);
		double ans = (p2[0] - p1[0] + p2[1] - p1[1]) * 100 + (Math.PI * 5 - 20) * lis;
		if (lis == Math.min(p2[0] - p1[0] + 1, p2[1] - p1[1] + 1))
			ans += Math.PI * 5;
		System.out.println(String.format("%.20f", ans));
	}
 
	long LIS(int n, long[] a) {
		long[] f = new long[n];
		int sz = 0;
		for (int i = 0; i < n; ++i) {
			if (sz == 0) {
				f[sz] = a[0];
				++sz;
			} else {
				int ok = -1;
				int ng = sz;
				while (ng - ok > 1) {
					int middle = (ok + ng) / 2;
					if (f[middle] < a[i]) {
						ok = middle;
					} else {
						ng = middle;
					}
				}
 
				f[ok + 1] = a[i];
				if (ok + 1 == sz)
					++sz;
			}
		}
		return sz;
	}
 
	void tr(Object... objects) {
		System.out.println(Arrays.deepToString(objects));
	}
}

</source>
<source file="../hum_codes_raw/s318994732.java" startline="1" endline="87" pcid="10703">
import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;

class Main {
	public static void main(String[] args) {
		new Main().run();
	}

	void run() {
		Scanner sc = new Scanner(System.in);
		long[] p1 = { sc.nextLong(), sc.nextLong() };
		long[] p2 = { sc.nextLong(), sc.nextLong() };
		if (p1[0] > p2[0]) {
			long[] tmp = p1;
			p1 = p2;
			p2=tmp;
		}
		int coe = 1;
		if (p1[1] > p2[1]) {
			coe = -1;
			p1[1] *= coe;
			p2[1] *= coe;
		}
		int n = sc.nextInt();
		long[][] p = new long[n][2];
		for (int i = 0; i < n; ++i) {
			p[i][0] = sc.nextLong();
			p[i][1] = sc.nextLong() * coe;
		}
		Arrays.sort(p, new Comparator<long[]>() {
			@Override
			public int compare(long[] o1, long[] o2) {
				return Long.compare(o1[0], o2[0]);
			}
		});
		int sz = 0;
		for (int i = 0; i < n; ++i) {
			if (p1[0] <= p[i][0] && p[i][0] <= p2[0] && p1[1] <= p[i][1] && p[i][1] <= p2[1])
				++sz;
		}
		long[] a = new long[sz];
		sz = 0;
		for (int i = 0; i < n; ++i) {
			if (p1[0] <= p[i][0] && p[i][0] <= p2[0] && p1[1] <= p[i][1] && p[i][1] <= p2[1]) {
				a[sz++] = p[i][1];
			}
		}
		long lis = LIS(a.length, a);
		double ans = (p2[0] - p1[0] + p2[1] - p1[1]) * 100 + (Math.PI * 5 - 20) * lis;
		if (lis == Math.min(p2[0] - p1[0] + 1, p2[1] - p1[1] + 1))
			ans += Math.PI * 5;
		System.out.println(String.format("%.20f", ans));
	}

	long LIS(int n, long[] a) {
		long[] f = new long[n];
		int sz = 0;
		for (int i = 0; i < n; ++i) {
			if (sz == 0) {
				f[sz] = a[0];
				++sz;
			} else {
				int ok = -1;
				int ng = sz;
				while (ng - ok > 1) {
					int middle = (ok + ng) / 2;
					if (f[middle] < a[i]) {
						ok = middle;
					} else {
						ng = middle;
					}
				}

				f[ok + 1] = a[i];
				if (ok + 1 == sz)
					++sz;
			}
		}
		return sz;
	}

	void tr(Object... objects) {
		System.out.println(Arrays.deepToString(objects));
	}
}

</source>
</class>

<class classid="112" nclones="2" nlines="34" similarity="100">
<source file="../hum_codes_raw/s196107800.java" startline="1" endline="35" pcid="6613">
import java.util.Scanner;
public class Main {
	public static void main(String args[]){
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int m = sc.nextInt();
		int a[] = new int[n];//??¶???????????¨
		int b[] = new int[m];//????????????
		int cnt[] = new int[n];//????????????
		int max = 0, idx = 0;//?????§?????¨????????????????????????
		for(int i = 0;i < n;i++){
			a[i] = sc.nextInt();
			cnt[i] = 0;//????????????????????????
		}
		for(int i = 0;i < m;i++){
			b[i] = sc.nextInt();
		}
		for(int i = 0;i < m;i++){
			for(int k = 0;k < n;k++){
				if(a[k] <= b[i]){
					cnt[k]++;
					break;
				}
			}
		}
		for(int i = 0;i < n;i++){
			if(max < cnt[i]){
				max = cnt[i];
				idx = i;
			}
		}
		System.out.println(idx + 1);
	}
}

</source>
<source file="../hum_codes_raw/s318845272.java" startline="1" endline="35" pcid="10699">
import java.util.Scanner;
public class Main {
	public static void main(String args[]){
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int m = sc.nextInt();
		int a[] = new int[n];//??¶???????????¨
		int b[] = new int[m];//????????????
		int cnt[] = new int[n];//????????????
		int max = 0, idx = 0;//?????§?????¨????????????????????????
		for(int i = 0;i < n;i++){
			a[i] = sc.nextInt();
			cnt[i] = 0;//????????????????????????
		}
		for(int i = 0;i < m;i++){
			b[i] = sc.nextInt();
		}
		for(int i = 0;i < m;i++){
			for(int k = 0;k < n;k++){
				if(a[k] <= b[i]){
					cnt[k]++;
					break;
				}
			}
		}
		for(int i = 0;i < n;i++){
			if(max < cnt[i]){
				max = cnt[i];
				idx = i;
			}
		}
		System.out.println(idx + 1);
	}
}

</source>
</class>

<class classid="113" nclones="2" nlines="14" similarity="100">
<source file="../hum_codes_raw/s197501754.java" startline="1" endline="14" pcid="6662">
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
      Scanner sc = new Scanner(System.in);
      int n = sc.nextInt();
      int r = sc.nextInt();
      if(n>=10){
      	System.out.println(r);
      }else{
        System.out.println(r+100*(10-n));
      }
    }
}

</source>
<source file="../hum_codes_raw/s621888968.java" startline="1" endline="18" pcid="20885">
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int r = sc.nextInt();
		if (n >= 10) {
			System.out.println(r);
		} else {
			System.out.println(r + 100 * (10 - n));
		}

	}

}

</source>
</class>

<class classid="114" nclones="2" nlines="32" similarity="100">
<source file="../hum_codes_raw/s198093778.java" startline="1" endline="46" pcid="6669">
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Scanner;

/**
 * Created by shoya on 2017/04/12.
 */
public class Main {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        String str1 = sc.next();
        String str2 = sc.next();
        PrintWriter pwout = new PrintWriter(System.out);
        for(Integer i : rabinKarp(str2, str1))
            pwout.println(i);
        pwout.flush();
        return;
    }

    static ArrayList<Integer> rabinKarp(String str1, String str2){
        ArrayList<Integer> list = new ArrayList<>();
        if (str1.length() > str2.length())
            return list;

        final long RADIX = Long.parseUnsignedLong("100000007");
        long t = 1, str1hash = 0, str2hash = 0;
        for (int i = 0; i < str1.length(); i++) {
            t *= RADIX;
            str1hash = str1hash * RADIX + str1.charAt(i);
            str2hash = str2hash * RADIX + str2.charAt(i);
        }
        for (int i = 0; i + str1.length() <= str2.length(); i++) {
            //System.out.println(Long.toUnsignedString(str1hash));
            //System.out.println(Long.toUnsignedString(str2hash));
            //System.out.println();
            if (str1hash == str2hash)
                list.add(i);
            if (i + str1.length() < str2.length()) {
                str2hash = str2hash * RADIX + str2.charAt(i + str1.length()) - str2.charAt(i) * t;
                //System.out.println(Long.toUnsignedString(str2hash));
            }
        }
        return list;
    }
}

</source>
<source file="../hum_codes_raw/s608386792.java" startline="1" endline="46" pcid="20447">
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Scanner;

/**
 * Created by shoya on 2017/04/12.
 */
public class Main {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        String str1 = sc.next();
        String str2 = sc.next();
        PrintWriter pwout = new PrintWriter(System.out);
        for(Integer i : rabinKarp(str2, str1))
            pwout.println(i);
        pwout.flush();
        return;
    }

    static ArrayList<Integer> rabinKarp(String str1, String str2){
        ArrayList<Integer> list = new ArrayList<>();
        if (str1.length() > str2.length())
            return list;

        final long RADIX = Long.parseUnsignedLong("100000007");
        long t = 1, str1hash = 0, str2hash = 0;
        for (int i = 0; i < str1.length(); i++) {
            t *= RADIX;
            str1hash = str1hash * RADIX + str1.charAt(i);
            str2hash = str2hash * RADIX + str2.charAt(i);
        }
        for (int i = 0; i + str1.length() <= str2.length(); i++) {
            //System.out.println(Long.toUnsignedString(str1hash));
            //System.out.println(Long.toUnsignedString(str2hash));
            //System.out.println();
            if (str1hash == str2hash)
                list.add(i);
            if (i + str1.length() < str2.length()) {
                str2hash = str2hash * RADIX + str2.charAt(i + str1.length()) - str2.charAt(i) * t;
                //System.out.println(Long.toUnsignedString(str2hash));
            }
        }
        return list;
    }
}

</source>
</class>

<class classid="115" nclones="2" nlines="85" similarity="100">
<source file="../hum_codes_raw/s199319317.java" startline="1" endline="106" pcid="6717">
import java.awt.geom.AffineTransform;
import java.awt.geom.Point2D;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] tmpArray = br.readLine().split(" ");
        double px1 = Double.parseDouble(tmpArray[0]);
        double py1 = Double.parseDouble(tmpArray[1]);
        double px2 = Double.parseDouble(tmpArray[2]);
        double py2 = Double.parseDouble(tmpArray[3]);
        
        Point2D p1 = new Point2D.Double(px1, py1);
        Point2D p2 = new Point2D.Double(px2, py2);
        
        int q = Integer.parseInt(br.readLine());
        
        for(int i = 0; i < q; i++) {
            tmpArray = br.readLine().split(" ");
            double x = Double.parseDouble(tmpArray[0]);
            double y = Double.parseDouble(tmpArray[1]);
            
            Point2D p = new Point2D.Double(x, y);
            
            int result = checkClockwise(p, p1, p2);
            
            switch(result) {
                case COUNTER_CLOCKWISE:
                    System.out.println("COUNTER_CLOCKWISE");
                    break;
                
                case CLOCKWISE:
                    System.out.println("CLOCKWISE");
                    break;
                
                case ONLINE_BACK:
                    System.out.println("ONLINE_BACK");
                    break;
                
                case ONLINE_FRONT:
                    System.out.println("ONLINE_FRONT");
                    break;
                
                case ON_SEGMENT:
                    System.out.println("ON_SEGMENT");
                    break;
                    
                default:
                    break;
            }
        }
    }
    
    static final int COUNTER_CLOCKWISE = 1;
    static final int CLOCKWISE         = 2;
    static final int ONLINE_BACK       = 3;
    static final int ONLINE_FRONT      = 4;
    static final int ON_SEGMENT        = 5;
    static final double EPS            = 0.00000001;
    
    //p1, p2が作るベクトルに対しpの位置関係を調べる
    static int checkClockwise(Point2D p, Point2D p1, Point2D p2) {
        if(p1.getX() > p2.getX() || (p1.getX() == p2.getX() && p1.getY() > p2.getY())) {
            AffineTransform rotate = AffineTransform.getQuadrantRotateInstance(2);
            Point2D tmp = null;
            p  = rotate.transform(p , tmp);
            p1 = rotate.transform(p1, tmp);
            p2 = rotate.transform(p2, tmp);
        }
        double theta = Math.PI / 2;
        
        //直線のなす角が90度でないときはここで計算
        if(p1.getX() != p2.getX()) {
            theta = Math.atan((p1.getY() - p2.getY()) / (p1.getX() - p2.getX()));
        }
        
        AffineTransform affine;
        affine = AffineTransform.getRotateInstance(-theta);
        affine.concatenate(AffineTransform.getTranslateInstance(-p1.getX(), -p1.getY()));
        Point2D pD = new Point2D.Double();
        pD = affine.transform(p, pD);
        Point2D p2D = new Point2D.Double();
        p2D = affine.transform(p2, p2D);
        
        if(pD.getY() > EPS) {
            return COUNTER_CLOCKWISE;
        }
        else if(pD.getY() < -EPS) {
            return CLOCKWISE;
        }
        else if(pD.getX() < 0) {
            return ONLINE_BACK;
        }
        else if(pD.getX() > p2D.getX()) {
            return ONLINE_FRONT;
        }
        else {
            return ON_SEGMENT;
        }
    }   
    
}

</source>
<source file="../hum_codes_raw/s778145644.java" startline="1" endline="119" pcid="26130">

import java.awt.geom.AffineTransform;
import java.awt.geom.Point2D;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

		String[] tmpArray = br.readLine().split(" ");
		double px1 = Double.parseDouble(tmpArray[0]);
		double py1 = Double.parseDouble(tmpArray[1]);
		double px2 = Double.parseDouble(tmpArray[2]);
		double py2 = Double.parseDouble(tmpArray[3]);

		Point2D p1 = new Point2D.Double(px1, py1);
		Point2D p2 = new Point2D.Double(px2, py2);

		int q = Integer.parseInt(br.readLine());

		for(int i = 0; i < q; i++){
			tmpArray = br.readLine().split(" ");
			double x = Double.parseDouble(tmpArray[0]);
			double y = Double.parseDouble(tmpArray[1]);

			Point2D p = new Point2D.Double(x,y);

			int result = checkClockwise(p, p1, p2);

			switch (result) {
			case COUNTER_CLOCKWISE:
				System.out.println("COUNTER_CLOCKWISE");
				break;

			case CLOCKWISE:
				System.out.println("CLOCKWISE");
				break;

			case ONLINE_BACK:
				System.out.println("ONLINE_BACK");
				break;

			case ONLINE_FRONT:
				System.out.println("ONLINE_FRONT");
				break;

			case ON_SEGMENT:
				System.out.println("ON_SEGMENT");
				break;

			default:
				break;
			}
		}

	}

	static final int COUNTER_CLOCKWISE = 1;
	static final int CLOCKWISE = 2;
	static final int ONLINE_BACK = 3;
	static final int ONLINE_FRONT = 4;
	static final int ON_SEGMENT = 5;
	static final double EPS = 0.00000001;

	//p1,p2が作るベクトルに対してpの位置関係を調べる
	static int checkClockwise(Point2D p, Point2D p1, Point2D p2){
		if(p1.getX() > p2.getX() || (p1.getX() == p2.getX() && p1.getY() > p2.getY())){
			AffineTransform rotate = AffineTransform.getQuadrantRotateInstance(2);
			Point2D tmp = null;
			p = rotate.transform(p, tmp);
			p1 = rotate.transform(p1, tmp);
			p2 = rotate.transform(p2, tmp);

//			System.out.println(p);
		}

		double theta = Math.PI/2;

		//直線のなす角が90度ではないときはここで計算
		if(p1.getX() != p2.getX()){
			theta = Math.atan((p1.getY() - p2.getY()) / (p1.getX() - p2.getX()));
		}


		AffineTransform affine;// = AffineTransform.getTranslateInstance(p1.getX(), p1.getY());
//		affine.concatenate(AffineTransform.getRotateInstance(theta));
//		affine.concatenate(new AffineTransform(1, 0, 0, -1, 0, 0));
		affine = AffineTransform.getRotateInstance(-theta);
		affine.concatenate(AffineTransform.getTranslateInstance(-p1.getX(), -p1.getY()));

		Point2D pD = new Point2D.Double();
		pD = affine.transform(p, pD);
		Point2D p2D = new Point2D.Double();
		p2D = affine.transform(p2, p2D);

		if(pD.getY() > EPS){
			return COUNTER_CLOCKWISE;
		}
		else if(pD.getY() < -EPS){
			return CLOCKWISE;
		}
		else if(pD.getX() < 0){
			return ONLINE_BACK;
		}
		else if(pD.getX() > p2D.getX()){
			return ONLINE_FRONT;
		}
		else {
			return ON_SEGMENT;
		}

	}

}


</source>
</class>

<class classid="116" nclones="2" nlines="32" similarity="100">
<source file="../hum_codes_raw/s199979698.java" startline="1" endline="39" pcid="6739">
import java.util.Scanner;

//Search
public class Main{

	static int c;
	static int[] a;

	static int comp(int k, int x){
		c++;
		return a[k]-x;
	}

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int n = sc.nextInt();
			if(n==0)break;
			a = new int[n];
			for(int i=0;i<n;i++)a[i]=sc.nextInt();
			int x = sc.nextInt();
			c = 0;
			int l = 0;
			int r = n-1;
			int k = (l+r)/2;
			while(l<=r){
//				System.out.println("K: " + k + " L:" + l + " R:" + r);
				int com = comp(k, x);
				if(r<=l)break;
				if(com<0)l=k+1;
				else if(com>0)r=k-1;
				else break;
				k=(l+r)/2;
			}
			System.out.println(c);
		}
	}
}

</source>
<source file="../hum_codes_raw/s289066775.java" startline="1" endline="38" pcid="9678">
import java.util.Scanner;

//Search
public class Main {

	static int c;
	static int[] a;

	static int comp(int k, int x){
		c++;
		return a[k]-x;
	}

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int n = sc.nextInt();
			if(n==0)break;
			a = new int[n];
			for(int i=0;i<n;i++)a[i]=sc.nextInt();
			int x = sc.nextInt();
			c = 0;
			int l = 0;
			int r = n-1;
			int k = (l+r)/2;
			while(l<=r){
				int com = comp(k, x);
				if(r<=l)break;
				if(com<0)l=k+1;
				else if(com>0)r=k-1;
				else break;
				k=(l+r)/2;
			}
			System.out.println(c);
		}
	}
}

</source>
</class>

<class classid="117" nclones="2" nlines="44" similarity="100">
<source file="../hum_codes_raw/s200353596.java" startline="1" endline="58" pcid="6754">
import java.util.*;
import java.util.regex.*;

class Main{
	private final static Pattern addsubmuldiv = Pattern.compile("^(.*?)(-?\\d+)([+Z*/])(-?\\d+)(.*)$");
	private final static Pattern addsub = Pattern.compile("^(.*?)(-?\\d+)([+Z])(-?\\d+)(.*)$");
	private final static Pattern muldiv = Pattern.compile("^(.*?)(-?\\d+)([*/])(-?\\d+)(.*)$");

	private static String process(String s){
		Matcher m=muldiv.matcher(s);
		while(m.find()){
			if(m.group(3).equals("*"))
				s=m.group(1)+(Integer.parseInt(m.group(2))*Integer.parseInt(m.group(4)))+m.group(5);
			else
				s=m.group(1)+(Integer.parseInt(m.group(2))/Integer.parseInt(m.group(4)))+m.group(5);
			m=muldiv.matcher(s);
		}

		m=addsub.matcher(s);
		while(m.find()){
			if(m.group(3).equals("+"))
				s=m.group(1)+(Integer.parseInt(m.group(2))+Integer.parseInt(m.group(4)))+m.group(5);
			else
				s=m.group(1)+(Integer.parseInt(m.group(2))-Integer.parseInt(m.group(4)))+m.group(5);
			m=addsub.matcher(s);
		}
		return s;
	}

	private static String process2(String s){
		Matcher m=addsubmuldiv.matcher(s);
		while(m.find()){
			if(m.group(3).equals("*"))
				s=m.group(1)+(Integer.parseInt(m.group(2))*Integer.parseInt(m.group(4)))+m.group(5);
			else if(m.group(3).equals("/"))
				s=m.group(1)+(Integer.parseInt(m.group(2))/Integer.parseInt(m.group(4)))+m.group(5);
			else if(m.group(3).equals("+"))
				s=m.group(1)+(Integer.parseInt(m.group(2))+Integer.parseInt(m.group(4)))+m.group(5);
			else
				s=m.group(1)+(Integer.parseInt(m.group(2))-Integer.parseInt(m.group(4)))+m.group(5);
			m=addsubmuldiv.matcher(s);
		}
		return s;
	}

	public static void main(String[]z){
		Scanner x=new Scanner(System.in);
		String s=x.next().replaceAll("-","Z");
		String ans=x.next();
		boolean a=process(s).equals(ans);
		boolean b=process2(s).equals(ans);
		if(a&&b)System.out.println("U");
		if(a&&!b)System.out.println("M");
		if(!a&&b)System.out.println("L");
		if(!a&&!b)System.out.println("I");
	}
}

</source>
<source file="../hum_codes_raw/s771420354.java" startline="1" endline="58" pcid="25897">
import java.util.*;
import java.util.regex.*;

class Main{
	private final static Pattern addsubmuldiv = Pattern.compile("^(.*?)(-?\\d+)([+Z*/])(-?\\d+)(.*)$");
	private final static Pattern addsub = Pattern.compile("^(.*?)(-?\\d+)([+Z])(-?\\d+)(.*)$");
	private final static Pattern muldiv = Pattern.compile("^(.*?)(-?\\d+)([*/])(-?\\d+)(.*)$");

	private static String process(String s){
		Matcher m=muldiv.matcher(s);
		while(m.find()){
			if(m.group(3).equals("*"))
				s=m.group(1)+(Integer.parseInt(m.group(2))*Integer.parseInt(m.group(4)))+m.group(5);
			else
				s=m.group(1)+(Integer.parseInt(m.group(2))/Integer.parseInt(m.group(4)))+m.group(5);
			m=muldiv.matcher(s);
		}

		m=addsub.matcher(s);
		while(m.find()){
			if(m.group(3).equals("+"))
				s=m.group(1)+(Integer.parseInt(m.group(2))+Integer.parseInt(m.group(4)))+m.group(5);
			else
				s=m.group(1)+(Integer.parseInt(m.group(2))-Integer.parseInt(m.group(4)))+m.group(5);
			m=addsub.matcher(s);
		}
		return s;
	}

	private static String process2(String s){
		Matcher m=addsubmuldiv.matcher(s);
		while(m.find()){
			if(m.group(3).equals("*"))
				s=m.group(1)+(Integer.parseInt(m.group(2))*Integer.parseInt(m.group(4)))+m.group(5);
			else if(m.group(3).equals("/"))
				s=m.group(1)+(Integer.parseInt(m.group(2))/Integer.parseInt(m.group(4)))+m.group(5);
			else if(m.group(3).equals("+"))
				s=m.group(1)+(Integer.parseInt(m.group(2))+Integer.parseInt(m.group(4)))+m.group(5);
			else
				s=m.group(1)+(Integer.parseInt(m.group(2))-Integer.parseInt(m.group(4)))+m.group(5);
			m=addsubmuldiv.matcher(s);
		}
		return s;
	}

	public static void main(String[]z){
		Scanner x=new Scanner(System.in);
		String s=x.next().replaceAll("-","Z");
		String ans=x.next();
		boolean a=process(s).equals(ans);
		boolean b=process2(s).equals(ans);
		if(a&&b)System.out.println("U");
		if(a&&!b)System.out.println("M");
		if(!a&&b)System.out.println("L");
		if(!a&&!b)System.out.println("I");
	}
}

</source>
</class>

<class classid="118" nclones="2" nlines="186" similarity="100">
<source file="../hum_codes_raw/s200363083.java" startline="1" endline="201" pcid="6755">
import java.io.*;
import java.util.*;
import java.util.Map.Entry;
import java.util.stream.Collectors;

@SuppressWarnings("unused")
public class Main {
	
	//final boolean isDebug = true;
	final boolean isDebug = false;
	String fileName = "input.txt";
	FastScanner sc;
	PrintWriter out;
	final int MOD = (int)1e9+7;
	//final int INF = Integer.MAX_VALUE / 2;
	final long INF = Long.MAX_VALUE / 2;
	
	void solve() throws Exception{
		Scanner scanner = new Scanner(System.in);
		while(scanner.hasNext()){
			String S = scanner.next();
			if(S == null) break;
			int[] num = new int[10];
			for(int i = 0; i < S.length(); i++) num[S.charAt(i) - '0']++;
			
			ArrayList<Integer> ans = new ArrayList<>();
			for(int i = 1; i <= 9; i++){
				int[] tehai = Arrays.copyOf(num, num.length);
				tehai[i]++;
				if(tehai[i] == 5) continue;
				if(canTitoi(Arrays.copyOf(tehai, tehai.length)) || can1(Arrays.copyOf(tehai, tehai.length))) ans.add(i);
			}
			
			if(ans.isEmpty()) System.out.println(0);
			else{
				for(int i = 0; i < ans.size(); i++){
					System.out.print(ans.get(i) + (i == ans.size()-1 ? "\n" : " "));
				}
			}
		}
		scanner.close();
 	}
	
	
	
	boolean canTitoi(int[] tehai){
		int sum = 0;
		for(int i = 1; i <= 9; i++){
			if(tehai[i] == 2) sum++;
			else if(tehai[i] != 0) return false;
		}
		return sum == 7;
	}
	
	boolean can1(int[] tehai){
		for(int i = 1; i <= 9; i++){
			if(tehai[i] < 2) continue;
			int[] t = Arrays.copyOf(tehai, tehai.length);
			t[i] -= 2;
			if(can4(t)) return true;
		}
		return false;
	}
	
	boolean can4(int[] tehai){
		int sumAll = 0;
		for(int i = 1; i <= 9; i++){
			sumAll += tehai[i];
			if(tehai[i] >= 3){
				int[] t = Arrays.copyOf(tehai, tehai.length);
				t[i] -= 3;
				if(can4(t)) return true;
			}
			if(i <= 7 && tehai[i] >= 1 && tehai[i+1] >= 1 && tehai[i+2] >= 1){
				int[] t = Arrays.copyOf(tehai, tehai.length);
				t[i]--; t[i+1]--; t[i+2]--;
				if(can4(t)) return true;
			}
		}
		return sumAll == 0;
	}
	
	/* end solve */
	
	/* main */
	public static void main(String[] args) throws Exception {
		new Main().m();
	}
	
	void m() throws Exception {
		long S = System.currentTimeMillis();
		sc = (isDebug) ? new FastScanner(new FileInputStream(fileName)) : new FastScanner(System.in);
		out = new PrintWriter(System.out);
		solve();
		out.flush();
		long G = System.currentTimeMillis();
		if(isDebug){
			System.out.println("---Debug---");
			System.out.printf("%8d ms\n", (G-S));
		}
	}
	/* end main */
}
/* end Main */

class Pair{
	int x;
	long d;
	public Pair(int x, long d){this.x = x; this.d = d;}
}

class FastScanner {
    private InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;
    public FastScanner(InputStream in) {
		this.in = in;
	}
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() {
    	if (hasNextByte()) return buffer[ptr++];
    	else return -1;
    }
    private static boolean isPrintableChar(int c){
    	return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
    	while(hasNextByte() && !isPrintableChar(buffer[ptr]))
    		ptr++; return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
    public String nextLine() {
        if (!hasNext()) throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(b != 10) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
    public long nextLong() {
        if (!hasNext()) throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while(true){
            if ('0' <= b && b <= '9') {
                n *= 10;
                n += b - '0';
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
    	return Double.parseDouble(next());
    }
}


</source>
<source file="../hum_codes_raw/s749602919.java" startline="1" endline="201" pcid="25183">
import java.io.*;
import java.util.*;
import java.util.Map.Entry;
import java.util.stream.Collectors;

@SuppressWarnings("unused")
public class Main {
	
	//final boolean isDebug = true;
	final boolean isDebug = false;
	String fileName = "input.txt";
	FastScanner sc;
	PrintWriter out;
	final int MOD = (int)1e9+7;
	//final int INF = Integer.MAX_VALUE / 2;
	final long INF = Long.MAX_VALUE / 2;
	
	void solve() throws Exception{
		Scanner scanner = new Scanner(System.in);
		while(scanner.hasNext()){
			String S = scanner.next();
			if(S == null) break;
			int[] num = new int[10];
			for(int i = 0; i < S.length(); i++) num[S.charAt(i) - '0']++;
			
			ArrayList<Integer> ans = new ArrayList<>();
			for(int i = 1; i <= 9; i++){
				int[] tehai = Arrays.copyOf(num, num.length);
				tehai[i]++;
				if(tehai[i] == 5) continue;
				if(canTitoi(Arrays.copyOf(tehai, tehai.length)) || can1(Arrays.copyOf(tehai, tehai.length))) ans.add(i);
			}
			
			if(ans.isEmpty()) System.out.println(0);
			else{
				for(int i = 0; i < ans.size(); i++){
					System.out.print(ans.get(i) + (i == ans.size()-1 ? "\n" : " "));
				}
			}
		}
		scanner.close();
 	}
	
	
	
	boolean canTitoi(int[] tehai){
		int sum = 0;
		for(int i = 1; i <= 9; i++){
			if(tehai[i] == 2) sum++;
			else if(tehai[i] != 0) return false;
		}
		return sum == 7;
	}
	
	boolean can1(int[] tehai){
		for(int i = 1; i <= 9; i++){
			if(tehai[i] < 2) continue;
			int[] t = Arrays.copyOf(tehai, tehai.length);
			t[i] -= 2;
			if(can4(t)) return true;
		}
		return false;
	}
	
	boolean can4(int[] tehai){
		int sumAll = 0;
		for(int i = 1; i <= 9; i++){
			sumAll += tehai[i];
			if(tehai[i] >= 3){
				int[] t = Arrays.copyOf(tehai, tehai.length);
				t[i] -= 3;
				if(can4(t)) return true;
			}
			if(i <= 7 && tehai[i] >= 1 && tehai[i+1] >= 1 && tehai[i+2] >= 1){
				int[] t = Arrays.copyOf(tehai, tehai.length);
				t[i]--; t[i+1]--; t[i+2]--;
				if(can4(t)) return true;
			}
		}
		return sumAll == 0;
	}
	
	/* end solve */
	
	/* main */
	public static void main(String[] args) throws Exception {
		new Main().m();
	}
	
	void m() throws Exception {
		long S = System.currentTimeMillis();
		sc = (isDebug) ? new FastScanner(new FileInputStream(fileName)) : new FastScanner(System.in);
		out = new PrintWriter(System.out);
		solve();
		out.flush();
		long G = System.currentTimeMillis();
		if(isDebug){
			System.out.println("---Debug---");
			System.out.printf("%8d ms\n", (G-S));
		}
	}
	/* end main */
}
/* end Main */

class Pair{
	int x;
	long d;
	public Pair(int x, long d){this.x = x; this.d = d;}
}

class FastScanner {
    private InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;
    public FastScanner(InputStream in) {
		this.in = in;
	}
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() {
    	if (hasNextByte()) return buffer[ptr++];
    	else return -1;
    }
    private static boolean isPrintableChar(int c){
    	return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
    	while(hasNextByte() && !isPrintableChar(buffer[ptr]))
    		ptr++; return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
    public String nextLine() {
        if (!hasNext()) throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(b != 10) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
    public long nextLong() {
        if (!hasNext()) throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while(true){
            if ('0' <= b && b <= '9') {
                n *= 10;
                n += b - '0';
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
    	return Double.parseDouble(next());
    }
}


</source>
</class>

<class classid="119" nclones="2" nlines="39" similarity="100">
<source file="../hum_codes_raw/s210510115.java" startline="1" endline="36" pcid="7101">
import java.util.Scanner;
public class Main {
	public static void main(String[] args){
		Scanner stdIn=new Scanner(System.in);
		int N=stdIn.nextInt();
		int X=stdIn.nextInt();
		int A[]=new int[N];
		int B[]=new int[N-1];
		int z=0,y=0,x=0;
		long ans=0;
		while(z<N){
			A[z]=stdIn.nextInt();
			z++;
		}z=0;
		while(z<N-1){
			B[z]=A[z]+A[z+1];
			z++;
		}z=0;
		while(z<N-1){
			if(B[z]>X){
				y=B[z]-X;
				if(y>A[z+1]){
					x=y-A[z+1];y=A[z+1];
				}
				A[z]-=x;
				A[z+1]-=y;
				if(z!=N-2)
					B[z+1]-=y;
				ans+=x+y;
			}
			x=0;y=0;z++;
		}
		System.out.println(ans);
	}
}

</source>
<source file="../hum_codes_raw/s379237304.java" startline="1" endline="36" pcid="12754">
import java.util.Scanner;
public class Main {
	public static void main(String[] args){
		Scanner stdIn=new Scanner(System.in);
		int N=stdIn.nextInt();
		int X=stdIn.nextInt();
		int A[]=new int[N];
		int B[]=new int[N-1];
		int z=0,y=0,x=0;
		long ans=0;
		while(z<N){
			A[z]=stdIn.nextInt();
			z++;
		}z=0;
		while(z<N-1){
			B[z]=A[z]+A[z+1];
			z++;
		}z=0;
		while(z<N-1){
			if(B[z]>X){
				y=B[z]-X;
				if(y>A[z+1]){
					x=y-A[z+1];y=A[z+1];
				}
				A[z]-=x;
				A[z+1]-=y;
				if(z!=N-2)
					B[z+1]-=y;
				ans+=x+y;
			}
			x=0;y=0;z++;
		}
		System.out.println(ans);
	}
}

</source>
</class>

<class classid="120" nclones="2" nlines="21" similarity="100">
<source file="../hum_codes_raw/s215591855.java" startline="1" endline="54" pcid="7278">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.function.Function;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class Main {

  public static void main(String[] args) throws IOException {
    
    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      int n = Integer.parseInt(br.readLine());

      Function<String,double[]> lineSpliteThenArray =
        s -> Stream.of(s.split(" "))
          .mapToDouble(Double::parseDouble)
          .toArray();

      double[][] vecter =
        br.lines()
          .limit(2)
          .map( lineSpliteThenArray )
          .toArray(double[][]::new);

      double p1 =
        IntStream.range(0, n)
          .mapToDouble(i -> Math.abs(vecter[0][i] - vecter[1][i]) )
          .sum();

      double p2 = Math.sqrt(
        IntStream.range(0, n)
          .mapToDouble(i -> Math.pow( vecter[0][i] - vecter[1][i], 2))
          .sum() );

      double p3 = Math.pow(
        IntStream.range(0, n)
        .mapToDouble(i -> Math.pow( Math.abs(vecter[0][i] - vecter[1][i]), 3d))
        .sum() , 1d/3d );

      double p00 =
        IntStream.range(0, n)
          .mapToDouble(i -> Math.abs(vecter[0][i] - vecter[1][i]))
          .max()
          .getAsDouble();

      System.out.printf("%.8f\n%.8f\n%.8f\n%.8f\n", p1,p2,p3,p00);
    }
  }

}

</source>
<source file="../hum_codes_raw/s855876782.java" startline="1" endline="54" pcid="28772">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.function.Function;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class Main {

  public static void main(String[] args) throws IOException {
    
    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      int n = Integer.parseInt(br.readLine());

      Function<String,double[]> lineSpliteThenArray =
        s -> Stream.of(s.split(" "))
          .mapToDouble(Double::parseDouble)
          .toArray();

      double[][] vecter =
        br.lines()
          .limit(2)
          .map( lineSpliteThenArray )
          .toArray(double[][]::new);

      double p1 =
        IntStream.range(0, n)
          .mapToDouble(i -> Math.abs(vecter[0][i] - vecter[1][i]) )
          .sum();

      double p2 = Math.sqrt(
        IntStream.range(0, n)
          .mapToDouble(i -> Math.pow( vecter[0][i] - vecter[1][i], 2))
          .sum() );

      double p3 = Math.pow(
        IntStream.range(0, n)
        .mapToDouble(i -> Math.pow( Math.abs(vecter[0][i] - vecter[1][i]), 3d))
        .sum() , 1d/3d );

      double p00 =
        IntStream.range(0, n)
          .mapToDouble(i -> Math.abs(vecter[0][i] - vecter[1][i]))
          .max()
          .getAsDouble();

      System.out.printf("%.8f\n%.8f\n%.8f\n%.8f\n", p1,p2,p3,p00);
    }
  }

}

</source>
</class>

<class classid="121" nclones="2" nlines="41" similarity="100">
<source file="../hum_codes_raw/s217045508.java" startline="1" endline="44" pcid="7328">
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc = new Scanner(System.in);
		int h = sc.nextInt();
		int w = sc.nextInt();
		char[][] weather = new char[h][w + 1];
		int[][] result = new int[h][w + 1];
		for (int i = 0; i < h; i++) {
			weather[i] = sc.next().toCharArray();
		}
		int cnt;
		for(int i = 0; i < h; i++) {
			cnt = -1;
			for(int k = 0; k < w; k++) {
				if(weather[i][k] == 'c') {
					cnt = 0;
					result[i][k] = cnt;
					cnt = cnt + 1;
				} else if(cnt >= 0) {
					result[i][k] = cnt;
					cnt = cnt + 1;
				} else {
					result[i][k] = cnt;
				}
				
			}
		}
		for(int i = 0; i < h; i++) {
			for(int k = 0; k < w; k++) {
				if(k == w - 1) {
					System.out.println(result[i][k]);
				} else {
					System.out.print(result[i][k] + " ");
				}
			}
		}
	}

}

</source>
<source file="../hum_codes_raw/s381324116.java" startline="1" endline="44" pcid="12815">
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc = new Scanner(System.in);
		int h = sc.nextInt();
		int w = sc.nextInt();
		char[][] weather = new char[h][w + 1];
		int[][] result = new int[h][w + 1];
		for (int i = 0; i < h; i++) {
			weather[i] = sc.next().toCharArray();
		}
		int cnt;
		for(int i = 0; i < h; i++) {
			cnt = -1;
			for(int k = 0; k < w; k++) {
				if(weather[i][k] == 'c') {
					cnt = 0;
					result[i][k] = cnt;
					cnt = cnt + 1;
				} else if(cnt >= 0) {
					result[i][k] = cnt;
					cnt = cnt + 1;
				} else {
					result[i][k] = cnt;
				}
				
			}
		}
		for(int i = 0; i < h; i++) {
			for(int k = 0; k < w; k++) {
				if(k == w - 1) {
					System.out.println(result[i][k]);
				} else {
					System.out.print(result[i][k] + " ");
				}
			}
		}
	}

}

</source>
</class>

<class classid="122" nclones="3" nlines="38" similarity="100">
<source file="../hum_codes_raw/s223434161.java" startline="1" endline="49" pcid="7548">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Main {

  public static void main(String[] args) throws IOException {
    
    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      int q = Integer.parseInt(br.readLine());
      String[] s = new String[q+q];
      Arrays.fill(s, "");
      List<String> list  = Arrays.asList(s);
      int head = q;
      int tail = q;

      String[] query;
      int op;
      for ( int i=0; i<q; i++ ){
        query = br.readLine().split(" ");
        op  = Integer.parseInt(query[0]);

        switch( op ) {
          case 0 :
            if ( Integer.parseInt(query[1]) == 0 )
              list.set(head--,query[2]);
            else
              list.set(++tail,query[2]);
            break;
          case 1 :
            System.out.println( list.get(head+1 + Integer.parseInt(query[1])) );
            break;
          case 2 :
            if ( Integer.parseInt(query[1]) == 0 )
              head++; // list.set(head++,"");
            else
              tail--; // list.set(tail--,"");
            break;
          default:
        }
      }
    }
  }
}

</source>
<source file="../hum_codes_raw/s730888198.java" startline="1" endline="49" pcid="24568">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Main {

  public static void main(String[] args) throws IOException {
    
    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      int q = Integer.parseInt(br.readLine());
      String[] s = new String[q+q];
      Arrays.fill(s, "");
      List<String> list  = Arrays.asList(s);
      int head = q;
      int tail = q;

      String[] query;
      int op;
      for ( int i=0; i<q; i++ ){
        query = br.readLine().split(" ");
        op  = Integer.parseInt(query[0]);

        switch( op ) {
          case 0 :
            if ( Integer.parseInt(query[1]) == 0 )
              list.set(head--,query[2]);
            else
              list.set(++tail,query[2]);
            break;
          case 1 :
            System.out.println( list.get(head+1 + Integer.parseInt(query[1])) );
            break;
          case 2 :
            if ( Integer.parseInt(query[1]) == 0 )
              head++; // list.set(head++,"");
            else
              tail--; // list.set(tail--,"");
            break;
          default:
        }
      }
    }
  }
}

</source>
<source file="../hum_codes_raw/s280856904.java" startline="1" endline="49" pcid="9399">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Main {

  public static void main(String[] args) throws IOException {
    
    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      int q = Integer.parseInt(br.readLine());
      String[] s = new String[q+q];
      Arrays.fill(s, "");
      List<String> list  = Arrays.asList(s);
      int head = q;
      int tail = q;

      String[] query;
      int op;
      for ( int i=0; i<q; i++ ){
        query = br.readLine().split(" ");
        op  = Integer.parseInt(query[0]);

        switch( op ) {
          case 0 :
            if ( Integer.parseInt(query[1]) == 0 )
              list.set(head--,query[2]);
            else
              list.set(++tail,query[2]);
            break;
          case 1 :
            System.out.println( list.get(head+1 + Integer.parseInt(query[1])) );
            break;
          case 2 :
            if ( Integer.parseInt(query[1]) == 0 )
              head++; // list.set(head++,"");
            else
              tail--; // list.set(tail--,"");
            break;
          default:
        }
      }
    }
  }
}

</source>
</class>

<class classid="123" nclones="2" nlines="73" similarity="100">
<source file="../hum_codes_raw/s224294059.java" startline="1" endline="93" pcid="7576">

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.*;


public class Main {

    public static void main(String[] args) throws IOException {
        Scanner s = new Scanner(System.in);
        int n = s.nextInt(),x=s.nextInt();
        long total=0;
        int arr[] = new int[n];
        for(int i=0;i<n;i++)arr[i]=s.nextInt();
        for(int i=1;i<n;i++){
            int sum = arr[i]+arr[i-1];
            if(sum>x){
                int diff = sum-x;
                total+=diff;

                if(arr[i]-diff>=0){
                    arr[i]-=diff;
                }
                else{
                    arr[i]=0;
                }
            }
        }
        System.out.println(total);
    }


}




class Scanner
{
    StringTokenizer st;
    BufferedReader br;

    public Scanner(InputStream s){	br = new BufferedReader(new InputStreamReader(s));}

    public String next() throws IOException
    {
        while (st == null || !st.hasMoreTokens())
            st = new StringTokenizer(br.readLine());
        return st.nextToken();
    }

    public int nextInt() throws IOException {return Integer.parseInt(next());}

    public long nextLong() throws IOException {return Long.parseLong(next());}

    public String nextLine() throws IOException {return br.readLine();}

    public double nextDouble() throws IOException
    {
        String x = next();
        StringBuilder sb = new StringBuilder("0");
        double res = 0, f = 1;
        boolean dec = false, neg = false;
        int start = 0;
        if(x.charAt(0) == '-')
        {
            neg = true;
            start++;
        }
        for(int i = start; i < x.length(); i++)
            if(x.charAt(i) == '.')
            {
                res = Long.parseLong(sb.toString());
                sb = new StringBuilder("0");
                dec = true;
            }
            else
            {
                sb.append(x.charAt(i));
                if(dec)
                    f *= 10;
            }
        res += Long.parseLong(sb.toString()) / f;
        return res * (neg?-1:1);
    }

    public boolean ready() throws IOException {return br.ready();}


}

</source>
<source file="../hum_codes_raw/s225899038.java" startline="1" endline="93" pcid="7638">

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.*;


public class Main {

    public static void main(String[] args) throws IOException {
        Scanner s = new Scanner(System.in);
        int n = s.nextInt(),x=s.nextInt();
        long total=0;
        int arr[] = new int[n];
        for(int i=0;i<n;i++)arr[i]=s.nextInt();
        for(int i=1;i<n;i++){
            int sum = arr[i]+arr[i-1];
            if(sum>x){
                int diff = sum-x;
                total+=diff;

                if(arr[i]-diff>=0){
                    arr[i]-=diff;
                }
                else{
                    arr[i]=0;
                }
            }
        }
        System.out.println(total);
    }


}




class Scanner
{
    StringTokenizer st;
    BufferedReader br;

    public Scanner(InputStream s){	br = new BufferedReader(new InputStreamReader(s));}

    public String next() throws IOException
    {
        while (st == null || !st.hasMoreTokens())
            st = new StringTokenizer(br.readLine());
        return st.nextToken();
    }

    public int nextInt() throws IOException {return Integer.parseInt(next());}

    public long nextLong() throws IOException {return Long.parseLong(next());}

    public String nextLine() throws IOException {return br.readLine();}

    public double nextDouble() throws IOException
    {
        String x = next();
        StringBuilder sb = new StringBuilder("0");
        double res = 0, f = 1;
        boolean dec = false, neg = false;
        int start = 0;
        if(x.charAt(0) == '-')
        {
            neg = true;
            start++;
        }
        for(int i = start; i < x.length(); i++)
            if(x.charAt(i) == '.')
            {
                res = Long.parseLong(sb.toString());
                sb = new StringBuilder("0");
                dec = true;
            }
            else
            {
                sb.append(x.charAt(i));
                if(dec)
                    f *= 10;
            }
        res += Long.parseLong(sb.toString()) / f;
        return res * (neg?-1:1);
    }

    public boolean ready() throws IOException {return br.ready();}


}

</source>
</class>

<class classid="124" nclones="2" nlines="58" similarity="100">
<source file="../hum_codes_raw/s225400136.java" startline="1" endline="64" pcid="7629">
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

//Wrought Gold Master
public class Main {

	public static int[] price;
	public static int[] opt;
	public static Map<String, Integer> ref;
	public static int[][] list;

	public static int get(int k){
		if(opt[k]!=Integer.MAX_VALUE){
			return opt[k];
		}
		if(list[k].length==0){
			return opt[k] = price[k];
		}
		int p = 0;
		for(int i=0;i<list[k].length;i++){
			p += get(list[k][i]);
		}
		return opt[k] = Math.min(p, price[k]);
	}

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int n = sc.nextInt();
			if(n==0)break;
			price = new int[300];
			opt = new int[300];
			list = new int[300][0];
			Arrays.fill(opt, Integer.MAX_VALUE);
			int id = 0;
			ref = new HashMap<String, Integer>();
			for(int i=0;i<n;i++){
				ref.put(sc.next(), id);
				price[id++] = sc.nextInt();
			}
			int m = sc.nextInt();
			while(m--!=0){
				String s = sc.next();
				if(!ref.containsKey(s)){
					ref.put(s, id++);
				}
				int i = ref.get(s);
				int k = sc.nextInt();
				list[i] = new int[k];
				for(int j=0;j<k;j++){
					s = sc.next();
					if(!ref.containsKey(s)){
						ref.put(s, id++);
					}
					list[i][j] = ref.get(s);
				}
			}
			System.out.println(get(ref.get(sc.next())));
		}
	}
}

</source>
<source file="../hum_codes_raw/s934297997.java" startline="1" endline="64" pcid="31419">
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

//Wrought Gold Master
public class Main{

	public static int[] price;
	public static int[] opt;
	public static Map<String, Integer> ref;
	public static int[][] list;

	public static int get(int k){
		if(opt[k]!=Integer.MAX_VALUE){
			return opt[k];
		}
		if(list[k].length==0){
			return opt[k] = price[k];
		}
		int p = 0;
		for(int i=0;i<list[k].length;i++){
			p += get(list[k][i]);
		}
		return opt[k] = Math.min(p, price[k]);
	}

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int n = sc.nextInt();
			if(n==0)break;
			price = new int[300];
			opt = new int[300];
			list = new int[300][0];
			Arrays.fill(opt, Integer.MAX_VALUE);
			int id = 0;
			ref = new HashMap<String, Integer>();
			for(int i=0;i<n;i++){
				ref.put(sc.next(), id);
				price[id++] = sc.nextInt();
			}
			int m = sc.nextInt();
			while(m--!=0){
				String s = sc.next();
				if(!ref.containsKey(s)){
					ref.put(s, id++);
				}
				int i = ref.get(s);
				int k = sc.nextInt();
				list[i] = new int[k];
				for(int j=0;j<k;j++){
					s = sc.next();
					if(!ref.containsKey(s)){
						ref.put(s, id++);
					}
					list[i][j] = ref.get(s);
				}
			}
			System.out.println(get(ref.get(sc.next())));
		}
	}
}

</source>
</class>

<class classid="125" nclones="2" nlines="18" similarity="100">
<source file="../hum_codes_raw/s226358701.java" startline="1" endline="21" pcid="7652">
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int a = scan.nextInt();
        int b = scan.nextInt();
        int c = scan.nextInt();

        if (a == b) {
            System.out.println(c);
        } else if(b == c) {
            System.out.println(a);
        } else {
            System.out.println(b);
        }
    }
}


</source>
<source file="../hum_codes_raw/s565471129.java" startline="1" endline="19" pcid="19026">
import java.util.Scanner;
public class Main{
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int a=scan.nextInt();
		int b=scan.nextInt();
		int c=scan.nextInt();
if(a==b) {
	System.out.println(c);
}
else if(b==c){
	System.out.println(a);
}
else {
	System.out.println(b);
}
	}
}

</source>
</class>

<class classid="126" nclones="2" nlines="36" similarity="100">
<source file="../hum_codes_raw/s226968743.java" startline="1" endline="42" pcid="7677">
import java.util.ArrayList;
import java.util.Collections;
import java.util.PriorityQueue;
import java.util.Scanner;

class Main{
	public static void main(String[] args) {
		ArrayList <PriorityQueue<Integer>> queues = new ArrayList <PriorityQueue<Integer>>();  //PriorityQueueのArrayListを生成
		try (Scanner sc = new Scanner (System.in)){
			int n = sc.nextInt();
			for (int i=0; i<n; i++) {
				queues.add(new PriorityQueue<Integer>(Collections.reverseOrder()));

			}
			int times = sc.nextInt();
			for (int i=0; i<times; i++) {
				int query = sc.nextInt();
				int que = sc.nextInt();
				switch (query) {
				//insert(t,x)
				case 0:
					int x = sc.nextInt();
					queues.get(que).add(x);
					break;
				case 1:
					if (queues.get(que).size() != 0) {
						System.out.println(queues.get(que).peek());
					}
					break;
				case 2:
					if (queues.get(que).size() != 0) {
						queues.get(que).poll();
					}
					break;

				}
			}
		}
	}
}


</source>
<source file="../hum_codes_raw/s607330585.java" startline="1" endline="46" pcid="20406">
import java.util.ArrayList;
import java.util.Collections;
import java.util.PriorityQueue;
import java.util.Scanner;

class Main {

	public static void main(String[] args) {
		ArrayList <PriorityQueue<Integer>> queues = new ArrayList <PriorityQueue<Integer>>();  //PriorityQueueのArrayListを生成
		try (Scanner sc = new Scanner (System.in)){
			int n = sc.nextInt();
			for (int i=0; i<n; i++) {
				queues.add(new PriorityQueue<Integer>(Collections.reverseOrder()));  //n個のPriorityQueueを追加（逆順）
																					//Collectionsの参考：https://qiita.com/p_shiki37/items/3902f4e3adc3aeb382f1
			}
			int times = sc.nextInt();
			for (int i=0; i<times; i++) {
				int query = sc.nextInt();  //命令 0 insert 1 getMax 2 deleteMax
				int que = sc.nextInt();  //何個目のqueue
				switch (query) {
				//insert(t,x)
				case 0:
					int x = sc.nextInt();
					queues.get(que).add(x);
					break;

				//getMax(t)
				case 1:
					if (queues.get(que).size() != 0) { //空じゃなかったら
						System.out.println(queues.get(que).peek());
					}
					break;

				//deleteMax(t)
				case 2:
					if (queues.get(que).size() != 0) { //空じゃなかったら
						queues.get(que).poll();
					}
					break;

				}
			}
		}
	}
}

</source>
</class>

<class classid="127" nclones="2" nlines="39" similarity="100">
<source file="../hum_codes_raw/s228857483.java" startline="1" endline="45" pcid="7726">
import java.util.Arrays;
import java.util.Scanner;

public class Main {
	Scanner sc = new Scanner(System.in);
	int N, M;
	int INF = Integer.MAX_VALUE / 2;
	int[][] graph, memo;

	void run() {
		N = sc.nextInt(); // edge number
		M = sc.nextInt(); // vertex number
		graph = new int[N][N];
		memo = new int[N][1 << N];
		for (int i = 0; i < N; i++) {
			Arrays.fill(graph[i], INF);
			Arrays.fill(memo[i], -1);
		}
		for (int i = 0; i < M; i++) {
			int s = sc.nextInt();
			int t = sc.nextInt();
			int cost = sc.nextInt();
			graph[s][t] = cost;
		}
		int res = tsp(0, 1);
		System.out.println(res == INF ? -1 : res);
	}

	int tsp(int v, int mask) {
		if (memo[v][mask] != -1)  return memo[v][mask];
		if (mask == (1 << N) - 1) return graph[v][0];

		int res = INF;
		for (int i = 0; i < N; i++) {
			if ((mask & (1 << i)) != 0) continue;
			res = Math.min(res, graph[v][i] + tsp(i, mask | (1 << i)));
		}
		return memo[v][mask] = res;
	}

	public static void main(String[] args) {
		new Main().run();
	}
}

</source>
<source file="../hum_codes_raw/s507253512.java" startline="1" endline="45" pcid="16995">
import java.util.Arrays;
import java.util.Scanner;

public class Main {
	Scanner sc = new Scanner(System.in);
	int N, M;
	int INF = Integer.MAX_VALUE / 2;
	int[][] graph, memo;

	void run() {
		N = sc.nextInt(); // edge number
		M = sc.nextInt(); // vertex number
		graph = new int[N][N];
		memo = new int[N][1 << N];
		for (int i = 0; i < N; i++) {
			Arrays.fill(graph[i], INF);
			Arrays.fill(memo[i], -1);
		}
		for (int i = 0; i < M; i++) {
			int s = sc.nextInt();
			int t = sc.nextInt();
			int cost = sc.nextInt();
			graph[s][t] = cost;
		}
		int res = tsp(0, 1);
		System.out.println(res == INF ? -1 : res);
	}

	int tsp(int v, int mask) {
		if (memo[v][mask] != -1)  return memo[v][mask];
		if (mask == (1 << N) - 1) return graph[v][0];

		int res = INF;
		for (int i = 0; i < N; i++) {
			if ((mask & (1 << i)) != 0) continue;
			res = Math.min(res, graph[v][i] + tsp(i, mask | (1 << i)));
		}
		return memo[v][mask] = res;
	}

	public static void main(String[] args) {
		new Main().run();
	}
}

</source>
</class>

<class classid="128" nclones="2" nlines="19" similarity="100">
<source file="../hum_codes_raw/s229096843.java" startline="1" endline="32" pcid="7736">
import java.util.Scanner;
public class Main{
    int high;
		int low;
		int sa;
		
    public void solve(){
		Scanner sc=new Scanner(System.in);
		
		
    
		for(int i=0;i<7;i++){
			
        high=sc.nextInt();
        low=sc.nextInt();
		sa=high-low;
   
	System.out.println(sa);
    
    }
	
    }

        
    public static void main(String[]args){
		
        Main obj =new Main();
        obj.solve();
    
    }
}

</source>
<source file="../hum_codes_raw/s259696948.java" startline="1" endline="21" pcid="8724">
import java.util.Scanner;
public class Main{
    int high;
    int low;
    int sa;
    
    public void solve(){
       Scanner sc = new Scanner(System.in);
	   for(int i=0;i<7;i++){
        high=sc.nextInt();
		low=sc.nextInt();
		sa=high-low;
		System.out.println(sa);
	   }
    }
    public static void main(String[]args){
        Main obj = new Main();
        obj.solve();
    }
}

</source>
</class>

<class classid="129" nclones="2" nlines="27" similarity="100">
<source file="../hum_codes_raw/s232142104.java" startline="1" endline="30" pcid="7836">

import java.util.*;
import java.lang.*;
import java.math.*;

public class Main {
	Scanner sc = new Scanner(System.in);
	void run(){
		int[] dp = new int[51];
		Arrays.fill(dp, Integer.MAX_VALUE - 3000);
		dp[0] = 0;
		int price[] ={380,550,850,380*4,(int)(550*4*0.85 + 0.4),(int)(850*3*0.88 + 0.4)} ;
		int weigh[] ={  2,  3,  5, 10,12,15} ;
		for(int i = 0;i < 6;i++){
			for(int j=0;weigh[i]+j < 51;j++){
				dp[j+weigh[i]] = Math.min(dp[j] + price[i],dp[j+weigh[i]]);
			}
		}
		for(;;){
			int n = sc.nextInt()/100;
			if(n==0) break;
			System.out.println(dp[n]);
		}
	}
	public static void main(String[] args){
		Main m = new Main();
		m.run();
	}
}

</source>
<source file="../hum_codes_raw/s610653046.java" startline="1" endline="58" pcid="20511">


import java.util.*;

import java.lang.*;

import java.math.*;



public class Main {

	Scanner sc = new Scanner(System.in);

	void run(){

		int[] dp = new int[51];

		Arrays.fill(dp, Integer.MAX_VALUE - 3000);

		dp[0] = 0;

		int price[] ={380,550,850,380*4,(int)(550*4*0.85 + 0.4),(int)(850*3*0.88 + 0.4)} ;

		int weigh[] ={  2,  3,  5, 10,12,15} ;

		for(int i = 0;i < 6;i++){

			for(int j=0;weigh[i]+j < 51;j++){

				dp[j+weigh[i]] = Math.min(dp[j] + price[i],dp[j+weigh[i]]);

			}

		}

		for(;;){

			int n = sc.nextInt()/100;

			if(n==0) break;

			System.out.println(dp[n]);

		}

	}

	public static void main(String[] args){

		Main m = new Main();

		m.run();

	}

}

</source>
</class>

<class classid="130" nclones="2" nlines="20" similarity="100">
<source file="../hum_codes_raw/s233405311.java" startline="1" endline="22" pcid="7882">
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        while (true) {
            int H = sc.nextInt();
            int W = sc.nextInt();
            if (H == 0 && W == 0) {
                break;
            }
            for (int i = 0; i < H; i++) {
                for (int j = 0; j < W; j++) {
                    System.out.printf("#");
                }
                System.out.printf("\n");
            }
            System.out.printf("\n");
        }
    }
}

</source>
<source file="../hum_codes_raw/s450531715.java" startline="1" endline="22" pcid="15104">
import java.util.Scanner;

public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        while(true){
            int H = sc.nextInt();
            int W = sc.nextInt();
            if(H == 0 && W == 0){
                break;
            }
            for(int i=0;i<H;i++){
                for(int j=0;j<W;j++){
                    System.out.printf("#");
                }
                System.out.printf("\n");
        }
        System.out.printf("\n");
    }
}
}

</source>
</class>

<class classid="131" nclones="2" nlines="161" similarity="100">
<source file="../hum_codes_raw/s234525574.java" startline="1" endline="220" pcid="7926">
import java.io.IOException;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Scanner;

public class Main {
	// static int time = 0;

	public static void main(String[] args) throws IOException {

		Scanner scan = new Scanner(System.in);
		// Scanner scan = new Scanner(new
		// File("D:\\UserArea\\J0124567\\Downloads\\ALDS1_6_A-in9.txt"));

		HS hs = new HS();

		for (int y = 0; y < 4; y++)
			for (int x = 0; x < 4; x++)
				hs.SetIni(x, y, scan.nextInt());

		System.out.println(hs.solve());

		scan.close();
		System.exit(0);
	}
}

class HS {
	class Bd {
		byte[][] pn = new byte[4][4];
		int oper = 0;
		int diff = 0;

		public long getKey() {
			long key = 0;
			for (int x = 0; x < 4; x++)
				for (int y = 0; y < 4; y++) {
					key *= 10;
					key += pn[x][y];
				}
			return key;
		}

		public int eval() {
			int ret = 0;
			for (int x = 0; x < 4; x++)
				for (int y = 0; y < 4; y++) {
					int p = pn[x][y];
					if (p != 0)
						ret += Math.abs(x - gx[p]) + Math.abs(y - gy[p]);
				}
			diff = ret;
			return ret;
		}

		public void copy(Bd b) {
			for (int x = 0; x < 4; x++)
				for (int y = 0; y < 4; y++)
					pn[x][y] = b.pn[x][y];
			diff = b.diff;
			oper = b.oper;
		}

		private boolean up() {
			for (int x = 0; x < 4; x++)
				for (int y = 0; y < 3; y++)
					if (pn[x][y] == 0) {
						pn[x][y] = pn[x][y + 1];
						pn[x][y + 1] = 0;
						oper++;
						eval();
						return true;
					}
			return false;
		}

		private boolean down() {
			for (int x = 0; x < 4; x++)
				for (int y = 1; y < 4; y++)
					if (pn[x][y] == 0) {
						pn[x][y] = pn[x][y - 1];
						pn[x][y - 1] = 0;
						oper++;
						eval();
						return true;
					}
			return false;
		}

		private boolean right() {
			for (int x = 1; x < 4; x++)
				for (int y = 0; y < 4; y++)
					if (pn[x][y] == 0) {
						pn[x][y] = pn[x - 1][y];
						pn[x - 1][y] = 0;
						oper++;
						eval();
						return true;
					}
			return false;
		}

		private boolean left() {
			for (int x = 0; x < 3; x++)
				for (int y = 0; y < 4; y++)
					if (pn[x][y] == 0) {
						pn[x][y] = pn[x + 1][y];
						pn[x + 1][y] = 0;
						oper++;
						eval();
						return true;
					}
			return false;
		}

		public boolean move(int op) {
			switch (op) {
			case (0):
				return up();
			case (1):
				return down();
			case (2):
				return right();
			case (3):
				return left();
			}
			return false;
		}

		public boolean isSame(Bd b) {
			for (int x = 0; x < 4; x++)
				for (int y = 0; y < 4; y++)
					if (b.pn[x][y] != pn[x][y])
						return false;
			return true;
		}
	}

	private Bd bd = new Bd();
	private int[] gx = { 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2 };
	private int[] gy = { 3, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3 };
	// private ArrayList<Bd> hist = new ArrayList<Bd>();
	private Map<Long, Integer> hist = new HashMap<>();
	private PriorityQueue<Bd> pqueue = new PriorityQueue<Bd>(3, new Qcomparator());

	class Qcomparator implements Comparator<Bd> {
		@Override
		public int compare(Bd b1, Bd b2) {
			if (b1.diff + b1.oper > b2.diff + b2.oper)
				return 1;
			else if (b1.diff + b1.oper == b2.diff + b2.oper)
				return 0;
			else
				return -1;
		}
	}

	public void SetIni(int x, int y, int a) {
		bd.pn[x][y] = (byte) a;
	}

	public int solve() {
		Bd b = new Bd();
		b.copy(bd);
		b.eval();
		pqueue.add(b);
		hist.put(b.getKey(), 0);
		return search();
	}

	private int search() {
		while (true) {
			Bd b = pqueue.poll();
			if (b == null)
				return -1;

			// printBd(b);

			if (b.diff == 0)
				return b.oper;

			for (int i = 0; i < 4; i++) {
				Bd nb = new Bd();
				nb.copy(b);
				if (nb.move(i))
					addQueue(nb);
			}
		}
	}

	private boolean addQueue(Bd b) {
		long k = b.getKey();
		if (hist.containsKey(k)) {
			int oper = hist.get(k);
			if (oper > b.oper) {
				hist.put(k, b.oper);
				pqueue.add(b);
				return true;
			} else
				return false;
		}
		hist.put(k, b.oper);
		pqueue.add(b);
		return true;
	}

	private void printBd(Bd b) {
		System.out.println("----------------");
		for (int y = 0; y < 3; y++)
			System.out.println("- " + b.pn[0][y] + " " + b.pn[1][y] + " " + b.pn[2][y] + " -");
		System.out.println("------- diff " + b.diff + " oper " + b.oper + " queue " + pqueue.size());
		if (pqueue.size() > 100000)
			System.exit(0);
	}
}

</source>
<source file="../hum_codes_raw/s872592449.java" startline="1" endline="220" pcid="29334">
import java.io.IOException;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Scanner;
 
public class Main {
    // static int time = 0;
 
    public static void main(String[] args) throws IOException {
 
        Scanner scan = new Scanner(System.in);
        // Scanner scan = new Scanner(new
        // File("D:\\UserArea\\J0124567\\Downloads\\ALDS1_6_A-in9.txt"));
 
        HS hs = new HS();
 
        for (int y = 0; y < 4; y++)
            for (int x = 0; x < 4; x++)
                hs.SetIni(x, y, scan.nextInt());
 
        System.out.println(hs.solve());
 
        scan.close();
        System.exit(0);
    }
}
 
class HS {
    class Bd {
        byte[][] pn = new byte[4][4];
        int oper = 0;
        int diff = 0;
 
        public long getKey() {
            long key = 0;
            for (int x = 0; x < 4; x++)
                for (int y = 0; y < 4; y++) {
                    key *= 10;
                    key += pn[x][y];
                }
            return key;
        }
 
        public int eval() {
            int ret = 0;
            for (int x = 0; x < 4; x++)
                for (int y = 0; y < 4; y++) {
                    int p = pn[x][y];
                    if (p != 0)
                        ret += Math.abs(x - gx[p]) + Math.abs(y - gy[p]);
                }
            diff = ret;
            return ret;
        }
 
        public void copy(Bd b) {
            for (int x = 0; x < 4; x++)
                for (int y = 0; y < 4; y++)
                    pn[x][y] = b.pn[x][y];
            diff = b.diff;
            oper = b.oper;
        }
 
        private boolean up() {
            for (int x = 0; x < 4; x++)
                for (int y = 0; y < 3; y++)
                    if (pn[x][y] == 0) {
                        pn[x][y] = pn[x][y + 1];
                        pn[x][y + 1] = 0;
                        oper++;
                        eval();
                        return true;
                    }
            return false;
        }
 
        private boolean down() {
            for (int x = 0; x < 4; x++)
                for (int y = 1; y < 4; y++)
                    if (pn[x][y] == 0) {
                        pn[x][y] = pn[x][y - 1];
                        pn[x][y - 1] = 0;
                        oper++;
                        eval();
                        return true;
                    }
            return false;
        }
 
        private boolean right() {
            for (int x = 1; x < 4; x++)
                for (int y = 0; y < 4; y++)
                    if (pn[x][y] == 0) {
                        pn[x][y] = pn[x - 1][y];
                        pn[x - 1][y] = 0;
                        oper++;
                        eval();
                        return true;
                    }
            return false;
        }
 
        private boolean left() {
            for (int x = 0; x < 3; x++)
                for (int y = 0; y < 4; y++)
                    if (pn[x][y] == 0) {
                        pn[x][y] = pn[x + 1][y];
                        pn[x + 1][y] = 0;
                        oper++;
                        eval();
                        return true;
                    }
            return false;
        }
 
        public boolean move(int op) {
            switch (op) {
            case (0):
                return up();
            case (1):
                return down();
            case (2):
                return right();
            case (3):
                return left();
            }
            return false;
        }
 
        public boolean isSame(Bd b) {
            for (int x = 0; x < 4; x++)
                for (int y = 0; y < 4; y++)
                    if (b.pn[x][y] != pn[x][y])
                        return false;
            return true;
        }
    }
 
    private Bd bd = new Bd();
    private int[] gx = { 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2 };
    private int[] gy = { 3, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3 };
    // private ArrayList<Bd> hist = new ArrayList<Bd>();
    private Map<Long, Integer> hist = new HashMap<>();
    private PriorityQueue<Bd> pqueue = new PriorityQueue<Bd>(3, new Qcomparator());
 
    class Qcomparator implements Comparator<Bd> {
        @Override
        public int compare(Bd b1, Bd b2) {
            if (b1.diff + b1.oper > b2.diff + b2.oper)
                return 1;
            else if (b1.diff + b1.oper == b2.diff + b2.oper)
                return 0;
            else
                return -1;
        }
    }
 
    public void SetIni(int x, int y, int a) {
        bd.pn[x][y] = (byte) a;
    }
 
    public int solve() {
        Bd b = new Bd();
        b.copy(bd);
        b.eval();
        pqueue.add(b);
        hist.put(b.getKey(), 0);
        return search();
    }
 
    private int search() {
        while (true) {
            Bd b = pqueue.poll();
            if (b == null)
                return -1;
 
            // printBd(b);
 
            if (b.diff == 0)
                return b.oper;
 
            for (int i = 0; i < 4; i++) {
                Bd nb = new Bd();
                nb.copy(b);
                if (nb.move(i))
                    addQueue(nb);
            }
        }
    }
 
    private boolean addQueue(Bd b) {
        long k = b.getKey();
        if (hist.containsKey(k)) {
            int oper = hist.get(k);
            if (oper > b.oper) {
                hist.put(k, b.oper);
                pqueue.add(b);
                return true;
            } else
                return false;
        }
        hist.put(k, b.oper);
        pqueue.add(b);
        return true;
    }
 
    private void printBd(Bd b) {
        System.out.println("----------------");
        for (int y = 0; y < 3; y++)
            System.out.println("- " + b.pn[0][y] + " " + b.pn[1][y] + " " + b.pn[2][y] + " -");
        System.out.println("------- diff " + b.diff + " oper " + b.oper + " queue " + pqueue.size());
        if (pqueue.size() > 100000)
            System.exit(0);
    }
}

</source>
</class>

<class classid="132" nclones="2" nlines="91" similarity="100">
<source file="../hum_codes_raw/s234632500.java" startline="1" endline="196" pcid="7929">
import java.util.*;
// import java.io.*;
import java.io.PrintWriter;

public class Main {
    public static void main(String[] args) throws Exception {
        // Your code here!
        Scanner sc = new Scanner(System.in);
        // FastScanner sc = new FastScanner(System.in);
        int n = sc.nextInt();
        int[][] array = new int[n][3];
        for (int i = 0; i < n; i++) {
            array[i][0] = Integer.parseInt(sc.next())-1;   // x[i]
            array[i][1] = Integer.parseInt(sc.next())-1;   // y[i]
            array[i][2] = i;
        }
        
        // ans[i]:
        // 二次元座標において、「自分より左下の点」「自分より右上の点」に
        // 自由に行き来できる。ans[i] = 自分から行ける点の数(自分含め)
        // ex. (2,2) -> (4,5) -> (1,3)という移動が可能。
        
        // how:
        // 自分より右上、自分より左下の人をUnion-Findで結ぶ。
        // 1. 「←方向」に点を舐め、自分と自分のhigher(y)な点を結ぶ。
        // 2. 「↑方向」に点を舐め、自分と自分のlower(x)な点を結ぶ。
        // (それでなぜかうまく行く。)
        
        // a: xを昇順にソートした点
        int[][] a = new int[n][3];
        for (int i = 0; i < n; i++) {
            a[i][0] = array[i][0];
            a[i][1] = array[i][1];
            a[i][2] = array[i][2];
        }
        Arrays.sort(a, (ax, bx) -> Integer.compare(ax[0], bx[0]));
        
        // b: yを昇順にソートした点
        int[][] b = new int[n][3];
        for (int i = 0; i < n; i++) {
            b[i][0] = array[i][0];
            b[i][1] = array[i][1];
            b[i][2] = array[i][2];
        }
        Arrays.sort(b, (ax, bx) -> Integer.compare(ax[1], bx[1]));
        
        UnionFind uf = new UnionFind(n);
        
        // ←方向に舐める
        TreeMap<Integer, Integer> map = new TreeMap<Integer, Integer>();
        for (int i = n-1; i >= 0; i--) {
            int nowy = a[i][1];
            int idx = a[i][2];
            
            if (map.higherKey(nowy) != null) {
                int key = map.higherKey(nowy);
                int val = map.get(key);
                uf.unite(idx, val);
                // System.out.println(i + " " + idx + " " + val);
            }
            map.put(nowy, idx);
        }
        // System.out.println(map.toString());
        
        // ↑方向に舐める
        map = new TreeMap<Integer, Integer>();
        for (int i = 0; i < n; i++) {
            int nowx = b[i][0];
            int idx = b[i][2];
            
            if (map.lowerKey(nowx) != null) {
                int key = map.lowerKey(nowx);
                int val = map.get(key);
                uf.unite(idx, val);
                // System.out.println(i + " " + idx + " " + val);
            }
            map.put(nowx, idx);
        }
        // System.out.println(map.toString());
        
        // ans: 自分の属するグループの要素数
        PrintWriter out = new PrintWriter(System.out);
        for (int i = 0; i < n; i++) {
            int res = uf.size[uf.root(i)];
            out.println(res);
        }    
        out.flush();
    }
    
    // static class FastScanner {
    //     private BufferedReader reader = null;
    //     private StringTokenizer tokenizer = null;
        
    //     public FastScanner(InputStream in) {
    //         reader = new BufferedReader(new InputStreamReader(in));
    //         tokenizer = null;
    //     }
        
    //     public String next() {
    //         if (tokenizer == null || !tokenizer.hasMoreTokens()) {
    //             try {
    //                 tokenizer = new StringTokenizer(reader.readLine());
    //             } catch (IOException e) {
    //                 throw new RuntimeException(e);
    //             }
    //         }
    //         return tokenizer.nextToken();
    //     }
        
    //     public String nextLine() {
    //         if (tokenizer == null || !tokenizer.hasMoreTokens()) {
    //             try {
    //                 return reader.readLine();
    //             } catch (IOException e) {
    //                 throw new RuntimeException(e);
    //             }
    //         }
        
    //         return tokenizer.nextToken("\n");
    //     }
        
    //     public long nextLong() {
    //         return Long.parseLong(next());
    //     }
        
    //     public int nextInt() {
    //         return Integer.parseInt(next());
    //     }
        
    //     public double nextDouble() {
    //          return Double.parseDouble(next());
    //     }
        
    //     public int[] nextIntArray(int n) {
    //         int[] a = new int[n];
    //         for (int i = 0; i < n; i++)
    //             a[i] = nextInt();
    //         return a;
    //     }
        
    //     public long[] nextLongArray(int n) {
    //         long[] a = new long[n];
    //         for (int i = 0; i < n; i++)
    //             a[i] = nextLong();
    //         return a;
    //     } 
    // }
}

class UnionFind {
    int[] par;  // 自身の親
    int[] size; // ※(自身の属するグループの要素数はsize[uf.root(i)]。)
                // (※[i]全てに対して↑を更新するのは時間がかかるので)
    int connectedComponent;

    UnionFind(int n) {
        par = new int[n];
        for (int i = 0; i < n; i++) {
            par[i] = i;
        }
        
        size = new int[n];
        Arrays.fill(size, 1);
        connectedComponent = n;
    }

    int root(int x) {
        if (par[x] == x) return x;
        return par[x] = root(par[x]);
        // 1-2-4の場合、4の親=2を4の根=1に繋ぎ変えた上で親を返す
        // ↑根まで辿る深さ(計算量)を減らす為
        // return a = b;とは、aにbを代入し、aを返すという意味
    }
    
    // 点x, yを連結させる=同じグループにする
    void unite(int x, int y) {
        int rx = root(x);
        int ry = root(y);
        if (rx != ry) {
            par[ry] = rx;
            
            int resize = size[rx] + size[ry];
            size[rx] = resize;
            size[ry] = resize;
            connectedComponent--;
        }
    }
    
    // 同グループか否か
    boolean same(int x, int y) {
        int rx = root(x);
        int ry = root(y);
        return rx == ry;
    }
}

</source>
<source file="../hum_codes_raw/s373167882.java" startline="1" endline="196" pcid="12550">
import java.util.*;
// import java.io.*;
import java.io.PrintWriter;

public class Main {
    public static void main(String[] args) throws Exception {
        // Your code here!
        Scanner sc = new Scanner(System.in);
        // FastScanner sc = new FastScanner(System.in);
        int n = sc.nextInt();
        int[][] array = new int[n][3];
        for (int i = 0; i < n; i++) {
            array[i][0] = Integer.parseInt(sc.next())-1;   // x[i]
            array[i][1] = Integer.parseInt(sc.next())-1;   // y[i]
            array[i][2] = i;
        }
        
        // ans[i]:
        // 二次元座標において、「自分より左下の点」「自分より右上の点」に
        // 自由に行き来できる。ans[i] = 自分から行ける点の数(自分含め)
        // ex. (2,2) -> (4,5) -> (1,3)という移動が可能。
        
        // how:
        // 自分より右上、自分より左下の人をUnion-Findで結ぶ。
        // 1. 「←方向」に点を舐め、自分と自分のhigher(y)な点を結ぶ。
        // 2. 「↑方向」に点を舐め、自分と自分のlower(x)な点を結ぶ。
        // (それでなぜかうまく行く。)
        
        // a: xを昇順にソートした点
        int[][] a = new int[n][3];
        for (int i = 0; i < n; i++) {
            a[i][0] = array[i][0];
            a[i][1] = array[i][1];
            a[i][2] = array[i][2];
        }
        Arrays.sort(a, (ax, bx) -> Integer.compare(ax[0], bx[0]));
        
        // b: yを昇順にソートした点
        int[][] b = new int[n][3];
        for (int i = 0; i < n; i++) {
            b[i][0] = array[i][0];
            b[i][1] = array[i][1];
            b[i][2] = array[i][2];
        }
        Arrays.sort(b, (ax, bx) -> Integer.compare(ax[1], bx[1]));
        
        UnionFind uf = new UnionFind(n);
        
        // ←方向に舐める
        TreeMap<Integer, Integer> map = new TreeMap<Integer, Integer>();
        for (int i = n-1; i >= 0; i--) {
            int nowy = a[i][1];
            int idx = a[i][2];
            
            if (map.higherKey(nowy) != null) {
                int key = map.higherKey(nowy);
                int val = map.get(key);
                uf.unite(idx, val);
                // System.out.println(i + " " + idx + " " + val);
            }
            map.put(nowy, idx);
        }
        // System.out.println(map.toString());
        
        // ↑方向に舐める
        map = new TreeMap<Integer, Integer>();
        for (int i = 0; i < n; i++) {
            int nowx = b[i][0];
            int idx = b[i][2];
            
            if (map.lowerKey(nowx) != null) {
                int key = map.lowerKey(nowx);
                int val = map.get(key);
                uf.unite(idx, val);
                // System.out.println(i + " " + idx + " " + val);
            }
            map.put(nowx, idx);
        }
        // System.out.println(map.toString());
        
        // ans: 自分の属するグループの要素数
        PrintWriter out = new PrintWriter(System.out);
        for (int i = 0; i < n; i++) {
            int res = uf.size[uf.root(i)];
            out.println(res);
        }    
        out.flush();
    }
    
    // static class FastScanner {
    //     private BufferedReader reader = null;
    //     private StringTokenizer tokenizer = null;
        
    //     public FastScanner(InputStream in) {
    //         reader = new BufferedReader(new InputStreamReader(in));
    //         tokenizer = null;
    //     }
        
    //     public String next() {
    //         if (tokenizer == null || !tokenizer.hasMoreTokens()) {
    //             try {
    //                 tokenizer = new StringTokenizer(reader.readLine());
    //             } catch (IOException e) {
    //                 throw new RuntimeException(e);
    //             }
    //         }
    //         return tokenizer.nextToken();
    //     }
        
    //     public String nextLine() {
    //         if (tokenizer == null || !tokenizer.hasMoreTokens()) {
    //             try {
    //                 return reader.readLine();
    //             } catch (IOException e) {
    //                 throw new RuntimeException(e);
    //             }
    //         }
        
    //         return tokenizer.nextToken("\n");
    //     }
        
    //     public long nextLong() {
    //         return Long.parseLong(next());
    //     }
        
    //     public int nextInt() {
    //         return Integer.parseInt(next());
    //     }
        
    //     public double nextDouble() {
    //          return Double.parseDouble(next());
    //     }
        
    //     public int[] nextIntArray(int n) {
    //         int[] a = new int[n];
    //         for (int i = 0; i < n; i++)
    //             a[i] = nextInt();
    //         return a;
    //     }
        
    //     public long[] nextLongArray(int n) {
    //         long[] a = new long[n];
    //         for (int i = 0; i < n; i++)
    //             a[i] = nextLong();
    //         return a;
    //     } 
    // }
}

class UnionFind {
    int[] par;  // 自身の親
    int[] size; // ※(自身の属するグループの要素数はsize[uf.root(i)]。)
                // (※[i]全てに対して↑を更新するのは時間がかかるので)
    int connectedComponent;

    UnionFind(int n) {
        par = new int[n];
        for (int i = 0; i < n; i++) {
            par[i] = i;
        }
        
        size = new int[n];
        Arrays.fill(size, 1);
        connectedComponent = n;
    }

    int root(int x) {
        if (par[x] == x) return x;
        return par[x] = root(par[x]);
        // 1-2-4の場合、4の親=2を4の根=1に繋ぎ変えた上で親を返す
        // ↑根まで辿る深さ(計算量)を減らす為
        // return a = b;とは、aにbを代入し、aを返すという意味
    }
    
    // 点x, yを連結させる=同じグループにする
    void unite(int x, int y) {
        int rx = root(x);
        int ry = root(y);
        if (rx != ry) {
            par[ry] = rx;
            
            int resize = size[rx] + size[ry];
            size[rx] = resize;
            size[ry] = resize;
            connectedComponent--;
        }
    }
    
    // 同グループか否か
    boolean same(int x, int y) {
        int rx = root(x);
        int ry = root(y);
        return rx == ry;
    }
}

</source>
</class>

<class classid="133" nclones="2" nlines="25" similarity="100">
<source file="../hum_codes_raw/s235438384.java" startline="1" endline="28" pcid="7948">
import java.util.*;
import java.util.stream.*;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int K = in.nextInt();
        long num = 0, d = 1;
        for(int i = 0; i < K; i++)  {
            num += d;
            if(calc(num + 2 * d) < calc(num + d)) {
                d *= 10L;
            }
            System.out.println(num);
        }
    }

    public static double calc(long num) {
        double n = (double) num;
        double sum = 0;
        while(num != 0L) {
            sum += num % 10;
            num /= 10;
        }
        return n / sum;
    }
}

</source>
<source file="../hum_codes_raw/s660376524.java" startline="1" endline="28" pcid="22171">
import java.util.*;
import java.util.stream.*;
 
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int K = in.nextInt();
        long num = 0, d = 1;
        for(int i = 0; i < K; i++)  {
            num += d;
            if(calc(num + 2 * d) < calc(num + d)) {
                d *= 10L;
            }
            System.out.println(num);
        }
    }
 
    public static double calc(long num) {
        double n = (double) num;
        double sum = 0;
        while(num != 0L) {
            sum += num % 10;
            num /= 10;
        }
        return n / sum;
    }
}

</source>
</class>

<class classid="134" nclones="2" nlines="11" similarity="100">
<source file="../hum_codes_raw/s239362552.java" startline="1" endline="15" pcid="8085">
import java.util.*;

public class Main{
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);

		while(true){
			int x = sc.nextInt();
			if(x == -1) break;

			System.out.println(Integer.toString(x,4));
		}
	}
}

</source>
<source file="../hum_codes_raw/s764964207.java" startline="1" endline="14" pcid="25689">
import java.util.*;

public class Main{
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);

		while(true){
			int x = sc.nextInt();
			if(x == -1) break;
			System.out.println(Integer.toString(x,4));
		}
	}
}

</source>
</class>

<class classid="135" nclones="2" nlines="17" similarity="100">
<source file="../hum_codes_raw/s241036746.java" startline="1" endline="21" pcid="8127">
import java.util.Scanner;
 class Main{
	int high,low,sa;
	
	public void solve(){
		Scanner sc =new Scanner(System.in);
		
		for(int i=0;i<7;i++){
			high = sc.nextInt();
			low = sc.nextInt();
			sa = high-low;
			System.out.println(sa);
		}
	}
	public static void main(String[] args){
		Main obj = new Main();
		obj.solve();
	}
 }
	

</source>
<source file="../hum_codes_raw/s746654939.java" startline="1" endline="21" pcid="25068">
import java.util.Scanner;
 
class Main{
        int high,low,sa;
     
    public void solve(){
        Scanner sc=new Scanner(System.in);
         
        for(int i=0;i<7;i++){
        high=sc.nextInt();
        low=sc.nextInt();
        sa=high-low;
        System.out.println(sa);
        }
    }
    public static void main(String[]args){
        Main obj=new Main();
        obj.solve();
    }
}

</source>
</class>

<class classid="136" nclones="2" nlines="86" similarity="100">
<source file="../hum_codes_raw/s247757307.java" startline="1" endline="96" pcid="8339">
import java.util.Scanner;
import java.util.PriorityQueue;
import java.util.Comparator;

public class Main {
	class Edge{
		int p, q;
		double cost;
		Edge(int p, int q, double cost){
			this.p = p; this.q = q;
			this.cost = cost;
		}
	}
	int[] par;
//	union-findの木の初期化
	void unionfindInit(int n){
		for(int i = 0;i < n;i++) {
			par[i] = i;
		}
	}
//	木の根を求める
	int unionfindRoot(int x) {
		if(par[x]==x) {
			return x;
		}
		else {
			return par[x] = unionfindRoot(par[x]);
		}
	}
//	xとyが同じ集合に属するか否か
	boolean unionfindSame(int x, int y) {
		return unionfindRoot(x) == unionfindRoot(y);
	}
	
//	xとyの属する集合を併合
	void unionfinUnite(int x, int y) {
		x = unionfindRoot(x);
		y = unionfindRoot(y);
		if (x == y) return;
		par[x]=y;
	}
	void run(){
		Scanner scan = new Scanner(System.in);
		int N = scan.nextInt();
		par = new int[N+1];
		int M = scan.nextInt();
		int coordinate[][] = new int[N+1][2];
		int p, q;
		double hen1, hen2;
		double[] hypotenuse = new double[M]; //パイル間の距離
		PriorityQueue<Edge> edge = new PriorityQueue<Edge>(new Comparator<Edge>() {
			@Override
			public int compare(Edge e1, Edge e2) {
				if(e2.cost > e1.cost) {
					return 1;
				}
				else if(e2.cost < e1.cost){
					return -1;
				}
				return 0;
			}
		});
		Edge tmp = new Edge(0,0,0);
//		釘の座標情報
		for(int i=1; i< N+1;i++) {
			coordinate[i][0] = scan.nextInt();;
			coordinate[i][1] = scan.nextInt();;
		}
//		フェンスの情報
		unionfindInit(N+1);
		for(int i=0; i < M; i++) {
			p = scan.nextInt();
			q = scan.nextInt();
			hen1 = Math.abs(coordinate[p][0] - coordinate[q][0]);
			hen2 = Math.abs(coordinate[p][1] - coordinate[q][1]);
			hypotenuse[i] = Math.sqrt(hen1*hen1+hen2*hen2);
			edge.offer(new Edge(p, q, hypotenuse[i]));
		}
//		System.out.println("mainasu: " + mainasu_sum);
		double sum=0;
		for(int i = 0; i < M; i++) {
			tmp = edge.poll();
			if(!unionfindSame(tmp.p, tmp.q)) unionfinUnite(tmp.p, tmp.q);
			else {
				sum += tmp.cost;
//				System.out.println("tmp: " + tmp.cost);
			}
		}
		System.out.println(sum);
	}
	public static void main(String[] args) {
		new Main().run();
	}
}


</source>
<source file="../hum_codes_raw/s643937992.java" startline="1" endline="96" pcid="21607">
import java.util.Scanner;
import java.util.PriorityQueue;
import java.util.Comparator;

public class Main {
	class Edge{
		int p, q;
		double cost;
		Edge(int p, int q, double cost){
			this.p = p; this.q = q;
			this.cost = cost;
		}
	}
	int[] par;
//	union-findの木の初期化
	void unionfindInit(int n){
		for(int i = 0;i < n;i++) {
			par[i] = i;
		}
	}
//	木の根を求める
	int unionfindRoot(int x) {
		if(par[x]==x) {
			return x;
		}
		else {
			return par[x] = unionfindRoot(par[x]);
		}
	}
//	xとyが同じ集合に属するか否か
	boolean unionfindSame(int x, int y) {
		return unionfindRoot(x) == unionfindRoot(y);
	}
	
//	xとyの属する集合を併合
	void unionfinUnite(int x, int y) {
		x = unionfindRoot(x);
		y = unionfindRoot(y);
		if (x == y) return;
		par[x]=y;
	}
	void run(){
		Scanner scan = new Scanner(System.in);
		int N = scan.nextInt();
		par = new int[N+1];
		int M = scan.nextInt();
		int coordinate[][] = new int[N+1][2];
		int p, q;
		double hen1, hen2;
		double[] hypotenuse = new double[M]; //パイル間の距離
		PriorityQueue<Edge> edge = new PriorityQueue<Edge>(new Comparator<Edge>() {
			@Override
			public int compare(Edge e1, Edge e2) {
				if(e2.cost > e1.cost) {
					return 1;
				}
				else if(e2.cost < e1.cost){
					return -1;
				}
				return 0;
			}
		});
		Edge tmp = new Edge(0,0,0);
//		釘の座標情報
		for(int i=1; i< N+1;i++) {
			coordinate[i][0] = scan.nextInt();;
			coordinate[i][1] = scan.nextInt();;
		}
//		フェンスの情報
		unionfindInit(N+1);
		for(int i=0; i < M; i++) {
			p = scan.nextInt();
			q = scan.nextInt();
			hen1 = Math.abs(coordinate[p][0] - coordinate[q][0]);
			hen2 = Math.abs(coordinate[p][1] - coordinate[q][1]);
			hypotenuse[i] = Math.sqrt(hen1*hen1+hen2*hen2);
			edge.offer(new Edge(p, q, hypotenuse[i]));
		}
//		System.out.println("mainasu: " + mainasu_sum);
		double sum=0;
		for(int i = 0; i < M; i++) {
			tmp = edge.poll();
			if(!unionfindSame(tmp.p, tmp.q)) unionfinUnite(tmp.p, tmp.q);
			else {
				sum += tmp.cost;
//				System.out.println("tmp: " + tmp.cost);
			}
		}
		System.out.println(sum);
	}
	public static void main(String[] args) {
		new Main().run();
	}
}


</source>
</class>

<class classid="137" nclones="2" nlines="154" similarity="100">
<source file="../hum_codes_raw/s249685457.java" startline="1" endline="157" pcid="8404">
import java.io.InputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.BitSet;
import java.util.Collections;
import java.util.Comparator;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;
import java.math.BigInteger;

public class Main{

static PrintWriter out;
static InputReader ir;

static void solve(){
 ArrayList<Integer> buf=new ArrayList<>();
 boolean[] prime=sieveOfEratosthenes(100350);
 int n,p;
 for(;;){
  ArrayList<Integer> al=new ArrayList<>();
  n=ir.nextInt();
  p=ir.nextInt();
  if(n<0&&p<0) return;
  for(int i=n+1;i<=n+350;i++){
   if(prime[i]) al.add(i);
  }
  for(int i=0;i<al.size();i++){
   for(int j=i;j<al.size();j++){
    int sum=al.get(i)+al.get(j);
    buf.add(sum);
   }
  }
  Collections.sort(buf);
  out.println(buf.get(p-1));
  buf.clear();
 }
}

public static boolean[] sieveOfEratosthenes(int a){
 boolean[] ret=new boolean[a+1];
 Arrays.fill(ret,true);
 ret[0]=ret[1]=false;
 for(int i=2;i<=Math.sqrt(a);i++){
  if(!ret[i]) continue;
  for(int j=i+i;j<=a;j+=i) ret[j]=false;
 }
 return ret;
}

public static void main(String[] args) throws Exception{
 ir=new InputReader(System.in);
 out=new PrintWriter(System.out);
 solve();
 out.flush();
}

static class InputReader {
 private InputStream in;
 private byte[] buffer=new byte[1024];
 private int curbuf;
 private int lenbuf;

 public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}
 
 public boolean hasNextByte() {
  if(curbuf>=lenbuf){
   curbuf= 0;
   try{
    lenbuf=in.read(buffer);
   }catch(IOException e) {
    throw new InputMismatchException();
   }
   if(lenbuf<=0) return false;
  }
  return true;
 }

 private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}
 
 private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}
 
 private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}
 
 public boolean hasNext(){skip(); return hasNextByte();}
 
 public String next(){
  if(!hasNext()) throw new NoSuchElementException();
  StringBuilder sb=new StringBuilder();
  int b=readByte();
  while(!isSpaceChar(b)){
   sb.appendCodePoint(b);
   b=readByte();
  }
  return sb.toString();
 }
 
 public int nextInt() {
  if(!hasNext()) throw new NoSuchElementException();
  int c=readByte();
  while (isSpaceChar(c)) c=readByte();
  boolean minus=false;
  if (c=='-') {
   minus=true;
   c=readByte();
  }
  int res=0;
  do{
   if(c<'0'||c>'9') throw new InputMismatchException();
   res=res*10+c-'0';
   c=readByte();
  }while(!isSpaceChar(c));
  return (minus)?-res:res;
 }
 
 public long nextLong() {
  if(!hasNext()) throw new NoSuchElementException();
  int c=readByte();
  while (isSpaceChar(c)) c=readByte();
  boolean minus=false;
  if (c=='-') {
   minus=true;
   c=readByte();
  }
  long res = 0;
  do{
   if(c<'0'||c>'9') throw new InputMismatchException();
   res=res*10+c-'0';
   c=readByte();
  }while(!isSpaceChar(c));
  return (minus)?-res:res;
 }

 public double nextDouble(){return Double.parseDouble(next());}

 public int[] nextIntArray(int n){
  int[] a=new int[n];
  for(int i=0;i<n;i++) a[i]=nextInt();
  return a;
 }

 public long[] nextLongArray(int n){
  long[] a=new long[n];
  for(int i=0;i<n;i++) a[i]=nextLong();
  return a;
 }

 public char[][] nextCharMap(int n,int m){
  char[][] map=new char[n][m];
  for(int i=0;i<n;i++) map[i]=next().toCharArray();
  return map;
 }
}
}

</source>
<source file="../hum_codes_raw/s804874321.java" startline="1" endline="157" pcid="27036">
import java.io.InputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.BitSet;
import java.util.Collections;
import java.util.Comparator;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;
import java.math.BigInteger;

public class Main{

static PrintWriter out;
static InputReader ir;

static void solve(){
 ArrayList<Integer> buf=new ArrayList<>();
 boolean[] prime=sieveOfEratosthenes(100350);
 int n,p;
 for(;;){
  ArrayList<Integer> al=new ArrayList<>();
  n=ir.nextInt();
  p=ir.nextInt();
  if(n<0&&p<0) return;
  for(int i=n+1;i<=n+350;i++){
   if(prime[i]) al.add(i);
  }
  for(int i=0;i<al.size();i++){
   for(int j=i;j<al.size();j++){
    int sum=al.get(i)+al.get(j);
    buf.add(sum);
   }
  }
  Collections.sort(buf);
  out.println(buf.get(p-1));
  buf.clear();
 }
}

public static boolean[] sieveOfEratosthenes(int a){
 boolean[] ret=new boolean[a+1];
 Arrays.fill(ret,true);
 ret[0]=ret[1]=false;
 for(int i=2;i<=Math.sqrt(a);i++){
  if(!ret[i]) continue;
  for(int j=i+i;j<=a;j+=i) ret[j]=false;
 }
 return ret;
}

public static void main(String[] args) throws Exception{
 ir=new InputReader(System.in);
 out=new PrintWriter(System.out);
 solve();
 out.flush();
}

static class InputReader {
 private InputStream in;
 private byte[] buffer=new byte[1024];
 private int curbuf;
 private int lenbuf;

 public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}
 
 public boolean hasNextByte() {
  if(curbuf>=lenbuf){
   curbuf= 0;
   try{
    lenbuf=in.read(buffer);
   }catch(IOException e) {
    throw new InputMismatchException();
   }
   if(lenbuf<=0) return false;
  }
  return true;
 }

 private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}
 
 private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}
 
 private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}
 
 public boolean hasNext(){skip(); return hasNextByte();}
 
 public String next(){
  if(!hasNext()) throw new NoSuchElementException();
  StringBuilder sb=new StringBuilder();
  int b=readByte();
  while(!isSpaceChar(b)){
   sb.appendCodePoint(b);
   b=readByte();
  }
  return sb.toString();
 }
 
 public int nextInt() {
  if(!hasNext()) throw new NoSuchElementException();
  int c=readByte();
  while (isSpaceChar(c)) c=readByte();
  boolean minus=false;
  if (c=='-') {
   minus=true;
   c=readByte();
  }
  int res=0;
  do{
   if(c<'0'||c>'9') throw new InputMismatchException();
   res=res*10+c-'0';
   c=readByte();
  }while(!isSpaceChar(c));
  return (minus)?-res:res;
 }
 
 public long nextLong() {
  if(!hasNext()) throw new NoSuchElementException();
  int c=readByte();
  while (isSpaceChar(c)) c=readByte();
  boolean minus=false;
  if (c=='-') {
   minus=true;
   c=readByte();
  }
  long res = 0;
  do{
   if(c<'0'||c>'9') throw new InputMismatchException();
   res=res*10+c-'0';
   c=readByte();
  }while(!isSpaceChar(c));
  return (minus)?-res:res;
 }

 public double nextDouble(){return Double.parseDouble(next());}

 public int[] nextIntArray(int n){
  int[] a=new int[n];
  for(int i=0;i<n;i++) a[i]=nextInt();
  return a;
 }

 public long[] nextLongArray(int n){
  long[] a=new long[n];
  for(int i=0;i<n;i++) a[i]=nextLong();
  return a;
 }

 public char[][] nextCharMap(int n,int m){
  char[][] map=new char[n][m];
  for(int i=0;i<n;i++) map[i]=next().toCharArray();
  return map;
 }
}
}

</source>
</class>

<class classid="138" nclones="2" nlines="118" similarity="100">
<source file="../hum_codes_raw/s250783456.java" startline="1" endline="153" pcid="8447">
import java.util.*;

public class Main {
    static long INF = 1001001001001001018L;
    
    public static void main(String[] args) throws Exception {
        // Your code here!
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        
        while (t--> 0) {
            long n = sc.nextLong();
            long a = sc.nextLong();
            long b = sc.nextLong();
            long c = sc.nextLong();
            long d = sc.nextLong();
            
            long start = n;
            long goal = 1;
            
            // to: 隣接リスト(有向)
            
            // dist: startからの最短距離
            // 配列ではなくmapで持つ。
            // <- 状態数が10^18もあるから。
            // <- (また、間引きできるので全状態を構える必要がないから。)
            Map<Long, Long> dist = new HashMap<Long, Long>();
            dist.put(start, 0L);
            
            // ダイクストラ法: BFSで距離を配る。
            // (キューの先頭の点はそう来る他最短経路がないので最短距離が確定する)
            PriorityQueue<Point> que = new PriorityQueue<>();
            que.add(new Point(start, 0));
            while (!que.isEmpty()) {
                Point cur = que.poll();
                long p = cur.name;
                long dis = cur.dist;
                
                // System.out.println(p + " " + dis);
                
                // distより大きいdisを持つ点からは配らせない
                if (dis > dist.getOrDefault(p, INF)) continue;
                
                if (p <= 1) continue;
                
                long q;
                long PtoQ;
                
                // -1のパターン
                q = 1;
                PtoQ = dis + (p-1) * d;
                // if (PtoQ < dist.getOrDefault(q, INF)) {
                if (dis / d + (p-1) < dist.getOrDefault(q, INF) / d) {
                    dist.put(q, PtoQ);
                    que.add(new Point(q, PtoQ));
                }
                
                // /2のパターン
                if (p % 2 == 0) {
                    q = p / 2;
                    PtoQ = dis + a;
                    if (PtoQ < dist.getOrDefault(q, INF)) {
                        dist.put(q, PtoQ);
                        que.add(new Point(q, PtoQ));
                    }
                } else {
                    q = p / 2;
                    PtoQ = dis + d * (p % 2) + a;
                    if (PtoQ < dist.getOrDefault(q, INF)) {
                        dist.put(q, PtoQ);
                        que.add(new Point(q, PtoQ));
                    }
                    
                    q = (p+1) / 2;
                    PtoQ = dis + d * (2 - (p % 2)) + a;
                    if (PtoQ < dist.getOrDefault(q, INF)) {
                        dist.put(q, PtoQ);
                        que.add(new Point(q, PtoQ));
                    }
                }
                
                // /3のパターン
                if (p % 3 == 0) {
                    q = p / 3;
                    PtoQ = dis + b;
                    if (PtoQ < dist.getOrDefault(q, INF)) {
                        dist.put(q, PtoQ);
                        que.add(new Point(q, PtoQ));
                    }
                } else {
                    q = p / 3;
                    PtoQ = dis + d * (p % 3) + b;
                    if (PtoQ < dist.getOrDefault(q, INF)) {
                        dist.put(q, PtoQ);
                        que.add(new Point(q, PtoQ));
                    }
                    
                    q = (p+2) / 3;
                    PtoQ = dis + d * (3 - (p % 3)) + b;
                    if (PtoQ < dist.getOrDefault(q, INF)) {
                        dist.put(q, PtoQ);
                        que.add(new Point(q, PtoQ));
                    }
                }
                
                // /5のパターン
                if (p % 5 == 0) {
                    q = p / 5;
                    PtoQ = dis + c;
                    if (PtoQ < dist.getOrDefault(q, INF)) {
                        dist.put(q, PtoQ);
                        que.add(new Point(q, PtoQ));
                    }
                } else {
                    q = p / 5;
                    PtoQ = dis + d * (p % 5) + c;
                    if (PtoQ < dist.getOrDefault(q, INF)) {
                        dist.put(q, PtoQ);
                        que.add(new Point(q, PtoQ));
                    }
                    
                    q = (p+4) / 5;
                    PtoQ = dis + d * (5 - (p % 5)) + c;
                    if (PtoQ < dist.getOrDefault(q, INF)) {
                        dist.put(q, PtoQ);
                        que.add(new Point(q, PtoQ));
                    }
                }
            }
            System.out.println(dist.get(goal) + d);
        }
    }
}
    
class Point implements Comparable<Point> {
    long name;
    long dist;
     
    Point(long name, long dist) {
        this.name = name;
        this.dist = dist;
    }
    
    @Override
    public int compareTo(Point o) {
        //重みの小さい順
        if (this.dist < o.dist) {
            return -1;
        } 
        return 1;
    }
}

</source>
<source file="../hum_codes_raw/s809415687.java" startline="1" endline="174" pcid="27193">
import java.util.*;

public class Main {
    static long INF = 1001001001001001018L;
    
    public static void main(String[] args) throws Exception {
        // Your code here!
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        
        // ans: 点nから点0に行くまでの最小コスト (N <= 10^18)
        // 可能な操作: 点p -> 点q (移動コスト)
        // 1. n -> n/2 (a) (ただし n%2 = 0)
        // 2. n -> n/3 (b) (ただし n%3 = 0)
        // 3. n -> n/5 (c) (ただし n%5 = 0)
        // 4. n -> n-1 (d)
        // 5. n -> n+1 (d)
        
        while (t--> 0) {
            long n = sc.nextLong();
            long a = sc.nextLong();
            long b = sc.nextLong();
            long c = sc.nextLong();
            long d = sc.nextLong();
            
            long start = n;
            long goal = 1;
            
            // to: 隣接リスト(有向)
            
            // dist: startからの最短距離
            // ！配列ではなくmapで持つ。
            // <- 状態数が10^18もあるから。
            // <- (また、間引きできるので全状態を構える必要がないから。)
            Map<Long, Long> dist = new HashMap<Long, Long>();
            dist.put(start, 0L);
            
            // ダイクストラ法: BFSで距離を配る。
            // (キューの先頭の点はそう来る他最短経路がないので最短距離が確定する)
            PriorityQueue<Point> que = new PriorityQueue<>();
            que.add(new Point(start, 0));
            while (!que.isEmpty()) {
                Point cur = que.poll();
                long p = cur.name;
                long dis = cur.dist;
                
                // distより大きいdisを持つ点からは配らせない
                if (dis > dist.getOrDefault(p, INF)) continue;
                
                if (p <= 1) continue;
                
                // // 確定したpとdis
                // System.out.println(p + " " + dis);
                
                // 子に「自分の距離 + p→qの距離」を配る
                long q;
                long PtoQ;
                
                // 遷移パターン: ex. 11 -> q (移動コスト)
                // (中間点はキューに入れない)
                // 1. 1まで-1ずつ移動
                // -> 11->1                     ((p-1)*d)
                // 2. 2の倍数(上下)に移動し、/2の点へ移動
                // -> 11(->10)->5, 11(->12)->6  (2の倍数までの距離*d + a)
                // 3. 3の倍数(上下)に移動し、/3の点へ移動
                // -> 11(->9)->3, 11(->12)->4   (3の倍数までの距離*d + b)
                // 4. 5の倍数(上下)に移動し、/5の点へ移動
                // -> 11(->10)->2, 11(->15)->3  (5の倍数までの距離*d + c)
                
                // -1のパターン
                q = 1;
                PtoQ = dis + (p-1) * d;
                // if (PtoQ < dist.getOrDefault(q, INF)) {
                if (dis / d + (p-1) < dist.getOrDefault(q, INF) / d) {  // オーバーフロー対策
                    dist.put(q, PtoQ);
                    que.add(new Point(q, PtoQ));
                }
                
                // /2のパターン
                if (p % 2 == 0) {
                    q = p / 2;
                    PtoQ = dis + a;
                    if (PtoQ < dist.getOrDefault(q, INF)) {
                        dist.put(q, PtoQ);
                        que.add(new Point(q, PtoQ));
                    }
                } else {
                    q = p / 2;
                    PtoQ = dis + d * (p % 2) + a;
                    if (PtoQ < dist.getOrDefault(q, INF)) {
                        dist.put(q, PtoQ);
                        que.add(new Point(q, PtoQ));
                    }
                    
                    q = (p+1) / 2;
                    PtoQ = dis + d * (2 - (p % 2)) + a;
                    if (PtoQ < dist.getOrDefault(q, INF)) {
                        dist.put(q, PtoQ);
                        que.add(new Point(q, PtoQ));
                    }
                }
                
                // /3のパターン
                if (p % 3 == 0) {
                    q = p / 3;
                    PtoQ = dis + b;
                    if (PtoQ < dist.getOrDefault(q, INF)) {
                        dist.put(q, PtoQ);
                        que.add(new Point(q, PtoQ));
                    }
                } else {
                    q = p / 3;
                    PtoQ = dis + d * (p % 3) + b;
                    if (PtoQ < dist.getOrDefault(q, INF)) {
                        dist.put(q, PtoQ);
                        que.add(new Point(q, PtoQ));
                    }
                    
                    q = (p+2) / 3;
                    PtoQ = dis + d * (3 - (p % 3)) + b;
                    if (PtoQ < dist.getOrDefault(q, INF)) {
                        dist.put(q, PtoQ);
                        que.add(new Point(q, PtoQ));
                    }
                }
                
                // /5のパターン
                if (p % 5 == 0) {
                    q = p / 5;
                    PtoQ = dis + c;
                    if (PtoQ < dist.getOrDefault(q, INF)) {
                        dist.put(q, PtoQ);
                        que.add(new Point(q, PtoQ));
                    }
                } else {
                    q = p / 5;
                    PtoQ = dis + d * (p % 5) + c;
                    if (PtoQ < dist.getOrDefault(q, INF)) {
                        dist.put(q, PtoQ);
                        que.add(new Point(q, PtoQ));
                    }
                    
                    q = (p+4) / 5;
                    PtoQ = dis + d * (5 - (p % 5)) + c;
                    if (PtoQ < dist.getOrDefault(q, INF)) {
                        dist.put(q, PtoQ);
                        que.add(new Point(q, PtoQ));
                    }
                }
            }
            System.out.println(dist.get(goal) + d);
        }
    }
}
    
class Point implements Comparable<Point> {
    long name;
    long dist;
     
    Point(long name, long dist) {
        this.name = name;
        this.dist = dist;
    }
    
    @Override
    public int compareTo(Point o) {
        //重みの小さい順
        if (this.dist < o.dist) {
            return -1;
        } 
        return 1;
    }
}

</source>
</class>

<class classid="139" nclones="2" nlines="86" similarity="100">
<source file="../hum_codes_raw/s250879105.java" startline="1" endline="99" pcid="8449">
import java.util.Scanner;

public class Main {
	final int N = 4;
	final int N2 = 16;
	final int LIMIT = 45;

	class Puzzle {
		int[] board = new int[N2];
		int space, md;
		Puzzle() {}
		Puzzle(Puzzle p) {
			space = p.space;
			md = p.md;
			for (int i = 0; i < N2; i++)
				board[i] = p.board[i];
		}
		int getAllMD() {
			int sum = 0;
			for (int i = 0; i < N2; i++) {
				if (board[i] == N2) continue;
				sum += mdt[i][board[i] - 1];
			}
			return sum;
		}
		void swap(int next, int cur) {
			int tmp = this.board[cur];
			this.board[cur] = this.board[next];
			this.board[next] = tmp;
		}
	}

	int limit = 0;
	int[] path = new int[LIMIT];
	int[][] mdt = new int[N2][N2];
	Puzzle state = null;
	char[] dir = {'r', 'u', 'l', 'd'};
	int[] dx = { 0, -1, 0, 1 };
	int[] dy = { 1, 0, -1, 0 };

	void run() {
		Scanner scan = new Scanner(System.in);
		
		for (int i = 0; i < N2; i++)
			for (int j = 0; j < N2; j++)
				mdt[i][j] = Math.abs(i / N - j / N) + Math.abs(i % N - j % N);

		Puzzle p = new Puzzle();
		
		for (int i = 0; i < N2; i++) {
			p.board[i] = scan.nextInt();
			if (p.board[i] == 0) {
				p.board[i] = N2;
				p.space = i;
			}
		}
		iterative_deepening(p);
	}
	boolean dfs(int depth, int prev) {
		if (state.md == 0) return true;
		if (depth + state.md > limit) return false;

		int sx = state.space / N;
		int sy = state.space % N;
		for (int i = 0; i < 4; i++) {
			int tx = sx + dx[i];
			int ty = sy + dy[i];
			if (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;
			if (Math.max(prev, i) - Math.min(prev, i) == 2) continue;
			Puzzle p = new Puzzle(state);
			state.md -= mdt[tx * N + ty][state.board[tx * N + ty] - 1];
			state.md += mdt[sx * N + sy][state.board[tx * N + ty] - 1];
			state.swap(tx * N + ty, sx * N + sy);
			state.space = tx * N + ty;
			if (dfs(depth + 1, i)) {
				path[depth] = i;
				return true;
			}
			state = p;
		}
		return false;
	}
	void iterative_deepening(Puzzle p) {
		p.md = p.getAllMD();
		
		for (limit = p.md; limit <= LIMIT; limit++) {
			state = new Puzzle(p);
			if (dfs(0, -100)) {
				System.out.println(limit);
				return;
			}
		}
	}
	public static void main(String[] args) {
		new Main().run();
	}
}


</source>
<source file="../hum_codes_raw/s563038916.java" startline="1" endline="100" pcid="18952">
import java.util.Scanner;

public class Main {
	final int N = 4;
	final int N2 = 16;
	final int LIMIT = 45;

	class Puzzle {
		int[] board = new int[N2];
		int space, md;
		Puzzle() {}
		Puzzle(Puzzle p) {
			space = p.space;
			md = p.md;
			for (int i = 0; i < N2; i++)
				board[i] = p.board[i];
		}
		int getAllMD() {
			int sum = 0;
			for (int i = 0; i < N2; i++) {
				if (board[i] == N2) continue;
				sum += mdt[i][board[i] - 1];
			}
			return sum;
		}
		void swap(int next, int cur) {
			int tmp = this.board[cur];
			this.board[cur] = this.board[next];
			this.board[next] = tmp;
		}
	}

	int limit = 0;
	int[] path = new int[LIMIT];
	int[][] mdt = new int[N2][N2];
	Puzzle state = null;
	char[] dir = {'r', 'u', 'l', 'd'};
	int[] dx = { 0, -1, 0, 1 };
	int[] dy = { 1, 0, -1, 0 };

	void run() {
		Scanner scan = new Scanner(System.in);
		
		for (int i = 0; i < N2; i++)
			for (int j = 0; j < N2; j++)
				mdt[i][j] = Math.abs(i / N - j / N) + Math.abs(i % N - j % N);

		Puzzle p = new Puzzle();
		
		for (int i = 0; i < N2; i++) {
			p.board[i] = scan.nextInt();
			if (p.board[i] == 0) {
				p.board[i] = N2;
				p.space = i;
			}
		}
		iterative_deepening(p);
	}
	boolean dfs(int depth, int prev) {
		if (state.md == 0) return true;
		if (depth + state.md > limit) return false;

		int sx = state.space / N;
		int sy = state.space % N;
		for (int i = 0; i < 4; i++) {
			int tx = sx + dx[i];
			int ty = sy + dy[i];
			if (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;
			if (Math.max(prev, i) - Math.min(prev, i) == 2) continue;
			Puzzle p = new Puzzle(state);
			state.md -= mdt[tx * N + ty][state.board[tx * N + ty] - 1];
			state.md += mdt[sx * N + sy][state.board[tx * N + ty] - 1];
			state.swap(tx * N + ty, sx * N + sy);
			state.space = tx * N + ty;
			if (dfs(depth + 1, i)) {
				path[depth] = i;
				return true;
			}
			state = p;
		}
		return false;
	}
	void iterative_deepening(Puzzle p) {
		p.md = p.getAllMD();
		
		for (limit = p.md; limit <= LIMIT; limit++) {
			state = new Puzzle(p);
			if (dfs(0, -100)) {
				System.out.println(limit);
				return;
			}
		}
	}
	public static void main(String[] args) {
		new Main().run();
	}
}



</source>
</class>

<class classid="140" nclones="2" nlines="16" similarity="100">
<source file="../hum_codes_raw/s251188564.java" startline="1" endline="21" pcid="8457">
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		int n = sc.nextInt();
		long cnt = 0;
		for(int i=0;i<n;i++){
			sc.next();
			char c = sc.next().charAt(0);
			if(c=='(') cnt += sc.nextInt();
			else cnt -= sc.nextInt();
			if(cnt==0) System.out.println("Yes");
			else System.out.println("No");
		}
	}

}

</source>
<source file="../hum_codes_raw/s459257377.java" startline="1" endline="21" pcid="15409">
import java.util.*;
 
public class Main {
 
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
         
        int n = sc.nextInt();
        long cnt = 0;
        for(int i=0;i<n;i++){
            sc.next();
            char c = sc.next().charAt(0);
            if(c=='(') cnt += sc.nextInt();
            else cnt -= sc.nextInt();
            if(cnt==0) System.out.println("Yes");
            else System.out.println("No");
        }
    }
 
}

</source>
</class>

<class classid="141" nclones="2" nlines="103" similarity="100">
<source file="../hum_codes_raw/s253685459.java" startline="1" endline="129" pcid="8533">
import java.io.*;
import java.util.*;
 
public class Main {
 
	BufferedReader br;
	PrintWriter out;
	StringTokenizer st;
	boolean eof;
	
	List<Integer>[] g;
	int[] b;
	int k;
	
	int dfs(int v, int p) {
		int depth = 0;
		for (int u : g[v]) {
			if (u == p) {
				continue;
			}
			depth = Math.max(depth, dfs(u, v) + 1);
		}
		
		if (depth == k - 1) {
			b[v] = 0;
			return -1;
		}
		return depth;
	}
 
	void solve() throws IOException {
		int n = nextInt();
		k = nextInt();
		int[] a = new int[n];
		
		for (int i = 0; i < n; i++) {
			a[i] = nextInt() - 1;
		}
		
		b = a.clone();
		b[0] = 0;
		
		g = new List[n];
		for (int i = 0; i < n; i++) {
			g[i] = new ArrayList<>();
		}
		
		for (int i = 1; i < n; i++) {
			g[b[i]].add(i);
		}
		
		dfs(0, -1);
		
		int ret = 0;
		for (int i = 0; i < n; i++) {
			if (a[i] != b[i]) {
				ret++;
			}
		}
		
		out.println(ret);
	}
 
	Main() throws IOException {
		br = new BufferedReader(new InputStreamReader(System.in));
		out = new PrintWriter(System.out);
		
		Thread t = new Thread(null, new Runnable() {
 
			@Override
			public void run() {
				try {
					solve();
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
			
		}, "lul", 1 << 26);
		
		t.start();
		try {
			t.join();
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		out.close();
	}
 
	public static void main(String[] args) throws IOException {
		new Main();
	}
 
	String nextToken() {
		while (st == null || !st.hasMoreTokens()) {
			try {
				st = new StringTokenizer(br.readLine());
			} catch (Exception e) {
				eof = true;
				return null;
			}
		}
		return st.nextToken();
	}
 
	String nextString() {
		try {
			return br.readLine();
		} catch (IOException e) {
			eof = true;
			return null;
		}
	}
 
	int nextInt() throws IOException {
		return Integer.parseInt(nextToken());
	}
 
	long nextLong() throws IOException {
		return Long.parseLong(nextToken());
	}
 
	double nextDouble() throws IOException {
		return Double.parseDouble(nextToken());
	}
}

</source>
<source file="../hum_codes_raw/s532315066.java" startline="1" endline="129" pcid="17922">
import java.io.*;
import java.util.*;

public class Main {

	BufferedReader br;
	PrintWriter out;
	StringTokenizer st;
	boolean eof;
	
	List<Integer>[] g;
	int[] b;
	int k;
	
	int dfs(int v, int p) {
		int depth = 0;
		for (int u : g[v]) {
			if (u == p) {
				continue;
			}
			depth = Math.max(depth, dfs(u, v) + 1);
		}
		
		if (depth == k - 1) {
			b[v] = 0;
			return -1;
		}
		return depth;
	}

	void solve() throws IOException {
		int n = nextInt();
		k = nextInt();
		int[] a = new int[n];
		
		for (int i = 0; i < n; i++) {
			a[i] = nextInt() - 1;
		}
		
		b = a.clone();
		b[0] = 0;
		
		g = new List[n];
		for (int i = 0; i < n; i++) {
			g[i] = new ArrayList<>();
		}
		
		for (int i = 1; i < n; i++) {
			g[b[i]].add(i);
		}
		
		dfs(0, -1);
		
		int ret = 0;
		for (int i = 0; i < n; i++) {
			if (a[i] != b[i]) {
				ret++;
			}
		}
		
		out.println(ret);
	}

	Main() throws IOException {
		br = new BufferedReader(new InputStreamReader(System.in));
		out = new PrintWriter(System.out);
		
		Thread t = new Thread(null, new Runnable() {

			@Override
			public void run() {
				try {
					solve();
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
			
		}, "lul", 1 << 26);
		
		t.start();
		try {
			t.join();
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		out.close();
	}

	public static void main(String[] args) throws IOException {
		new Main();
	}

	String nextToken() {
		while (st == null || !st.hasMoreTokens()) {
			try {
				st = new StringTokenizer(br.readLine());
			} catch (Exception e) {
				eof = true;
				return null;
			}
		}
		return st.nextToken();
	}

	String nextString() {
		try {
			return br.readLine();
		} catch (IOException e) {
			eof = true;
			return null;
		}
	}

	int nextInt() throws IOException {
		return Integer.parseInt(nextToken());
	}

	long nextLong() throws IOException {
		return Long.parseLong(nextToken());
	}

	double nextDouble() throws IOException {
		return Double.parseDouble(nextToken());
	}
}

</source>
</class>

<class classid="142" nclones="2" nlines="163" similarity="100">
<source file="../hum_codes_raw/s254255566.java" startline="1" endline="203" pcid="8554">
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.util.List;

public class Main{
	static StringBuilder out = new StringBuilder();
	static final String OK = "OK";
	static final String NG = "NG";
	static final String Possible = "Possible";
	static final String Impossible = "Impossible";
	static FastReader in = new FastReader();
	static final int HEADS = 1;
	static final int TAILS = 0;

	// static final int INF = Integer.MAX_VALUE - 300000000;

	public static void main(String[] args) {
		while (upsideDown())
			;
	}

	private static boolean upsideDown() {
		int h = in.nextInt();
		int w = in.nextInt();
		if (h == 0 && w == 0) return false;

		int[][] senbei = in.nextIntArray2D(h, w);

		System.out.println(solve(senbei));
		return true;
	}

	private static int solve(int[][] senbei) {
		int row = senbei.length;
		int line = senbei[0].length;
		int ex = (int) Math.pow(2, row);

		int[] score = new int[ex];

		for (int i = 0; i < line; i++) {
			for (int j = 0; j < ex; j++) {
				int tempScore = 0;
				int[] filter = makeFilter(row, j);
				for (int k = 0; k < row; k++) {
					tempScore += (senbei[k][i] + filter[k]) % 2;
					// System.out.print((senbei[i][k] +
					// filter[base + k]) % 2);
				}
				// System.out.print("  ");
				score[j] += Math.max(tempScore, row - tempScore);
			}
			// System.out.println();
		}

		int maxScore = 0;
		for (int i = 0; i < ex; i++) {
			maxScore = Math.max(maxScore, score[i]);
			// System.err.println(score[i]);
		}
		return maxScore;
	}

	private static int[] makeFilter(int row, int i) {
		int[] filter = new int[row];
		int temp = i;
		for (int j = 0; j < row; j++) {
			filter[j] = temp % 2;
			temp /= 2;
		}
		return filter;
	}

	static void printExit(Object msg) {
		System.out.println(msg);
		System.exit(0);
	}
}

class FastReader{
	private InputStream in = System.in;
	private byte[] buf = new byte[1024];
	private int charNum;
	private int charLen;
	private StringBuilder sb = new StringBuilder();

	public int read() {
		if (charLen == -1) throw new InputMismatchException();
		if (charNum >= charLen) {
			charNum = 0;
			try {
				charLen = in.read(buf);
			} catch (IOException e) {
				throw new InputMismatchException();
			}
			if (charLen <= 0) return -1;
		}
		return buf[charNum++];
	}

	public String next() {
		int c = read();
		while (isWhitespace(c)) {
			c = read();
		}
		sb.setLength(0);
		do {
			sb.appendCodePoint(c);
			c = read();
		} while (!isWhitespace(c));
		return sb.toString();
	}

	public char[] nextCharArray() {
		return next().toCharArray();
	}

	public char[][] nextCharArray2d(int lines) {
		char[] first = nextCharArray();
		char[][] array = new char[lines][first.length];
		array[0] = first;
		for (int i = 1; i < lines; i++)
			array[i] = nextCharArray();
		return array;
	}

	public char[][] nextCharArray2d(int lines, int rows) {
		char[][] array = new char[lines][rows];
		for (int i = 0; i < lines; i++)
			array[i] = nextCharArray();
		return array;
	}

	public int nextInt() {
		return (int) nextLong();
	}

	public int[] nextIntArray(int n) {
		int[] array = new int[n];
		for (int i = 0; i < n; i++)
			array[i] = nextInt();
		return array;
	}

	public List<Integer> nextIntList(int n) {
		Integer[] array = new Integer[n];
		for (int i = 0; i < n; i++)
			array[i] = nextInt();
		return Arrays.asList(array);
	}

	public int[][] nextIntArray2D(int n, int m) {
		int[][] array = new int[n][m];
		for (int i = 0; i < n; i++)
			array[i] = nextIntArray(m);
		return array;
	}

	public List<int[]> nextIntsList(int n, int m) {
		List<int[]> list = new ArrayList<int[]>(n);
		for (int i = 0; i < n; i++)
			list.add(nextIntArray(m));
		return list;
	}

	public long nextLong() {
		int c = read();
		while (isWhitespace(c)) {
			c = read();
		}
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		long res = 0;
		do {
			if (c < '0' || c > '9') throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isWhitespace(c));
		return res * sgn;
	}

	public double nextDouble() {
		return Double.parseDouble(next());
	}

	public double[] nextDoubleArray(int n) {
		double[] array = new double[n];
		for (int i = 0; i < n; i++)
			array[i] = nextDouble();
		return array;
	}

	public boolean isWhitespace(int c) {
		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
	}
}

</source>
<source file="../hum_codes_raw/s647109273.java" startline="1" endline="198" pcid="21720">
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.util.List;

public class Main{
	static StringBuilder out = new StringBuilder();
	static final String OK = "OK";
	static final String NG = "NG";
	static final String Possible = "Possible";
	static final String Impossible = "Impossible";
	static FastReader in = new FastReader();
	static final int HEADS = 1;
	static final int TAILS = 0;

	// static final int INF = Integer.MAX_VALUE - 300000000;

	public static void main(String[] args) {
		while (upsideDown())
			;
	}

	private static boolean upsideDown() {
		int h = in.nextInt();
		int w = in.nextInt();
		if (h == 0 && w == 0) return false;

		int[][] senbei = in.nextIntArray2D(h, w);

		System.out.println(solve(senbei));
		return true;
	}

	private static int solve(int[][] senbei) {
		int row = senbei.length;
		int line = senbei[0].length;
		int ex = (int) Math.pow(2, row);

		int[] score = new int[ex];

		for (int i = 0; i < line; i++) {
			for (int j = 0; j < ex; j++) {
				int tempScore = 0;
				int[] filter = makeFilter(row, j);
				for (int k = 0; k < row; k++) {
					tempScore += (senbei[k][i] + filter[k]) % 2;
				}
				score[j] += Math.max(tempScore, row - tempScore);
			}
		}

		int maxScore = 0;
		for (int i = 0; i < ex; i++) {
			maxScore = Math.max(maxScore, score[i]);
		}
		return maxScore;
	}

	private static int[] makeFilter(int row, int i) {
		int[] filter = new int[row];
		int temp = i;
		for (int j = 0; j < row; j++) {
			filter[j] = temp % 2;
			temp /= 2;
		}
		return filter;
	}

	static void printExit(Object msg) {
		System.out.println(msg);
		System.exit(0);
	}
}

class FastReader{
	private InputStream in = System.in;
	private byte[] buf = new byte[1024];
	private int charNum;
	private int charLen;
	private StringBuilder sb = new StringBuilder();

	public int read() {
		if (charLen == -1) throw new InputMismatchException();
		if (charNum >= charLen) {
			charNum = 0;
			try {
				charLen = in.read(buf);
			} catch (IOException e) {
				throw new InputMismatchException();
			}
			if (charLen <= 0) return -1;
		}
		return buf[charNum++];
	}

	public String next() {
		int c = read();
		while (isWhitespace(c)) {
			c = read();
		}
		sb.setLength(0);
		do {
			sb.appendCodePoint(c);
			c = read();
		} while (!isWhitespace(c));
		return sb.toString();
	}

	public char[] nextCharArray() {
		return next().toCharArray();
	}

	public char[][] nextCharArray2d(int lines) {
		char[] first = nextCharArray();
		char[][] array = new char[lines][first.length];
		array[0] = first;
		for (int i = 1; i < lines; i++)
			array[i] = nextCharArray();
		return array;
	}

	public char[][] nextCharArray2d(int lines, int rows) {
		char[][] array = new char[lines][rows];
		for (int i = 0; i < lines; i++)
			array[i] = nextCharArray();
		return array;
	}

	public int nextInt() {
		return (int) nextLong();
	}

	public int[] nextIntArray(int n) {
		int[] array = new int[n];
		for (int i = 0; i < n; i++)
			array[i] = nextInt();
		return array;
	}

	public List<Integer> nextIntList(int n) {
		Integer[] array = new Integer[n];
		for (int i = 0; i < n; i++)
			array[i] = nextInt();
		return Arrays.asList(array);
	}

	public int[][] nextIntArray2D(int n, int m) {
		int[][] array = new int[n][m];
		for (int i = 0; i < n; i++)
			array[i] = nextIntArray(m);
		return array;
	}

	public List<int[]> nextIntsList(int n, int m) {
		List<int[]> list = new ArrayList<int[]>(n);
		for (int i = 0; i < n; i++)
			list.add(nextIntArray(m));
		return list;
	}

	public long nextLong() {
		int c = read();
		while (isWhitespace(c)) {
			c = read();
		}
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		long res = 0;
		do {
			if (c < '0' || c > '9') throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isWhitespace(c));
		return res * sgn;
	}

	public double nextDouble() {
		return Double.parseDouble(next());
	}

	public double[] nextDoubleArray(int n) {
		double[] array = new double[n];
		for (int i = 0; i < n; i++)
			array[i] = nextDouble();
		return array;
	}

	public boolean isWhitespace(int c) {
		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
	}
}

</source>
</class>

<class classid="143" nclones="2" nlines="39" similarity="100">
<source file="../hum_codes_raw/s260575609.java" startline="1" endline="50" pcid="8751">
import java.util.Scanner;

public class Main{
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		
		while(true){
			String str = sc.nextLine();
			String[] nums = str.split(" ");
			int[] a = new int[nums.length];
			int ace=0, score=0;
			boolean flag = true;
			
			if(nums[0].equals("0")) break;
			
			for(int i=0; i<nums.length; i++) {
				a[i] = Integer.parseInt(nums[i]);
				if(a[i] == 1) ace++;
				else if(a[i]>9 && a[i]<14) score+=10;
				else score+=a[i];
				
				if(score>21) {
					score=0;
					flag = false;
					break;
				}
			}
			
			if(score +1*ace > 21) {
				flag = false;
				score=0;
			}
			
			int tt = score;
					
			if(flag){
				for(int i=0; i<=ace; i++){
					if(tt + 1*i + 11*(ace-i) <= 21) {
						score = tt + 1*i + 11*(ace-i);
						break;
					} 	
				}
			}
		
			System.out.println(score);
		}	

	}
}

</source>
<source file="../hum_codes_raw/s982251484.java" startline="1" endline="50" pcid="33031">
import java.util.Scanner;

public class Main{
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		
		while(true){
			String str = sc.nextLine();
			String[] nums = str.split(" ");
			int[] a = new int[nums.length];
			int ace=0, score=0;
			boolean flag = true;
			
			if(nums[0].equals("0")) break;
			
			for(int i=0; i<nums.length; i++) {
				a[i] = Integer.parseInt(nums[i]);
				if(a[i] == 1) ace++;
				else if(a[i]>9 && a[i]<14) score+=10;
				else score+=a[i];
				
				if(score>21) {
					score=0;
					flag = false;
					break;
				}
			}
			
			if(score +1*ace > 21) {
				flag = false;
				score=0;
			}
			
			int tt = score;
					
			if(flag){
				for(int i=0; i<=ace; i++){
					if(tt + 1*i + 11*(ace-i) <= 21) {
						score = tt + 1*i + 11*(ace-i);
						break;
					} 	
				}
			}
		
			System.out.println(score);
		}	

	}
}

</source>
</class>

<class classid="144" nclones="2" nlines="111" similarity="100">
<source file="../hum_codes_raw/s263937011.java" startline="1" endline="153" pcid="8869">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;


public class Main {
	static final int N = 4;
	static final int N2 = 16;
	static final int LIMIT = 100;
	
	static final int[] dx = {0, -1, 0, 1};
	static final int[] dy = {1, 0, -1, 0};
	static final char[] dir = {'r','u','l','d'};
	static int[][] MDT = new int[N2][N2];
	
	static Puzzle state;
	static int limit;
	static int[] path = new int[LIMIT];
	/**
	 * @param args
	 * @throws IOException 
	 */
	public static void main(String[] args) throws IOException {
		// TODO Auto-generated method stub
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		for(int i = 0; i < N2 ;i++){
			for(int j = 0; j < N2 ; j++){
				MDT[i][j] = Math.abs(i/N - j/N) + Math.abs(i%N - j%N);
			}
		}
		
		Puzzle in = new Puzzle();
		
		
		for(int i = 0; i < N ; i++){
			String[] tmpArray = br.readLine().split(" ");
			
			for(int j = 0; j < N; j++){
				in.f[i*N + j] = Integer.parseInt(tmpArray[j]);
				if(in.f[i*N + j] == 0 ){
					in.f[i*N + j] = N2;
					in.space = i*N + j;
				}
			}
		}
//		
//		for(int i = 0; i < N2; i++){
//			System.out.print(in.f[i]+" ");
//		}
//		
		String ans = ID(in);
		//System.out.println(ans);
		System.out.println(ans.length());
	}
	
	static int getAllMD(Puzzle pz){
		int sum = 0;
		for(int i = 0; i < N2 ;i++){
			if(pz.f[i] == N2) continue;
			sum += MDT[i][pz.f[i] - 1];
			//System.out.println("index = "+(i + 1)+" MD += "+ MDT[i][pz.f[i] - 1]);
		}
		return sum;
	}
	
	static boolean isSolved() {
		for(int i = 0; i < N2; i++){
			if(state.f[i] != i + 1){
				return false;
			}
		}
		return true;
	}
	
	static boolean dfs(int depth, int prev){
		if(state.MD == 0){
			return true;
		}
		
		if( depth + state.MD > limit){
			return false;
		}
		
		int sx = state.space/N;
		int sy = state.space%N;
		Puzzle tmp;
		
		//System.out.println("sx "+sx+" sy "+sy);
		
		for(int r = 0; r < 4; r++){
			int tx = sx + dx[r];
			int ty = sy + dy[r];
			if(tx < 0 || ty < 0 || tx >= N || ty >= N){
				continue;
			}
			if(Math.max(prev, r) - Math.min(prev, r) == 2){
				continue;
			}
			//C++??¨?????£??????????????????????????¨????????????????????????
			tmp = new Puzzle();
			tmp.MD = state.MD;
			tmp.space = state.space;
			tmp.f = Arrays.copyOf(state.f, N2);
//			tmp = state;
			state.MD -= MDT[tx*N + ty][state.f[tx*N + ty] - 1];
			state.MD += MDT[sx*N + sy][state.f[tx*N + ty] - 1];
			int tmpf = state.f[tx*N + ty];
			state.f[tx*N + ty] = state.f[sx*N + sy];
			state.f[sx*N + sy] = tmpf;
			state.space = tx*N + ty;
			if(dfs(depth + 1, r)) {
				path[depth] = r;
				return true;
			}
//			state = tmp;
			state.MD = tmp.MD;
			state.space = tmp.space;
			state.f = Arrays.copyOf(tmp.f, N2);
		}
		
		return false;
			
	}
	
	static String ID(Puzzle in){
		in.MD = getAllMD(in);
		//System.out.println("MD = "+in.MD);
		
		for(limit = in.MD ; limit <= LIMIT ; limit++){
			state = in;
			if(dfs(0,-100)){
				String ans = "";
				for(int i = 0; i < limit ; i++){
					ans += dir[path[i]];
				}
				return ans;
			}
		}
		
		return "unsolvable";
	}

}

class Puzzle {
	int[] f = new int[Main.N2];
	int space;
	int MD;
}


</source>
<source file="../hum_codes_raw/s977055145.java" startline="1" endline="152" pcid="32875">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;


public class Main {
	static final int N = 4;
	static final int N2 = 16;
	static final int LIMIT = 100;
	
	static final int[] dx = {0, -1, 0, 1};
	static final int[] dy = {1, 0, -1, 0};
	static final char[] dir = {'r','u','l','d'};
	static int[][] MDT = new int[N2][N2];
	
	static Puzzle state;
	static int limit;
	static int[] path = new int[LIMIT];
	/**
	 * @param args
	 * @throws IOException 
	 */
	public static void main(String[] args) throws IOException {
		// TODO Auto-generated method stub
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		for(int i = 0; i < N2 ;i++){
			for(int j = 0; j < N2 ; j++){
				MDT[i][j] = Math.abs(i/N - j/N) + Math.abs(i%N - j%N);
			}
		}
		
		Puzzle in = new Puzzle();
		
		
		for(int i = 0; i < N ; i++){
			String[] tmpArray = br.readLine().split(" ");
			
			for(int j = 0; j < N; j++){
				in.f[i*N + j] = Integer.parseInt(tmpArray[j]);
				if(in.f[i*N + j] == 0 ){
					in.f[i*N + j] = N2;
					in.space = i*N + j;
				}
			}
		}
//		
//		for(int i = 0; i < N2; i++){
//			System.out.print(in.f[i]+" ");
//		}
//		
		String ans = ID(in);
		//System.out.println(ans);
		System.out.println(ans.length());
	}
	
	static int getAllMD(Puzzle pz){
		int sum = 0;
		for(int i = 0; i < N2 ;i++){
			if(pz.f[i] == N2) continue;
			sum += MDT[i][pz.f[i] - 1];
			//System.out.println("index = "+(i + 1)+" MD += "+ MDT[i][pz.f[i] - 1]);
		}
		return sum;
	}
	
	static boolean isSolved() {
		for(int i = 0; i < N2; i++){
			if(state.f[i] != i + 1){
				return false;
			}
		}
		return true;
	}
	
	static boolean dfs(int depth, int prev){
		if(state.MD == 0){
			return true;
		}
		
		if( depth + state.MD > limit){
			return false;
		}
		
		int sx = state.space/N;
		int sy = state.space%N;
		Puzzle tmp;
		
		//System.out.println("sx "+sx+" sy "+sy);
		
		for(int r = 0; r < 4; r++){
			int tx = sx + dx[r];
			int ty = sy + dy[r];
			if(tx < 0 || ty < 0 || tx >= N || ty >= N){
				continue;
			}
			if(Math.max(prev, r) - Math.min(prev, r) == 2){
				continue;
			}
			//C++??¨?????£??????????????????????????¨????????????????????????
			tmp = new Puzzle();
			tmp.MD = state.MD;
			tmp.space = state.space;
			tmp.f = Arrays.copyOf(state.f, N2);
//			tmp = state;
			state.MD -= MDT[tx*N + ty][state.f[tx*N + ty] - 1];
			state.MD += MDT[sx*N + sy][state.f[tx*N + ty] - 1];
			int tmpf = state.f[tx*N + ty];
			state.f[tx*N + ty] = state.f[sx*N + sy];
			state.f[sx*N + sy] = tmpf;
			state.space = tx*N + ty;
			if(dfs(depth + 1, r)) {
				path[depth] = r;
				return true;
			}
//			state = tmp;
			state.MD = tmp.MD;
			state.space = tmp.space;
			state.f = Arrays.copyOf(tmp.f, N2);
		}
		
		return false;
			
	}
	
	static String ID(Puzzle in){
		in.MD = getAllMD(in);
		//System.out.println("MD = "+in.MD);
		
		for(limit = in.MD ; limit <= LIMIT ; limit++){
			state = in;
			if(dfs(0,-100)){
				String ans = "";
				for(int i = 0; i < limit ; i++){
					ans += dir[path[i]];
				}
				return ans;
			}
		}
		
		return "unsolvable";
	}

}

class Puzzle {
	int[] f = new int[Main.N2];
	int space;
	int MD;
}

</source>
</class>

<class classid="145" nclones="2" nlines="42" similarity="100">
<source file="../hum_codes_raw/s264763781.java" startline="1" endline="52" pcid="8888">
import java.util.*;

public class Main {
	static int goal;

	static ArrayList<Integer> list = new ArrayList<>();
	static int[] cache;

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		goal = sc.nextInt();

		int c = sc.nextInt();
		for (int i = 0; i < c; i++) {
			list.add(sc.nextInt());
		}
		cache = new int[goal + 1];
		Collections.sort(list, Collections.reverseOrder());
		System.out.println(compute(goal));

	}

	public static int compute(int value) {
		if (cache[value] != 0) {
			return cache[value];
		}
		HashSet<Integer> set = new HashSet<Integer>();
		for (int e : list) {
			if (e == value) {
				cache[value] = 1;
				return 1;
			}
			if (e < value) {
				int coins = 1;
				coins += compute(value - e);
				set.add(coins);

			}
		}
		int result = Integer.MAX_VALUE;
		for (int e : set) {
			if (e < result) {
				result = e;
			}
		}
		cache[value] = result;
		return result;

	}

}

</source>
<source file="../hum_codes_raw/s370099020.java" startline="1" endline="55" pcid="12442">
import java.util.*;

public class Main {
	static int goal;

	static ArrayList<Integer> list = new ArrayList<>();
	static int[] cache;

	// static int[] result;

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		goal = sc.nextInt();
		// result = new int[goal + 1];
		// Arrays.fill(result, -1);
		int c = sc.nextInt();
		for (int i = 0; i < c; i++) {
			list.add(sc.nextInt());
		}
		cache = new int[goal + 1];
		Collections.sort(list, Collections.reverseOrder());
		System.out.println(compute(goal));

	}

	public static int compute(int value) {
		if (cache[value] != 0) {
			return cache[value];
		}
		HashSet<Integer> set = new HashSet<Integer>();
		for (int e : list) {
			if (e == value) {
				cache[value] = 1;
				return 1;
			}
			if (e < value) {
				int coins = 1;
				coins += compute(value - e);
				set.add(coins);

			}
		}
		int result = Integer.MAX_VALUE;
		for (int e : set) {
			if (e < result) {
				result = e;
			}
		}
		cache[value] = result;
		return result;

	}

}

</source>
</class>

<class classid="146" nclones="2" nlines="123" similarity="100">
<source file="../hum_codes_raw/s268173447.java" startline="1" endline="145" pcid="8973">
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.*;

public class Main {
    public static void main(String[] args) throws Exception {
        // Your code here!
        String[] inputPlane = new String[8];
        
        //入力を受付、計算しやすいようにintに変換
        List<int[][]> planeList = new ArrayList<int[][]>();
        Scanner scan = new Scanner(System.in);
        int row = 0;
        while(scan.hasNext()){
            String str = scan.next();
            if(str.length() != 0){
                if(row == 8){
                    row = 0;
                    int[][] plane = new int[8][8];
                    for(int i = 0;i < inputPlane.length;i++){
                        for(int j = 0;j < inputPlane[i].length();j++){
                            plane[i][j] = Integer.parseInt(inputPlane[i].substring(j,j+1));
                        }
                    }
                    planeList.add(plane);
                }
                inputPlane[row++] = str;
            }
        }
        
        //if(planeList.size()==0){return;}
        if(!scan.hasNext()){
            int[][] planes = new int[8][8];
            for(int i = 0;i < inputPlane.length;i++){
                for(int j = 0;j < inputPlane[i].length();j++){
                    planes[i][j] = Integer.parseInt(inputPlane[i].substring(j,j+1));
                }
            }
            planeList.add(planes);
        }
        //debug
        /*for(int i = 0;i < planeList.size();i++){
            int[][] debug = planeList.get(i);
            for(int k = 0;k < debug.length;k++){
                for(int j = 0;j < debug[k].length;j++){
                    System.out.print(debug[k][j]);
                }
                System.out.println();
            }
            System.out.println();
        }*/
        for(int i = 0;i < planeList.size();i++){
            //System.out.print(i);
            int[][] plane = planeList.get(i);
            if(blockJudgeD(plane))continue;
            if(blockJudgeG(plane))continue;
            if(blockJudgeE(plane))continue;
            if(blockJudgeF(plane))continue;
            if(blockJudgeA(plane))continue;
            if(blockJudgeB(plane))continue;
            if(blockJudgeC(plane))continue;
        }
    }
    //以下各判定
    static boolean blockJudgeA(int[][] plane){
        for(int i = 0;i < plane.length;i++){
            for(int j = 0;j < plane[i].length;j++){
                if(i <= 6 && j <= 6 && plane[i][j] == 1 && plane[i][j+1] == 1 && plane[i+1][j] == 1){
                    System.out.println("A");
                    return true;
                }
            }
        }
        return false;
    }
    static boolean blockJudgeB(int[][] plane){
        for(int i = 0;i < plane.length;i++){
            for(int j = 0;j < plane[i].length;j++){
                if(i <= 4 && plane[i][j] == 1 && plane[i+1][j] == 1 && plane[i+2][j] == 1){
                    System.out.println("B");
                    return true;
                }
            }
        }
        return false;
    }
    static boolean blockJudgeC(int[][] plane){
        for(int i = 0;i < plane.length;i++){
            for(int j = 0;j < plane[i].length;j++){
                if(j <= 4 && plane[i][j] == 1 && plane[i][j+1] == 1 && plane[i][j+2] == 1){
                    System.out.println("C");
                    return true;
                }
            }
        }
        return false;
    }
    static boolean blockJudgeD(int[][] plane){
        for(int i = 0;i < plane.length;i++){
            for(int j = 0;j < plane[i].length;j++){
                if(i <= 5 && j <= 7 && j - 1>= 0 && plane[i][j] == 1 && plane[i+1][j-1] == 1 && plane[i+2][j-1] == 1){
                    System.out.println("D");
                    return true;
                }
            }
        }
        return false;
    }
    static boolean blockJudgeE(int[][] plane){
        for(int i = 0;i < plane.length;i++){
            for(int j = 0;j < plane[i].length;j++){
                if(i <= 6 && j <= 5 && plane[i][j] == 1 && plane[i][j+1] == 1 && plane[i+1][j+2] == 1){
                    System.out.println("E");
                    return true;
                }
            }
        }
        return false;
    }
    
    static boolean blockJudgeF(int[][] plane){
        for(int i = 0;i < plane.length;i++){
            for(int j = 0;j < plane[i].length;j++){
                if(i <= 5 && j <= 6 && plane[i][j] == 1 && plane[i+1][j] == 1 && plane[i+2][j+1] == 1){
                    System.out.println("F");
                    return true;
                }
            }
        }
        return false;
    }
    static boolean blockJudgeG(int[][] plane){
        for(int i = 0;i < plane.length;i++){
            for(int j = 0;j < plane[i].length;j++){
                if(j - 1 >= 0 && i <= 6 && j <= 6 && plane[i][j] == 1 && plane[i][j+1] == 1 && plane[i+1][j-1] == 1){
                    System.out.println("G");
                    return true;
                }
            }
        }
        return false;
    }
}


</source>
<source file="../hum_codes_raw/s988324026.java" startline="1" endline="145" pcid="33241">
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.*;

public class Main {
    public static void main(String[] args) throws Exception {
        // Your code here!
        String[] inputPlane = new String[8];
        
        //入力を受付、計算しやすいようにintに変換
        List<int[][]> planeList = new ArrayList<int[][]>();
        Scanner scan = new Scanner(System.in);
        int row = 0;
        while(scan.hasNext()){
            String str = scan.next();
            if(str.length() != 0){
                if(row == 8){
                    row = 0;
                    int[][] plane = new int[8][8];
                    for(int i = 0;i < inputPlane.length;i++){
                        for(int j = 0;j < inputPlane[i].length();j++){
                            plane[i][j] = Integer.parseInt(inputPlane[i].substring(j,j+1));
                        }
                    }
                    planeList.add(plane);
                }
                inputPlane[row++] = str;
            }
        }
        
        //if(planeList.size()==0){return;}
        if(!scan.hasNext()){
            int[][] planes = new int[8][8];
            for(int i = 0;i < inputPlane.length;i++){
                for(int j = 0;j < inputPlane[i].length();j++){
                    planes[i][j] = Integer.parseInt(inputPlane[i].substring(j,j+1));
                }
            }
            planeList.add(planes);
        }
        //debug
        /*for(int i = 0;i < planeList.size();i++){
            int[][] debug = planeList.get(i);
            for(int k = 0;k < debug.length;k++){
                for(int j = 0;j < debug[k].length;j++){
                    System.out.print(debug[k][j]);
                }
                System.out.println();
            }
            System.out.println();
        }*/
        for(int i = 0;i < planeList.size();i++){
            //System.out.print(i);
            int[][] plane = planeList.get(i);
            if(blockJudgeD(plane))continue;
            if(blockJudgeG(plane))continue;
            if(blockJudgeE(plane))continue;
            if(blockJudgeF(plane))continue;
            if(blockJudgeA(plane))continue;
            if(blockJudgeB(plane))continue;
            if(blockJudgeC(plane))continue;
        }
    }
    //以下各判定
    static boolean blockJudgeA(int[][] plane){
        for(int i = 0;i < plane.length;i++){
            for(int j = 0;j < plane[i].length;j++){
                if(i <= 6 && j <= 6 && plane[i][j] == 1 && plane[i][j+1] == 1 && plane[i+1][j] == 1){
                    System.out.println("A");
                    return true;
                }
            }
        }
        return false;
    }
    static boolean blockJudgeB(int[][] plane){
        for(int i = 0;i < plane.length;i++){
            for(int j = 0;j < plane[i].length;j++){
                if(i <= 4 && plane[i][j] == 1 && plane[i+1][j] == 1 && plane[i+2][j] == 1){
                    System.out.println("B");
                    return true;
                }
            }
        }
        return false;
    }
    static boolean blockJudgeC(int[][] plane){
        for(int i = 0;i < plane.length;i++){
            for(int j = 0;j < plane[i].length;j++){
                if(j <= 4 && plane[i][j] == 1 && plane[i][j+1] == 1 && plane[i][j+2] == 1){
                    System.out.println("C");
                    return true;
                }
            }
        }
        return false;
    }
    static boolean blockJudgeD(int[][] plane){
        for(int i = 0;i < plane.length;i++){
            for(int j = 0;j < plane[i].length;j++){
                if(i <= 5 && j <= 7 && j - 1>= 0 && plane[i][j] == 1 && plane[i+1][j-1] == 1 && plane[i+2][j-1] == 1){
                    System.out.println("D");
                    return true;
                }
            }
        }
        return false;
    }
    static boolean blockJudgeE(int[][] plane){
        for(int i = 0;i < plane.length;i++){
            for(int j = 0;j < plane[i].length;j++){
                if(i <= 6 && j <= 5 && plane[i][j] == 1 && plane[i][j+1] == 1 && plane[i+1][j+2] == 1){
                    System.out.println("E");
                    return true;
                }
            }
        }
        return false;
    }
    
    static boolean blockJudgeF(int[][] plane){
        for(int i = 0;i < plane.length;i++){
            for(int j = 0;j < plane[i].length;j++){
                if(i <= 5 && j <= 6 && plane[i][j] == 1 && plane[i+1][j] == 1 && plane[i+2][j+1] == 1){
                    System.out.println("F");
                    return true;
                }
            }
        }
        return false;
    }
    static boolean blockJudgeG(int[][] plane){
        for(int i = 0;i < plane.length;i++){
            for(int j = 0;j < plane[i].length;j++){
                if(j - 1 >= 0 && i <= 6 && j <= 6 && plane[i][j] == 1 && plane[i][j+1] == 1 && plane[i+1][j-1] == 1){
                    System.out.println("G");
                    return true;
                }
            }
        }
        return false;
    }
}


</source>
</class>

<class classid="147" nclones="2" nlines="21" similarity="100">
<source file="../hum_codes_raw/s268738325.java" startline="1" endline="25" pcid="8999">
import java.awt.Point;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

class Main{
	public static void main(String[] args) {
		try(Scanner sc = new Scanner(System.in)) {
			int n = sc.nextInt();
			List<Point> points = new ArrayList<Point>();
			for(int i=0;i<n;i++) {
				points.add(new Point(sc.nextInt(), sc.nextInt()));
			}
			points.sort((p1, p2) -> {
				int result = p1.x - p2.x;
				if(result == 0)
					result = p1.y - p2.y;
				return result;
			});
			points.forEach(point -> System.out.println(point.x + " " + point.y));
		}
	}
}


</source>
<source file="../hum_codes_raw/s512387774.java" startline="1" endline="23" pcid="17193">
import java.awt.Point;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
class Main{
	public static void main(String[] args) {
		try(Scanner sc = new Scanner(System.in)) {
			int n = sc.nextInt();
			List<Point> points = new ArrayList<Point>();
			for(int i=0;i<n;i++) {
				points.add(new Point(sc.nextInt(), sc.nextInt()));
			}
			points.sort((p1, p2) -> {
				int result = p1.x - p2.x;
				if(result == 0)
					result = p1.y - p2.y;
				return result;
			});
			points.forEach(point -> System.out.println(point.x + " " + point.y));
		}
	}
}

</source>
</class>

<class classid="148" nclones="2" nlines="14" similarity="100">
<source file="../hum_codes_raw/s269532901.java" startline="1" endline="17" pcid="9022">
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int a = sc.nextInt();
        int b = sc.nextInt();

        if((a * b) % 2 == 0) {
            System.out.println("Even");
        } else {
            System.out.println("Odd");
        }
    }
}

</source>
<source file="../hum_codes_raw/s458628710.java" startline="1" endline="17" pcid="15382">
import java.util.Scanner;

public class Main{
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);

		int a=sc.nextInt();
		int b=sc.nextInt();

		if((a*b)%2==0) {
			System.out.println("Even");
		}else {
			System.out.println("Odd");
		}
	}
}

</source>
</class>

<class classid="149" nclones="3" nlines="24" similarity="100">
<source file="../hum_codes_raw/s270545487.java" startline="1" endline="27" pcid="9050">
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int n = sc.nextInt();
			if(n==0)break;
			int[] a = new int[n];
			for(int i=0;i<n;i++)a[i]=sc.nextInt();
			int s = 0;
			for(int j=n-1;j>=1;j--){
				for(int i=0;i<j;i++){
					if(a[i+1]<a[i]){
						int t = a[i];
						a[i]=a[i+1];
						a[i+1]=t;
						s++;
					}
				}
			}
			System.out.println(s);
		}
	}
}

</source>
<source file="../hum_codes_raw/s743508109.java" startline="1" endline="28" pcid="24978">
import java.util.Scanner;

//Bubble Sort
public class Main{

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int n = sc.nextInt();
			if(n==0)break;
			int[] a = new int[n];
			for(int i=0;i<n;i++)a[i]=sc.nextInt();
			int s = 0;
			for(int j=n-1;j>=1;j--){
				for(int i=0;i<j;i++){
					if(a[i+1]<a[i]){
						int t = a[i];
						a[i]=a[i+1];
						a[i+1]=t;
						s++;
					}
				}
			}
			System.out.println(s);
		}
	}
}

</source>
<source file="../hum_codes_raw/s588971163.java" startline="1" endline="28" pcid="19770">
import java.util.Scanner;

//Bubble Sort
public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int n = sc.nextInt();
			if(n==0)break;
			int[] a = new int[n];
			for(int i=0;i<n;i++)a[i]=sc.nextInt();
			int s = 0;
			for(int j=n-1;j>=1;j--){
				for(int i=0;i<j;i++){
					if(a[i+1]<a[i]){
						int t = a[i];
						a[i]=a[i+1];
						a[i+1]=t;
						s++;
					}
				}
			}
			System.out.println(s);
		}
	}
}

</source>
</class>

<class classid="150" nclones="2" nlines="247" similarity="100">
<source file="../hum_codes_raw/s271055260.java" startline="1" endline="296" pcid="9063">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            EWeightsOnVerticesAndEdges solver = new EWeightsOnVerticesAndEdges();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class EWeightsOnVerticesAndEdges {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            int m = in.readInt();
            int[] vertex = new int[n];
            in.populate(vertex);
            Edge[] edges = new Edge[m];
            for (int i = 0; i < m; i++) {
                edges[i] = new Edge();
                edges[i].a = in.readInt() - 1;
                edges[i].b = in.readInt() - 1;
                edges[i].w = in.readInt();
            }

            DSU dsu = new DSU(n);
            for (int i = 0; i < n; i++) {
                dsu.sum[i] = vertex[i];
            }

            Arrays.sort(edges, (a, b) -> Integer.compare(a.w, b.w));
            for (int i = 0; i < m; i++) {
                int r = i;
                while (r + 1 < m && edges[r + 1].w == edges[i].w) {
                    r++;
                }
                for (int j = i; j <= r; j++) {
                    Edge e = edges[j];
                    if (dsu.prev[dsu.find(e.a)] != null) {
                        dsu.prev[dsu.find(e.a)].next = e;
                        dsu.prev[dsu.find(e.a)] = null;
                    }
                    if (dsu.prev[dsu.find(e.b)] != null) {
                        dsu.prev[dsu.find(e.b)].next = e;
                        dsu.prev[dsu.find(e.b)] = null;
                    }
                    dsu.merge(e.a, e.b);
                    dsu.prev[dsu.find(e.b)] = e;
                }

                for (int j = i; j <= r; j++) {
                    Edge e = edges[j];
                    e.sum = dsu.sum[dsu.find(e.a)];
                }

                i = r;
            }

            for (int i = m - 1; i >= 0; i--) {
                Edge e = edges[i];
                if ((e.next == null || e.next.deleted) && e.sum < e.w) {
                    e.deleted = true;
                }
            }

            int ans = 0;
            for (Edge e : edges) {
                if (e.deleted) {
                    ans++;
                }
            }

            out.println(ans);
        }

    }

    static class Edge {
        int a;
        int b;
        int w;
        long sum;
        boolean deleted;
        Edge next;

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        public void populate(int[] data) {
            for (int i = 0; i < data.length; i++) {
                data[i] = readInt();
            }
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class DSU {
        protected int[] p;
        protected int[] rank;
        protected Edge[] prev;
        protected long[] sum;

        public DSU(int n) {
            p = new int[n];
            rank = new int[n];
            prev = new Edge[n];
            sum = new long[n];
            reset();
        }

        public final void reset() {
            for (int i = 0; i < p.length; i++) {
                p[i] = i;
                rank[i] = 0;
            }
        }

        public final int find(int a) {
            if (p[a] == p[p[a]]) {
                return p[a];
            }
            return p[a] = find(p[a]);
        }

        public final void merge(int a, int b) {
            a = find(a);
            b = find(b);
            if (a == b) {
                return;
            }
            if (rank[a] == rank[b]) {
                rank[a]++;
            }

            if (rank[a] < rank[b]) {
                int tmp = a;
                a = b;
                b = tmp;
            }

            p[b] = a;
            sum[a] += sum[b];
        }

    }
}


</source>
<source file="../hum_codes_raw/s323487421.java" startline="1" endline="296" pcid="10845">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            EWeightsOnVerticesAndEdges solver = new EWeightsOnVerticesAndEdges();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class EWeightsOnVerticesAndEdges {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            int m = in.readInt();
            int[] vertex = new int[n];
            in.populate(vertex);
            Edge[] edges = new Edge[m];
            for (int i = 0; i < m; i++) {
                edges[i] = new Edge();
                edges[i].a = in.readInt() - 1;
                edges[i].b = in.readInt() - 1;
                edges[i].w = in.readInt();
            }

            DSU dsu = new DSU(n);
            for (int i = 0; i < n; i++) {
                dsu.sum[i] = vertex[i];
            }

            Arrays.sort(edges, (a, b) -> Integer.compare(a.w, b.w));
            for (int i = 0; i < m; i++) {
                int r = i;
                while (r + 1 < m && edges[r + 1].w == edges[i].w) {
                    r++;
                }
                for (int j = i; j <= r; j++) {
                    Edge e = edges[j];
                    if (dsu.prev[dsu.find(e.a)] != null) {
                        dsu.prev[dsu.find(e.a)].next = e;
                        dsu.prev[dsu.find(e.a)] = null;
                    }
                    if (dsu.prev[dsu.find(e.b)] != null) {
                        dsu.prev[dsu.find(e.b)].next = e;
                        dsu.prev[dsu.find(e.b)] = null;
                    }
                    dsu.merge(e.a, e.b);
                    dsu.prev[dsu.find(e.b)] = e;
                }

                for (int j = i; j <= r; j++) {
                    Edge e = edges[j];
                    e.sum = dsu.sum[dsu.find(e.a)];
                }

                i = r;
            }

            for (int i = m - 1; i >= 0; i--) {
                Edge e = edges[i];
                if ((e.next == null || e.next.deleted) && e.sum < e.w) {
                    e.deleted = true;
                }
            }

            int ans = 0;
            for (Edge e : edges) {
                if (e.deleted) {
                    ans++;
                }
            }

            out.println(ans);
        }

    }

    static class Edge {
        int a;
        int b;
        int w;
        long sum;
        boolean deleted;
        Edge next;

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        public void populate(int[] data) {
            for (int i = 0; i < data.length; i++) {
                data[i] = readInt();
            }
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class DSU {
        protected int[] p;
        protected int[] rank;
        protected Edge[] prev;
        protected long[] sum;

        public DSU(int n) {
            p = new int[n];
            rank = new int[n];
            prev = new Edge[n];
            sum = new long[n];
            reset();
        }

        public final void reset() {
            for (int i = 0; i < p.length; i++) {
                p[i] = i;
                rank[i] = 0;
            }
        }

        public final int find(int a) {
            if (p[a] == p[p[a]]) {
                return p[a];
            }
            return p[a] = find(p[a]);
        }

        public final void merge(int a, int b) {
            a = find(a);
            b = find(b);
            if (a == b) {
                return;
            }
            if (rank[a] == rank[b]) {
                rank[a]++;
            }

            if (rank[a] < rank[b]) {
                int tmp = a;
                a = b;
                b = tmp;
            }

            p[b] = a;
            sum[a] += sum[b];
        }

    }
}


</source>
</class>

<class classid="151" nclones="2" nlines="39" similarity="100">
<source file="../hum_codes_raw/s272561156.java" startline="1" endline="44" pcid="9115">
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		try(Scanner sc = new Scanner(System.in)){
			while(sc.hasNext()) {
				int m=sc.nextInt();
				int n=sc.nextInt();
				if(m+n==0) break;
				int[] w=new int[n+1];
				int max=0;
				int sum=0;
				for(int i=0; i<n; i++) {
					w[i]=sc.nextInt();
					max=Math.max(w[i], max);
					sum+=w[i];
				}
				int mini=0;
				for(int i=max; i<=sum; i++) {
					int h=1;
					int[] book=new int[n+1];
					int end=0;
					for(int j=0; j<n; j++) {
						if(book[h]+w[j]>i) {
							h++;
							if(h>m) {
								end=1;
								break;
							}
						}
						book[h]+=w[j];
					}
					mini=i;
					if(end==0) break;
				}
				System.out.println(mini);

			}
		}
	}
}



</source>
<source file="../hum_codes_raw/s744183787.java" startline="1" endline="44" pcid="24997">
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		try(Scanner sc = new Scanner(System.in)){
			while(sc.hasNext()) {
				int m=sc.nextInt();
				int n=sc.nextInt();
				if(m+n==0) break;
				int[] w=new int[n+1];
				int max=0;
				int sum=0;
				for(int i=0; i<n; i++) {
					w[i]=sc.nextInt();
					max=Math.max(w[i], max);
					sum+=w[i];
				}
				int mini=0;
				for(int i=max; i<=sum; i++) {
					int h=1;
					int[] book=new int[n+1];
					int end=0;
					for(int j=0; j<n; j++) {
						if(book[h]+w[j]>i) {
							h++;
							if(h>m) {
								end=1;
								break;
							}
						}
						book[h]+=w[j];
					}
					mini=i;
					if(end==0) break;
				}
				System.out.println(mini);

			}
		}
	}
}



</source>
</class>

<class classid="152" nclones="2" nlines="75" similarity="100">
<source file="../hum_codes_raw/s273328080.java" startline="1" endline="92" pcid="9141">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.List;
import java.util.Scanner;
import java.util.Comparator;
import java.util.ArrayList;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        Scanner in = new Scanner(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskC solver = new TaskC();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskC {
        public void solve(int testNumber, Scanner in, PrintWriter out) {
            final int n = in.nextInt();
            List<TaskC.Point> pointA = new ArrayList<>();
            List<TaskC.Point> pointB = new ArrayList<>();
            Comparator<TaskC.Point> min = Comparator.comparing(TaskC.Point::getMin);
            Comparator<TaskC.Point> max = Comparator.comparing(TaskC.Point::getMax);

            for (int i = 0; i < n; i++) {
                pointA.add(new TaskC.Point(in.nextInt(), in.nextInt()));
            }
            for (int i = 0; i < n; i++) {
                pointB.add(new TaskC.Point(in.nextInt(), in.nextInt()));
            }

            pointA.sort(max);
            pointB.sort(min);
            int ans = 0;
            int index = pointA.size() - 1;
            while (index >= 0) {
                TaskC.Point ca = pointA.get(index);
                for (int i = 0; i < pointB.size(); i++) {
                    TaskC.Point cb = pointB.get(i);
                    if (ca.getX() < cb.getX() && ca.getY() < cb.getY()) {
                        pointA.remove(ca);
                        pointB.remove(cb);
                        ans++;
                        index--;
                        break;
                    } else if (i == pointB.size() - 1) {
                        index--;
                    }
                }
            }
            out.println(ans);
        }

        static class Point {
            private int x;
            private int y;

            public Point(int x, int y) {
                this.x = x;
                this.y = y;
            }

            public int getX() {
                return this.x;
            }

            public int getY() {
                return this.y;
            }

            public int getMax() {
                return Math.max(x, y);
            }

            public int getMin() {
                return Math.min(x, y);
            }

        }

    }
}


</source>
<source file="../hum_codes_raw/s668721837.java" startline="1" endline="91" pcid="22472">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.List;
import java.util.Scanner;
import java.util.Comparator;
import java.util.ArrayList;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        Scanner in = new Scanner(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskC solver = new TaskC();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskC {
        public void solve(int testNumber, Scanner in, PrintWriter out) {
            final int n = in.nextInt();
            List<TaskC.Point> pointA = new ArrayList<>();
            List<TaskC.Point> pointB = new ArrayList<>();
            Comparator<TaskC.Point> min = Comparator.comparing(TaskC.Point::getMin);
            Comparator<TaskC.Point> max = Comparator.comparing(TaskC.Point::getMax);

            for (int i = 0; i < n; i++) {
                pointA.add(new TaskC.Point(in.nextInt(), in.nextInt()));
            }
            for (int i = 0; i < n; i++) {
                pointB.add(new TaskC.Point(in.nextInt(), in.nextInt()));
            }

            pointA.sort(max);
            pointB.sort(min);
            int ans = 0;
            int index = pointA.size() - 1;
            while (index >= 0) {
                TaskC.Point ca = pointA.get(index);
                for (int i = 0; i < pointB.size(); i++) {
                    TaskC.Point cb = pointB.get(i);
                    if (ca.getX() < cb.getX() && ca.getY() < cb.getY()) {
                        pointA.remove(ca);
                        pointB.remove(cb);
                        ans++;
                        index--;
                        break;
                    } else if (i == pointB.size() - 1) {
                        index--;
                    }
                }
            }
            out.println(ans);
        }

        static class Point {
            private int x;
            private int y;

            public Point(int x, int y) {
                this.x = x;
                this.y = y;
            }

            public int getX() {
                return this.x;
            }

            public int getY() {
                return this.y;
            }

            public int getMax() {
                return Math.max(x, y);
            }

            public int getMin() {
                return Math.min(x, y);
            }

        }

    }
}

</source>
</class>

<class classid="153" nclones="2" nlines="324" similarity="100">
<source file="../hum_codes_raw/s274100373.java" startline="1" endline="408" pcid="9166">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            FPass solver = new FPass();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class FPass {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            Modular mod = new Modular(998244353);
            char[] s = in.readString().toCharArray();
            int n = s.length;

            int[][] dp = new int[n + 1][n + 1];
            dp[0][0] = 1;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j <= i; j++) {
                    int b = j;
                    int r = i - j;
                    int way = dp[i][j];
                    if (way == 0) {
                        continue;
                    }
                    if (s[i] == '0') {
                        //two blue
                        //this is blue
                        dp[i + 1][j + 1] = mod.plus(dp[i + 1][j + 1], way);
                        //this is red
                        if (r > 0) {
                            dp[i + 1][j + 2] = mod.plus(dp[i + 1][j + 2], way);
                        }
                    } else if (s[i] == '1') {
                        //one blue one red
                        //this is blue
                        dp[i + 1][j] = mod.plus(dp[i + 1][j], way);
                        //this is red
                        dp[i + 1][j + 1] = mod.plus(dp[i + 1][j + 1], way);
                    } else {
                        //two red
                        //this is blue
                        if (j > 0) {
                            dp[i + 1][j - 1] = mod.plus(dp[i + 1][j - 1], way);
                        }
                        //this is red
                        dp[i + 1][j] = mod.plus(dp[i + 1][j], way);
                    }
                }
            }

            int ans = 0;
            Combination comb = new Combination(n, new Power(mod));
            for (int i = 0; i <= n; i++) {
                int way = dp[n][i];
                way = mod.mul(way, comb.combination(n, i));
                ans = mod.plus(ans, way);
            }
            out.println(ans);
        }

    }

    static class Power implements InverseNumber {
        static IntExtGCDObject extGCD = new IntExtGCDObject();
        final Modular modular;

        public Modular getModular() {
            return modular;
        }

        public Power(Modular modular) {
            this.modular = modular;
        }

        public int inverse(int x) {
            int ans = inverseExtGCD(x);
//        if(modular.mul(ans, x) != 1){
//            throw new IllegalStateException();
//        }
            return ans;
        }

        public int inverseExtGCD(int x) {
            if (extGCD.extgcd(x, modular.getMod()) != 1) {
                throw new IllegalArgumentException();
            }
            return modular.valueOf(extGCD.getX());
        }

    }

    static class ExtGCD {
        public static int extGCD(int a, int b, int[] xy) {
            if (a >= b) {
                return extGCD0(a, b, xy);
            }
            int ans = extGCD0(b, a, xy);
            SequenceUtils.swap(xy, 0, 1);
            return ans;
        }

        private static int extGCD0(int a, int b, int[] xy) {
            if (b == 0) {
                xy[0] = 1;
                xy[1] = 0;
                return a;
            }
            int ans = extGCD0(b, a % b, xy);
            int x = xy[0];
            int y = xy[1];
            xy[0] = y;
            xy[1] = x - a / b * y;
            return ans;
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class Modular {
        int m;

        public int getMod() {
            return m;
        }

        public Modular(int m) {
            this.m = m;
        }

        public Modular(long m) {
            this.m = (int) m;
            if (this.m != m) {
                throw new IllegalArgumentException();
            }
        }

        public Modular(double m) {
            this.m = (int) m;
            if (this.m != m) {
                throw new IllegalArgumentException();
            }
        }

        public int valueOf(int x) {
            x %= m;
            if (x < 0) {
                x += m;
            }
            return x;
        }

        public int valueOf(long x) {
            x %= m;
            if (x < 0) {
                x += m;
            }
            return (int) x;
        }

        public int mul(int x, int y) {
            return valueOf((long) x * y);
        }

        public int plus(int x, int y) {
            return valueOf(x + y);
        }

        public String toString() {
            return "mod " + m;
        }

    }

    static class SequenceUtils {
        public static void swap(int[] data, int i, int j) {
            int tmp = data[i];
            data[i] = data[j];
            data[j] = tmp;
        }

    }

    static interface InverseNumber {
    }

    static interface IntCombination {
    }

    static class Combination implements IntCombination {
        final Factorial factorial;
        final Modular modular;

        public Combination(Factorial factorial) {
            this.factorial = factorial;
            this.modular = factorial.getMod();
        }

        public Combination(int limit, Power pow) {
            this(new Factorial(limit, pow));
        }

        public int combination(int m, int n) {
            if (n > m || n < 0) {
                return 0;
            }
            return modular.mul(modular.mul(factorial.fact(m), factorial.invFact(n)), factorial.invFact(m - n));
        }

    }

    static class Factorial {
        int[] fact;
        int[] inv;
        Modular mod;

        public Modular getMod() {
            return mod;
        }

        public Factorial(int[] fact, int[] inv, Power pow) {
            this.mod = pow.getModular();
            this.fact = fact;
            this.inv = inv;
            fact[0] = inv[0] = 1;
            int n = Math.min(fact.length, pow.getModular().getMod());
            for (int i = 1; i < n; i++) {
                fact[i] = i;
                fact[i] = mod.mul(fact[i], fact[i - 1]);
            }
            inv[n - 1] = pow.inverse(fact[n - 1]);
            for (int i = n - 2; i >= 1; i--) {
                inv[i] = mod.mul(inv[i + 1], i + 1);
            }
        }

        public Factorial(int limit, Power pow) {
            this(new int[limit + 1], new int[limit + 1], pow);
        }

        public int fact(int n) {
            return fact[n];
        }

        public int invFact(int n) {
            return inv[n];
        }

    }

    static class FastInput {
        private final InputStream is;
        private StringBuilder defaultStringBuf = new StringBuilder(1 << 13);
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public String readString(StringBuilder builder) {
            skipBlank();

            while (next > 32) {
                builder.append((char) next);
                next = read();
            }

            return builder.toString();
        }

        public String readString() {
            defaultStringBuf.setLength(0);
            return readString(defaultStringBuf);
        }

    }

    static class IntExtGCDObject {
        private int[] xy = new int[2];

        public int extgcd(int a, int b) {
            return ExtGCD.extGCD(a, b, xy);
        }

        public int getX() {
            return xy[0];
        }

    }
}


</source>
<source file="../hum_codes_raw/s765718955.java" startline="1" endline="408" pcid="25717">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            FPass solver = new FPass();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class FPass {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            Modular mod = new Modular(998244353);
            char[] s = in.readString().toCharArray();
            int n = s.length;

            int[][] dp = new int[n + 1][n + 1];
            dp[0][0] = 1;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j <= i; j++) {
                    int b = j;
                    int r = i - j;
                    int way = dp[i][j];
                    if (way == 0) {
                        continue;
                    }
                    if (s[i] == '0') {
                        //two blue
                        //this is blue
                        dp[i + 1][j + 1] = mod.plus(dp[i + 1][j + 1], way);
                        //this is red
                        if (r > 0) {
                            dp[i + 1][j + 2] = mod.plus(dp[i + 1][j + 2], way);
                        }
                    } else if (s[i] == '1') {
                        //one blue one red
                        //this is blue
                        dp[i + 1][j] = mod.plus(dp[i + 1][j], way);
                        //this is red
                        dp[i + 1][j + 1] = mod.plus(dp[i + 1][j + 1], way);
                    } else {
                        //two red
                        //this is blue
                        if (j > 0) {
                            dp[i + 1][j - 1] = mod.plus(dp[i + 1][j - 1], way);
                        }
                        //this is red
                        dp[i + 1][j] = mod.plus(dp[i + 1][j], way);
                    }
                }
            }

            int ans = 0;
            Combination comb = new Combination(n, new Power(mod));
            for (int i = 0; i <= n; i++) {
                int way = dp[n][i];
                way = mod.mul(way, comb.combination(n, i));
                ans = mod.plus(ans, way);
            }
            out.println(ans);
        }

    }

    static class Power implements InverseNumber {
        static IntExtGCDObject extGCD = new IntExtGCDObject();
        final Modular modular;

        public Modular getModular() {
            return modular;
        }

        public Power(Modular modular) {
            this.modular = modular;
        }

        public int inverse(int x) {
            int ans = inverseExtGCD(x);
//        if(modular.mul(ans, x) != 1){
//            throw new IllegalStateException();
//        }
            return ans;
        }

        public int inverseExtGCD(int x) {
            if (extGCD.extgcd(x, modular.getMod()) != 1) {
                throw new IllegalArgumentException();
            }
            return modular.valueOf(extGCD.getX());
        }

    }

    static class ExtGCD {
        public static int extGCD(int a, int b, int[] xy) {
            if (a >= b) {
                return extGCD0(a, b, xy);
            }
            int ans = extGCD0(b, a, xy);
            SequenceUtils.swap(xy, 0, 1);
            return ans;
        }

        private static int extGCD0(int a, int b, int[] xy) {
            if (b == 0) {
                xy[0] = 1;
                xy[1] = 0;
                return a;
            }
            int ans = extGCD0(b, a % b, xy);
            int x = xy[0];
            int y = xy[1];
            xy[0] = y;
            xy[1] = x - a / b * y;
            return ans;
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class Modular {
        int m;

        public int getMod() {
            return m;
        }

        public Modular(int m) {
            this.m = m;
        }

        public Modular(long m) {
            this.m = (int) m;
            if (this.m != m) {
                throw new IllegalArgumentException();
            }
        }

        public Modular(double m) {
            this.m = (int) m;
            if (this.m != m) {
                throw new IllegalArgumentException();
            }
        }

        public int valueOf(int x) {
            x %= m;
            if (x < 0) {
                x += m;
            }
            return x;
        }

        public int valueOf(long x) {
            x %= m;
            if (x < 0) {
                x += m;
            }
            return (int) x;
        }

        public int mul(int x, int y) {
            return valueOf((long) x * y);
        }

        public int plus(int x, int y) {
            return valueOf(x + y);
        }

        public String toString() {
            return "mod " + m;
        }

    }

    static class SequenceUtils {
        public static void swap(int[] data, int i, int j) {
            int tmp = data[i];
            data[i] = data[j];
            data[j] = tmp;
        }

    }

    static interface InverseNumber {
    }

    static interface IntCombination {
    }

    static class Combination implements IntCombination {
        final Factorial factorial;
        final Modular modular;

        public Combination(Factorial factorial) {
            this.factorial = factorial;
            this.modular = factorial.getMod();
        }

        public Combination(int limit, Power pow) {
            this(new Factorial(limit, pow));
        }

        public int combination(int m, int n) {
            if (n > m || n < 0) {
                return 0;
            }
            return modular.mul(modular.mul(factorial.fact(m), factorial.invFact(n)), factorial.invFact(m - n));
        }

    }

    static class Factorial {
        int[] fact;
        int[] inv;
        Modular mod;

        public Modular getMod() {
            return mod;
        }

        public Factorial(int[] fact, int[] inv, Power pow) {
            this.mod = pow.getModular();
            this.fact = fact;
            this.inv = inv;
            fact[0] = inv[0] = 1;
            int n = Math.min(fact.length, pow.getModular().getMod());
            for (int i = 1; i < n; i++) {
                fact[i] = i;
                fact[i] = mod.mul(fact[i], fact[i - 1]);
            }
            inv[n - 1] = pow.inverse(fact[n - 1]);
            for (int i = n - 2; i >= 1; i--) {
                inv[i] = mod.mul(inv[i + 1], i + 1);
            }
        }

        public Factorial(int limit, Power pow) {
            this(new int[limit + 1], new int[limit + 1], pow);
        }

        public int fact(int n) {
            return fact[n];
        }

        public int invFact(int n) {
            return inv[n];
        }

    }

    static class FastInput {
        private final InputStream is;
        private StringBuilder defaultStringBuf = new StringBuilder(1 << 13);
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public String readString(StringBuilder builder) {
            skipBlank();

            while (next > 32) {
                builder.append((char) next);
                next = read();
            }

            return builder.toString();
        }

        public String readString() {
            defaultStringBuf.setLength(0);
            return readString(defaultStringBuf);
        }

    }

    static class IntExtGCDObject {
        private int[] xy = new int[2];

        public int extgcd(int a, int b) {
            return ExtGCD.extGCD(a, b, xy);
        }

        public int getX() {
            return xy[0];
        }

    }
}


</source>
</class>

<class classid="154" nclones="2" nlines="10" similarity="100">
<source file="../hum_codes_raw/s274344490.java" startline="1" endline="14" pcid="9175">
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		int W = s.nextInt();
		int res = W*32;
		System.out.println(res);

		s.close();

	}
}

</source>
<source file="../hum_codes_raw/s933072200.java" startline="1" endline="14" pcid="31376">
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		int W = s.nextInt();
		int res = W*32;
		System.out.println(res);

		s.close();

	}
}

</source>
</class>

<class classid="155" nclones="2" nlines="34" similarity="100">
<source file="../hum_codes_raw/s275165787.java" startline="1" endline="40" pcid="9200">
import java.util.BitSet;
import java.util.Scanner;
 
public class Main {
 
    static Scanner sc = new Scanner(System.in);
 
    static BitSet primes() {
        int SIZE = 1 << 15;
        BitSet ret = new BitSet(SIZE);
        ret.set(2, SIZE);
        for (int i = 2; i < SIZE; ++i) {
            if (!ret.get(i)) continue;
            for (int j = i * i; j < SIZE; j += i) {
                ret.clear(j);
            }
        }
        return ret;
    }
 
    public static void main(String[] args) {
        BitSet psset = primes();
        int[] ps = new int[psset.cardinality()];
        int idx = 0;
        for (int i = 0; i < psset.size(); ++i) {
            if (psset.get(i)) ps[idx++] = i;
        }
        while (true) {
            int N = sc.nextInt();
            if (N == 0) break;
            int ans = 0;
            for (int i = 0; i < ps.length && ps[i] <= N / 2; ++i) {
                if (psset.get(N - ps[i])) ++ans;
            }
            System.out.println(ans);
        }
    }
 
}

</source>
<source file="../hum_codes_raw/s777160410.java" startline="1" endline="40" pcid="26091">
import java.util.BitSet;
import java.util.Scanner;

public class Main {

	static Scanner sc = new Scanner(System.in);

	static BitSet primes() {
		int SIZE = 1 << 15;
		BitSet ret = new BitSet(SIZE);
		ret.set(2, SIZE);
		for (int i = 2; i < SIZE; ++i) {
			if (!ret.get(i)) continue;
			for (int j = i * i; j < SIZE; j += i) {
				ret.clear(j);
			}
		}
		return ret;
	}

	public static void main(String[] args) {
		BitSet psset = primes();
		int[] ps = new int[psset.cardinality()];
		int idx = 0;
		for (int i = 0; i < psset.size(); ++i) {
			if (psset.get(i)) ps[idx++] = i;
		}
		while (true) {
			int N = sc.nextInt();
			if (N == 0) break;
			int ans = 0;
			for (int i = 0; i < ps.length && ps[i] <= N / 2; ++i) {
				if (psset.get(N - ps[i])) ++ans;
			}
			System.out.println(ans);
		}
	}

}

</source>
</class>

<class classid="156" nclones="2" nlines="105" similarity="100">
<source file="../hum_codes_raw/s275374216.java" startline="1" endline="127" pcid="9203">

import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Deque;
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

public class Main {
	static int N = 3;
	static int N2 = 9;

	public static void main(String[] args) {
		new Main().run();
	}

	private void run() {
		Scanner scanner = new Scanner(System.in);
		Puzzle puzzle = new Puzzle();
		for (int i = 0; i < N2; i++) {
			int v = scanner.nextInt();
			puzzle.map[i] = v;
			if (v == 0) {
				puzzle.space = i;
			}
		}
		System.out.println(slove(puzzle));
	}

	int[][] dxy = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };

	private int slove(Puzzle in) {
		Puzzle u = new Puzzle();
		Puzzle v = new Puzzle();
		Deque<Puzzle> deque = new ArrayDeque<Puzzle>();
		Set<Puzzle> set = new HashSet<Main.Puzzle>();
		set.add(in);
		deque.offer(in);
		while (!deque.isEmpty()) {
			u = deque.poll();
			if (isTrue(u)) {
				return u.count;
			}
			int y = u.space / N;
			int x = u.space % N;
			for (int[] a : dxy) {
				int dy = y + a[0];
				int dx = x + a[1];
				if (dy < 0 || dx < 0 || N <= dy || N <= dx)
					continue;
				v = u.clone();
				swap(v, u.space, dy * N + dx);
				v.space = dy * N + dx;
				if (!set.contains(v)) {
					set.add(v);
					v.count++;
					deque.offer(v);
				}
			}
		}
		return -1;
	}

	private boolean isTrue(Puzzle u) {
		for (int i = 0; i < N2 - 1; i++) {
			if (u.map[i] != i + 1) {
				return false;
			}
		}
		return true;
	}

	private void swap(Puzzle v, int space, int i) {
		int t = v.map[i];
		v.map[i] = v.map[space];
		v.map[space] = t;

	}
	class Puzzle implements Cloneable {
		int[] map = new int[N2];
		int space;
		int count = 0;

		@Override
		public Puzzle clone() {
			try {
				Puzzle clonePuzzle = (Puzzle) super.clone();
				clonePuzzle.map = Arrays.copyOf(map, N2);
				return clonePuzzle;
			} catch (CloneNotSupportedException e) {
				throw new InternalError();
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + getOuterType().hashCode();
			result = prime * result + Arrays.hashCode(map);
			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			Puzzle other = (Puzzle) obj;
			if (!getOuterType().equals(other.getOuterType()))
				return false;
			if (!Arrays.equals(map, other.map))
				return false;
			return true;
		}

		private Main getOuterType() {
			return Main.this;
		}

	}
}


</source>
<source file="../hum_codes_raw/s908069064.java" startline="1" endline="126" pcid="30554">

import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Deque;
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

public class Main {
	static int N = 3;
	static int N2 = 9;

	public static void main(String[] args) {
		new Main().run();
	}

	private void run() {
		Scanner scanner = new Scanner(System.in);
		Puzzle puzzle = new Puzzle();
		for (int i = 0; i < N2; i++) {
			int v = scanner.nextInt();
			puzzle.map[i] = v;
			if (v == 0) {
				puzzle.space = i;
			}
		}
		System.out.println(slove(puzzle));
	}

	int[][] dxy = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };

	private int slove(Puzzle in) {
		Puzzle u = new Puzzle();
		Puzzle v = new Puzzle();
		Deque<Puzzle> deque = new ArrayDeque<Puzzle>();
		Set<Puzzle> set = new HashSet<Main.Puzzle>();
		set.add(in);
		deque.offer(in);
		while (!deque.isEmpty()) {
			u = deque.poll();
			if (isTrue(u)) {
				return u.count;
			}
			int y = u.space / N;
			int x = u.space % N;
			for (int[] a : dxy) {
				int dy = y + a[0];
				int dx = x + a[1];
				if (dy < 0 || dx < 0 || N <= dy || N <= dx)
					continue;
				v = u.clone();
				swap(v, u.space, dy * N + dx);
				v.space = dy * N + dx;
				if (!set.contains(v)) {
					set.add(v);
					v.count++;
					deque.offer(v);
				}
			}
		}
		return -1;
	}

	private boolean isTrue(Puzzle u) {
		for (int i = 0; i < N2 - 1; i++) {
			if (u.map[i] != i + 1) {
				return false;
			}
		}
		return true;
	}

	private void swap(Puzzle v, int space, int i) {
		int t = v.map[i];
		v.map[i] = v.map[space];
		v.map[space] = t;

	}
	class Puzzle implements Cloneable {
		int[] map = new int[N2];
		int space;
		int count = 0;

		@Override
		public Puzzle clone() {
			try {
				Puzzle clonePuzzle = (Puzzle) super.clone();
				clonePuzzle.map = Arrays.copyOf(map, N2);
				return clonePuzzle;
			} catch (CloneNotSupportedException e) {
				throw new InternalError();
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + getOuterType().hashCode();
			result = prime * result + Arrays.hashCode(map);
			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			Puzzle other = (Puzzle) obj;
			if (!getOuterType().equals(other.getOuterType()))
				return false;
			if (!Arrays.equals(map, other.map))
				return false;
			return true;
		}

		private Main getOuterType() {
			return Main.this;
		}

	}
}

</source>
</class>

<class classid="157" nclones="2" nlines="24" similarity="100">
<source file="../hum_codes_raw/s275725695.java" startline="1" endline="25" pcid="9219">
import java.util.*;
import java.text.*;

class Main {
    public static void main(String[]args)throws Exception {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        for(int i = 1; i <= n; i++) {
            int x = i;
            if((x % 3) == 0) {
                System.out.print(" " + i);
            } else {
                while(x != 0) {
                    if((x % 10) == 3) {
                        System.out.print(" " + i);
                        x = 0;
                    }
                    x = x / 10;
                }
            }
        }
        System.out.println();
    }
}

</source>
<source file="../hum_codes_raw/s848354165.java" startline="1" endline="26" pcid="28498">
import java.util.*;
import java.text.*;

class Main {
    public static void main(String[]args)throws Exception {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        for(int i = 1; i <= n; i++) {
            int x = i;
            if((x % 3) == 0) {
                System.out.print(" " + i);
            } else {
                while(x != 0) {
                    if((x % 10) == 3) {
                        System.out.print(" " + i);
                        x = 0;
                    }
                    x = x / 10;
                }
            }
        }
        System.out.println();
    }
}


</source>
</class>

<class classid="158" nclones="2" nlines="51" similarity="100">
<source file="../hum_codes_raw/s276733936.java" startline="1" endline="59" pcid="9254">
import java.util.*;
public class Main{
    static Scanner kbd = new Scanner(System.in);
    public static void main(String[] args){
	int[] p = new int[10000];
	putN(p);
	while(kbd.hasNext()){
	    int n = kbd.nextInt();
	    if(n!=0){
		int i=0;
		int s=0;  //テゥツ?」テァツカツ堙」ツ?療」ツ?淌ァツエツ?ヲツ閉ーテ」ツ?ョテ・ツ陳?
		int l=0;  //テゥツ?」テァツカツ堙ァツエツ?ヲツ閉ーテ」ツ?ョテ」ツ??」ツ?。テヲツ慊?・ツーツ?
		int c = 0;  //ティツ。ツィテァツ渉セテ」ツ?ァテ」ツ?催」ツ?淌」ツδ妥」ツつソテ」ツδシテ」ツδウテヲツ閉ー
		while(p[i]!=0){
		    if(s < n) {
			s += p[i];
			i++;
		    }
		    else if(s>n){
			s -= p[l];
			l++;
		    }
		    else;

		    if(s==n) {
			c++;
			s += p[i];
			i++;
		    }
		}	 
		System.out.println(c);
	    }
	}
    }

    
    
    
    static void putN(int[] p){
	int i=0, k;
	for(k=2; k<10000; k++){
	    if(check(k)) {
		p[i] = k;
		//System.out.print(p[i]+" ");
		i++;
	    }
	}

    }
    static boolean check(int n){
	int a, c=0;
	for(a=1; a<=n; a++){
	    if(n%a==0) c++;
	}
	if(c>2) return false;
	return true;
    }    
}

</source>
<source file="../hum_codes_raw/s352963618.java" startline="1" endline="59" pcid="11850">
import java.util.*;
public class Main{
    static Scanner kbd = new Scanner(System.in);
    public static void main(String[] args){
	int[] p = new int[10000];
	putN(p);
	while(kbd.hasNext()){
	    int n = kbd.nextInt();
	    if(n!=0){
		int i=0;
		int s=0;  //連続した素数の和
		int l=0;  //連続素数のうち最小
		int c = 0;  //表現できたパターン数
		while(p[i]!=0){
		    if(s < n) {
			s += p[i];
			i++;
		    }
		    else if(s>n){
			s -= p[l];
			l++;
		    }
		    else;

		    if(s==n) {
			c++;
			s += p[i];
			i++;
		    }
		}	 
		System.out.println(c);
	    }
	}
    }

    
    
    
    static void putN(int[] p){
	int i=0, k;
	for(k=2; k<10000; k++){
	    if(check(k)) {
		p[i] = k;
		//System.out.print(p[i]+" ");
		i++;
	    }
	}

    }
    static boolean check(int n){
	int a, c=0;
	for(a=1; a<=n; a++){
	    if(n%a==0) c++;
	}
	if(c>2) return false;
	return true;
    }    
}

</source>
</class>

<class classid="159" nclones="3" nlines="31" similarity="100">
<source file="../hum_codes_raw/s277064174.java" startline="1" endline="49" pcid="9269">
import java.util.Arrays;
import java.util.Scanner;

public class Main 
{
	public static void main(String arg[])
	{
		Scanner sc=new Scanner(System.in);
		boolean a[] =new boolean[10001];
		Arrays.fill(a, true);
		a[0]=a[1]=false;
		for(int i=2; i*i<=10000; i++)
		{
			if(!a[i])
				continue;
			for(int j=i*2; j<=10000; j+=i)
				a[j]=false;
		}


		while(sc.hasNext())
		{
			int n=sc.nextInt();
			if(n==0)
				return;
			int sum=0;
			int ans=0;

			for(int i=2; i<=n; i++)
			{
				sum =0;
				if(a[i])
					for(int j=i; j<=n; j++)
					{
						if(a[j])
						{
							sum+=j;
							if(n==sum)
								ans++;
						}
						if(sum>=n)
							break;
					}
			}
			System.out.println(ans);
		}
	}
}

</source>
<source file="../hum_codes_raw/s866706293.java" startline="1" endline="46" pcid="29152">
import java.util.Arrays;
import java.util.Scanner;

public class Main
{
	public static void main(String arg[])
	{
		Scanner sc=new Scanner(System.in);
		boolean a[] =new boolean[10001];
		Arrays.fill(a, true);
		a[0]=a[1]=false;
		for(int i=2; i*i<=10000; i++)
		{
			if(!a[i])
				continue;
			for(int j=i*2; j<=10000; j+=i)
				a[j]=false;
		}
		while(sc.hasNext())
		{
			int n=sc.nextInt();
			if(n==0)
				return;
			int sum=0;
			int ans=0;
			for(int i=2; i<=n; i++)
			{
				sum =0;
				if(a[i])
					for(int j=i; j<=n; j++)
					{
						if(a[j])
						{
							sum+=j;
							if(n==sum)
								ans++;
						}
						if(sum>=n)
							break;
					}
			}
			System.out.println(ans);
		}
	}
}

</source>
<source file="../hum_codes_raw/s586575169.java" startline="1" endline="46" pcid="19689">
import java.util.Arrays;
import java.util.Scanner;

public class Main
{
	public static void main(String arg[])
	{
		Scanner sc=new Scanner(System.in);
		boolean a[] =new boolean[10001];
		Arrays.fill(a, true);
		a[0]=a[1]=false;
		for(int i=2; i*i<=10000; i++)
		{
			if(!a[i])
				continue;
			for(int j=i*2; j<=10000; j+=i)
				a[j]=false;
		}
		while(sc.hasNext())
		{
			int n=sc.nextInt();
			if(n==0)
				return;
			int sum=0;
			int ans=0;
			for(int i=2; i<=n; i++)
			{
				sum =0;
				if(a[i])
					for(int j=i; j<=n; j++)
					{
						if(a[j])
						{
							sum+=j;
							if(n==sum)
								ans++;
						}
						if(sum>=n)
							break;
					}
			}
			System.out.println(ans);
		}
	}
}

</source>
</class>

<class classid="160" nclones="2" nlines="58" similarity="100">
<source file="../hum_codes_raw/s277875295.java" startline="1" endline="75" pcid="9301">
import java.util.Scanner;
 
class Bot{
    int x = 1, y = 1 , dir = 0;
    private int width, height;
     
    private int[][] xy = {
            {0,1},{1,0},{0,-1},{-1,0}
    };
     
    public Bot(int w, int h) {
        width = w;
        height = h;
    }
     
     
    public void  forward(int step){
        x += xy[dir][0]*step;
        y += xy[dir][1]*step;
        beProperly();
    }
     
    public void backward(int step){
        x -= xy[dir][0]*step;
        y -= xy[dir][1]*step;
        beProperly();
    }
     
    public void right(){
        dir = (dir+1)%4;
    }
     
    public void left(){
        if(--dir == -1) dir = 3;
    }
     
    private void beProperly(){
        if(x > width) x = width;
        if(y > height) y = height;
        if(x < 1) x = 1;
        if(y < 1) y = 1;
    }
}
 
 
public class Main {
    public static void main(String[] args){
        Scanner sn = new Scanner(System.in);
 
        while(true){
            int w = sn.nextInt(), h = sn.nextInt();
            if(w == 0 && h == 0) break;
            Bot bot = new Bot(w, h);
            while(true){
 
                String cmd = sn.nextLine();
                String[] go = cmd.split(" ");
                String dir;
                 
                if(go.length == 2){
                    int step = new Integer(go[1]);
                    if(go[0].equals("FORWARD")) bot.forward(step);
                    else if(go[0].equals("BACKWARD")) bot.backward(step);
                } else{
                     
                    if(go[0].equals("RIGHT")) bot.right();
                    else if(go[0].equals("LEFT")) bot.left();
                    else if(go[0].equals("STOP")) break;
                }
            }
            System.out.println(bot.x+" "+bot.y);
        }      
    }
}

</source>
<source file="../hum_codes_raw/s462178555.java" startline="1" endline="75" pcid="15515">
import java.util.Scanner;

class Bot{
	int x = 1, y = 1 , dir = 0;
	private int width, height;
	
	private int[][] xy = {
			{0,1},{1,0},{0,-1},{-1,0}
	};
	
	public Bot(int w, int h) {
		width = w;
		height = h;
	}
	
	
	public void  forward(int step){
		x += xy[dir][0]*step;
		y += xy[dir][1]*step;
		beProperly();
	}
	
	public void backward(int step){
		x -= xy[dir][0]*step;
		y -= xy[dir][1]*step;
		beProperly();
	}
	
	public void right(){
		dir = (dir+1)%4;
	}
	
	public void left(){
		if(--dir == -1) dir = 3;
	}
	
	private void beProperly(){
		if(x > width) x = width;
		if(y > height) y = height;
		if(x < 1) x = 1;
		if(y < 1) y = 1;
	}
}


public class Main {
	public static void main(String[] args){
		Scanner sn = new Scanner(System.in);

		while(true){
			int w = sn.nextInt(), h = sn.nextInt();
			if(w == 0 && h == 0) break;
			Bot bot = new Bot(w, h);
			while(true){

				String cmd = sn.nextLine();
				String[] go = cmd.split(" ");
				String dir;
				
				if(go.length == 2){
					int step = new Integer(go[1]);
					if(go[0].equals("FORWARD")) bot.forward(step);
					else if(go[0].equals("BACKWARD")) bot.backward(step);
				} else{
					
					if(go[0].equals("RIGHT")) bot.right();
					else if(go[0].equals("LEFT")) bot.left();
					else if(go[0].equals("STOP")) break;
				}
			}
			System.out.println(bot.x+" "+bot.y);
		}		
	}
}

</source>
</class>

<class classid="161" nclones="2" nlines="180" similarity="100">
<source file="../hum_codes_raw/s280908225.java" startline="1" endline="218" pcid="9404">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 27);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            BRowToColumn solver = new BRowToColumn();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class BRowToColumn {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            int[][] mat = new int[n][n];
            int sum = 0;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    mat[i][j] = in.readChar() == '#' ? 1 : 0;
                    sum += mat[i][j];
                }
            }

            if (sum == 0) {
                out.println(-1);
                return;
            }

            int ans = (int) 1e9;
            for (int i = 0; i < n; i++) {
                int cnt = 0;
                for (int j = 0; j < n; j++) {
                    cnt += mat[j][i];
                }

                int row = 0;
                for (int j = 0; j < n; j++) {
                    row += mat[i][j];
                }

                int req = n - row;
                ans = Math.min(ans, req + (cnt == 0 ? 1 : 0));
            }

            for (int i = 0; i < n; i++) {
                int cnt = 0;
                for (int j = 0; j < n; j++) {
                    cnt += mat[j][i];
                }
                if (cnt < n) {
                    ans++;
                }
            }

            out.println(ans);
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

        public char readChar() {
            skipBlank();
            char c = (char) next;
            next = read();
            return c;
        }

    }
}


</source>
<source file="../hum_codes_raw/s851321599.java" startline="1" endline="218" pcid="28601">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 27);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            BRowToColumn solver = new BRowToColumn();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class BRowToColumn {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            int[][] mat = new int[n][n];
            int sum = 0;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    mat[i][j] = in.readChar() == '#' ? 1 : 0;
                    sum += mat[i][j];
                }
            }

            if (sum == 0) {
                out.println(-1);
                return;
            }

            int ans = (int) 1e9;
            for (int i = 0; i < n; i++) {
                int cnt = 0;
                for (int j = 0; j < n; j++) {
                    cnt += mat[j][i];
                }

                int row = 0;
                for (int j = 0; j < n; j++) {
                    row += mat[i][j];
                }

                int req = n - row;
                ans = Math.min(ans, req + (cnt == 0 ? 1 : 0));
            }

            for (int i = 0; i < n; i++) {
                int cnt = 0;
                for (int j = 0; j < n; j++) {
                    cnt += mat[j][i];
                }
                if (cnt < n) {
                    ans++;
                }
            }

            out.println(ans);
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

        public char readChar() {
            skipBlank();
            char c = (char) next;
            next = read();
            return c;
        }

    }
}


</source>
</class>

<class classid="162" nclones="2" nlines="32" similarity="100">
<source file="../hum_codes_raw/s283215821.java" startline="1" endline="43" pcid="9489">
import java.util.Arrays;
import java.util.Scanner;

class Main{
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		while(sc.hasNextInt()){
			int N = sc.nextInt();
			int[] n = new int[N];

			for(int i = 0; i < N; i++)
				n[i] = sc.nextInt()*60 + sc.nextInt();

			int M = sc.nextInt();
			int[] m = new int[M];

			for(int i = 0; i < M; i++)
				m[i] = sc.nextInt()*60 + sc.nextInt();

			int[] nm = new int[N+M];
			for(int i = 0; i < N; i++)
				nm[i] = n[i];
			for(int i = 0 ; i < M; i++)
				nm[N+i] = m[i];
			Arrays.sort(nm);
			int count=0;
			for(int i=1;i<nm.length;i++){
				if((nm[i]==nm[i-1])){
					nm[i-1]=0;count++;
				}

			}
			Arrays.sort(nm);
			for(;count < N+M; count++){
				System.out.printf("%d:%02d",nm[count]/60, nm[count]%60);
			if(!(count == N+M-1))
				System.out.print(" ");
			}
			System.out.println();
		}
	}
}

</source>
<source file="../hum_codes_raw/s994582133.java" startline="1" endline="43" pcid="33470">
import java.util.Arrays;
import java.util.Scanner;

class Main{
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		while(sc.hasNextInt()){
			int N = sc.nextInt();
			int[] n = new int[N];

			for(int i = 0; i < N; i++)
				n[i] = sc.nextInt()*60 + sc.nextInt();

			int M = sc.nextInt();
			int[] m = new int[M];

			for(int i = 0; i < M; i++)
				m[i] = sc.nextInt()*60 + sc.nextInt();

			int[] nm = new int[N+M];
			for(int i = 0; i < N; i++)
				nm[i] = n[i];
			for(int i = 0 ; i < M; i++)
				nm[N+i] = m[i];
			Arrays.sort(nm);
			int count=0;
			for(int i=1;i<nm.length;i++){
				if((nm[i]==nm[i-1])){
					nm[i-1]=0;count++;
				}

			}
			Arrays.sort(nm);
			for(;count < N+M; count++){
				System.out.printf("%d:%02d",nm[count]/60, nm[count]%60);
			if(!(count == N+M-1))
				System.out.print(" ");
			}
			System.out.println();
		}
	}
}

</source>
</class>

<class classid="163" nclones="2" nlines="37" similarity="100">
<source file="../hum_codes_raw/s286777872.java" startline="1" endline="50" pcid="9615">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Stack;

public class Main {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String[] tmpArray = br.readLine().split(" ");
		int n = Integer.parseInt(tmpArray[0]);
		int q = Integer.parseInt(tmpArray[1]);

		@SuppressWarnings("unchecked")
		Stack<Integer>[] stackArray = new Stack[n];
		for(int i = 0; i < n; i++){
			stackArray[i] = new Stack<Integer>();
		}

		for(int i = 0; i < q; i++){
			tmpArray = br.readLine().split(" ");

			//push
			if(tmpArray[0].equals("0")){
				int t = Integer.parseInt(tmpArray[1]);
				int x = Integer.parseInt(tmpArray[2]);

				stackArray[t].push(x);
			}
			//top
			else if(tmpArray[0].equals("1")){
				int t = Integer.parseInt(tmpArray[1]);

				if(!stackArray[t].isEmpty()){
					System.out.println(stackArray[t].peek());
				}
			}
			//pop
			else {
				int t = Integer.parseInt(tmpArray[1]);

				if(!stackArray[t].isEmpty()){
					stackArray[t].pop();
				}
			}
		}

	}
}

</source>
<source file="../hum_codes_raw/s608277077.java" startline="1" endline="51" pcid="20442">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Stack;

public class Main{

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String[] tmpArray = br.readLine().split(" ");
		int n = Integer.parseInt(tmpArray[0]);
		int q = Integer.parseInt(tmpArray[1]);

		@SuppressWarnings("unchecked")
		Stack<Integer>[] stackArray = new Stack[n];
		for(int i = 0; i < n; i++){
			stackArray[i] = new Stack<Integer>();
		}

		for(int i = 0; i < q; i++){
			tmpArray = br.readLine().split(" ");

			//push
			if(tmpArray[0].equals("0")){
				int t = Integer.parseInt(tmpArray[1]);
				int x = Integer.parseInt(tmpArray[2]);

				stackArray[t].push(x);
			}
			//top
			else if(tmpArray[0].equals("1")){
				int t = Integer.parseInt(tmpArray[1]);

				if(!stackArray[t].isEmpty()){
					System.out.println(stackArray[t].peek());
				}
			}
			//pop
			else {
				int t = Integer.parseInt(tmpArray[1]);

				if(!stackArray[t].isEmpty()){
					stackArray[t].pop();
				}
			}
		}

	}
}


</source>
</class>

<class classid="164" nclones="2" nlines="186" similarity="100">
<source file="../hum_codes_raw/s289533688.java" startline="1" endline="222" pcid="9691">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.io.UncheckedIOException;
import java.util.List;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            BSplatterPainting solver = new BSplatterPainting();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class BSplatterPainting {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            int m = in.readInt();
            Node[] nodes = new Node[n];
            for (int i = 0; i < n; i++) {
                nodes[i] = new Node();
            }
            for (int j = 0; j < m; j++) {
                Node a = nodes[in.readInt() - 1];
                Node b = nodes[in.readInt() - 1];
                a.adj.add(b);
                b.adj.add(a);
            }
            int q = in.readInt();
            int[][] qs = new int[3][q];
            for (int i = 0; i < q; i++) {
                for (int j = 0; j < 3; j++) {
                    qs[j][i] = in.readInt();
                }
            }

            for (int i = q - 1; i >= 0; i--) {
                Node v = nodes[qs[0][i] - 1];
                int d = qs[1][i];
                int c = qs[2][i];
                paint(v, c, d);
            }

            for (Node node : nodes) {
                int c = node.color == -1 ? 0 : node.color;
                out.println(c);
            }
        }

        public void paint(Node root, int c, int power) {
            if (power < 0 || root.used[power]) {
                return;
            }
            root.used[power] = true;
            if (root.color == -1) {
                root.color = c;
            }
            for (Node node : root.adj) {
                paint(node, c, power - 1);
            }
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class Node {
        List<Node> adj = new ArrayList<>();
        boolean[] used = new boolean[11];
        int color = -1;

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }
}


</source>
<source file="../hum_codes_raw/s825806369.java" startline="1" endline="222" pcid="27702">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.io.UncheckedIOException;
import java.util.List;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            BSplatterPainting solver = new BSplatterPainting();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class BSplatterPainting {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            int m = in.readInt();
            Node[] nodes = new Node[n];
            for (int i = 0; i < n; i++) {
                nodes[i] = new Node();
            }
            for (int j = 0; j < m; j++) {
                Node a = nodes[in.readInt() - 1];
                Node b = nodes[in.readInt() - 1];
                a.adj.add(b);
                b.adj.add(a);
            }
            int q = in.readInt();
            int[][] qs = new int[3][q];
            for (int i = 0; i < q; i++) {
                for (int j = 0; j < 3; j++) {
                    qs[j][i] = in.readInt();
                }
            }

            for (int i = q - 1; i >= 0; i--) {
                Node v = nodes[qs[0][i] - 1];
                int d = qs[1][i];
                int c = qs[2][i];
                paint(v, c, d);
            }

            for (Node node : nodes) {
                int c = node.color == -1 ? 0 : node.color;
                out.println(c);
            }
        }

        public void paint(Node root, int c, int power) {
            if (power < 0 || root.used[power]) {
                return;
            }
            root.used[power] = true;
            if (root.color == -1) {
                root.color = c;
            }
            for (Node node : root.adj) {
                paint(node, c, power - 1);
            }
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class Node {
        List<Node> adj = new ArrayList<>();
        boolean[] used = new boolean[11];
        int color = -1;

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }
}


</source>
</class>

<class classid="165" nclones="2" nlines="475" similarity="100">
<source file="../hum_codes_raw/s297470456.java" startline="1" endline="548" pcid="9996">
import java.io.*;
import java.util.*;

class P{
	long x, y;
	public P(int x, int y) {
		super();
		this.x = x;
		this.y = y;
	}
}

public class Main {
	static InputStream is;
	static PrintWriter out;
	static String INPUT = "";

	static final long mod = (long) 1e9 + 7;
	static final int dx[] = { -1, 0, 1, 0 }, dy[] = { 0, -1, 0, 1 };
	static final int[] dx8 = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy8 = { -1, 0, 1, -1, 1, -1, 0, 1 };
	static final int inf = Integer.MAX_VALUE / 3;
	static final long linf = Long.MAX_VALUE / 3;
	static final double dinf = Double.MAX_VALUE / 3;
	static final double eps = 1e-10;
	static final double pi = Math.PI;

	static void solve() {
		int n = ni();
		P p[] = new P[n];
		for(int i=0;i<n;i++) {
			p[i] = new P(ni(),ni());
		}
		//到達できるかチェック
		int check = (int)Math.abs(p[0].x-p[0].y)%2;
		for(int i=0;i<n;i++) {
			if(check != Math.abs(p[i].x - p[i].y)%2) {
				out.println(-1);
				return;
			}
		}
		
		
		int m = 0;
		long d[];
		if(check==1) {
			m = 33;
			d = new long[m];
			for(int i=0;i<m;i++) {
				d[i] = 1L<<i;
			}
		}
		else {
			m = 34;
			d = new long[m];
			for(int i=0;i<m-1;i++) {
				d[i+1] = 1L<<i;
				d[0] = 1;
			}
		}
		
		out.println(m);
		for(int i=0;i<m;i++) {
			out.print(d[m-1-i] + " ");
		}
		out.println();
		
		for(int i=0;i<n;i++) {
			String s = "";
			long x = p[i].x, y = p[i].y;
			for(int j=m-1;j>=0;j--) {
				if(abs(x)-abs(y)>0) {
					if(x<0) {
						s += "L";
						x += d[j];
					}
					else {
						s += "R";
						x -= d[j];
					}
				}
				else {
					if(y<0) {
						s += "D";
						y += d[j];
					}
					else {
						s += "U";
						y -= d[j];
					}
				}					
			}
			out.println(s);
		}
		

	}

	static int abs(int x) {
		return Math.abs(x);
	}	
	static long abs(long x) {
		return Math.abs(x);
	}
	static double abs(double x) {
		return Math.abs(x);
	}
	
	//libraries		
	static int lowerBound(int[] a, int x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] < x) {//昇順の配列
				//if (a[c] > x) {//降順の配列
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static int upperBound(int[] a, int x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] <= x) {
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static int lowerBound(long[] a, long x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] < x) {
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static int upperBound(long[] a, long x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] <= x) {
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static int lowerBound(double[] a, double x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] < x) {
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static int upperBound(double[] a, double x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] <= x) {
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static <T> int lowerBound(List<T> ls, T x) throws RuntimeException {
		if (ls.size() == 0)
			return -1;
		if (ls.get(0) instanceof Integer) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) >= 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Long) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) >= 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Double) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) >= 0 ? 1 : -1);
		} else {
			System.err.println(
					String.format("%s:数値でないリストを二分探索しています。", Thread.currentThread().getStackTrace()[1].getMethodName()));
			throw new RuntimeException();
		}
	}

	static <T> int upperBound(List<T> ls, T x) throws RuntimeException {
		if (ls.size() == 0)
			return -1;
		if (ls.get(0) instanceof Integer) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) > 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Long) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) > 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Double) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) > 0 ? 1 : -1);
		} else {
			System.err.println(
					String.format("%s:数値でないリストを二分探索しています。", Thread.currentThread().getStackTrace()[1].getMethodName()));
			throw new RuntimeException();
		}
	}

	static <T> int rupperBound(List<T> ls, T x) throws RuntimeException {
		if (ls.size() == 0)
			return -1;
		if (ls.get(0) instanceof Integer) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) < 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Long) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) < 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Double) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) < 0 ? 1 : -1);
		} else {
			System.err.println(
					String.format("%s:数値でないリストを二分探索しています。", Thread.currentThread().getStackTrace()[1].getMethodName()));
			throw new RuntimeException();
		}
	}

	static <T> int rlowerBound(List<T> ls, T x) {
		if (ls.size() == 0)
			return -1;
		if (ls.get(0) instanceof Integer) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) <= 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Long) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) <= 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Double) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) <= 0 ? 1 : -1);
		} else {
			System.err.println(
					String.format("%s:数値でないリストを二分探索しています。", Thread.currentThread().getStackTrace()[1].getMethodName()));
			throw new RuntimeException();
		}
	}

	static int[] concat(int x, int arr[]) {
		int ret[] = new int[arr.length + 1];
		System.arraycopy(arr, 0, ret, 1, ret.length - 1);
		ret[0] = x;
		return ret;
	}

	static int[] concat(int arr[], int x) {
		int ret[] = new int[arr.length + 1];
		System.arraycopy(arr, 0, ret, 0, ret.length - 1);
		ret[ret.length - 1] = x;
		return ret;
	}

	static long[] concat(long x, long arr[]) {
		long ret[] = new long[arr.length + 1];
		System.arraycopy(arr, 0, ret, 1, ret.length - 1);
		ret[0] = x;
		return ret;
	}

	static long[] concat(long arr[], long x) {
		long ret[] = new long[arr.length + 1];
		System.arraycopy(arr, 0, ret, 0, ret.length - 1);
		ret[ret.length - 1] = x;
		return ret;
	}

	static long max(long x, long y) {
		return Math.max(x, y);
	}

	static long min(long x, long y) {
		return Math.min(x, y);
	}

	static long max(long x, long y, long z) {
		x = Math.max(x, y);
		x = Math.max(x, z);
		return x;
	}

	static long min(long x, long y, long z) {
		x = Math.min(x, y);
		x = Math.min(x, z);
		return x;
	}

	static double max(double x, double y) {
		return Math.max(x, y);
	}

	static double min(double x, double y) {
		return Math.min(x, y);
	}

	static double max(double x, double y, double z) {
		x = Math.max(x, y);
		x = Math.max(x, z);
		return x;
	}

	static double min(double x, double y, double z) {
		x = Math.min(x, y);
		x = Math.min(x, z);
		return x;
	}

	static void sort(int[] ar) {
		Arrays.sort(ar);
	}

	static void sort(long[] ar) {
		Arrays.sort(ar);
	}

	static void sort(double[] ar) {
		Arrays.sort(ar);
	}

	static void rsort(int[] ar) {
		Arrays.sort(ar);
		int len = ar.length;
		for (int i = 0; i < len / 2; i++) {
			int tmp = ar[i];
			ar[i] = ar[len - 1 - i];
			ar[len - 1 - i] = tmp;
		}
	}

	static void rsort(long[] ar) {
		Arrays.sort(ar);
		int len = ar.length;
		for (int i = 0; i < len / 2; i++) {
			long tmp = ar[i];
			ar[i] = ar[len - 1 - i];
			ar[len - 1 - i] = tmp;
		}
	}

	static void rsort(double[] ar) {
		Arrays.sort(ar);
		int len = ar.length;
		for (int i = 0; i < len / 2; i++) {
			double tmp = ar[i];
			ar[i] = ar[len - 1 - i];
			ar[len - 1 - i] = tmp;
		}
	}

	static void fill(int arr[], int x) {
		Arrays.fill(arr, x);
	}

	static void fill(long arr[], long x) {
		Arrays.fill(arr, x);
	}

	static void fill(double arr[], double x) {
		Arrays.fill(arr, x);
	}

	static void fill(int arr[][], int x) {
		for (int i = 0; i < arr.length; i++)
			Arrays.fill(arr[i], x);
	}

	static void fill(long arr[][], long x) {
		for (int i = 0; i < arr.length; i++)
			Arrays.fill(arr[i], x);
	}

	static void fill(double arr[][], double x) {
		for (int i = 0; i < arr.length; i++)
			Arrays.fill(arr[i], x);
	}

	//MOD culc
	static long plus(long x, long y) {
		long res = (x + y) % mod;
		return res < 0 ? res + mod : res;
	}

	static long sub(long x, long y) {
		long res = (x - y) % mod;
		return res < 0 ? res + mod : res;
	}

	static long mul(long x, long y) {
		long res = (x * y) % mod;
		return res < 0 ? res + mod : res;
	}

	static long div(long x, long y) {
		long res = x * pow(y, mod - 2) % mod;
		return res < 0 ? res + mod : res;
	}

	static long pow(long x, long y) {
		if (y < 0)
			return 0;
		if (y == 0)
			return 1;
		if (y % 2 == 1)
			return (x * pow(x, y - 1)) % mod;
		long root = pow(x, y / 2);
		return root * root % mod;
	}

	public static void main(String[] args) throws Exception {
		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		solve();
		out.flush();
	}

	//input
	private static byte[] inbuf = new byte[1024];
	static int lenbuf = 0, ptrbuf = 0;

	private static int readByte() {
		if (lenbuf == -1)
			throw new InputMismatchException();
		if (ptrbuf >= lenbuf) {
			ptrbuf = 0;
			try {
				lenbuf = is.read(inbuf);
			} catch (IOException e) {
				throw new InputMismatchException();
			}
			if (lenbuf <= 0)
				return -1;
		}
		return inbuf[ptrbuf++];
	}

	private static boolean isSpaceChar(int c) {
		return !(c >= 33 && c <= 126);
	}

	private static int skip() {
		int b;
		while ((b = readByte()) != -1 && isSpaceChar(b))
			;
		return b;
	}

	@SuppressWarnings("unused")
	private static double nd() {
		return Double.parseDouble(ns());
	}

	@SuppressWarnings("unused")
	private static char nc() {
		return (char) skip();
	}

	private static String ns() {
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while (!(isSpaceChar(b))) {
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}

	private static char[] ns(int n) {
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while (p < n && !(isSpaceChar(b))) {
			buf[p++] = (char) b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}

	@SuppressWarnings("unused")
	private static char[][] nm(int n, int m) {
		char[][] map = new char[n][];
		for (int i = 0; i < n; i++)
			map[i] = ns(m);
		return map;
	}

	@SuppressWarnings("unused")
	private static int[] na(int n) {
		int[] a = new int[n];
		for (int i = 0; i < n; i++)
			a[i] = ni();
		return a;
	}

	private static int ni() {
		int num = 0, b;
		boolean minus = false;
		while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))
			;
		if (b == '-') {
			minus = true;
			b = readByte();
		}

		while (true) {
			if (b >= '0' && b <= '9') {
				num = num * 10 + (b - '0');
			} else {
				return minus ? -num : num;
			}
			b = readByte();
		}
	}

	@SuppressWarnings("unused")
	private static long nl() {
		long num = 0;
		int b;
		boolean minus = false;
		while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))
			;
		if (b == '-') {
			minus = true;
			b = readByte();
		}

		while (true) {
			if (b >= '0' && b <= '9') {
				num = num * 10 + (b - '0');
			} else {
				return minus ? -num : num;
			}
			b = readByte();
		}
	}

}

</source>
<source file="../hum_codes_raw/s898792213.java" startline="1" endline="548" pcid="30243">
import java.io.*;
import java.util.*;

class P{
	long x, y;
	public P(int x, int y) {
		super();
		this.x = x;
		this.y = y;
	}
}

public class Main {
	static InputStream is;
	static PrintWriter out;
	static String INPUT = "";

	static final long mod = (long) 1e9 + 7;
	static final int dx[] = { -1, 0, 1, 0 }, dy[] = { 0, -1, 0, 1 };
	static final int[] dx8 = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy8 = { -1, 0, 1, -1, 1, -1, 0, 1 };
	static final int inf = Integer.MAX_VALUE / 3;
	static final long linf = Long.MAX_VALUE / 3;
	static final double dinf = Double.MAX_VALUE / 3;
	static final double eps = 1e-10;
	static final double pi = Math.PI;

	static void solve() {
		int n = ni();
		P p[] = new P[n];
		for(int i=0;i<n;i++) {
			p[i] = new P(ni(),ni());
		}
		//到達できるかチェック
		int check = (int)Math.abs(p[0].x-p[0].y)%2;
		for(int i=0;i<n;i++) {
			if(check != Math.abs(p[i].x - p[i].y)%2) {
				out.println(-1);
				return;
			}
		}
		
		
		int m = 0;
		long d[];
		if(check==1) {
			m = 33;
			d = new long[m];
			for(int i=0;i<m;i++) {
				d[i] = 1L<<i;
			}
		}
		else {
			m = 34;
			d = new long[m];
			for(int i=0;i<m-1;i++) {
				d[i+1] = 1L<<i;
				d[0] = 1;
			}
		}
		
		out.println(m);
		for(int i=0;i<m;i++) {
			out.print(d[m-1-i] + " ");
		}
		out.println();
		
		for(int i=0;i<n;i++) {
			String s = "";
			long x = p[i].x, y = p[i].y;
			for(int j=m-1;j>=0;j--) {
				if(abs(x)-abs(y)>0) {
					if(x<0) {
						s += "L";
						x += d[j];
					}
					else {
						s += "R";
						x -= d[j];
					}
				}
				else {
					if(y<0) {
						s += "D";
						y += d[j];
					}
					else {
						s += "U";
						y -= d[j];
					}
				}					
			}
			out.println(s);
		}
		

	}

	static int abs(int x) {
		return Math.abs(x);
	}	
	static long abs(long x) {
		return Math.abs(x);
	}
	static double abs(double x) {
		return Math.abs(x);
	}
	
	//libraries		
	static int lowerBound(int[] a, int x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] < x) {//昇順の配列
				//if (a[c] > x) {//降順の配列
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static int upperBound(int[] a, int x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] <= x) {
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static int lowerBound(long[] a, long x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] < x) {
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static int upperBound(long[] a, long x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] <= x) {
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static int lowerBound(double[] a, double x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] < x) {
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static int upperBound(double[] a, double x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] <= x) {
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static <T> int lowerBound(List<T> ls, T x) throws RuntimeException {
		if (ls.size() == 0)
			return -1;
		if (ls.get(0) instanceof Integer) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) >= 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Long) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) >= 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Double) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) >= 0 ? 1 : -1);
		} else {
			System.err.println(
					String.format("%s:数値でないリストを二分探索しています。", Thread.currentThread().getStackTrace()[1].getMethodName()));
			throw new RuntimeException();
		}
	}

	static <T> int upperBound(List<T> ls, T x) throws RuntimeException {
		if (ls.size() == 0)
			return -1;
		if (ls.get(0) instanceof Integer) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) > 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Long) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) > 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Double) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) > 0 ? 1 : -1);
		} else {
			System.err.println(
					String.format("%s:数値でないリストを二分探索しています。", Thread.currentThread().getStackTrace()[1].getMethodName()));
			throw new RuntimeException();
		}
	}

	static <T> int rupperBound(List<T> ls, T x) throws RuntimeException {
		if (ls.size() == 0)
			return -1;
		if (ls.get(0) instanceof Integer) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) < 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Long) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) < 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Double) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) < 0 ? 1 : -1);
		} else {
			System.err.println(
					String.format("%s:数値でないリストを二分探索しています。", Thread.currentThread().getStackTrace()[1].getMethodName()));
			throw new RuntimeException();
		}
	}

	static <T> int rlowerBound(List<T> ls, T x) {
		if (ls.size() == 0)
			return -1;
		if (ls.get(0) instanceof Integer) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) <= 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Long) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) <= 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Double) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) <= 0 ? 1 : -1);
		} else {
			System.err.println(
					String.format("%s:数値でないリストを二分探索しています。", Thread.currentThread().getStackTrace()[1].getMethodName()));
			throw new RuntimeException();
		}
	}

	static int[] concat(int x, int arr[]) {
		int ret[] = new int[arr.length + 1];
		System.arraycopy(arr, 0, ret, 1, ret.length - 1);
		ret[0] = x;
		return ret;
	}

	static int[] concat(int arr[], int x) {
		int ret[] = new int[arr.length + 1];
		System.arraycopy(arr, 0, ret, 0, ret.length - 1);
		ret[ret.length - 1] = x;
		return ret;
	}

	static long[] concat(long x, long arr[]) {
		long ret[] = new long[arr.length + 1];
		System.arraycopy(arr, 0, ret, 1, ret.length - 1);
		ret[0] = x;
		return ret;
	}

	static long[] concat(long arr[], long x) {
		long ret[] = new long[arr.length + 1];
		System.arraycopy(arr, 0, ret, 0, ret.length - 1);
		ret[ret.length - 1] = x;
		return ret;
	}

	static long max(long x, long y) {
		return Math.max(x, y);
	}

	static long min(long x, long y) {
		return Math.min(x, y);
	}

	static long max(long x, long y, long z) {
		x = Math.max(x, y);
		x = Math.max(x, z);
		return x;
	}

	static long min(long x, long y, long z) {
		x = Math.min(x, y);
		x = Math.min(x, z);
		return x;
	}

	static double max(double x, double y) {
		return Math.max(x, y);
	}

	static double min(double x, double y) {
		return Math.min(x, y);
	}

	static double max(double x, double y, double z) {
		x = Math.max(x, y);
		x = Math.max(x, z);
		return x;
	}

	static double min(double x, double y, double z) {
		x = Math.min(x, y);
		x = Math.min(x, z);
		return x;
	}

	static void sort(int[] ar) {
		Arrays.sort(ar);
	}

	static void sort(long[] ar) {
		Arrays.sort(ar);
	}

	static void sort(double[] ar) {
		Arrays.sort(ar);
	}

	static void rsort(int[] ar) {
		Arrays.sort(ar);
		int len = ar.length;
		for (int i = 0; i < len / 2; i++) {
			int tmp = ar[i];
			ar[i] = ar[len - 1 - i];
			ar[len - 1 - i] = tmp;
		}
	}

	static void rsort(long[] ar) {
		Arrays.sort(ar);
		int len = ar.length;
		for (int i = 0; i < len / 2; i++) {
			long tmp = ar[i];
			ar[i] = ar[len - 1 - i];
			ar[len - 1 - i] = tmp;
		}
	}

	static void rsort(double[] ar) {
		Arrays.sort(ar);
		int len = ar.length;
		for (int i = 0; i < len / 2; i++) {
			double tmp = ar[i];
			ar[i] = ar[len - 1 - i];
			ar[len - 1 - i] = tmp;
		}
	}

	static void fill(int arr[], int x) {
		Arrays.fill(arr, x);
	}

	static void fill(long arr[], long x) {
		Arrays.fill(arr, x);
	}

	static void fill(double arr[], double x) {
		Arrays.fill(arr, x);
	}

	static void fill(int arr[][], int x) {
		for (int i = 0; i < arr.length; i++)
			Arrays.fill(arr[i], x);
	}

	static void fill(long arr[][], long x) {
		for (int i = 0; i < arr.length; i++)
			Arrays.fill(arr[i], x);
	}

	static void fill(double arr[][], double x) {
		for (int i = 0; i < arr.length; i++)
			Arrays.fill(arr[i], x);
	}

	//MOD culc
	static long plus(long x, long y) {
		long res = (x + y) % mod;
		return res < 0 ? res + mod : res;
	}

	static long sub(long x, long y) {
		long res = (x - y) % mod;
		return res < 0 ? res + mod : res;
	}

	static long mul(long x, long y) {
		long res = (x * y) % mod;
		return res < 0 ? res + mod : res;
	}

	static long div(long x, long y) {
		long res = x * pow(y, mod - 2) % mod;
		return res < 0 ? res + mod : res;
	}

	static long pow(long x, long y) {
		if (y < 0)
			return 0;
		if (y == 0)
			return 1;
		if (y % 2 == 1)
			return (x * pow(x, y - 1)) % mod;
		long root = pow(x, y / 2);
		return root * root % mod;
	}

	public static void main(String[] args) throws Exception {
		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		solve();
		out.flush();
	}

	//input
	private static byte[] inbuf = new byte[1024];
	static int lenbuf = 0, ptrbuf = 0;

	private static int readByte() {
		if (lenbuf == -1)
			throw new InputMismatchException();
		if (ptrbuf >= lenbuf) {
			ptrbuf = 0;
			try {
				lenbuf = is.read(inbuf);
			} catch (IOException e) {
				throw new InputMismatchException();
			}
			if (lenbuf <= 0)
				return -1;
		}
		return inbuf[ptrbuf++];
	}

	private static boolean isSpaceChar(int c) {
		return !(c >= 33 && c <= 126);
	}

	private static int skip() {
		int b;
		while ((b = readByte()) != -1 && isSpaceChar(b))
			;
		return b;
	}

	@SuppressWarnings("unused")
	private static double nd() {
		return Double.parseDouble(ns());
	}

	@SuppressWarnings("unused")
	private static char nc() {
		return (char) skip();
	}

	private static String ns() {
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while (!(isSpaceChar(b))) {
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}

	private static char[] ns(int n) {
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while (p < n && !(isSpaceChar(b))) {
			buf[p++] = (char) b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}

	@SuppressWarnings("unused")
	private static char[][] nm(int n, int m) {
		char[][] map = new char[n][];
		for (int i = 0; i < n; i++)
			map[i] = ns(m);
		return map;
	}

	@SuppressWarnings("unused")
	private static int[] na(int n) {
		int[] a = new int[n];
		for (int i = 0; i < n; i++)
			a[i] = ni();
		return a;
	}

	private static int ni() {
		int num = 0, b;
		boolean minus = false;
		while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))
			;
		if (b == '-') {
			minus = true;
			b = readByte();
		}

		while (true) {
			if (b >= '0' && b <= '9') {
				num = num * 10 + (b - '0');
			} else {
				return minus ? -num : num;
			}
			b = readByte();
		}
	}

	@SuppressWarnings("unused")
	private static long nl() {
		long num = 0;
		int b;
		boolean minus = false;
		while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))
			;
		if (b == '-') {
			minus = true;
			b = readByte();
		}

		while (true) {
			if (b >= '0' && b <= '9') {
				num = num * 10 + (b - '0');
			} else {
				return minus ? -num : num;
			}
			b = readByte();
		}
	}

}

</source>
</class>

<class classid="166" nclones="2" nlines="10" similarity="100">
<source file="../hum_codes_raw/s300046550.java" startline="1" endline="16" pcid="10105">
import java.util.Scanner;

public class Main {

  public static void main(String[] args) {

    Scanner sc = new Scanner(System.in);
    int a = sc.nextInt();
    int b = sc.nextInt();
    int h = sc.nextInt();

    System.out.println((a + b) * h / 2);

  }
}

</source>
<source file="../hum_codes_raw/s734792783.java" startline="1" endline="14" pcid="24696">
import java.util.Scanner;

public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        
        int a = sc.nextInt();
        int b = sc.nextInt();
        int h = sc.nextInt();
        
        System.out.println((a + b) * h / 2);
    }
}

</source>
</class>

<class classid="167" nclones="2" nlines="26" similarity="100">
<source file="../hum_codes_raw/s302989808.java" startline="1" endline="26" pcid="10203">
import java.util.*; 
class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int q = sc.nextInt();
        Queue<String> qProcess = new LinkedList<String>();
        Queue<Integer> qTime = new LinkedList<Integer>();        
        int totalTime = 0;
        for (int i = 0; i < n; i++) {
            qProcess.add(sc.next());
            qTime.add(sc.nextInt());
        }         
        while (qProcess.size()>0) {
            if (qTime.peek() - q > 0) {
                qProcess.add(qProcess.poll());
                qTime.add(qTime.poll()-q);
                totalTime = totalTime + q;
            } else {
                totalTime = totalTime + qTime.poll();
                System.out.println(qProcess.poll() + ' ' + totalTime);
            }
        }
    }
}

</source>
<source file="../hum_codes_raw/s544542918.java" startline="1" endline="26" pcid="18345">
import java.util.*; 
class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int q = sc.nextInt();
        Queue<String> qProcess = new LinkedList<String>();
        Queue<Integer> qTime = new LinkedList<Integer>();        
        int totalTime = 0;
        for (int i = 0; i < n; i++) {
            qProcess.add(sc.next());
            qTime.add(sc.nextInt());
        }         
        while (qProcess.size()>0) {
            if (qTime.peek() - q > 0) {
                qProcess.add(qProcess.poll());
                qTime.add(qTime.poll()-q);
                totalTime = totalTime + q;
            } else {
                totalTime = totalTime + qTime.poll();
                System.out.println(qProcess.poll() + ' ' + totalTime);
            }
        }
    }
}

</source>
</class>

<class classid="168" nclones="2" nlines="162" similarity="100">
<source file="../hum_codes_raw/s306147031.java" startline="1" endline="180" pcid="10309">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

class Node {
	int key, priority;
	Node parent, left, right;

	public Node(int key, int priority) {
		super();
		this.key = key;
		this.priority = priority;
	}

}

class Tree {
	Node root;

	Node rightRotate(Node t) {
		Node s = t.left;
		t.left = s.right;
		s.right = t;
		if (t == this.root) {
			this.root = s;
		}
		return s;
	}

	Node leftRotate(Node t) {
		Node s = t.right;
		t.right = s.left;
		s.left = t;
		if (t == this.root) {
			this.root = s;
		}
		return s;
	}

	Node insert(Node t, int key, int priority) {
		if (this.root == null) {
			this.root = new Node(key, priority);
			return t;
		}
		if (t == null) {
			return new Node(key, priority);
		}
		if (key == t.key) {
			return t;
		}

		if (key < t.key) {
			t.left = insert(t.left, key, priority);
			if (t.priority < t.left.priority) {
				t = rightRotate(t);
			}
		} else {
			t.right = insert(t.right, key, priority);
			if (t.priority < t.right.priority) {
				t = leftRotate(t);
			}
		}
		return t;

	}


	Node delete(Node t, int key) {
		if (t == null) {
			return null;
		}
		if (key < t.key) {
			t.left = delete(t.left, key);
		} else if(key > t.key) {
			 t.right = delete(t.right, key);
		} else {
			return _delete(t, key);
		}

		return t;
	}

	Node _delete(Node t, int key) {
		if (t.left == null && t.right == null) {
			return null;
		} else if (t.left == null) {
			t = leftRotate(t);
		} else if (t.right == null) {
			t = rightRotate(t);
		} else {
			if (t.left.priority > t.right.priority) {
				t = rightRotate(t);
			} else {
				t = leftRotate(t);
			}
		}

		return delete(t, key);
	}

	boolean find(Node t, int key) {
		if (t == null) {
			return false;
		}
		if (key < t.key) {
			return find(t.left, key);
		} else if (key > t.key) {
			return find(t.right, key);
		} else {
			return true;
		}
	}



}

public class Main {

	static StringBuilder sb;

	public static void printPreOrder(Node node) {
		if (node == null) {
			return;
		}

		sb.append(" " + node.key);
		printPreOrder(node.left);
		printPreOrder(node.right);
	}

	public static void printInOrder(Node node) {
		if (node == null) {
			return;
		}

		printInOrder(node.left);
		sb.append(" " + node.key);
		printInOrder(node.right);
	}



	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

		int m = Integer.parseInt(br.readLine());
		String[] operation;
		int key, priority;
		Tree tree = new Tree();
		sb = new StringBuilder();

		for (int i = 0; i < m; i++) {
			operation = br.readLine().split(" ");
			if (operation[0].equals("insert")) {
				key = Integer.parseInt(operation[1]);
				priority = Integer.parseInt(operation[2]);
				tree.insert(tree.root, key, priority);
			} else if (operation[0].equals("find")) {
				key = Integer.parseInt(operation[1]);
				if (tree.find(tree.root, key)) {
					System.out.println("yes");
				} else {
					System.out.println("no");
				}
			} else if (operation[0].equals("delete")) {
				key = Integer.parseInt(operation[1]);
				tree.delete(tree.root, key);
			} else {
				printInOrder(tree.root);
				sb.append("\n");
				printPreOrder(tree.root);
				System.out.println(sb.toString());
				sb.setLength(0);
			}
		}

	}
}

</source>
<source file="../hum_codes_raw/s723913417.java" startline="1" endline="202" pcid="24348">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

class Node {
	int key, priority;
	Node parent, left, right;

	public Node(int key, int priority) {
		super();
		this.key = key;
		this.priority = priority;
	}

}

class Tree {
	Node root;

	Node rightRotate(Node t) {
		Node s = t.left;
		t.left = s.right;
		s.right = t;
		if (t == this.root) {
			this.root = s;
		}
		return s;
	}

	Node leftRotate(Node t) {
		Node s = t.right;
		t.right = s.left;
		s.left = t;
		if (t == this.root) {
			this.root = s;
		}
		return s;
	}

//	void insert(Node z) {
//		Node y = null;
//		Node x = this.root;
//		while (x != null) {
//			y = x;
//			if (z.key < x.key) {
//				x = y.left;
//			} else {
//				x = y.right;
//			}
//		}
//		z.parent = y;
//
//		if (y == null) {
//			this.root = z;
//		} else if (z.key < y.key) {
//			y.left = z;
//		} else {
//			y.right = z;
//		}
//	}

	Node insert(Node t, int key, int priority) {
		if (this.root == null) {
			this.root = new Node(key, priority);
			return t;
		}
		if (t == null) {
			return new Node(key, priority);
		}
		if (key == t.key) {
			return t;
		}

		if (key < t.key) {
			t.left = insert(t.left, key, priority);
			if (t.priority < t.left.priority) {
				t = rightRotate(t);
			}
		} else {
			t.right = insert(t.right, key, priority);
			if (t.priority < t.right.priority) {
				t = leftRotate(t);
			}
		}
		return t;

	}


	Node delete(Node t, int key) {
		if (t == null) {
			return null;
		}
		if (key < t.key) {
			t.left = delete(t.left, key);
		} else if(key > t.key) {
			 t.right = delete(t.right, key);
		} else {
			return _delete(t, key);
		}

		return t;
	}

	Node _delete(Node t, int key) {
		if (t.left == null && t.right == null) {
			return null;
		} else if (t.left == null) {
			t = leftRotate(t);
		} else if (t.right == null) {
			t = rightRotate(t);
		} else {
			if (t.left.priority > t.right.priority) {
				t = rightRotate(t);
			} else {
				t = leftRotate(t);
			}
		}

		return delete(t, key);
	}

	boolean find(Node t, int key) {
		if (t == null) {
			return false;
		}
		if (key < t.key) {
			return find(t.left, key);
		} else if (key > t.key) {
			return find(t.right, key);
		} else {
			return true;
		}
	}



}

public class Main {

	static StringBuilder sb;

	public static void printPreOrder(Node node) {
		if (node == null) {
			return;
		}

		sb.append(" " + node.key);
		printPreOrder(node.left);
		printPreOrder(node.right);
	}

	public static void printInOrder(Node node) {
		if (node == null) {
			return;
		}

		printInOrder(node.left);
		sb.append(" " + node.key);
		printInOrder(node.right);
	}



	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

		int m = Integer.parseInt(br.readLine());
		String[] operation;
		int key, priority;
		Tree tree = new Tree();
		sb = new StringBuilder();

		for (int i = 0; i < m; i++) {
			operation = br.readLine().split(" ");
			if (operation[0].equals("insert")) {
				key = Integer.parseInt(operation[1]);
				priority = Integer.parseInt(operation[2]);
				tree.insert(tree.root, key, priority);
			} else if (operation[0].equals("find")) {
				key = Integer.parseInt(operation[1]);
				if (tree.find(tree.root, key)) {
					System.out.println("yes");
				} else {
					System.out.println("no");
				}
			} else if (operation[0].equals("delete")) {
				key = Integer.parseInt(operation[1]);
				tree.delete(tree.root, key);
			} else {
				printInOrder(tree.root);
				sb.append("\n");
				printPreOrder(tree.root);
				System.out.println(sb.toString());
				sb.setLength(0);
			}
		}

	}
}

</source>
</class>

<class classid="169" nclones="2" nlines="34" similarity="100">
<source file="../hum_codes_raw/s306713968.java" startline="1" endline="37" pcid="10327">
import java.util.Scanner;

public class Main{
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		double x_p1 = scan.nextDouble();
		double y_p1 = scan.nextDouble();
		double x_p2 = scan.nextDouble();
		double y_p2 = scan.nextDouble();
		double vx = x_p2 - x_p1;
		double vy = y_p2 - y_p1;
		int q = scan.nextInt();
		double l = norm(x_p1, y_p1, x_p2, y_p2);
		StringBuilder sb = new StringBuilder();
		for(int i = 0; i < q; i++) {
			double x = scan.nextDouble();
			double y = scan.nextDouble();
			double ux = x - x_p1;
			double uy = y - y_p1;
			double t = dot(ux, uy, vx, vy);
			double k = t / l;
			double a = k * vx + x_p1;
			double b = k * vy + y_p1;
			//System.out.println(a + " " + b);
			sb.append(a).append(" ").append(b).append("\n");
		}
		scan.close();
		System.out.print(sb.toString());
	}
	static double dot(double x1, double y1, double x2, double y2) {
		return x1 * x2 + y1 * y2;
	}
	static double norm(double x1, double y1, double x2, double y2) {
		return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
	}
}

</source>
<source file="../hum_codes_raw/s525519255.java" startline="1" endline="45" pcid="17671">
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        
        double x_p1 = scan.nextDouble();
        double y_p1 = scan.nextDouble();
        double x_p2 = scan.nextDouble();
        double y_p2 = scan.nextDouble();
        
        double vx = x_p2 - x_p1;
        double vy = y_p2 - y_p1;
        
        int q = scan.nextInt();
        double l = norm(x_p1, y_p1, x_p2, y_p2);
        
        StringBuilder sb = new StringBuilder();
        
        for(int i = 0; i < q; i++) {
            double x = scan.nextDouble();
            double y = scan.nextDouble();
            double ux = x - x_p1;
            double uy = y - y_p1;
            double t = dot(ux, uy, vx, vy);
            double k = t / l;
            double a = k * vx + x_p1;
            double b = k * vy + y_p1;
            
            //System.out.println(a + " " + b);
            sb.append(a).append(" ").append(b).append("\n");
        }
        scan.close();
        System.out.print(sb.toString());
    }
    
    static double dot(double x1, double y1, double x2, double y2) {
        return x1 * x2 + y1 * y2;
    }
    
    static double norm(double x1, double y1, double x2, double y2) {
        return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
    }
}

</source>
</class>

<class classid="170" nclones="2" nlines="120" similarity="100">
<source file="../hum_codes_raw/s308183422.java" startline="1" endline="135" pcid="10382">
import java.util.LinkedList;
import java.util.PriorityQueue;
import java.util.Scanner;

public class Main {
	static final int INF = 1000000000;
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc = new Scanner(System.in);
		Node[] inn = new Node[101];
		int[][] dp = new int[101][101];
		while(true){
			int n = sc.nextInt();
			int m = sc.nextInt();
			int l = sc.nextInt();
			if(n == 0 && m == 0 & l == 0){
				break;
			}
			for(int i = 1; i <= n; i++){
				inn[i] = new Node(i);
			}
			Node start = inn[1];
			Node goal = inn[n];
			for(int i = 0; i < m; i++){
				int a = sc.nextInt();
				int b = sc.nextInt();
				int d = sc.nextInt();
				int e = sc.nextInt();
				
				inn[a].edges.add(new Edge(e, d, inn[b]));
				inn[b].edges.add(new Edge(e, d, inn[a]));
			}
			boolean[] flg = new boolean[n + 1];
			for(int i = 0; i <= n; i++){
				flg[i] = false;
			}
			for(int i = 1; i <= n; i++){
				for(int j = 0; j <= l; j++){
					dp[i][j] = INF;
				}
			}
			PriorityQueue<Node> q = new PriorityQueue<Node>();
			int len = 0;
			dp[1][0] = 0;
			q.add(inn[1]);
			while(!q.isEmpty()){
				Node node = q.poll();
				len = node.c;
				for(Edge e : node.edges){
					// ???????????£????????????
					if(len + e.d <= l){ // ?????¨??????????????????
						// ?????¨?????£?????´???????\???????????????°????°???????????????????
						if(dp[e.t.n][len + e.d] > dp[node.n][len]){
							Node nnode = new Node(e.t.n);
							nnode.edges = e.t.edges;
							nnode.c = len + e.d;
							q.add(nnode);
							dp[e.t.n][len + e.d] = dp[node.n][len] ;
						}
					}
					// ????????£???????????????
					// ?????¨??????????????´???????\???????????????°????????????
					if(dp[e.t.n][len] > dp[node.n][len] + e.e){
						Node nnode = new Node(e.t.n);
						nnode.edges = e.t.edges;
						nnode.c = len;
						q.add(nnode);
						dp[e.t.n][len] = dp[node.n][len] + e.e;
					}
				}
			}
			
			int min = INF;
			for(int i = 0; i <= l; i++){
				min = Math.min(min, dp[n][i]);
			}
			System.out.println(min);
//			System.out.println(func(start, l, goal, flg));
			
		}
		
		
		sc.close();
	}
	static int func(Node node, int cap, Node goal, boolean[] flg){
		int res = 1000000000;
		if(node.equals(goal)){
			return 0;
		}
		for(Edge e : node.edges){
			if(!flg[e.t.n]){
				if(e.d > cap){
					flg[node.n] = true;
					res = Math.min(res, func(e.t, cap, goal, flg) + e.e);
					flg[node.n] = false;
				}else{
					flg[node.n] = true;
					res = Math.min(res, Math.min(func(e.t, cap - e.d, goal, flg), func(e.t, cap, goal, flg) + e.e));
					flg[node.n] = false;
				}
			}
		}
		
		return res;
	}

}
class Node implements Comparable<Node>{
	int n;
	int c;
	LinkedList<Edge> edges;
	Node(int number){
		edges = new LinkedList<Edge>();
		n = number;
		c = 0;
	}
	@Override
	public int compareTo(Node o) {
		// TODO Auto-generated method stub
		return n - o.n;
	}
}
class Edge{
	boolean flg;
	int e;
	int d;
	Node t;
	Edge(int enemy, int dist, Node to){
		e = enemy;
		d = dist;
		t = to;
		flg = false;
	}
}

</source>
<source file="../hum_codes_raw/s623980376.java" startline="1" endline="135" pcid="20945">
import java.util.LinkedList;
import java.util.PriorityQueue;
import java.util.Scanner;

public class Main {
	static final int INF = 1000000000;
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc = new Scanner(System.in);
		Node[] inn = new Node[101];
		int[][] dp = new int[101][101];
		while(true){
			int n = sc.nextInt();
			int m = sc.nextInt();
			int l = sc.nextInt();
			if(n == 0 && m == 0 & l == 0){
				break;
			}
			for(int i = 1; i <= n; i++){
				inn[i] = new Node(i);
			}
			Node start = inn[1];
			Node goal = inn[n];
			for(int i = 0; i < m; i++){
				int a = sc.nextInt();
				int b = sc.nextInt();
				int d = sc.nextInt();
				int e = sc.nextInt();
				
				inn[a].edges.add(new Edge(e, d, inn[b]));
				inn[b].edges.add(new Edge(e, d, inn[a]));
			}
			boolean[] flg = new boolean[n + 1];
			for(int i = 0; i <= n; i++){
				flg[i] = false;
			}
			for(int i = 1; i <= n; i++){
				for(int j = 0; j <= l; j++){
					dp[i][j] = INF;
				}
			}
			PriorityQueue<Node> q = new PriorityQueue<Node>();
			int len = 0;
			dp[1][0] = 0;
			q.add(inn[1]);
			while(!q.isEmpty()){
				Node node = q.poll();
				len = node.c;
				for(Edge e : node.edges){
					// ???????????£????????????
					if(len + e.d <= l){ // ?????¨??????????????????
						// ?????¨?????£?????´???????\???????????????°????°???????????????????
						if(dp[e.t.n][len + e.d] > dp[node.n][len]){
							Node nnode = new Node(e.t.n);
							nnode.edges = e.t.edges;
							nnode.c = len + e.d;
							q.add(nnode);
							dp[e.t.n][len + e.d] = dp[node.n][len] ;
						}
					}
					// ????????£???????????????
					// ?????¨??????????????´???????\???????????????°????????????
					if(dp[e.t.n][len] > dp[node.n][len] + e.e){
						Node nnode = new Node(e.t.n);
						nnode.edges = e.t.edges;
						nnode.c = len;
						q.add(nnode);
						dp[e.t.n][len] = dp[node.n][len] + e.e;
					}
				}
			}
			
			int min = INF;
			for(int i = 0; i <= l; i++){
				min = Math.min(min, dp[n][i]);
			}
			System.out.println(min);
//			System.out.println(func(start, l, goal, flg));
			
		}
		
		
		sc.close();
	}
	static int func(Node node, int cap, Node goal, boolean[] flg){
		int res = 1000000000;
		if(node.equals(goal)){
			return 0;
		}
		for(Edge e : node.edges){
			if(!flg[e.t.n]){
				if(e.d > cap){
					flg[node.n] = true;
					res = Math.min(res, func(e.t, cap, goal, flg) + e.e);
					flg[node.n] = false;
				}else{
					flg[node.n] = true;
					res = Math.min(res, Math.min(func(e.t, cap - e.d, goal, flg), func(e.t, cap, goal, flg) + e.e));
					flg[node.n] = false;
				}
			}
		}
		
		return res;
	}

}
class Node implements Comparable<Node>{
	int n;
	int c;
	LinkedList<Edge> edges;
	Node(int number){
		edges = new LinkedList<Edge>();
		n = number;
		c = 0;
	}
	@Override
	public int compareTo(Node o) {
		// TODO Auto-generated method stub
		return n - o.n;
	}
}
class Edge{
	boolean flg;
	int e;
	int d;
	Node t;
	Edge(int enemy, int dist, Node to){
		e = enemy;
		d = dist;
		t = to;
		flg = false;
	}
}

</source>
</class>

<class classid="171" nclones="2" nlines="35" similarity="100">
<source file="../hum_codes_raw/s309722984.java" startline="1" endline="38" pcid="10426">
import java.util.Scanner;
 
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int[] p = new int[2];
        for (int i = 0; i < 2; i++) {
            int a1, a2, a3;
            p[i] += a1 = in.nextInt();
            p[i] += a2 = in.nextInt();
            p[i] += a3 = in.nextInt();
            for (int j = 4; j <= 10; j++) {
                int aj = in.nextInt();
                if (aj > a1) {
                    p[i] += (aj - a1);
                    int c = a1;
                    a1 = aj;
                    aj = c;
                }
                if (aj > a2) {
                    p[i] += (aj - a2);
                    int c = a2;
                    a2 = aj;
                    aj = c;
                }
                if (aj > a3) {
                    p[i] += (aj - a3);
                    int c = a3;
                    a3 = aj;
                    aj = c;
                }
            }
        }
        System.out.println(new StringBuilder().append(p[0]).append(' ')
                .append(p[1]));
    }
}

</source>
<source file="../hum_codes_raw/s821004732.java" startline="1" endline="38" pcid="27555">
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		int[] p = new int[2];
		for (int i = 0; i < 2; i++) {
			int a1, a2, a3;
			p[i] += a1 = in.nextInt();
			p[i] += a2 = in.nextInt();
			p[i] += a3 = in.nextInt();
			for (int j = 4; j <= 10; j++) {
				int aj = in.nextInt();
				if (aj > a1) {
					p[i] += (aj - a1);
					int c = a1;
					a1 = aj;
					aj = c;
				}
				if (aj > a2) {
					p[i] += (aj - a2);
					int c = a2;
					a2 = aj;
					aj = c;
				}
				if (aj > a3) {
					p[i] += (aj - a3);
					int c = a3;
					a3 = aj;
					aj = c;
				}
			}
		}
		System.out.println(new StringBuilder().append(p[0]).append(' ')
				.append(p[1]));
	}
}

</source>
</class>

<class classid="172" nclones="2" nlines="37" similarity="100">
<source file="../hum_codes_raw/s314955233.java" startline="1" endline="50" pcid="10595">
import java.util.Scanner;

class Main{
    final static int LEN = 105;
    public static void main(String args[]){
	int[][] graph = new int[LEN][LEN];
	int[] minCost = new int[LEN];
	int count=0;
	int v;
	boolean[] used = new boolean[LEN];

	Scanner in = new Scanner(System.in);

	//read
	int n = in.nextInt();
	for(int i=0; i<n; i++){
	    for(int j=0; j<n; j++){
		int k = in.nextInt();
		graph[i][j]=(k==-1? Integer.MAX_VALUE : k);
	    }
	}

	//make prim
	for(int i=0; i<n; i++){
	    minCost[i]=Integer.MAX_VALUE;
	    used[i]=false;
	}

	minCost[0]=0;

	while(true){
	    v = -1;
	    for(int i=0; i<n; i++){
		if(!used[i] && (v==-1 || minCost[i] < minCost[v]))v=i;
	    }

	    if(v==-1)break;
	    used[v]=true;
	    count+=minCost[v];

	    for(int i=0; i<n; i++){
		minCost[i]=Math.min(minCost[i], graph[v][i]);
	    }
	}

	//print
	System.out.println(count);
    }
}

</source>
<source file="../hum_codes_raw/s490587696.java" startline="1" endline="50" pcid="16477">
import java.util.Scanner;

class Main{
    final static int LEN = 105;
    public static void main(String args[]){
	int[][] graph = new int[LEN][LEN];
	int[] minCost = new int[LEN];
	int count=0;
	int v;
	boolean[] used = new boolean[LEN];

	Scanner in = new Scanner(System.in);

	//read
	int n = in.nextInt();
	for(int i=0; i<n; i++){
	    for(int j=0; j<n; j++){
		int k = in.nextInt();
		graph[i][j]=(k==-1? Integer.MAX_VALUE : k);
	    }
	}

	//make prim
	for(int i=0; i<n; i++){
	    minCost[i]=Integer.MAX_VALUE;
	    used[i]=false;
	}

	minCost[0]=0;

	while(true){
	    v = -1;
	    for(int i=0; i<n; i++){
		if(!used[i] && (v==-1 || minCost[i] < minCost[v]))v=i;
	    }

	    if(v==-1)break;
	    used[v]=true;
	    count+=minCost[v];

	    for(int i=0; i<n; i++){
		minCost[i]=Math.min(minCost[i], graph[v][i]);
	    }
	}

	//print
	System.out.println(count);
    }
}

</source>
</class>

<class classid="173" nclones="2" nlines="52" similarity="100">
<source file="../hum_codes_raw/s318955333.java" startline="1" endline="58" pcid="10702">
import java.util.Scanner;

//Lunch
public class Main {

	static int[] ans;
	static String[] name;
	static int n;
	static int[] w;
	static int[] s;
	static int[] order;
	static boolean[] used;
	static double best;
	
	static void dfs(int k, int num, int total){
		if(k==0){
			double g = num*1.0/total;
			if(g<best){
				best = g;
				for(int i=1;i<=n;i++)ans[i-1]=order[i];
			}
			return;
		}
		for(int i=0;i<n;i++){
			if(!used[i]&&total<=s[i]){
				used[i] = true;
				order[k] = i;
				dfs(k-1, num+k*w[i], total+w[i]);
				used[i] = false;
			}
		}
	}
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			n = sc.nextInt();
			if(n==0)break;
			name = new String[n];
			w = new int[n];
			s = new int[n];
			order = new int[n+1];
			best = Integer.MAX_VALUE;
			for(int i=0;i<n;i++){
				name[i] = sc.next();
				w[i] = sc.nextInt();
				s[i] = sc.nextInt();
			}
			used = new boolean[n];
			ans = new int[n];
			dfs(n, 0, 0);
			for(int i=0;i<n;i++){
				System.out.println(name[ans[i]]);
			}
		}
	}
}

</source>
<source file="../hum_codes_raw/s584602577.java" startline="1" endline="58" pcid="19615">
import java.util.Scanner;

//Lunch
public class Main{

	static int[] ans;
	static String[] name;
	static int n;
	static int[] w;
	static int[] s;
	static int[] order;
	static boolean[] used;
	static double best;
	
	static void dfs(int k, int num, int total){
		if(k==0){
			double g = num*1.0/total;
			if(g<best){
				best = g;
				for(int i=1;i<=n;i++)ans[i-1]=order[i];
			}
			return;
		}
		for(int i=0;i<n;i++){
			if(!used[i]&&total<=s[i]){
				used[i] = true;
				order[k] = i;
				dfs(k-1, num+k*w[i], total+w[i]);
				used[i] = false;
			}
		}
	}
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			n = sc.nextInt();
			if(n==0)break;
			name = new String[n];
			w = new int[n];
			s = new int[n];
			order = new int[n+1];
			best = Integer.MAX_VALUE;
			for(int i=0;i<n;i++){
				name[i] = sc.next();
				w[i] = sc.nextInt();
				s[i] = sc.nextInt();
			}
			used = new boolean[n];
			ans = new int[n];
			dfs(n, 0, 0);
			for(int i=0;i<n;i++){
				System.out.println(name[ans[i]]);
			}
		}
	}
}

</source>
</class>

<class classid="174" nclones="3" nlines="185" similarity="100">
<source file="../hum_codes_raw/s322188556.java" startline="1" endline="230" pcid="10799">
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

public class Main {

	static PrintWriter out;
	static InputReader ir;
	static boolean debug = false;
	static int s;

	static void solve() {
		for (;;) {
			int h = ir.nextInt();
			int w = ir.nextInt();
			s = ir.nextInt();
			if (h == 0 && w == 0)
				return;
			int[][] a = new int[h][];
			for (int i = 0; i < h; i++)
				a[i] = ir.nextIntArray(w);
			int[][] sum = getSumArray(a);
			int[][][][][] dp = new int[h + 1][w + 1][h + 1][w + 1][];
			int[] ret = dfs(0, 0, h, w, sum, dp);
			out.println(ret[0] + " " + (s - ret[1]));
		}
	}

	static int[] dfs(int lh, int lw, int rh, int rw, int[][] sum, int[][][][][] dp) {
		if (dp[lh][lw][rh][rw] != null)
			return dp[lh][lw][rh][rw];
		int[] ret = new int[] { -1, -1 };
		int t = sum[sum.length - 1][sum[0].length - 1] - sum(lh, lw, rh, rw, sum);
		if (sum[sum.length - 1][sum[0].length - 1] - sum(lh, lw, rh, rw, sum) <= s) {
			ret[0] = 1;
			ret[1] = t;
		} else
			return dp[lh][lw][rh][rw] = ret;
		for (int i = lh + 1; i < rh; i++) {
			int[] p = dfs(i, lw, rh, rw, sum, dp);
			int[] q = dfs(lh, lw, i, rw, sum, dp);
			if (p[0] > 0 && q[0] > 0 && p[0] + q[0] >= ret[0]) {
				if (p[0] + q[0] > ret[0]) {
					ret[0] = p[0] + q[0];
					ret[1] = Math.max(p[1], q[1]);
				} else if (ret[1] > Math.max(p[1], q[1])) {
					ret[0] = p[0] + q[0];
					ret[1] = Math.max(p[1], q[1]);
				}
			}
		}
		for (int i = lw + 1; i < rw; i++) {
			int[] p = dfs(lh, lw, rh, i, sum, dp);
			int[] q = dfs(lh, i, rh, rw, sum, dp);
			if (p[0] > 0 && q[0] > 0 && p[0] + q[0] >= ret[0]) {
				if (p[0] + q[0] > ret[0]) {
					ret[0] = p[0] + q[0];
					ret[1] = Math.max(p[1], q[1]);
				} else if (ret[1] > Math.max(p[1], q[1])) {
					ret[0] = p[0] + q[0];
					ret[1] = Math.max(p[1], q[1]);
				}
			}
		}
		return dp[lh][lw][rh][rw] = ret;
	}

	static int sum(int a, int b, int c, int d, int[][] s) {
		return s[c][d] - s[c][b] - s[a][d] + s[a][b];
	}

	public static int[][] getSumArray(int[][] a) {
		int h = a.length, w = a[0].length;
		int[][] ret = new int[h + 1][w + 1];
		for (int i = 0; i < h; i++)
			for (int j = 0; j < w; j++)
				ret[i + 1][j + 1] = a[i][j];
		for (int i = 0; i <= h; i++)
			for (int j = 0; j < w; j++)
				ret[i][j + 1] += ret[i][j];
		for (int i = 0; i < h; i++)
			for (int j = 0; j <= w; j++)
				ret[i + 1][j] += ret[i][j];
		return ret;
	}

	public static void main(String[] args) throws Exception {
		ir = new InputReader(System.in);
		out = new PrintWriter(System.out);
		solve();
		out.flush();
	}

	static class InputReader {

		private InputStream in;
		private byte[] buffer = new byte[1024];
		private int curbuf;
		private int lenbuf;

		public InputReader(InputStream in) {
			this.in = in;
			this.curbuf = this.lenbuf = 0;
		}

		public boolean hasNextByte() {
			if (curbuf >= lenbuf) {
				curbuf = 0;
				try {
					lenbuf = in.read(buffer);
				} catch (IOException e) {
					throw new InputMismatchException();
				}
				if (lenbuf <= 0)
					return false;
			}
			return true;
		}

		private int readByte() {
			if (hasNextByte())
				return buffer[curbuf++];
			else
				return -1;
		}

		private boolean isSpaceChar(int c) {
			return !(c >= 33 && c <= 126);
		}

		private void skip() {
			while (hasNextByte() && isSpaceChar(buffer[curbuf]))
				curbuf++;
		}

		public boolean hasNext() {
			skip();
			return hasNextByte();
		}

		public String next() {
			if (!hasNext())
				throw new NoSuchElementException();
			StringBuilder sb = new StringBuilder();
			int b = readByte();
			while (!isSpaceChar(b)) {
				sb.appendCodePoint(b);
				b = readByte();
			}
			return sb.toString();
		}

		public int nextInt() {
			if (!hasNext())
				throw new NoSuchElementException();
			int c = readByte();
			while (isSpaceChar(c))
				c = readByte();
			boolean minus = false;
			if (c == '-') {
				minus = true;
				c = readByte();
			}
			int res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res = res * 10 + c - '0';
				c = readByte();
			} while (!isSpaceChar(c));
			return (minus) ? -res : res;
		}

		public long nextLong() {
			if (!hasNext())
				throw new NoSuchElementException();
			int c = readByte();
			while (isSpaceChar(c))
				c = readByte();
			boolean minus = false;
			if (c == '-') {
				minus = true;
				c = readByte();
			}
			long res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res = res * 10 + c - '0';
				c = readByte();
			} while (!isSpaceChar(c));
			return (minus) ? -res : res;
		}

		public double nextDouble() {
			return Double.parseDouble(next());
		}

		public int[] nextIntArray(int n) {
			int[] a = new int[n];
			for (int i = 0; i < n; i++)
				a[i] = nextInt();
			return a;
		}

		public long[] nextLongArray(int n) {
			long[] a = new long[n];
			for (int i = 0; i < n; i++)
				a[i] = nextLong();
			return a;
		}

		public char[][] nextCharMap(int n, int m) {
			char[][] map = new char[n][m];
			for (int i = 0; i < n; i++)
				map[i] = next().toCharArray();
			return map;
		}
	}

	static void tr(Object... o) {
		if (debug)
			out.println(Arrays.deepToString(o));
	}
}


</source>
<source file="../hum_codes_raw/s365157941.java" startline="1" endline="230" pcid="12263">
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

public class Main {

	static PrintWriter out;
	static InputReader ir;
	static boolean debug = false;
	static int s;

	static void solve() {
		for (;;) {
			int h = ir.nextInt();
			int w = ir.nextInt();
			s = ir.nextInt();
			if (h == 0 && w == 0)
				return;
			int[][] a = new int[h][];
			for (int i = 0; i < h; i++)
				a[i] = ir.nextIntArray(w);
			int[][] sum = getSumArray(a);
			int[][][][][] dp = new int[h + 1][w + 1][h + 1][w + 1][];
			int[] ret = dfs(0, 0, h, w, sum, dp);
			out.println(ret[0] + " " + (s - ret[1]));
		}
	}

	static int[] dfs(int lh, int lw, int rh, int rw, int[][] sum, int[][][][][] dp) {
		if (dp[lh][lw][rh][rw] != null)
			return dp[lh][lw][rh][rw];
		int[] ret = new int[] { -1, -1 };
		int t = sum[sum.length - 1][sum[0].length - 1] - sum(lh, lw, rh, rw, sum);
		if (sum[sum.length - 1][sum[0].length - 1] - sum(lh, lw, rh, rw, sum) <= s) {
			ret[0] = 1;
			ret[1] = t;
		} else
			return dp[lh][lw][rh][rw] = ret;
		for (int i = lh + 1; i < rh; i++) {
			int[] p = dfs(i, lw, rh, rw, sum, dp);
			int[] q = dfs(lh, lw, i, rw, sum, dp);
			if (p[0] > 0 && q[0] > 0 && p[0] + q[0] >= ret[0]) {
				if (p[0] + q[0] > ret[0]) {
					ret[0] = p[0] + q[0];
					ret[1] = Math.max(p[1], q[1]);
				} else if (ret[1] > Math.max(p[1], q[1])) {
					ret[0] = p[0] + q[0];
					ret[1] = Math.max(p[1], q[1]);
				}
			}
		}
		for (int i = lw + 1; i < rw; i++) {
			int[] p = dfs(lh, lw, rh, i, sum, dp);
			int[] q = dfs(lh, i, rh, rw, sum, dp);
			if (p[0] > 0 && q[0] > 0 && p[0] + q[0] >= ret[0]) {
				if (p[0] + q[0] > ret[0]) {
					ret[0] = p[0] + q[0];
					ret[1] = Math.max(p[1], q[1]);
				} else if (ret[1] > Math.max(p[1], q[1])) {
					ret[0] = p[0] + q[0];
					ret[1] = Math.max(p[1], q[1]);
				}
			}
		}
		return dp[lh][lw][rh][rw] = ret;
	}

	static int sum(int a, int b, int c, int d, int[][] s) {
		return s[c][d] - s[c][b] - s[a][d] + s[a][b];
	}

	public static int[][] getSumArray(int[][] a) {
		int h = a.length, w = a[0].length;
		int[][] ret = new int[h + 1][w + 1];
		for (int i = 0; i < h; i++)
			for (int j = 0; j < w; j++)
				ret[i + 1][j + 1] = a[i][j];
		for (int i = 0; i <= h; i++)
			for (int j = 0; j < w; j++)
				ret[i][j + 1] += ret[i][j];
		for (int i = 0; i < h; i++)
			for (int j = 0; j <= w; j++)
				ret[i + 1][j] += ret[i][j];
		return ret;
	}

	public static void main(String[] args) throws Exception {
		ir = new InputReader(System.in);
		out = new PrintWriter(System.out);
		solve();
		out.flush();
	}

	static class InputReader {

		private InputStream in;
		private byte[] buffer = new byte[1024];
		private int curbuf;
		private int lenbuf;

		public InputReader(InputStream in) {
			this.in = in;
			this.curbuf = this.lenbuf = 0;
		}

		public boolean hasNextByte() {
			if (curbuf >= lenbuf) {
				curbuf = 0;
				try {
					lenbuf = in.read(buffer);
				} catch (IOException e) {
					throw new InputMismatchException();
				}
				if (lenbuf <= 0)
					return false;
			}
			return true;
		}

		private int readByte() {
			if (hasNextByte())
				return buffer[curbuf++];
			else
				return -1;
		}

		private boolean isSpaceChar(int c) {
			return !(c >= 33 && c <= 126);
		}

		private void skip() {
			while (hasNextByte() && isSpaceChar(buffer[curbuf]))
				curbuf++;
		}

		public boolean hasNext() {
			skip();
			return hasNextByte();
		}

		public String next() {
			if (!hasNext())
				throw new NoSuchElementException();
			StringBuilder sb = new StringBuilder();
			int b = readByte();
			while (!isSpaceChar(b)) {
				sb.appendCodePoint(b);
				b = readByte();
			}
			return sb.toString();
		}

		public int nextInt() {
			if (!hasNext())
				throw new NoSuchElementException();
			int c = readByte();
			while (isSpaceChar(c))
				c = readByte();
			boolean minus = false;
			if (c == '-') {
				minus = true;
				c = readByte();
			}
			int res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res = res * 10 + c - '0';
				c = readByte();
			} while (!isSpaceChar(c));
			return (minus) ? -res : res;
		}

		public long nextLong() {
			if (!hasNext())
				throw new NoSuchElementException();
			int c = readByte();
			while (isSpaceChar(c))
				c = readByte();
			boolean minus = false;
			if (c == '-') {
				minus = true;
				c = readByte();
			}
			long res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res = res * 10 + c - '0';
				c = readByte();
			} while (!isSpaceChar(c));
			return (minus) ? -res : res;
		}

		public double nextDouble() {
			return Double.parseDouble(next());
		}

		public int[] nextIntArray(int n) {
			int[] a = new int[n];
			for (int i = 0; i < n; i++)
				a[i] = nextInt();
			return a;
		}

		public long[] nextLongArray(int n) {
			long[] a = new long[n];
			for (int i = 0; i < n; i++)
				a[i] = nextLong();
			return a;
		}

		public char[][] nextCharMap(int n, int m) {
			char[][] map = new char[n][m];
			for (int i = 0; i < n; i++)
				map[i] = next().toCharArray();
			return map;
		}
	}

	static void tr(Object... o) {
		if (debug)
			out.println(Arrays.deepToString(o));
	}
}


</source>
<source file="../hum_codes_raw/s888621240.java" startline="1" endline="230" pcid="29881">
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

public class Main {

	static PrintWriter out;
	static InputReader ir;
	static boolean debug = false;
	static int s;

	static void solve() {
		for (;;) {
			int h = ir.nextInt();
			int w = ir.nextInt();
			s = ir.nextInt();
			if (h == 0 && w == 0)
				return;
			int[][] a = new int[h][];
			for (int i = 0; i < h; i++)
				a[i] = ir.nextIntArray(w);
			int[][] sum = getSumArray(a);
			int[][][][][] dp = new int[h + 1][w + 1][h + 1][w + 1][];
			int[] ret = dfs(0, 0, h, w, sum, dp);
			out.println(ret[0] + " " + (s - ret[1]));
		}
	}

	static int[] dfs(int lh, int lw, int rh, int rw, int[][] sum, int[][][][][] dp) {
		if (dp[lh][lw][rh][rw] != null)
			return dp[lh][lw][rh][rw];
		int[] ret = new int[] { -1, -1 };
		int t = sum[sum.length - 1][sum[0].length - 1] - sum(lh, lw, rh, rw, sum);
		if (sum[sum.length - 1][sum[0].length - 1] - sum(lh, lw, rh, rw, sum) <= s) {
			ret[0] = 1;
			ret[1] = t;
		} else
			return dp[lh][lw][rh][rw] = ret;
		for (int i = lh + 1; i < rh; i++) {
			int[] p = dfs(i, lw, rh, rw, sum, dp);
			int[] q = dfs(lh, lw, i, rw, sum, dp);
			if (p[0] > 0 && q[0] > 0 && p[0] + q[0] >= ret[0]) {
				if (p[0] + q[0] > ret[0]) {
					ret[0] = p[0] + q[0];
					ret[1] = Math.max(p[1], q[1]);
				} else if (ret[1] > Math.max(p[1], q[1])) {
					ret[0] = p[0] + q[0];
					ret[1] = Math.max(p[1], q[1]);
				}
			}
		}
		for (int i = lw + 1; i < rw; i++) {
			int[] p = dfs(lh, lw, rh, i, sum, dp);
			int[] q = dfs(lh, i, rh, rw, sum, dp);
			if (p[0] > 0 && q[0] > 0 && p[0] + q[0] >= ret[0]) {
				if (p[0] + q[0] > ret[0]) {
					ret[0] = p[0] + q[0];
					ret[1] = Math.max(p[1], q[1]);
				} else if (ret[1] > Math.max(p[1], q[1])) {
					ret[0] = p[0] + q[0];
					ret[1] = Math.max(p[1], q[1]);
				}
			}
		}
		return dp[lh][lw][rh][rw] = ret;
	}

	static int sum(int a, int b, int c, int d, int[][] s) {
		return s[c][d] - s[c][b] - s[a][d] + s[a][b];
	}

	public static int[][] getSumArray(int[][] a) {
		int h = a.length, w = a[0].length;
		int[][] ret = new int[h + 1][w + 1];
		for (int i = 0; i < h; i++)
			for (int j = 0; j < w; j++)
				ret[i + 1][j + 1] = a[i][j];
		for (int i = 0; i <= h; i++)
			for (int j = 0; j < w; j++)
				ret[i][j + 1] += ret[i][j];
		for (int i = 0; i < h; i++)
			for (int j = 0; j <= w; j++)
				ret[i + 1][j] += ret[i][j];
		return ret;
	}

	public static void main(String[] args) throws Exception {
		ir = new InputReader(System.in);
		out = new PrintWriter(System.out);
		solve();
		out.flush();
	}

	static class InputReader {

		private InputStream in;
		private byte[] buffer = new byte[1024];
		private int curbuf;
		private int lenbuf;

		public InputReader(InputStream in) {
			this.in = in;
			this.curbuf = this.lenbuf = 0;
		}

		public boolean hasNextByte() {
			if (curbuf >= lenbuf) {
				curbuf = 0;
				try {
					lenbuf = in.read(buffer);
				} catch (IOException e) {
					throw new InputMismatchException();
				}
				if (lenbuf <= 0)
					return false;
			}
			return true;
		}

		private int readByte() {
			if (hasNextByte())
				return buffer[curbuf++];
			else
				return -1;
		}

		private boolean isSpaceChar(int c) {
			return !(c >= 33 && c <= 126);
		}

		private void skip() {
			while (hasNextByte() && isSpaceChar(buffer[curbuf]))
				curbuf++;
		}

		public boolean hasNext() {
			skip();
			return hasNextByte();
		}

		public String next() {
			if (!hasNext())
				throw new NoSuchElementException();
			StringBuilder sb = new StringBuilder();
			int b = readByte();
			while (!isSpaceChar(b)) {
				sb.appendCodePoint(b);
				b = readByte();
			}
			return sb.toString();
		}

		public int nextInt() {
			if (!hasNext())
				throw new NoSuchElementException();
			int c = readByte();
			while (isSpaceChar(c))
				c = readByte();
			boolean minus = false;
			if (c == '-') {
				minus = true;
				c = readByte();
			}
			int res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res = res * 10 + c - '0';
				c = readByte();
			} while (!isSpaceChar(c));
			return (minus) ? -res : res;
		}

		public long nextLong() {
			if (!hasNext())
				throw new NoSuchElementException();
			int c = readByte();
			while (isSpaceChar(c))
				c = readByte();
			boolean minus = false;
			if (c == '-') {
				minus = true;
				c = readByte();
			}
			long res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res = res * 10 + c - '0';
				c = readByte();
			} while (!isSpaceChar(c));
			return (minus) ? -res : res;
		}

		public double nextDouble() {
			return Double.parseDouble(next());
		}

		public int[] nextIntArray(int n) {
			int[] a = new int[n];
			for (int i = 0; i < n; i++)
				a[i] = nextInt();
			return a;
		}

		public long[] nextLongArray(int n) {
			long[] a = new long[n];
			for (int i = 0; i < n; i++)
				a[i] = nextLong();
			return a;
		}

		public char[][] nextCharMap(int n, int m) {
			char[][] map = new char[n][m];
			for (int i = 0; i < n; i++)
				map[i] = next().toCharArray();
			return map;
		}
	}

	static void tr(Object... o) {
		if (debug)
			out.println(Arrays.deepToString(o));
	}
}


</source>
</class>

<class classid="175" nclones="2" nlines="46" similarity="100">
<source file="../hum_codes_raw/s323090943.java" startline="1" endline="58" pcid="10837">

import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int   n = sc.nextInt();
        
        // 二分ヒープ
        int[] h = new int[n+1];
        
        h[0] = Integer.MIN_VALUE;
        for (int i = 1; i <= n; i++) {
            h[i] = sc.nextInt();
        }
        
        // 最大ヒープを構築する。
        for (int i = n/2; i >= 1; i--) {
            maxHeapify(h, i);
        }
        for (int i = 1; i <= n; i++) {
            System.out.print(" " + h[i]);
        }
        System.out.println();
    }
    
    static void maxHeapify(int[] h, int idx) {
        int n = h.length - 1;
        int l = l(idx);
        int r = r(idx);
        // 左の子、自分、右の子で値が最大のノードを選ぶ
        int maxNodeIdx = 0;
        if (l <= n && h[l] > h[idx]) {
            maxNodeIdx = l;
        } else {
            maxNodeIdx = idx;
        }
        if (r <= n && h[r] > h[maxNodeIdx]) {
            maxNodeIdx = r;
        }
        // 子の方が値が大きい場合
        if (maxNodeIdx != idx) {
            int temp = h[idx];
            h[idx]        = h[maxNodeIdx];
            h[maxNodeIdx] = temp;
            maxHeapify(h, maxNodeIdx);
        }
    }
    
    static int l(int i) {
        return 2*i;
    }
    static int r(int i) {
        return 2*i + 1;
    }
}


</source>
<source file="../hum_codes_raw/s973271954.java" startline="1" endline="52" pcid="32754">
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int   n = sc.nextInt();
        
        int[] h = new int[n+1];
        
        h[0] = Integer.MIN_VALUE;
        for (int i = 1; i <= n; i++) {
            h[i] = sc.nextInt();
        }
        
        for (int i = n/2; i >= 1; i--) {
            maxHeapify(h, i);
        }
        for (int i = 1; i <= n; i++) {
            System.out.print(" " + h[i]);
        }
        System.out.println();
    }
    
    static void maxHeapify(int[] h, int idx) {
        int n = h.length - 1;
        int l = l(idx);
        int r = r(idx);
        int maxNodeIdx = 0;
        if (l <= n && h[l] > h[idx]) {
            maxNodeIdx = l;
        } else {
            maxNodeIdx = idx;
        }
        if (r <= n && h[r] > h[maxNodeIdx]) {
            maxNodeIdx = r;
        }
        if (maxNodeIdx != idx) {
            int temp = h[idx];
            h[idx]        = h[maxNodeIdx];
            h[maxNodeIdx] = temp;
            maxHeapify(h, maxNodeIdx);
        }
    }
    
    static int l(int i) {
        return 2*i;
    }
    static int r(int i) {
        return 2*i + 1;
    }
}

</source>
</class>

<class classid="176" nclones="2" nlines="42" similarity="100">
<source file="../hum_codes_raw/s325955835.java" startline="1" endline="40" pcid="10919">

import java.util.*;
public class Main {
    static Scanner sc = new Scanner(System.in);//XLipÌÏ
    static double time_of_500m, time_of_1000m;//^Cði[·éÏ
    public static void main(String[] args) {
        while(sc.hasNextDouble()){//Ìsª éÈçÇÝæèÆ»èðÀs
            read();//ÇÝæè
            slove();//»è
        }
    }
    static boolean read(){
        time_of_500m = sc.nextDouble();//ÇÝæè
        time_of_1000m = sc.nextDouble();//ÇÝæè
        return true;
    }
    static void slove(){
        //System.out.println(time_of_500m);fobOpÈÌÅCÉµÈ¢Å­¾³¢
        //System.out.println(time_of_1000m);fobOpÈÌÅCÉµÈ¢Å­¾³¢
        //±±©çÍüÍÉÎµÄif¶Åðð»èµÄ¢Ü·B
        if(time_of_500m < 35.5 && time_of_1000m < 71.0){
            System.out.println("AAA");
        }else if(time_of_500m < 37.5 && time_of_1000m < 77.0){
            System.out.println("AA");
        }else if(time_of_500m < 40.0 && time_of_1000m < 83.0){
            System.out.println("A");
        }else if(time_of_500m < 43.0 && time_of_1000m < 89.0){
            System.out.println("B");
        }else if(time_of_500m < 50.0 && time_of_1000m < 105.0){
            System.out.println("C");
        }else if(time_of_500m < 55.0 && time_of_1000m < 116.0){
            System.out.println("D");
        }else if(time_of_500m < 70.0 && time_of_1000m < 148.0){
            System.out.println("E");
        }else{
            System.out.println("NA");
        }
    }
}

</source>
<source file="../hum_codes_raw/s666083294.java" startline="1" endline="40" pcid="22366">
import java.util.*;
public class Main {
	static Scanner sc = new Scanner(System.in);//XLipÌÏ
	static double time_of_500m, time_of_1000m;//^Cði[·éÏ
	public static void main(String[] args) {
		while(sc.hasNextDouble()){//Ìsª éÈçÇÝæèÆ»èðÀs
			read();//ÇÝæè
			slove();//»è
		}
		
	}
	static boolean read(){
		time_of_500m = sc.nextDouble();//ÇÝæè
		time_of_1000m = sc.nextDouble();//ÇÝæè
		return true;
	}
	static void slove(){
		//System.out.println(time_of_500m);fobOpÈÌÅCÉµÈ¢Å­¾³¢
		//System.out.println(time_of_1000m);fobOpÈÌÅCÉµÈ¢Å­¾³¢
		//±±©çÍüÍÉÎµÄif¶Åðð»èµÄ¢Ü·B
		if(time_of_500m < 35.5 && time_of_1000m < 71.0){
			System.out.println("AAA");
		}else if(time_of_500m < 37.5 && time_of_1000m < 77.0){
			System.out.println("AA");
		}else if(time_of_500m < 40.0 && time_of_1000m < 83.0){
			System.out.println("A");
		}else if(time_of_500m < 43.0 && time_of_1000m < 89.0){
			System.out.println("B");
		}else if(time_of_500m < 50.0 && time_of_1000m < 105.0){
			System.out.println("C");
		}else if(time_of_500m < 55.0 && time_of_1000m < 116.0){
			System.out.println("D");
		}else if(time_of_500m < 70.0 && time_of_1000m < 148.0){
			System.out.println("E");
		}else{
			System.out.println("NA");
		}
	}
}

</source>
</class>

<class classid="177" nclones="2" nlines="40" similarity="100">
<source file="../hum_codes_raw/s330022854.java" startline="1" endline="46" pcid="11042">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.MathContext;
import java.text.BreakIterator;
import java.util.Arrays;
import java.util.StringTokenizer;

public class Main{

	static int n, m;
	static char[][] a;
	static boolean[][] ok;
	static int[] dx = new int[] { -1, 0, 1, 0, -1, -1, 1, 1 };
	static int[] dy = new int[] { 0, 1, 0, -1, -1, 1, -1, 1 };
	static int A, B, C;

	public static void main(String[] args) throws IOException {

		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		PrintWriter pw = new PrintWriter(System.out);
		StringTokenizer st = new StringTokenizer(br.readLine());
		int n = Integer.parseInt(st.nextToken());
		int m = Integer.parseInt(st.nextToken());
		if (n % 2 == 1) {
			for (int i = 1; i <= m; i++) {
				pw.println(i + " " + (n - i + 1));
			}
		} else {
			int odd = (m + 1) / 2;
			for (int i = 1; i <= odd ; i++) {
				pw.println(i + " " + (n - i + 1));
			}
			for (int i = odd+1; i <= m; i++) {
				pw.println(i + " " + (n - i));
			}
		}

		pw.flush();
	}

}

</source>
<source file="../hum_codes_raw/s769338576.java" startline="1" endline="46" pcid="25831">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.MathContext;
import java.text.BreakIterator;
import java.util.Arrays;
import java.util.StringTokenizer;

public class Main {

	static int n, m;
	static char[][] a;
	static boolean[][] ok;
	static int[] dx = new int[] { -1, 0, 1, 0, -1, -1, 1, 1 };
	static int[] dy = new int[] { 0, 1, 0, -1, -1, 1, -1, 1 };
	static int A, B, C;

	public static void main(String[] args) throws IOException {

		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		PrintWriter pw = new PrintWriter(System.out);
		StringTokenizer st = new StringTokenizer(br.readLine());
		int n = Integer.parseInt(st.nextToken());
		int m = Integer.parseInt(st.nextToken());
		if (n % 2 == 1) {
			for (int i = 1; i <= m; i++) {
				pw.println(i + " " + (n - i + 1));
			}
		} else {
			int odd = (m + 1) / 2;
			for (int i = 1; i <= odd ; i++) {
				pw.println(i + " " + (n - i + 1));
			}
			for (int i = odd+1; i <= m; i++) {
				pw.println(i + " " + (n - i));
			}
		}

		pw.flush();
	}

}

</source>
</class>

<class classid="178" nclones="2" nlines="417" similarity="100">
<source file="../hum_codes_raw/s330468875.java" startline="1" endline="484" pcid="11063">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Deque;
import java.util.ArrayList;
import java.math.BigDecimal;
import java.util.Map;
import java.io.OutputStreamWriter;
import java.io.OutputStream;
import java.io.PrintStream;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.util.List;
import java.io.Closeable;
import java.io.Writer;
import java.util.Comparator;
import java.util.ArrayDeque;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            CHoles solver = new CHoles();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class CHoles {
        Debug debug = new Debug(false);

        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            Point2D[] pts = new Point2D[n];
            for (int i = 0; i < n; i++) {
                pts[i] = new Point2D(in.readInt(), in.readInt());
            }

            if (n == 2) {
                for (int i = 0; i < 2; i++) {
                    out.println(0.5);
                }
                return;
            }

            PointPolygon pointPolygon = new PointPolygon(Arrays.asList(pts));
            PointConvexHull ch = PointConvexHull.grahamScan(pointPolygon);
            List<Point2D> outside = ch.getData();
            Map<Point2D, Double> prob = new HashMap<>(n);
            KahanSummation sum = new KahanSummation();
            if (outside.size() == 2) {
                for (Point2D pt : outside) {
                    prob.put(pt, 0.5);
                }
                sum.add(1);
            } else {
                for (int i = 0; i < outside.size(); i++) {
                    Point2D a = outside.get(i);
                    Point2D b = outside.get(DigitUtils.mod(i - 1, outside.size()));
                    Point2D c = outside.get(DigitUtils.mod(i + 1, outside.size()));
                    double ab = a.distanceBetween(b);
                    double ac = a.distanceBetween(c);
                    double bc = b.distanceBetween(c);
                    double ans = Math.PI - GeometryUtils.triangleAngle(bc, ab, ac);
                    prob.put(a, ans);
                    sum.add(ans);
                }
            }

            debug.debug("sum", sum);
            for (Point2D pt : pts) {
                double ans = prob.getOrDefault(pt, 0D);
                ans /= sum.sum();
                out.println(ans);
            }
        }

    }

    static class DigitUtils {
        private DigitUtils() {
        }

        public static int mod(int x, int mod) {
            x %= mod;
            if (x < 0) {
                x += mod;
            }
            return x;
        }

    }

    static class Point2D {
        public final double x;
        public final double y;

        public Point2D(double x, double y) {
            this.x = x;//GeometryUtils.valueOf(x);
            this.y = y;//GeometryUtils.valueOf(y);
        }

        public double distance2Between(Point2D another) {
            double dx = x - another.x;
            double dy = y - another.y;
            return dx * dx + dy * dy;
        }

        public double distanceBetween(Point2D another) {
            return Math.sqrt(distance2Between(another));
        }

        public double cross(Point2D a, Point2D b) {
            return GeometryUtils.cross(a.x - x, a.y - y, b.x - x, b.y - y);
        }

        public String toString() {
            return String.format("(%f, %f)", x, y);
        }

        public int hashCode() {
            return (int) (Double.doubleToLongBits(x) * 31 + Double.doubleToLongBits(y));
        }

        public boolean equals(Object obj) {
            Point2D other = (Point2D) obj;
            return x == other.x && y == other.y;
        }

    }

    static class PointConvexHull extends PointPolygon {
        PointConvexHull(List<Point2D> points) {
            super(points);
        }

        public static PointConvexHull grahamScan(PointPolygon pointPolygon) {
            final Point2D[] points = pointPolygon.data.toArray(new Point2D[0]);
            int n = points.length;
            for (int i = 1; i < n; i++) {
                int cmp = points[i].y != points[0].y ? Double.compare(points[i].y, points[0].y)
                        : Double.compare(points[i].x, points[0].x);
                if (cmp >= 0) {
                    continue;
                }
                Point2D tmp = points[0];
                points[0] = points[i];
                points[i] = tmp;
            }


            Comparator<Point2D> cmp = new Comparator<Point2D>() {

                public int compare(Point2D o1, Point2D o2) {
                    return GeometryUtils.signOf(GeometryUtils.valueOf(-points[0].cross(o1, o2)));
                }
            };
            Arrays.sort(points, 1, n, cmp);

            int shrinkSize = 2;
            for (int i = 2; i < n; i++) {
                if (cmp.compare(points[i], points[shrinkSize - 1]) == 0) {
                    if (points[i].distance2Between(points[0]) > points[shrinkSize - 1].distance2Between(points[0])) {
                        points[shrinkSize - 1] = points[i];
                    }
                } else {
                    points[shrinkSize++] = points[i];
                }
            }

            n = shrinkSize;
            Deque<Point2D> stack = new ArrayDeque(n);
            stack.addLast(points[0]);
            for (int i = 1; i < n; i++) {
                while (stack.size() >= 2) {
                    Point2D last = stack.removeLast();
                    Point2D second = stack.peekLast();
                    if (GeometryUtils.valueOf(second.cross(points[i], last)) < 0) {
                        stack.addLast(last);
                        break;
                    }
                }
                stack.addLast(points[i]);
            }

            return new PointConvexHull(new ArrayList(stack));
        }

    }

    static class Debug {
        private boolean offline;
        private PrintStream out = System.err;
        static int[] empty = new int[0];

        public Debug(boolean enable) {
            offline = enable && System.getSecurityManager() == null;
        }

        public Debug debug(String name, Object x) {
            return debug(name, x, empty);
        }

        public Debug debug(String name, Object x, int... indexes) {
            if (offline) {
                if (x == null || !x.getClass().isArray()) {
                    out.append(name);
                    for (int i : indexes) {
                        out.printf("[%d]", i);
                    }
                    out.append("=").append("" + x);
                    out.println();
                } else {
                    indexes = Arrays.copyOf(indexes, indexes.length + 1);
                    if (x instanceof byte[]) {
                        byte[] arr = (byte[]) x;
                        for (int i = 0; i < arr.length; i++) {
                            indexes[indexes.length - 1] = i;
                            debug(name, arr[i], indexes);
                        }
                    } else if (x instanceof short[]) {
                        short[] arr = (short[]) x;
                        for (int i = 0; i < arr.length; i++) {
                            indexes[indexes.length - 1] = i;
                            debug(name, arr[i], indexes);
                        }
                    } else if (x instanceof boolean[]) {
                        boolean[] arr = (boolean[]) x;
                        for (int i = 0; i < arr.length; i++) {
                            indexes[indexes.length - 1] = i;
                            debug(name, arr[i], indexes);
                        }
                    } else if (x instanceof char[]) {
                        char[] arr = (char[]) x;
                        for (int i = 0; i < arr.length; i++) {
                            indexes[indexes.length - 1] = i;
                            debug(name, arr[i], indexes);
                        }
                    } else if (x instanceof int[]) {
                        int[] arr = (int[]) x;
                        for (int i = 0; i < arr.length; i++) {
                            indexes[indexes.length - 1] = i;
                            debug(name, arr[i], indexes);
                        }
                    } else if (x instanceof float[]) {
                        float[] arr = (float[]) x;
                        for (int i = 0; i < arr.length; i++) {
                            indexes[indexes.length - 1] = i;
                            debug(name, arr[i], indexes);
                        }
                    } else if (x instanceof double[]) {
                        double[] arr = (double[]) x;
                        for (int i = 0; i < arr.length; i++) {
                            indexes[indexes.length - 1] = i;
                            debug(name, arr[i], indexes);
                        }
                    } else if (x instanceof long[]) {
                        long[] arr = (long[]) x;
                        for (int i = 0; i < arr.length; i++) {
                            indexes[indexes.length - 1] = i;
                            debug(name, arr[i], indexes);
                        }
                    } else {
                        Object[] arr = (Object[]) x;
                        for (int i = 0; i < arr.length; i++) {
                            indexes[indexes.length - 1] = i;
                            debug(name, arr[i], indexes);
                        }
                    }
                }
            }
            return this;
        }

    }

    static class PointPolygon extends Polygon<Point2D> {
        public PointPolygon(List<Point2D> points) {
            super(points);
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(double c) {
            cache.append(new BigDecimal(c).toPlainString());
            return this;
        }

        public FastOutput println(double c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class Polygon<T> {
        protected List<T> data;

        protected Polygon(List<T> data) {
            this.data = data;
        }

        public List<T> getData() {
            return data;
        }

    }

    static class GeometryUtils {
        public static final double PREC = 1e-15;

        public static double valueOf(double x) {
            return x > -PREC && x < PREC ? 0 : x;
        }

        public static double triangleAngle(double a, double b, double c) {
            double cosa = (b * b + c * c - a * a) / (2 * b * c);
            return Math.acos(cosa);
        }

        public static double cross(double x1, double y1, double x2, double y2) {
            return valueOf(x1 * y2 - y1 * x2);
        }

        public static int signOf(double x) {
            return x > 0 ? 1 : x < 0 ? -1 : 0;
        }

    }

    static class KahanSummation {
        private double error;
        private double sum;

        public double sum() {
            return sum;
        }

        public void add(double x) {
            x = x - error;
            double t = sum + x;
            error = (t - sum) - x;
            sum = t;
        }

        public String toString() {
            return new BigDecimal(sum).toString();
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }
}


</source>
<source file="../hum_codes_raw/s428749243.java" startline="1" endline="484" pcid="14407">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Deque;
import java.util.ArrayList;
import java.math.BigDecimal;
import java.util.Map;
import java.io.OutputStreamWriter;
import java.io.OutputStream;
import java.io.PrintStream;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.util.List;
import java.io.Closeable;
import java.io.Writer;
import java.util.Comparator;
import java.util.ArrayDeque;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            CHoles solver = new CHoles();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class CHoles {
        Debug debug = new Debug(false);

        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            Point2D[] pts = new Point2D[n];
            for (int i = 0; i < n; i++) {
                pts[i] = new Point2D(in.readInt(), in.readInt());
            }

            if (n == 2) {
                for (int i = 0; i < 2; i++) {
                    out.println(0.5);
                }
                return;
            }

            PointPolygon pointPolygon = new PointPolygon(Arrays.asList(pts));
            PointConvexHull ch = PointConvexHull.grahamScan(pointPolygon);
            List<Point2D> outside = ch.getData();
            Map<Point2D, Double> prob = new HashMap<>(n);
            KahanSummation sum = new KahanSummation();
            if (outside.size() == 2) {
                for (Point2D pt : outside) {
                    prob.put(pt, 0.5);
                }
                sum.add(1);
            } else {
                for (int i = 0; i < outside.size(); i++) {
                    Point2D a = outside.get(i);
                    Point2D b = outside.get(DigitUtils.mod(i - 1, outside.size()));
                    Point2D c = outside.get(DigitUtils.mod(i + 1, outside.size()));
                    double ab = a.distanceBetween(b);
                    double ac = a.distanceBetween(c);
                    double bc = b.distanceBetween(c);
                    double ans = Math.PI - GeometryUtils.triangleAngle(bc, ab, ac);
                    prob.put(a, ans);
                    sum.add(ans);
                }
            }

            debug.debug("sum", sum);
            for (Point2D pt : pts) {
                double ans = prob.getOrDefault(pt, 0D);
                ans /= sum.sum();
                out.println(ans);
            }
        }

    }

    static class DigitUtils {
        private DigitUtils() {
        }

        public static int mod(int x, int mod) {
            x %= mod;
            if (x < 0) {
                x += mod;
            }
            return x;
        }

    }

    static class Point2D {
        public final double x;
        public final double y;

        public Point2D(double x, double y) {
            this.x = x;//GeometryUtils.valueOf(x);
            this.y = y;//GeometryUtils.valueOf(y);
        }

        public double distance2Between(Point2D another) {
            double dx = x - another.x;
            double dy = y - another.y;
            return dx * dx + dy * dy;
        }

        public double distanceBetween(Point2D another) {
            return Math.sqrt(distance2Between(another));
        }

        public double cross(Point2D a, Point2D b) {
            return GeometryUtils.cross(a.x - x, a.y - y, b.x - x, b.y - y);
        }

        public String toString() {
            return String.format("(%f, %f)", x, y);
        }

        public int hashCode() {
            return (int) (Double.doubleToLongBits(x) * 31 + Double.doubleToLongBits(y));
        }

        public boolean equals(Object obj) {
            Point2D other = (Point2D) obj;
            return x == other.x && y == other.y;
        }

    }

    static class PointConvexHull extends PointPolygon {
        PointConvexHull(List<Point2D> points) {
            super(points);
        }

        public static PointConvexHull grahamScan(PointPolygon pointPolygon) {
            final Point2D[] points = pointPolygon.data.toArray(new Point2D[0]);
            int n = points.length;
            for (int i = 1; i < n; i++) {
                int cmp = points[i].y != points[0].y ? Double.compare(points[i].y, points[0].y)
                        : Double.compare(points[i].x, points[0].x);
                if (cmp >= 0) {
                    continue;
                }
                Point2D tmp = points[0];
                points[0] = points[i];
                points[i] = tmp;
            }


            Comparator<Point2D> cmp = new Comparator<Point2D>() {

                public int compare(Point2D o1, Point2D o2) {
                    return GeometryUtils.signOf(GeometryUtils.valueOf(-points[0].cross(o1, o2)));
                }
            };
            Arrays.sort(points, 1, n, cmp);

            int shrinkSize = 2;
            for (int i = 2; i < n; i++) {
                if (cmp.compare(points[i], points[shrinkSize - 1]) == 0) {
                    if (points[i].distance2Between(points[0]) > points[shrinkSize - 1].distance2Between(points[0])) {
                        points[shrinkSize - 1] = points[i];
                    }
                } else {
                    points[shrinkSize++] = points[i];
                }
            }

            n = shrinkSize;
            Deque<Point2D> stack = new ArrayDeque(n);
            stack.addLast(points[0]);
            for (int i = 1; i < n; i++) {
                while (stack.size() >= 2) {
                    Point2D last = stack.removeLast();
                    Point2D second = stack.peekLast();
                    if (GeometryUtils.valueOf(second.cross(points[i], last)) < 0) {
                        stack.addLast(last);
                        break;
                    }
                }
                stack.addLast(points[i]);
            }

            return new PointConvexHull(new ArrayList(stack));
        }

    }

    static class Debug {
        private boolean offline;
        private PrintStream out = System.err;
        static int[] empty = new int[0];

        public Debug(boolean enable) {
            offline = enable && System.getSecurityManager() == null;
        }

        public Debug debug(String name, Object x) {
            return debug(name, x, empty);
        }

        public Debug debug(String name, Object x, int... indexes) {
            if (offline) {
                if (x == null || !x.getClass().isArray()) {
                    out.append(name);
                    for (int i : indexes) {
                        out.printf("[%d]", i);
                    }
                    out.append("=").append("" + x);
                    out.println();
                } else {
                    indexes = Arrays.copyOf(indexes, indexes.length + 1);
                    if (x instanceof byte[]) {
                        byte[] arr = (byte[]) x;
                        for (int i = 0; i < arr.length; i++) {
                            indexes[indexes.length - 1] = i;
                            debug(name, arr[i], indexes);
                        }
                    } else if (x instanceof short[]) {
                        short[] arr = (short[]) x;
                        for (int i = 0; i < arr.length; i++) {
                            indexes[indexes.length - 1] = i;
                            debug(name, arr[i], indexes);
                        }
                    } else if (x instanceof boolean[]) {
                        boolean[] arr = (boolean[]) x;
                        for (int i = 0; i < arr.length; i++) {
                            indexes[indexes.length - 1] = i;
                            debug(name, arr[i], indexes);
                        }
                    } else if (x instanceof char[]) {
                        char[] arr = (char[]) x;
                        for (int i = 0; i < arr.length; i++) {
                            indexes[indexes.length - 1] = i;
                            debug(name, arr[i], indexes);
                        }
                    } else if (x instanceof int[]) {
                        int[] arr = (int[]) x;
                        for (int i = 0; i < arr.length; i++) {
                            indexes[indexes.length - 1] = i;
                            debug(name, arr[i], indexes);
                        }
                    } else if (x instanceof float[]) {
                        float[] arr = (float[]) x;
                        for (int i = 0; i < arr.length; i++) {
                            indexes[indexes.length - 1] = i;
                            debug(name, arr[i], indexes);
                        }
                    } else if (x instanceof double[]) {
                        double[] arr = (double[]) x;
                        for (int i = 0; i < arr.length; i++) {
                            indexes[indexes.length - 1] = i;
                            debug(name, arr[i], indexes);
                        }
                    } else if (x instanceof long[]) {
                        long[] arr = (long[]) x;
                        for (int i = 0; i < arr.length; i++) {
                            indexes[indexes.length - 1] = i;
                            debug(name, arr[i], indexes);
                        }
                    } else {
                        Object[] arr = (Object[]) x;
                        for (int i = 0; i < arr.length; i++) {
                            indexes[indexes.length - 1] = i;
                            debug(name, arr[i], indexes);
                        }
                    }
                }
            }
            return this;
        }

    }

    static class PointPolygon extends Polygon<Point2D> {
        public PointPolygon(List<Point2D> points) {
            super(points);
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(double c) {
            cache.append(new BigDecimal(c).toPlainString());
            return this;
        }

        public FastOutput println(double c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class Polygon<T> {
        protected List<T> data;

        protected Polygon(List<T> data) {
            this.data = data;
        }

        public List<T> getData() {
            return data;
        }

    }

    static class GeometryUtils {
        public static final double PREC = 1e-15;

        public static double valueOf(double x) {
            return x > -PREC && x < PREC ? 0 : x;
        }

        public static double triangleAngle(double a, double b, double c) {
            double cosa = (b * b + c * c - a * a) / (2 * b * c);
            return Math.acos(cosa);
        }

        public static double cross(double x1, double y1, double x2, double y2) {
            return valueOf(x1 * y2 - y1 * x2);
        }

        public static int signOf(double x) {
            return x > 0 ? 1 : x < 0 ? -1 : 0;
        }

    }

    static class KahanSummation {
        private double error;
        private double sum;

        public double sum() {
            return sum;
        }

        public void add(double x) {
            x = x - error;
            double t = sum + x;
            error = (t - sum) - x;
            sum = t;
        }

        public String toString() {
            return new BigDecimal(sum).toString();
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }
}


</source>
</class>

<class classid="179" nclones="2" nlines="37" similarity="100">
<source file="../hum_codes_raw/s336149885.java" startline="1" endline="41" pcid="11275">
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		char[][] board = new char[n + 1][];
		for(int i = 0; i < n + 1; i++) {
			board[i] = sc.next().toCharArray();
		}
		int sum = 0; //print
		for(int i = 1; i <= n; i++) {//?????????????????£????????????
			out: for(int j = 0; j < board[i].length; j++) {//1??????????????¢?´¢
				if(board[i][j] == board[0][0]) {
					for(int k = j + 1; k < board[i].length; k++) {//2??????????????¢?´¢
						if(board[i][k] == board[0][1]) {
							int interval = k - j;//1???????????¨2??????????????????
							int cnt = 2;//?????????????????¢?´¢???????????????
							for(int m = k + interval; m < board[i].length; m = m + interval) {//3???????????\????????¢?´¢
								if(board[i][m] == board[0][cnt]) {
									cnt = cnt + 1;
									if(cnt == board[0].length) {
										sum = sum + 1;
										break out;
									}
								} else {
									break;
								}
							}
						}
					}
				}
			}
		}
		System.out.println(sum);
	}

}

</source>
<source file="../hum_codes_raw/s770812123.java" startline="1" endline="41" pcid="25876">
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		char[][] board = new char[n + 1][];
		for(int i = 0; i < n + 1; i++) {
			board[i] = sc.next().toCharArray();
		}
		int sum = 0; //print
		for(int i = 1; i <= n; i++) {//?????????????????£????????????
			out: for(int j = 0; j < board[i].length; j++) {//1??????????????¢?´¢
				if(board[i][j] == board[0][0]) {
					for(int k = j + 1; k < board[i].length; k++) {//2??????????????¢?´¢
						if(board[i][k] == board[0][1]) {
							int interval = k - j;//1???????????¨2??????????????????
							int cnt = 2;//?????????????????¢?´¢???????????????
							for(int m = k + interval; m < board[i].length; m = m + interval) {//3???????????\????????¢?´¢
								if(board[i][m] == board[0][cnt]) {
									cnt = cnt + 1;
									if(cnt == board[0].length) {
										sum = sum + 1;
										break out;
									}
								} else {
									break;
								}
							}
						}
					}
				}
			}
		}
		System.out.println(sum);
	}

}

</source>
</class>

<class classid="180" nclones="2" nlines="193" similarity="100">
<source file="../hum_codes_raw/s343584397.java" startline="1" endline="191" pcid="11528">
import java.io.*;
      
class Main{
static int[] sx={0,0,1,0,-1};
static int[] sy={0,1,0,-1,0};
static int[] mx={0,0,1,0,-1,-1,-1,1,1};
static int[] my={0,1,0,-1,0,-1,1,-1,1};
static int[] lx={0,0,1,0,-1,-1,-1,1,1,0,2,0,-2};
static int[] ly={0,1,0,-1,0,-1,1,-1,1,2,0,-2,0};
static int total;
static int res;
static int[][] map=new int[10][10];
static int[][][] drop=new int[10][10][3];
static void sd(int x,int y){
for(int i=0;i<sx.length;i++){
map[x+sx[i]][y+sy[i]]--;
}
total-=5;
res--;
}
static void sr(int x,int y){
for(int i=0;i<sx.length;i++){
map[x+sx[i]][y+sy[i]]++;
}
total+=5;
res++;
}
static boolean scd(int x,int y){
for(int i=0;i<sx.length;i++){
int nx=x+sx[i];
int ny=y+sy[i];
if(nx<0||ny<0||nx>=10||ny>=10||map[nx][ny]==0){
return false;
}
}
return true;
}
static void md(int x,int y){
for(int i=0;i<mx.length;i++){
map[x+mx[i]][y+my[i]]--;
}
total-=9;
res--;
}
static void mr(int x,int y){
for(int i=0;i<mx.length;i++){
map[x+mx[i]][y+my[i]]++;
}
total+=9;
res++;
}
static boolean mcd(int x,int y){
for(int i=0;i<mx.length;i++){
int nx=x+mx[i];
int ny=y+my[i];
if(nx<0||ny<0||nx>=10||ny>=10||map[nx][ny]==0){
return false;
}
}
return true;
}
static void ld(int x,int y){
for(int i=0;i<lx.length;i++){
map[x+lx[i]][y+ly[i]]--;
}
total-=13;
res--;
}
static void lr(int x,int y){
for(int i=0;i<lx.length;i++){
map[x+lx[i]][y+ly[i]]++;
}
total+=13;
res++;
}
static boolean lcd(int x,int y){
for(int i=0;i<lx.length;i++){
int nx=x+lx[i];
int ny=y+ly[i];
if(nx<0||ny<0||nx>=10||ny>=10||map[nx][ny]==0){
return false;
}
}
return true;
}
public static void main(String[] args) throws IOException{
BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
res=Integer.parseInt(br.readLine());
total=0;
for(int i=0;i<10;i++){
String[] value=br.readLine().split(" ");
for(int j=0;j<10;j++){
int num=Integer.parseInt(value[j]);
map[i][j]=num;
total+=num;
}
}
if(search(1,1,3)){
for(int i=1;i<9;i++){
for(int j=1;j<9;j++){
for(int k=0;k<3;k++){
if(drop[i][j][k]!=0){
for(int l=0;l<drop[i][j][k];l++){
int m=k+1;
System.out.println(j+" "+i+" "+m);
}
}
}
}
}
}
}
static boolean searchnext(int x,int y){
if(y==8){
return search(x+1,1,3);
}
return search(x,y+1,3);
}
static boolean search(int x,int y,int size){
if(res==0&&total==0){
return true;
}
else if(total<res*5||total>res*13){
return false;
}
else if(res==0){
return false;
}
if(x==9){
return false;
}
if(x>2&&y==1){
for(int i=0;i<10;i++){
if(map[x-3][i]!=0){
return false;
}
}
}
while(true){
switch(size){
case 3:if(lcd(x,y)){
       ld(x,y);
       drop[x][y][2]++;
       if(searchnext(x,y)){
       return true;
       }
       else{
       if(scd(x,y)&&search(x,y,3)){
       return true;
       }
       lr(x,y);
       drop[x][y][2]--;
       }
       }
       size--;
case 2:if(mcd(x,y)){
       md(x,y);
       drop[x][y][1]++;
       if(searchnext(x,y)){
       return true;
       }
       else{
       if(scd(x,y)&&search(x,y,2)){
       return true;
       }
       mr(x,y);
       drop[x][y][1]--;
       }
       }
       size--;
case 1:if(scd(x,y)){
       sd(x,y);
       drop[x][y][0]++;
       if(searchnext(x,y)){
       return true;
       }
       else{
       if(scd(x,y)&&search(x,y,1)){
       return true;
       }
       sr(x,y);
       drop[x][y][0]--;
       }
       }
       size--;
case 0:return searchnext(x,y);
}
}
}
}

</source>
<source file="../hum_codes_raw/s425716661.java" startline="1" endline="191" pcid="14314">
import java.io.*;
     
class Main{
static int[] sx={0,0,1,0,-1};
static int[] sy={0,1,0,-1,0};
static int[] mx={0,0,1,0,-1,-1,-1,1,1};
static int[] my={0,1,0,-1,0,-1,1,-1,1};
static int[] lx={0,0,1,0,-1,-1,-1,1,1,0,2,0,-2};
static int[] ly={0,1,0,-1,0,-1,1,-1,1,2,0,-2,0};
static int total;
static int res;
static int[][] map=new int[10][10];
static int[][][] drop=new int[10][10][3];
static void sd(int x,int y){
for(int i=0;i<sx.length;i++){
map[x+sx[i]][y+sy[i]]--;
}
total-=5;
res--;
}
static void sr(int x,int y){
for(int i=0;i<sx.length;i++){
map[x+sx[i]][y+sy[i]]++;
}
total+=5;
res++;
}
static boolean scd(int x,int y){
for(int i=0;i<sx.length;i++){
int nx=x+sx[i];
int ny=y+sy[i];
if(nx<0||ny<0||nx>=10||ny>=10||map[nx][ny]==0){
return false;
}
}
return true;
}
static void md(int x,int y){
for(int i=0;i<mx.length;i++){
map[x+mx[i]][y+my[i]]--;
}
total-=9;
res--;
}
static void mr(int x,int y){
for(int i=0;i<mx.length;i++){
map[x+mx[i]][y+my[i]]++;
}
total+=9;
res++;
}
static boolean mcd(int x,int y){
for(int i=0;i<mx.length;i++){
int nx=x+mx[i];
int ny=y+my[i];
if(nx<0||ny<0||nx>=10||ny>=10||map[nx][ny]==0){
return false;
}
}
return true;
}
static void ld(int x,int y){
for(int i=0;i<lx.length;i++){
map[x+lx[i]][y+ly[i]]--;
}
total-=13;
res--;
}
static void lr(int x,int y){
for(int i=0;i<lx.length;i++){
map[x+lx[i]][y+ly[i]]++;
}
total+=13;
res++;
}
static boolean lcd(int x,int y){
for(int i=0;i<lx.length;i++){
int nx=x+lx[i];
int ny=y+ly[i];
if(nx<0||ny<0||nx>=10||ny>=10||map[nx][ny]==0){
return false;
}
}
return true;
}
public static void main(String[] args) throws IOException{
BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
res=Integer.parseInt(br.readLine());
total=0;
for(int i=0;i<10;i++){
String[] value=br.readLine().split(" ");
for(int j=0;j<10;j++){
int num=Integer.parseInt(value[j]);
map[i][j]=num;
total+=num;
}
}
if(search(1,1,3)){
for(int i=1;i<9;i++){
for(int j=1;j<9;j++){
for(int k=0;k<3;k++){
if(drop[i][j][k]!=0){
for(int l=0;l<drop[i][j][k];l++){
int m=k+1;
System.out.println(j+" "+i+" "+m);
}
}
}
}
}
}
}
static boolean searchnext(int x,int y){
if(y==8){
return search(x+1,1,3);
}
return search(x,y+1,3);
}
static boolean search(int x,int y,int size){
if(res==0&&total==0){
return true;
}
else if(total<res*5||total>res*13){
return false;
}
else if(res==0){
return false;
}
if(x==9){
return false;
}
if(x>2&&y==1){
for(int i=0;i<10;i++){
if(map[x-3][i]!=0){
return false;
}
}
}
while(true){
switch(size){
case 3:if(lcd(x,y)){
       ld(x,y);
       drop[x][y][2]++;
       if(searchnext(x,y)){
       return true;
       }
       else{
       if(scd(x,y)&&search(x,y,3)){
       return true;
       }
       lr(x,y);
       drop[x][y][2]--;
       }
       }
       size--;
case 2:if(mcd(x,y)){
       md(x,y);
       drop[x][y][1]++;
       if(searchnext(x,y)){
       return true;
       }
       else{
       if(scd(x,y)&&search(x,y,2)){
       return true;
       }
       mr(x,y);
       drop[x][y][1]--;
       }
       }
       size--;
case 1:if(scd(x,y)){
       sd(x,y);
       drop[x][y][0]++;
       if(searchnext(x,y)){
       return true;
       }
       else{
       if(scd(x,y)&&search(x,y,1)){
       return true;
       }
       sr(x,y);
       drop[x][y][0]--;
       }
       }
       size--;
case 0:return searchnext(x,y);
}
}
}
}

</source>
</class>

<class classid="181" nclones="2" nlines="39" similarity="100">
<source file="../hum_codes_raw/s345464736.java" startline="1" endline="42" pcid="11599">
import java.util.Arrays;
import java.util.Scanner;
 
public class Main{
    public static void main(String[] args) {
        try(Scanner sc = new Scanner(System.in)){
            while(true) {
                int n = Integer.parseInt(sc.nextLine());
                if(n==0) break;
                int [] kouho = new int[26];
                int [] sokuhou = new int[26];
                String[] vote = new String[n];
                for(int i=0;i<26;i++) {
                    kouho[i] = 0;
                }
                vote = sc.nextLine().split(" ");
                boolean flag = true;
                loop:for(int i=1;i<=n;i++) {
                    int d = vote[i-1].charAt(0) - 'A';
                    kouho[d] += 1;
                    for(int j=0;j<26;j++) {
                        sokuhou[j] = kouho[j];
                    }
                    Arrays.sort(sokuhou);
                    if(sokuhou[24]+(n-i)<sokuhou[25]) {
                        int k=0;
                        for(k=0;k<26;k++) {
                            if(kouho[k] == sokuhou[25]) break;
                        }
                        System.out.printf("%c %d", k +'A',i);
                        System.out.println();
                        flag = false;
                        break loop;
                    }
                }
                if(flag) System.out.println("TIE");
            }
 
        }   
    }
}

</source>
<source file="../hum_codes_raw/s437483033.java" startline="1" endline="43" pcid="14672">
import java.util.Arrays;
import java.util.Scanner;

public class Main{
	public static void main(String[] args) {
		try(Scanner sc = new Scanner(System.in)){
			while(true) {
				int n = Integer.parseInt(sc.nextLine());
				if(n==0) break;
				int [] kouho = new int[26];
				int [] sokuhou = new int[26];
				String[] vote = new String[n];
				for(int i=0;i<26;i++) {
					kouho[i] = 0;
				}
				vote = sc.nextLine().split(" ");
				boolean flag = true;
				loop:for(int i=1;i<=n;i++) {
					int d = vote[i-1].charAt(0) - 'A';
					kouho[d] += 1;
					for(int j=0;j<26;j++) {
						sokuhou[j] = kouho[j];
					}
					Arrays.sort(sokuhou);
					if(sokuhou[24]+(n-i)<sokuhou[25]) {
						int k=0;
						for(k=0;k<26;k++) {
							if(kouho[k] == sokuhou[25]) break;
						}
						System.out.printf("%c %d", k +'A',i);
						System.out.println();
						flag = false;
						break loop;
					}
				}
				if(flag) System.out.println("TIE");
			}

		}	
	}
}


</source>
</class>

<class classid="182" nclones="2" nlines="88" similarity="100">
<source file="../hum_codes_raw/s346647414.java" startline="1" endline="62" pcid="11634">
import java.util.*;
public class Main{
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();
		int[] A = new int[N];
		for(int i=0; i<N; i++){
			A[i] = sc.nextInt();
		}
		sort(A);
		long answer = 0;
		int l = N/2;
		for(int i=N-1; i>=l; i--){
			answer += A[i]*2;
		}
		for(int i=0; i<l; i++){
			answer -= A[i]*2;
		}
		if(N%2==0){
			answer += A[l-1];
			answer -= A[l];
		}else{
			if(A[l-1]+A[l+1] > A[l]*2){
				answer += A[l-1];
				answer -= A[l]*3;
			}else{
				answer -= A[l]+A[l+1];
			}
		}
		System.out.println(answer);
		System.out.flush();
		return;
	}

	public static void sort(int[] a){
		quickSort(a, 0, a.length-1);
	}

	private static void quickSort(int[] a, int left, int right){
		if(left >= right){return;}
		int pivot = med3(a[left], a[left+(right-left)/2], a[right]);
		int l=left, r=right;
		while(true){
			while (a[l] < pivot){l++;}
			while (pivot < a[r]){r--;}
			if(l>=r){break;}
			int t=a[l]; a[l]=a[r]; a[r]=t;
			l++; r--;
		}
		quickSort(a, left, l-1);
		quickSort(a, r+1, right);
	}

	private static int med3(int x, int y, int z){
	    if(x < y){
	        if (y < z){return y;}else if(z < x){return x;}else{return z;}
	    } else {
	        if (z < y){return y;}else if(x < z){return x;}else{return z;}
	    }
	}
}

</source>
<source file="../hum_codes_raw/s828654204.java" startline="1" endline="62" pcid="27801">
import java.util.*;
public class Main{
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();
		int[] A = new int[N];
		for(int i=0; i<N; i++){
			A[i] = sc.nextInt();
		}
		sort(A);
		long answer = 0;
		int l = N/2;
		for(int i=N-1; i>=l; i--){
			answer += A[i]*2;
		}
		for(int i=0; i<l; i++){
			answer -= A[i]*2;
		}
		if(N%2==0){
			answer += A[l-1];
			answer -= A[l];
		}else{
			if(A[l-1]+A[l+1] > A[l]*2){
				answer += A[l-1];
				answer -= A[l]*3;
			}else{
				answer -= A[l]+A[l+1];
			}
		}
		System.out.println(answer);
		System.out.flush();
		return;
	}

	public static void sort(int[] a){
		quickSort(a, 0, a.length-1);
	}

	private static void quickSort(int[] a, int left, int right){
		if(left >= right){return;}
		int pivot = med3(a[left], a[left+(right-left)/2], a[right]);
		int l=left, r=right;
		while(true){
			while (a[l] < pivot){l++;}
			while (pivot < a[r]){r--;}
			if(l>=r){break;}
			int t=a[l]; a[l]=a[r]; a[r]=t;
			l++; r--;
		}
		quickSort(a, left, l-1);
		quickSort(a, r+1, right);
	}

	private static int med3(int x, int y, int z){
	    if(x < y){
	        if (y < z){return y;}else if(z < x){return x;}else{return z;}
	    } else {
	        if (z < y){return y;}else if(x < z){return x;}else{return z;}
	    }
	}
}

</source>
</class>

<class classid="183" nclones="2" nlines="150" similarity="100">
<source file="../hum_codes_raw/s348638788.java" startline="1" endline="157" pcid="11702">
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

public class Main{

	static PrintWriter out;
	static InputReader ir;

	static void solve(){
		for(;;){
            int n=ir.nextInt();
            if(n==0)
                break;
            char[][] ap=new char[n][];
            String[] cd=new String[n];
            int ma=0;
            for(int i=0;i<n;i++){
            	ap[i]=ir.next().toCharArray();
            	cd[i]=Character.toString(ap[i][0]);
            	for(int j=0;j<ap[i].length-1;j++){
            		if(ap[i][j]=='a'||ap[i][j]=='i'||ap[i][j]=='u'||ap[i][j]=='e'||ap[i][j]=='o'){
            			cd[i]+=Character.toString(ap[i][j+1]);
            		}
            	}
            	ma=Math.max(ma,cd[i].length());
            }
            outer:
            for(int i=0;i<ma;i++){
            	for(int j=0;j<n;j++){
            		for(int k=j+1;k<n;k++){
            			if(code(cd[j],i+1).equals(code(cd[k],i+1))){
            				if(i==ma-1)
            					out.println(-1);
            				continue outer;
            			}
            		}
            	}
            	out.println(i+1);
            	break;
            }
        }
	}

	static String code(String s,int k){
		if(s.length()<=k) return s;
		return s.substring(0,k);
	}

	public static void main(String[] args) throws Exception{
		ir=new InputReader(System.in);
		out=new PrintWriter(System.out);
		solve();
		out.flush();
	}

	static class InputReader {

		private InputStream in;
		private byte[] buffer=new byte[1024];
		private int curbuf;
		private int lenbuf;

		public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}

		public boolean hasNextByte() {
			if(curbuf>=lenbuf){
				curbuf= 0;
				try{
					lenbuf=in.read(buffer);
				}catch(IOException e) {
					throw new InputMismatchException();
				}
				if(lenbuf<=0) return false;
			}
			return true;
		}

		private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}

		private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}

		private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}

		public boolean hasNext(){skip(); return hasNextByte();}

		public String next(){
			if(!hasNext()) throw new NoSuchElementException();
			StringBuilder sb=new StringBuilder();
			int b=readByte();
			while(!isSpaceChar(b)){
				sb.appendCodePoint(b);
				b=readByte();
			}
			return sb.toString();
		}

		public int nextInt() {
			if(!hasNext()) throw new NoSuchElementException();
			int c=readByte();
			while (isSpaceChar(c)) c=readByte();
			boolean minus=false;
			if (c=='-') {
				minus=true;
				c=readByte();
			}
			int res=0;
			do{
				if(c<'0'||c>'9') throw new InputMismatchException();
				res=res*10+c-'0';
				c=readByte();
			}while(!isSpaceChar(c));
			return (minus)?-res:res;
		}

		public long nextLong() {
			if(!hasNext()) throw new NoSuchElementException();
			int c=readByte();
			while (isSpaceChar(c)) c=readByte();
			boolean minus=false;
			if (c=='-') {
				minus=true;
				c=readByte();
			}
			long res = 0;
			do{
				if(c<'0'||c>'9') throw new InputMismatchException();
				res=res*10+c-'0';
				c=readByte();
			}while(!isSpaceChar(c));
			return (minus)?-res:res;
		}

		public double nextDouble(){return Double.parseDouble(next());}

		public int[] nextIntArray(int n){
			int[] a=new int[n];
			for(int i=0;i<n;i++) a[i]=nextInt();
			return a;
		}

		public long[] nextLongArray(int n){
			long[] a=new long[n];
			for(int i=0;i<n;i++) a[i]=nextLong();
			return a;
		}

		public char[][] nextCharMap(int n,int m){
			char[][] map=new char[n][m];
			for(int i=0;i<n;i++) map[i]=next().toCharArray();
			return map;
		}
	}
}

</source>
<source file="../hum_codes_raw/s861226215.java" startline="1" endline="157" pcid="28954">
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

public class Main{

	static PrintWriter out;
	static InputReader ir;

	static void solve(){
		for(;;){
            int n=ir.nextInt();
            if(n==0)
                break;
            char[][] ap=new char[n][];
            String[] cd=new String[n];
            int ma=0;
            for(int i=0;i<n;i++){
            	ap[i]=ir.next().toCharArray();
            	cd[i]=Character.toString(ap[i][0]);
            	for(int j=0;j<ap[i].length-1;j++){
            		if(ap[i][j]=='a'||ap[i][j]=='i'||ap[i][j]=='u'||ap[i][j]=='e'||ap[i][j]=='o'){
            			cd[i]+=Character.toString(ap[i][j+1]);
            		}
            	}
            	ma=Math.max(ma,cd[i].length());
            }
            outer:
            for(int i=0;i<ma;i++){
            	for(int j=0;j<n;j++){
            		for(int k=j+1;k<n;k++){
            			if(code(cd[j],i+1).equals(code(cd[k],i+1))){
            				if(i==ma-1)
            					out.println(-1);
            				continue outer;
            			}
            		}
            	}
            	out.println(i+1);
            	break;
            }
        }
	}

	static String code(String s,int k){
		if(s.length()<=k) return s;
		return s.substring(0,k);
	}

	public static void main(String[] args) throws Exception{
		ir=new InputReader(System.in);
		out=new PrintWriter(System.out);
		solve();
		out.flush();
	}

	static class InputReader {

		private InputStream in;
		private byte[] buffer=new byte[1024];
		private int curbuf;
		private int lenbuf;

		public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}

		public boolean hasNextByte() {
			if(curbuf>=lenbuf){
				curbuf= 0;
				try{
					lenbuf=in.read(buffer);
				}catch(IOException e) {
					throw new InputMismatchException();
				}
				if(lenbuf<=0) return false;
			}
			return true;
		}

		private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}

		private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}

		private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}

		public boolean hasNext(){skip(); return hasNextByte();}

		public String next(){
			if(!hasNext()) throw new NoSuchElementException();
			StringBuilder sb=new StringBuilder();
			int b=readByte();
			while(!isSpaceChar(b)){
				sb.appendCodePoint(b);
				b=readByte();
			}
			return sb.toString();
		}

		public int nextInt() {
			if(!hasNext()) throw new NoSuchElementException();
			int c=readByte();
			while (isSpaceChar(c)) c=readByte();
			boolean minus=false;
			if (c=='-') {
				minus=true;
				c=readByte();
			}
			int res=0;
			do{
				if(c<'0'||c>'9') throw new InputMismatchException();
				res=res*10+c-'0';
				c=readByte();
			}while(!isSpaceChar(c));
			return (minus)?-res:res;
		}

		public long nextLong() {
			if(!hasNext()) throw new NoSuchElementException();
			int c=readByte();
			while (isSpaceChar(c)) c=readByte();
			boolean minus=false;
			if (c=='-') {
				minus=true;
				c=readByte();
			}
			long res = 0;
			do{
				if(c<'0'||c>'9') throw new InputMismatchException();
				res=res*10+c-'0';
				c=readByte();
			}while(!isSpaceChar(c));
			return (minus)?-res:res;
		}

		public double nextDouble(){return Double.parseDouble(next());}

		public int[] nextIntArray(int n){
			int[] a=new int[n];
			for(int i=0;i<n;i++) a[i]=nextInt();
			return a;
		}

		public long[] nextLongArray(int n){
			long[] a=new long[n];
			for(int i=0;i<n;i++) a[i]=nextLong();
			return a;
		}

		public char[][] nextCharMap(int n,int m){
			char[][] map=new char[n][m];
			for(int i=0;i<n;i++) map[i]=next().toCharArray();
			return map;
		}
	}
}

</source>
</class>

<class classid="184" nclones="2" nlines="22" similarity="100">
<source file="../hum_codes_raw/s356478895.java" startline="1" endline="41" pcid="11963">
import java.util.*;

public class Main {

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int N = sc.nextInt();
    int arr[] = new int[N+1];
    int srt[] = new int[N+1];
    for(int i = 1; i<=N; i++){
      arr[i] = sc.nextInt();
      srt[i] = arr[i];
    }
    Arrays.sort(srt);
    for(int i = 1; i<=N; i++){
      if(arr[i] >= srt[N/2+1]){
        System.out.println(srt[N/2]); 
      }
      else{
        System.out.println(srt[N/2+1]); 
      }
    }
  }

}


/*

pre[i] = arr[1] + arr[2] + arr[3] + arr[4] + ... + arr[i]
The question for some l and r
arr[l] + arr[l+1] + arr[l+2] + ... + arr[r]
= 
pre[r] - pre[l-1]

pre[r]   = arr[1] + arr[2] + ... + arr[l-1] + arr[l] + arr[l+1] + ... + arr[r]
-
pre[l-1] = arr[1] + arr[2] + ... + arr[l-1]

*/

</source>
<source file="../hum_codes_raw/s768585881.java" startline="1" endline="24" pcid="25800">
import java.util.*;
public class Main {

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int N = sc.nextInt();
    int arr[] = new int[N+1];
    int srt[] = new int[N+1];
    for(int i = 1; i<=N; i++){
      arr[i] = sc.nextInt();
      srt[i] = arr[i];
    }
    Arrays.sort(srt);
    for(int i = 1; i<=N; i++){
      if(arr[i] >= srt[N/2+1]){
        System.out.println(srt[N/2]); 
      }
      else{
        System.out.println(srt[N/2+1]); 
      }
    }
  }
}

</source>
</class>

<class classid="185" nclones="2" nlines="23" similarity="100">
<source file="../hum_codes_raw/s356499693.java" startline="1" endline="26" pcid="11965">
import java.util.Scanner;
 
public class Main {
 
    public static void main(String[] args) {
        Scanner stdIn = new Scanner(System.in);
        int n = stdIn.nextInt();
        int[] a = new int[n];
        int min = Integer.MAX_VALUE;
        for(int i=0;i<n;i++){
            a[i] = stdIn.nextInt();
            if(min>a[i]) min = a[i];
        }
        for(int i=1;i<=min;i++){
            boolean flag = true;
            for(int j=0;j<n;j++){
                if(a[j]%i!=0){
                    flag = false;
                    break;
                }
            }
            if(flag) System.out.println(i);
        }
    }
}

</source>
<source file="../hum_codes_raw/s677108130.java" startline="1" endline="26" pcid="22757">
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner stdIn = new Scanner(System.in);
		int n = stdIn.nextInt();
		int[] a = new int[n];
		int min = Integer.MAX_VALUE;
		for(int i=0;i<n;i++){
			a[i] = stdIn.nextInt();
			if(min>a[i]) min = a[i];
		}
		for(int i=1;i<=min;i++){
			boolean flag = true;
			for(int j=0;j<n;j++){
				if(a[j]%i!=0){
					flag = false;
					break;
				}
			}
			if(flag) System.out.println(i);
		}
	}
}

</source>
</class>

<class classid="186" nclones="2" nlines="64" similarity="100">
<source file="../hum_codes_raw/s363586947.java" startline="1" endline="79" pcid="12204">
import java.util.*;

public class Main {
	public static void main(String[] args){
		Prime p = new Prime();
		int n;
		Scanner sc = new Scanner(System.in);
		
		while(true){
			n = sc.nextInt();
			if(n == 0){
				break;
			}
			System.out.println(p.searchMaxQuadruplet(n));
		}
	}
}

class Prime {
	
	private final int size = 664579;
	private int[] prime;
	
	public Prime(){
		prime = new int[size];
		setPrime();
	}
	
    public void setPrime() {
        int ptr = 0;
        

        prime[ptr++] = 2;
        prime[ptr++] = 3;

        for (int n=5; n<=10000000; n+=2) {
            boolean flag = false;
            for (int i=1; prime[i]*prime[i]<=n; i++) {
                if (0 == n%prime[i]) {
                    flag = true;
                    break;
                }
            }
            
            if (!flag) {
                prime[ptr++] = n;
            }
        }
    }
    
    private int getIndex(int n){
    	for(int i=0; i<size; i++){
    		if(prime[i] > n){
    			return i-1;
    		}else if(prime[i] == n){
    			return i;
    		}
    	}
    	
    	return size-1;
    }
    
    public int searchMaxQuadruplet(int n){
    	int idx = getIndex(n);
    	
    	while(true){
    		if(prime[idx]-prime[idx-1] == 2){
    			if(prime[idx]-prime[idx-2] == 6){
    				if(prime[idx]-prime[idx-3] == 8){
    	    			return prime[idx];
    	    		}
        		}
    		}
    		idx --;
    	}
    	
    }
}

</source>
<source file="../hum_codes_raw/s446409773.java" startline="1" endline="79" pcid="14954">
import java.util.*;

public class Main {
	public static void main(String[] args){
		Prime p = new Prime();
		int n;
		Scanner sc = new Scanner(System.in);
		
		while(true){
			n = sc.nextInt();
			if(n == 0){
				break;
			}
			System.out.println(p.searchMaxQuadruplet(n));
		}
	}
}

class Prime {
	
	private final int size = 664579;
	private int[] prime;
	
	public Prime(){
		prime = new int[size];
		setPrime();
	}
	
    public void setPrime() {
        int ptr = 0;
        

        prime[ptr++] = 2;
        prime[ptr++] = 3;

        for (int n = 5; n <= 10000000; n += 2) {
            boolean flag = false;
            for (int i=1; prime[i]*prime[i]<=n; i++) {
                if (0 == n%prime[i]) {
                    flag = true;
                    break;
                }
            }
            
            if (!flag) {
                prime[ptr++] = n;
            }
        }
    }
    
    private int getIndex(int n){
    	for(int i=0; i<size; i++){
    		if(prime[i] > n){
    			return i-1;
    		}else if(prime[i] == n){
    			return i;
    		}
    	}
    	
    	return size-1;
    }
    
    public int searchMaxQuadruplet(int n){
    	int idx = getIndex(n);
    	
    	while(true){
    		if(prime[idx]-prime[idx-1] == 2){
    			if(prime[idx]-prime[idx-2] == 6){
    				if(prime[idx]-prime[idx-3] == 8){
    	    			return prime[idx];
    	    		}
        		}
    		}
    		idx --;
    	}
    	
    }
}

</source>
</class>

<class classid="187" nclones="2" nlines="180" similarity="100">
<source file="../hum_codes_raw/s365181821.java" startline="1" endline="225" pcid="12264">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in Actual solution is at the top
 * 
 * @author daltao
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "daltao", 1 << 27);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            TaskB solver = new TaskB();
            solver.solve(1, in, out);
            out.close();
        }
    }
    static class TaskB {
        NumberTheory.Modular mod = new NumberTheory.Modular(1e9 + 7);

        public void solve(int testNumber, FastInput in, FastOutput out) {
            long n = in.readLong();
            int[] bits = new int[64];
            DigitUtils.BitOperator bo = new DigitUtils.BitOperator();
            for (int i = 0; i < 64; i++) {
                bits[i] = bo.bitAt(n, i);
            }

            long[][] dp = new long[64][3];
            // 0 equal, 1 less 1, 2 less more than 1
            dp[63][0] = 1;
            for (int i = 62; i >= 0; i--) {
                if (bits[i] == 1) {
                    // a put and b put
                    dp[i][0] = dp[i + 1][0];
                    // b not put
                    // b and a put
                    dp[i][1] += dp[i + 1][0] + dp[i + 1][1];
                    // b put or not
                    // b and a put or not
                    dp[i][2] += dp[i + 1][1] * 2 + dp[i + 1][2] * 3;
                } else {
                    // a not put and b not put
                    // a put and b put
                    dp[i][0] += dp[i + 1][0] + dp[i + 1][1];
                    // b put
                    dp[i][1] += dp[i + 1][1];
                    // b and a not put
                    dp[i][2] += dp[i + 1][1] + dp[i + 1][2] * 3;
                }

                for (int j = 0; j < 3; j++) {
                    dp[i][j] = mod.valueOf(dp[i][j]);
                }
            }

            long ans = mod.valueOf(dp[0][0] + dp[0][1] + dp[0][2]);
            out.println(ans);
        }

    }
    static class NumberTheory {
        public static class Modular {
            int m;

            public Modular(int m) {
                this.m = m;
            }

            public Modular(long m) {
                this.m = (int) m;
                if (this.m != m) {
                    throw new IllegalArgumentException();
                }
            }

            public Modular(double m) {
                this.m = (int) m;
                if (this.m != m) {
                    throw new IllegalArgumentException();
                }
            }

            public int valueOf(long x) {
                x %= m;
                if (x < 0) {
                    x += m;
                }
                return (int) x;
            }

            public String toString() {
                return "mod " + m;
            }

        }

    }
    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public long readLong() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            long val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }
    static class FastOutput implements AutoCloseable, Closeable {
        private StringBuilder cache = new StringBuilder(1 << 20);
        private final Writer os;

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput println(long c) {
            cache.append(c).append('\n');
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

    }
    static class DigitUtils {
        private DigitUtils() {}

        public static class BitOperator {
            public int bitAt(long x, int i) {
                return (int) ((x >> i) & 1);
            }

        }

    }
}


</source>
<source file="../hum_codes_raw/s591135494.java" startline="1" endline="225" pcid="19833">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in Actual solution is at the top
 * 
 * @author daltao
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "daltao", 1 << 27);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            TaskB solver = new TaskB();
            solver.solve(1, in, out);
            out.close();
        }
    }
    static class TaskB {
        NumberTheory.Modular mod = new NumberTheory.Modular(1e9 + 7);

        public void solve(int testNumber, FastInput in, FastOutput out) {
            long n = in.readLong();
            int[] bits = new int[64];
            DigitUtils.BitOperator bo = new DigitUtils.BitOperator();
            for (int i = 0; i < 64; i++) {
                bits[i] = bo.bitAt(n, i);
            }

            long[][] dp = new long[64][3];
            // 0 equal, 1 less 1, 2 less more than 1
            dp[63][0] = 1;
            for (int i = 62; i >= 0; i--) {
                if (bits[i] == 1) {
                    // a put and b put
                    dp[i][0] = dp[i + 1][0];
                    // b not put
                    // b and a put
                    dp[i][1] += dp[i + 1][0] + dp[i + 1][1];
                    // b put or not
                    // b and a put or not
                    dp[i][2] += dp[i + 1][1] * 2 + dp[i + 1][2] * 3;
                } else {
                    // a not put and b not put
                    // a put and b put
                    dp[i][0] += dp[i + 1][0] + dp[i + 1][1];
                    // b put
                    dp[i][1] += dp[i + 1][1];
                    // b and a not put
                    dp[i][2] += dp[i + 1][1] + dp[i + 1][2] * 3;
                }

                for (int j = 0; j < 3; j++) {
                    dp[i][j] = mod.valueOf(dp[i][j]);
                }
            }

            long ans = mod.valueOf(dp[0][0] + dp[0][1] + dp[0][2]);
            out.println(ans);
        }

    }
    static class NumberTheory {
        public static class Modular {
            int m;

            public Modular(int m) {
                this.m = m;
            }

            public Modular(long m) {
                this.m = (int) m;
                if (this.m != m) {
                    throw new IllegalArgumentException();
                }
            }

            public Modular(double m) {
                this.m = (int) m;
                if (this.m != m) {
                    throw new IllegalArgumentException();
                }
            }

            public int valueOf(long x) {
                x %= m;
                if (x < 0) {
                    x += m;
                }
                return (int) x;
            }

            public String toString() {
                return "mod " + m;
            }

        }

    }
    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public long readLong() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            long val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }
    static class FastOutput implements AutoCloseable, Closeable {
        private StringBuilder cache = new StringBuilder(1 << 20);
        private final Writer os;

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput println(long c) {
            cache.append(c).append('\n');
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

    }
    static class DigitUtils {
        private DigitUtils() {}

        public static class BitOperator {
            public int bitAt(long x, int i) {
                return (int) ((x >> i) & 1);
            }

        }

    }
}


</source>
</class>

<class classid="188" nclones="2" nlines="340" similarity="100">
<source file="../hum_codes_raw/s365509257.java" startline="1" endline="405" pcid="12274">
import java.io.PrintWriter;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;

class Main implements Runnable {
	public static void main(String[] args) {
		new Thread(null, new Main(), "", Runtime.getRuntime().maxMemory()).start();
	}

	class State {
		int i;
		int parent;
		int j;// ?????????g[i][j]?????????

		public State(int i_, int parent_, int j_) {
			i = i_;
			parent = parent_;
			j = j_;
		}
	}

	int two_edge_connected_componets(ArrayList<Integer>[] g, int[] col) {
		int n = g.length;
		Arrays.fill(col, -1);
		int cols = 0;
		int[] low = new int[n];
		int[] ord = new int[n];
		boolean[] marked = new boolean[n];
		Arrays.fill(low, -1);
		Arrays.fill(ord, -1);
		int order = 0;
		ArrayDeque<State> stk = new ArrayDeque<>();
		ArrayDeque<Integer> pnd = new ArrayDeque<>();
		for (int ii = 0; ii < n; ++ii) {
			if (ord[ii] == -1) {
				stk.add(new State(ii, -1, 0));
			}
			while (!stk.isEmpty()) {
				State s = stk.pollFirst();
				if (ord[s.i] == -1) {
					low[s.i] = (ord[s.i] = order++);
					pnd.addFirst(s.i);
				}
				if (s.j > 0 && s.parent != g[s.i].get(s.j - 1) && !marked[g[s.i].get(s.j - 1)]) {
					if (low[g[s.i].get(s.j - 1)] == -1) {
						throw new AssertionError();
					}
					low[s.i] = Math.min(low[s.i], low[g[s.i].get(s.j - 1)]);
				}
				if (s.j == g[s.i].size() && low[s.i] == ord[s.i]) {
					while (true) {
						int v = pnd.pollFirst();
						col[v] = cols;
						marked[v] = true;
						if (v == s.i)
							break;
					}
					++cols;
					continue;
				}
				if (s.j == g[s.i].size())
					continue;
				int v = g[s.i].get(s.j);
				stk.addFirst(new State(s.i, s.parent, s.j + 1));
				if (ord[v] == -1) {
					stk.addFirst(new State(v, s.i, 0));
					// } else if (v != s.parent && !marked[v]) {
				} else if (!marked[v]) {
					low[s.i] = Math.min(low[s.i], low[v]);
				}
			}
		}
		return cols;
	}

	@SuppressWarnings("unchecked")
	public void run() {
		Scanner sc = new Scanner(System.in);
		PrintWriter pw = new PrintWriter(System.out);
		int V = sc.nextInt();
		int E = sc.nextInt();
		ArrayList<Integer>[] g = new ArrayList[V];
		for (int i = 0; i < V; ++i) {
			g[i] = new ArrayList<>();
		}
		for (int i = 0; i < E; ++i) {
			int s = sc.nextInt();
			int t = sc.nextInt();
			g[s].add(t);
		}
		int[] col = new int[V];
		two_edge_connected_componets(g, col);
		int q = sc.nextInt();
		while (q-- > 0) {
			int u = sc.nextInt();
			int v = sc.nextInt();
			System.out.println(col[u] == col[v] ? "1" : "0");
		}
		// int n = sc.nextInt();
		// int m = sc.nextInt();
		// int q = sc.nextInt();
		// ArrayList<Integer>[] g = new ArrayList[n];
		// for (int i = 0; i < n; ++i) {
		// g[i] = new ArrayList<>();
		// }
		//
		// for (int i = 0; i < m; ++i) {
		// int a = sc.nextInt() - 1;
		// int b = sc.nextInt() - 1;
		// g[a].add(b);
		// g[b].add(a);
		// }
		// two_edge_connected_componets(g);
		// HLDecomposition hl = new HLDecomposition(n);
		// hl.pre();
		// SegmentTree st = new SegmentTree(n);
		// for (int i = st.n - 2; i >= 0; --i) {
		// st.v[i] = merge(st.v[2 * i + 1], st.v[2 * i + 2]);
		// }
		// while (q-- > 0) {
		// int t = sc.nextInt();
		// int a = sc.nextInt();
		// int b = sc.nextInt();
		// if (t == 1) {//
		//
		// } else {//
		//
		// }
		// }
		pw.close();
	}

	long output(int a, int b, HLDecomposition hl, SegmentTree st) {
		E ea = new E(-(Long.MAX_VALUE >> 8), 1);
		E eb = new E(-(Long.MAX_VALUE >> 8), 1);

		while (hl.head[a] != hl.head[b]) {
			if (hl.depth[hl.head[a]] < hl.depth[hl.head[b]]) {
				int tmp = a;
				a = b;
				b = tmp;
				E tmp_e = ea;
				ea = eb;
				eb = tmp_e;
			}
			ea = merge(st.query(hl.id[hl.head[a]], hl.id[a] + 1), ea);
			a = hl.parent[hl.head[a]];
		}
		if (hl.depth[a] < hl.depth[b]) {
			int tmp = a;
			a = b;
			b = tmp;
			E tmp_e = ea;
			ea = eb;
			eb = tmp_e;
		}
		return merge(eb.reverse(), merge(st.query(hl.id[b], hl.id[a] + 1), ea)).max;
	}

	void modification(int a, int b, int c, HLDecomposition hl, SegmentTree st) {
		while (hl.head[a] != hl.head[b]) {
			if (hl.depth[hl.head[a]] < hl.depth[hl.head[b]]) {
				int tmp = a;
				a = b;
				b = tmp;
			}
			st.modification(hl.id[hl.head[a]], hl.id[a] + 1, c);
			a = hl.parent[hl.head[a]];
		}
		if (hl.depth[a] < hl.depth[b]) {
			int tmp = a;
			a = b;
			b = tmp;
		}
		if (hl.id[b] > hl.id[a]) {
			throw new AssertionError();
		}
		st.modification(hl.id[b], hl.id[a] + 1, c);
	}

	class E {
		long top;
		long bottom;
		long max;
		long sum;

		public E(long top, long bottom, long max, long sum) {
			this.top = top;
			this.bottom = bottom;
			this.max = max;
			this.sum = sum;
		}

		public E(long v, int width) {
			this.top = Math.max(v, v * width);
			this.bottom = Math.max(v, v * width);
			this.max = Math.max(v, v * width);
			this.sum = width * v;
		}

		public E() {
			this.top = -(Long.MAX_VALUE >> 8);
			this.bottom = -(Long.MAX_VALUE >> 8);
			this.max = -(Long.MAX_VALUE >> 8);
			this.sum = 0;
		}

		E reverse() {
			E e = new E();
			e.top = this.bottom;
			e.bottom = this.top;
			e.sum = this.sum;
			e.max = this.max;
			return e;
		}

		void tr() {
			System.out.println("top" + top);
			System.out.println("bottom" + bottom);
			System.out.println("max" + max);
			System.out.println("sum" + sum);
		}
	}

	E merge(E top, E bottom) {
		E e = new E();
		e.top = Math.max(top.top, top.sum + bottom.top);
		e.bottom = Math.max(bottom.bottom, top.bottom + bottom.sum);
		e.max = Math.max(Math.max(top.max, bottom.max), top.bottom + bottom.top);
		e.sum = top.sum + bottom.sum;
		return e;
	}

	class SegmentTree {
		int n;
		E[] v;
		long[] lazy;
		long nil = Long.MAX_VALUE >> 3;

		public SegmentTree(int n) {
			this.n = 1;
			while (this.n < n) {
				this.n *= 2;
			}
			v = new E[2 * this.n - 1];
			lazy = new long[2 * this.n - 1];
			Arrays.fill(lazy, nil);
			Arrays.fill(v, new E());
		}

		void push(int k, int l, int r) {
			if (lazy[k] == nil) {
				return;
			}
			v[k] = new E(lazy[k], r - l);
			if (r - l > 1) {
				lazy[2 * k + 1] = lazy[k];
				lazy[2 * k + 2] = lazy[k];
			}
			lazy[k] = nil;
		}

		void modification(int a, int b, int c) {
			modification(a, b, c, 0, n, 0);
		}

		// [a,b),[l,r)
		void modification(int a, int b, int c, int l, int r, int k) {
			push(k, l, r);
			if (b <= l || r <= a) {
				return;
			}
			if (a <= l && r <= b) {
				lazy[k] = c;
				push(k, l, r);
			} else {
				modification(a, b, c, l, (l + r) / 2, 2 * k + 1);
				modification(a, b, c, (l + r) / 2, r, 2 * k + 2);
				v[k] = merge(v[2 * k + 1], v[2 * k + 2]);
			}
		}

		E query(int a, int b) {
			return query(a, b, 0, n, 0);
		}

		E query(int a, int b, int l, int r, int k) {
			if (b <= l || r <= a) {
				return new E();
			}
			push(k, l, r);
			if (a <= l && r <= b) {
				return v[k];
			} else {
				E vl = query(a, b, l, (l + r) / 2, 2 * k + 1);
				E vr = query(a, b, (l + r) / 2, r, 2 * k + 2);
				return merge(vl, vr);
			}
		}
	}

	class HLDecomposition {
		int n;
		int[] depth;
		int[] head;
		int[] heavy;
		int[] parent;
		int[] sz;
		ArrayList<Integer>[] g;
		int[] id;

		@SuppressWarnings("unchecked")
		public HLDecomposition(int n) {
			this.n = n;
			depth = new int[n];
			head = new int[n];
			heavy = new int[n];
			parent = new int[n];
			id = new int[n];
			sz = new int[n];
			g = new ArrayList[n];
			for (int i = 0; i < n; ++i) {
				g[i] = new ArrayList<>();
			}
			Arrays.fill(head, -1);
			Arrays.fill(id, -1);
			Arrays.fill(parent, -1);
		}

		void ae(int a, int b) {
			g[a].add(b);
			g[b].add(a);
		}

		void pre() {
			dfs(0, -1);
			bfs();
		}

		void bfs() {
			ArrayDeque<Integer> pend = new ArrayDeque<>();
			int gen = 0;
			pend.add(0);
			while (!pend.isEmpty()) {
				int v = pend.pollFirst();
				int top = v;
				for (; v != -1; v = heavy[v]) {
					id[v] = gen++;
					head[v] = top;
					for (int d : g[v]) {
						if (d == parent[v] || d == heavy[v]) {
							continue;
						}
						pend.add(d);
					}
				}
			}
		}

		int lca(int u, int v) {
			if (head[u] != head[v]) {
				if (depth[head[u]] < depth[head[v]]) {
					int tmp = u;
					u = v;
					v = tmp;
				}
				return lca(parent[head[u]], v);
			} else {
				if (depth[u] > depth[v]) {
					int tmp = u;
					u = v;
					v = tmp;
				}
				return u;
			}
		}

		int dfs(int c, int p) {
			parent[c] = p;
			int s = 1;
			int to = -1;
			for (int d : g[c]) {
				if (d == p)
					continue;
				depth[d] = depth[c] + 1;
				s += dfs(d, c);
				if (to == -1 || sz[d] > sz[to]) {
					to = d;
				}
			}
			sz[c] = s;
			heavy[c] = to;
			return s;
		}

	}

	static void tr(Object... objects) {
		System.out.println(Arrays.deepToString(objects));
	}

}

</source>
<source file="../hum_codes_raw/s726195920.java" startline="1" endline="410" pcid="24421">
import java.io.PrintWriter;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;

class Main implements Runnable {
	public static void main(String[] args) {
		new Thread(null, new Main(), "", Runtime.getRuntime().maxMemory()).start();
	}

	class State {
		int i;
		int parent;
		int j;// ?????????g[i][j]?????????

		public State(int i_, int parent_, int j_) {
			i = i_;
			parent = parent_;
			j = j_;
		}
	}

	int two_edge_connected_componets(ArrayList<Integer>[] g, int[] col) {
		int n = g.length;
		Arrays.fill(col, -1);
		int cols = 0;
		int[] low = new int[n];
		int[] ord = new int[n];
		boolean[] marked = new boolean[n];
		Arrays.fill(low, -1);
		Arrays.fill(ord, -1);
		int order = 0;
		ArrayDeque<State> stk = new ArrayDeque<>();
		ArrayDeque<Integer> pnd = new ArrayDeque<>();
		for (int ii = 0; ii < n; ++ii) {
			if (ord[ii] == -1) {
				stk.add(new State(ii, -1, 0));
			}
			while (!stk.isEmpty()) {
				State s = stk.pollFirst();
				if (ord[s.i] == -1) {
					low[s.i] = (ord[s.i] = order++);
					pnd.addFirst(s.i);
				}
				if (s.j > 0 && s.parent != g[s.i].get(s.j - 1) && !marked[g[s.i].get(s.j - 1)]) {
					if (low[g[s.i].get(s.j - 1)] == -1) {
						throw new AssertionError();
					}
					low[s.i] = Math.min(low[s.i], low[g[s.i].get(s.j - 1)]);
				}
				if (s.j == g[s.i].size() && low[s.i] == ord[s.i]) {
					while (true) {
						int v = pnd.pollFirst();
						col[v] = cols;
						marked[v] = true;
						if (v == s.i)
							break;
					}
					++cols;
					continue;
				}
				if (s.j == g[s.i].size())
					continue;
				int v = g[s.i].get(s.j);
				stk.addFirst(new State(s.i, s.parent, s.j + 1));
				// ?????????????????±??????????????????
				if (ord[v] == -1) {
					stk.addFirst(new State(v, s.i, 0));
					// } else if (v != s.parent && !marked[v]) {
				} else if (!marked[v]) {
					low[s.i] = Math.min(low[s.i], low[v]);
				}
			}
		}
		return cols;
	}

	@SuppressWarnings("unchecked")
	public void run() {
		Scanner sc = new Scanner(System.in);
		PrintWriter pw = new PrintWriter(System.out);
		int V = sc.nextInt();
		int E = sc.nextInt();
		ArrayList<Integer>[] g = new ArrayList[V];
		for (int i = 0; i < V; ++i) {
			g[i] = new ArrayList<>();
		}
		for (int i = 0; i < E; ++i) {
			int s = sc.nextInt();
			int t = sc.nextInt();
			g[s].add(t);
		}
		int[] col = new int[V];
		two_edge_connected_componets(g, col);
		int q = sc.nextInt();
		while (q-- > 0) {
			int u = sc.nextInt();
			int v = sc.nextInt();
			System.out.println(col[u] == col[v] ? "1" : "0");
		}
		// int n = sc.nextInt();
		// int m = sc.nextInt();
		// int q = sc.nextInt();
		// ArrayList<Integer>[] g = new ArrayList[n];
		// for (int i = 0; i < n; ++i) {
		// g[i] = new ArrayList<>();
		// }
		//
		// for (int i = 0; i < m; ++i) {
		// int a = sc.nextInt() - 1;
		// int b = sc.nextInt() - 1;
		// g[a].add(b);
		// g[b].add(a);
		// }
		// two_edge_connected_componets(g);
		// HLDecomposition hl = new HLDecomposition(n);
		// hl.pre();
		// SegmentTree st = new SegmentTree(n);
		// for (int i = st.n - 2; i >= 0; --i) {
		// st.v[i] = merge(st.v[2 * i + 1], st.v[2 * i + 2]);
		// }
		// while (q-- > 0) {
		// int t = sc.nextInt();
		// int a = sc.nextInt();
		// int b = sc.nextInt();
		// if (t == 1) {//
		//
		// } else {//
		//
		// }
		// }
		pw.close();
	}

	long output(int a, int b, HLDecomposition hl, SegmentTree st) {
		E ea = new E(-(Long.MAX_VALUE >> 8), 1);
		E eb = new E(-(Long.MAX_VALUE >> 8), 1);

		while (hl.head[a] != hl.head[b]) {
			if (hl.depth[hl.head[a]] < hl.depth[hl.head[b]]) {
				int tmp = a;
				a = b;
				b = tmp;
				E tmp_e = ea;
				ea = eb;
				eb = tmp_e;
			}
			// a???head????????????±???
			ea = merge(st.query(hl.id[hl.head[a]], hl.id[a] + 1), ea);
			a = hl.parent[hl.head[a]];
		}
		if (hl.depth[a] < hl.depth[b]) {
			int tmp = a;
			a = b;
			b = tmp;
			E tmp_e = ea;
			ea = eb;
			eb = tmp_e;
		}
		// a????????????±???
		return merge(eb.reverse(), merge(st.query(hl.id[b], hl.id[a] + 1), ea)).max;
	}

	void modification(int a, int b, int c, HLDecomposition hl, SegmentTree st) {
		while (hl.head[a] != hl.head[b]) {
			if (hl.depth[hl.head[a]] < hl.depth[hl.head[b]]) {
				int tmp = a;
				a = b;
				b = tmp;
			}
			// a???head????????????±???
			st.modification(hl.id[hl.head[a]], hl.id[a] + 1, c);
			a = hl.parent[hl.head[a]];
		}
		if (hl.depth[a] < hl.depth[b]) {
			int tmp = a;
			a = b;
			b = tmp;
		}
		// a????????????±???
		if (hl.id[b] > hl.id[a]) {
			throw new AssertionError();
		}
		st.modification(hl.id[b], hl.id[a] + 1, c);
	}

	class E {
		long top;
		long bottom;
		long max;
		long sum;

		public E(long top, long bottom, long max, long sum) {
			this.top = top;
			this.bottom = bottom;
			this.max = max;
			this.sum = sum;
		}

		public E(long v, int width) {
			this.top = Math.max(v, v * width);
			this.bottom = Math.max(v, v * width);
			this.max = Math.max(v, v * width);
			this.sum = width * v;
		}

		public E() {
			this.top = -(Long.MAX_VALUE >> 8);
			this.bottom = -(Long.MAX_VALUE >> 8);
			this.max = -(Long.MAX_VALUE >> 8);
			this.sum = 0;
		}

		E reverse() {
			E e = new E();
			e.top = this.bottom;
			e.bottom = this.top;
			e.sum = this.sum;
			e.max = this.max;
			return e;
		}

		void tr() {
			System.out.println("top" + top);
			System.out.println("bottom" + bottom);
			System.out.println("max" + max);
			System.out.println("sum" + sum);
		}
	}

	E merge(E top, E bottom) {
		E e = new E();
		e.top = Math.max(top.top, top.sum + bottom.top);
		e.bottom = Math.max(bottom.bottom, top.bottom + bottom.sum);
		e.max = Math.max(Math.max(top.max, bottom.max), top.bottom + bottom.top);
		e.sum = top.sum + bottom.sum;
		return e;
	}

	class SegmentTree {
		int n;
		E[] v;
		long[] lazy;
		long nil = Long.MAX_VALUE >> 3;

		public SegmentTree(int n) {
			this.n = 1;
			while (this.n < n) {
				this.n *= 2;
			}
			v = new E[2 * this.n - 1];
			lazy = new long[2 * this.n - 1];
			Arrays.fill(lazy, nil);
			Arrays.fill(v, new E());
		}

		void push(int k, int l, int r) {
			if (lazy[k] == nil) {
				return;
			}
			v[k] = new E(lazy[k], r - l);
			if (r - l > 1) {
				lazy[2 * k + 1] = lazy[k];
				lazy[2 * k + 2] = lazy[k];
			}
			lazy[k] = nil;
		}

		void modification(int a, int b, int c) {
			modification(a, b, c, 0, n, 0);
		}

		// [a,b),[l,r)
		void modification(int a, int b, int c, int l, int r, int k) {
			push(k, l, r);
			if (b <= l || r <= a) {
				return;
			}
			if (a <= l && r <= b) {
				lazy[k] = c;
				push(k, l, r);
			} else {
				modification(a, b, c, l, (l + r) / 2, 2 * k + 1);
				modification(a, b, c, (l + r) / 2, r, 2 * k + 2);
				v[k] = merge(v[2 * k + 1], v[2 * k + 2]);
			}
		}

		E query(int a, int b) {
			return query(a, b, 0, n, 0);
		}

		E query(int a, int b, int l, int r, int k) {
			if (b <= l || r <= a) {
				return new E();
			}
			push(k, l, r);
			if (a <= l && r <= b) {
				return v[k];
			} else {
				E vl = query(a, b, l, (l + r) / 2, 2 * k + 1);
				E vr = query(a, b, (l + r) / 2, r, 2 * k + 2);
				return merge(vl, vr);
			}
		}
	}

	class HLDecomposition {
		int n;
		int[] depth;
		int[] head;
		int[] heavy;
		int[] parent;
		int[] sz;
		ArrayList<Integer>[] g;
		int[] id;

		@SuppressWarnings("unchecked")
		public HLDecomposition(int n) {
			this.n = n;
			depth = new int[n];
			head = new int[n];
			heavy = new int[n];
			parent = new int[n];
			id = new int[n];
			sz = new int[n];
			g = new ArrayList[n];
			for (int i = 0; i < n; ++i) {
				g[i] = new ArrayList<>();
			}
			Arrays.fill(head, -1);
			Arrays.fill(id, -1);
			Arrays.fill(parent, -1);
		}

		void ae(int a, int b) {
			g[a].add(b);
			g[b].add(a);
		}

		void pre() {
			dfs(0, -1);
			bfs();
		}

		void bfs() {
			ArrayDeque<Integer> pend = new ArrayDeque<>();
			int gen = 0;
			pend.add(0);
			while (!pend.isEmpty()) {
				int v = pend.pollFirst();
				int top = v;
				for (; v != -1; v = heavy[v]) {
					id[v] = gen++;
					head[v] = top;
					for (int d : g[v]) {
						if (d == parent[v] || d == heavy[v]) {
							continue;
						}
						pend.add(d);
					}
				}
			}
		}

		int lca(int u, int v) {
			if (head[u] != head[v]) {
				if (depth[head[u]] < depth[head[v]]) {
					int tmp = u;
					u = v;
					v = tmp;
				}
				return lca(parent[head[u]], v);
			} else {
				if (depth[u] > depth[v]) {
					int tmp = u;
					u = v;
					v = tmp;
				}
				return u;
			}
		}

		int dfs(int c, int p) {
			parent[c] = p;
			int s = 1;
			int to = -1;
			for (int d : g[c]) {
				if (d == p)
					continue;
				depth[d] = depth[c] + 1;
				s += dfs(d, c);
				if (to == -1 || sz[d] > sz[to]) {
					to = d;
				}
			}
			sz[c] = s;
			heavy[c] = to;
			return s;
		}

	}

	static void tr(Object... objects) {
		System.out.println(Arrays.deepToString(objects));
	}

}

</source>
</class>

<class classid="189" nclones="2" nlines="33" similarity="100">
<source file="../hum_codes_raw/s366950302.java" startline="1" endline="45" pcid="12332">
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;

public class Main {
  public static void main(String[] args) {
    Scanner scanner = new Scanner(System.in);

    int N = scanner.nextInt();
    int K = scanner.nextInt();
    long M = 1_000_000_007;

    List<Integer> factors = new ArrayList<>();
    factors.add(0);
    for (int i = 1; i * i <= N; i++) {
      int j = N / i;
      factors.add(i);
      if (j != i) factors.add(j);
    }
    Collections.sort(factors);

    int F = factors.size() - 1;
    long[][] dp = new long[K][F + 1];
    for (int i = 1; i <= F; i++) {
      dp[0][i] = factors.get(i);
    }
    for (int i = 1; i < K; i++) {
      for (int j = 1; j <= F; j++) {
        dp[i][j] = dp[i][j - 1];
        dp[i][j] += dp[i - 1][F - j + 1] * (factors.get(j) - factors.get(j - 1)) % M;
        if (dp[i][j] >= M) dp[i][j] -= M;
        //for (int k = 1; k <= F - j + 1; k++) {
        //  dp[i][j] += dp[i - 1][k];
        //  if (dp[i][j] >= M) dp[i][j] -= M;
        //}
        //dp[i][j] *= factors.get(j) - factors.get(j - 1);
        //dp[i][j] %= M;
      }
    }

    System.out.println(dp[K - 1][F]);
  }
}

</source>
<source file="../hum_codes_raw/s615983931.java" startline="1" endline="39" pcid="20702">
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;

public class Main {
  public static void main(String[] args) {
    Scanner scanner = new Scanner(System.in);

    int N = scanner.nextInt();
    int K = scanner.nextInt();
    long M = 1_000_000_007;

    List<Integer> factors = new ArrayList<>();
    factors.add(0);
    for (int i = 1; i * i <= N; i++) {
      int j = N / i;
      factors.add(i);
      if (j != i) factors.add(j);
    }
    Collections.sort(factors);

    int F = factors.size() - 1;
    long[][] dp = new long[K][F + 1];
    for (int i = 1; i <= F; i++) {
      dp[0][i] = factors.get(i);
    }
    for (int i = 1; i < K; i++) {
      for (int j = 1; j <= F; j++) {
        dp[i][j] = dp[i][j - 1];
        dp[i][j] += dp[i - 1][F - j + 1] * (factors.get(j) - factors.get(j - 1)) % M;
        if (dp[i][j] >= M) dp[i][j] -= M;
      }
    }

    System.out.println(dp[K - 1][F]);
  }
}

</source>
</class>

<class classid="190" nclones="2" nlines="21" similarity="100">
<source file="../hum_codes_raw/s367208360.java" startline="1" endline="21" pcid="12342">
import java.util.Scanner;
public class Main {
	public static void main(String[] args) throws java.io.IOException {
		Scanner scan = new Scanner(System.in);
		int n = scan.nextInt();
		int[] k = new int[n];
		int[] p = new int[n];
		for(int i = 0 ; i<n ; i++){
			k[i] = scan.nextInt();
			p[i] = scan.nextInt();
		}
		for(int i = 0 ; i<n ; i++){
			if(k[i]%p[i] == 0){
				System.out.println(p[i]);
			}else{
				System.out.println(k[i]%p[i]);
			}
		}
	}
}

</source>
<source file="../hum_codes_raw/s372355840.java" startline="1" endline="21" pcid="12520">
import java.util.Scanner;
public class Main {
	public static void main(String[] args) throws java.io.IOException {
		Scanner scan = new Scanner(System.in);
		int n = scan.nextInt();
		int[] k = new int[n];
		int[] p = new int[n];
		for(int i = 0 ; i<n ; i++){
			k[i] = scan.nextInt();
			p[i] = scan.nextInt();
		}
		for(int i = 0 ; i<n ; i++){
			if(k[i]%p[i] == 0){
				System.out.println(p[i]);
			}else{
				System.out.println(k[i]%p[i]);
			}
		}
	}
}

</source>
</class>

<class classid="191" nclones="2" nlines="53" similarity="100">
<source file="../hum_codes_raw/s368238428.java" startline="1" endline="74" pcid="12376">
import java.util.*;
public class Main 
{
	public static void main(String arg[])
	{
		Scanner in=new Scanner(System.in);
		for(;;)
		{
			int n=in.nextInt();
			String t=in.nextLine();
			ArrayList<String> AL=new ArrayList<String>();
			if(n==0)
				return;
			for(int i=0;i<n;i++)
			{
				String s[]=in.nextLine().split(" ");
				for(int j=0;j<s.length;j++)
					AL.add(s[j]);
			}
			String se=in.next();
			for(int i=0;i<AL.size();i++)
				if(se.charAt(0)!=AL.get(i).charAt(0))
				{
					AL.remove(i);
					i--;
				}
			if(AL.isEmpty())
			{
				System.out.println("NA");
				continue;
			}
			Collections.sort(AL);
			int count[]=new int[AL.size()];
			for(int i=0;i<AL.size()-1;i++)
			{
				while(i+1<AL.size()&&AL.get(i).equals(AL.get(i+1)))
				{
					count[i]++;
					AL.remove(i);
				}
			}
			ArrayList<Integer> cou=new ArrayList<Integer>();
			for(int i=0;i<count.length;i++)
				cou.add(count[i]);

			ArrayList<String> ANS=new ArrayList<String>();
			while(!AL.isEmpty())
			{
				int m=0;
				for(int j=0;j<cou.size();j++)
				{
					if(cou.get(m)<cou.get(j))
						m=j;
				}
				ANS.add(AL.get(m));
				AL.remove(m);
				cou.remove(m);
			}
			int p=0;
			for(int i=0;i<ANS.size();i++)
			{
				if(p==0)
					System.out.print(ANS.get(i));
				else
					System.out.print(" "+ANS.get(i));
				if(i>3)
					break;
				p=1;
			}
			System.out.println();
		}
	}
}

</source>
<source file="../hum_codes_raw/s563727636.java" startline="1" endline="74" pcid="18976">
import java.util.*;
public class Main
{
	public static void main(String arg[])
	{
		Scanner in=new Scanner(System.in);
		for(;;)
		{
			int n=in.nextInt();
			String t=in.nextLine();
			ArrayList<String> AL=new ArrayList<String>();
			if(n==0)
				return;
			for(int i=0;i<n;i++)
			{
				String s[]=in.nextLine().split(" ");
				for(int j=0;j<s.length;j++)
					AL.add(s[j]);
			}
			String se=in.next();
			for(int i=0;i<AL.size();i++)
				if(se.charAt(0)!=AL.get(i).charAt(0))
				{
					AL.remove(i);
					i--;
				}
			if(AL.isEmpty())
			{
				System.out.println("NA");
				continue;
			}
			Collections.sort(AL);
			int count[]=new int[AL.size()];
			for(int i=0;i<AL.size()-1;i++)
			{
				while(i+1<AL.size()&&AL.get(i).equals(AL.get(i+1)))
				{
					count[i]++;
					AL.remove(i);
				}
			}
			ArrayList<Integer> cou=new ArrayList<Integer>();
			for(int i=0;i<count.length;i++)
				cou.add(count[i]);

			ArrayList<String> ANS=new ArrayList<String>();
			while(!AL.isEmpty())
			{
				int m=0;
				for(int j=0;j<cou.size();j++)
				{
					if(cou.get(m)<cou.get(j))
						m=j;
				}
				ANS.add(AL.get(m));
				AL.remove(m);
				cou.remove(m);
			}
			int p=0;
			for(int i=0;i<ANS.size();i++)
			{
				if(p==0)
					System.out.print(ANS.get(i));
				else
					System.out.print(" "+ANS.get(i));
				if(i>3)
					break;
				p=1;
			}
			System.out.println();
		}
	}
}

</source>
</class>

<class classid="192" nclones="2" nlines="209" similarity="100">
<source file="../hum_codes_raw/s371628418.java" startline="1" endline="176" pcid="12500">
import java.util.*;
public class Main {
	Scanner in = new Scanner(System.in);
	public static void main(String[] args) {
		new Main();
	}
	public Main() {
		new AOJ0502();
	}

	class AOJ0502{
		public AOJ0502() {
			while(true){
				int n = in.nextInt();
				if(n==0)break;
				Dice dice = new Dice(1, 2);
				int sum = 1;
				for(int i=0;i<n;i++){
					String input = in.next();
					if(input.equals("North"))dice.rotateNorth();
					else if(input.equals("East"))dice.rotateEast();
					else if(input.equals("West"))dice.rotateWest();
					else if(input.equals("South"))dice.rotateSouth();
					else if(input.equals("Right"))dice.rotateCW();
					else if(input.equals("Left"))dice.rotateCCW();
//					System.out.println(dice.getTop());
					sum+=dice.getTop();
				}
				System.out.println(sum);
			}
		}

		class Dice{
			private int top=1,bottom=6,east=5,west=2,north=4,south=3;
			public Dice(int t,int s) {
				switch(t){
				case 1: break;
				case 2: rotateEast(); break;
				case 3: rotateNorth(); break;
				case 4: rotateSouth(); break;
				case 5: rotateWest(); break;
				case 6: reverse(); break;
				}
				while(s!=south) rotateCW();
			}
			boolean IsDice(){
				return north+south==7&&top+bottom==7&&west+east==7;
			}
			Dice rotateEast(){
				int temp=east;east=top;top=west;west=bottom;bottom=temp;
				return this;
			}
			Dice rotateWest(){
				int tmp=west; west=top; top=east; east=bottom; bottom=tmp;
				return this;
			}
			Dice rotateSouth(){
				int tmp=south; south=top; top=north; north=bottom; bottom=tmp;
				return this;
			}
			Dice rotateNorth(){
				int tmp=north; north=top; top=south; south=bottom; bottom=tmp;
				return this;
			}
			Dice reverse(){
				rotateNorth(); rotateNorth(); rotateCW(); rotateCW();
				return this;
			}
			Dice rotateCW(){//時計回り
				int tmp=north; north=west; west=south; south=east; east=tmp;
				return this;
			}
			Dice rotateCCW(){//反時計回り
				int tmp=north; north=east; east=south; south=west; west=tmp;
				return this;
			}
			int getTop(){
				return top;
			}
			int getBottom(){
				return bottom;
			}
			int getEast(){
				return east;
			}
			int getWest(){
				return west;
			}
			int getSourth(){
				return south;
			}
			int getNorth(){
				return north;
			}
			@Override public String toString(){
				return "top"+top+" north"+north+" east"+east+" south"+south+" west"+west+" bottom"+bottom;
			}
			@Override public boolean equals(Object obj){
				if(obj==this)return true;
				if(!(obj instanceof Dice))return false;
				Dice d = (Dice)obj;
				if(this.top==d.getTop()&&this.bottom==d.getBottom()&&
						this.east==d.getWest()&&this.west==d.getWest()&&
						this.north==d.getNorth()&&this.south==d.getSourth())return true;
				return false;
			}
		}
	}

	class AOJ0119{
		HashMap<Integer, ArrayList<Integer>> map;
		HashMap<Integer, ArrayList<Integer>> map2;
		boolean sw[];
		boolean flg;
		int m,n;
		ArrayList<Integer> result;
		void dfs(int person,int cnt){
			if(cnt==m){
				if(map2.get(person).size()!=0)return;
				flg=true;
				return;
			}
			if(flg)return;
			ArrayList<Integer> get_list = map2.get(person);
			for(int i=0;i<get_list.size();i++)if(!sw[get_list.get(i)]){
				sw[get_list.get(i)]=true;
				result.add(get_list.get(i));
				dfs(get_list.get(i),cnt+1);
				if(flg)return;
				result.remove(result.size()-1);
				sw[get_list.get(i)]=false;
			}
			if(map2.get(person).size()!=0)return;
			for(int key:map2.keySet())if(!sw[key]){
				sw[key] = true;
				result.add(key);
				dfs(key,cnt+1);
				if(flg)return;
				result.remove(result.size()-1);
				sw[key]=false;
			}
		}

		public AOJ0119() {
			map = new HashMap<Integer, ArrayList<Integer>>();
			map2 = new HashMap<Integer, ArrayList<Integer>>();
			m = in.nextInt();//容疑者数
			n = in.nextInt();//証言数
			sw = new boolean[m+1];
			result = new ArrayList<Integer>();
			for(int i=1;i<=m;i++){
				map.put(i, new ArrayList<Integer>());
				map2.put(i,new ArrayList<Integer>());
			}
			for(int i=0;i<n;i++){
				int x = in.nextInt();
				int y = in.nextInt();
				ArrayList<Integer> a = map.remove(x);a.add(y);
				map.put(x,a);
			}
			//			System.out.println(map);//deba
			for(int i=1;i<=m;i++){
				for(int s=1;s<=m;s++)if(map.get(s).contains(i)){
					ArrayList<Integer> a = map2.remove(i);a.add(s);
					map2.put(i,a);
				}
			}
			//			System.out.println(map2);//deba
			flg = false;sw[2]=true;result.add(2);
			dfs(2,1);
			for(int i=result.size()-1;i>=0;i--)System.out.println(result.get(i));
		}
	}

}

</source>
<source file="../hum_codes_raw/s467195810.java" startline="1" endline="176" pcid="15678">
import java.util.*;
public class Main {
	Scanner in = new Scanner(System.in);
	public static void main(String[] args) {
		new Main();
	}
	public Main() {
		new AOJ0502();
	}

	class AOJ0502{
		public AOJ0502() {
			while(true){
				int n = in.nextInt();
				if(n==0)break;
				Dice dice = new Dice(1, 2);
				int sum = 1;
				for(int i=0;i<n;i++){
					String input = in.next();
					if(input.equals("North"))dice.rotateNorth();
					else if(input.equals("East"))dice.rotateEast();
					else if(input.equals("West"))dice.rotateWest();
					else if(input.equals("South"))dice.rotateSouth();
					else if(input.equals("Right"))dice.rotateCW();
					else if(input.equals("Left"))dice.rotateCCW();
//					System.out.println(dice.getTop());
					sum+=dice.getTop();
				}
				System.out.println(sum);
			}
		}

		class Dice{
			private int top=1,bottom=6,east=5,west=2,north=4,south=3;
			public Dice(int t,int s) {
				switch(t){
				case 1: break;
				case 2: rotateEast(); break;
				case 3: rotateNorth(); break;
				case 4: rotateSouth(); break;
				case 5: rotateWest(); break;
				case 6: reverse(); break;
				}
				while(s!=south) rotateCW();
			}
			boolean IsDice(){
				return north+south==7&&top+bottom==7&&west+east==7;
			}
			Dice rotateEast(){
				int temp=east;east=top;top=west;west=bottom;bottom=temp;
				return this;
			}
			Dice rotateWest(){
				int tmp=west; west=top; top=east; east=bottom; bottom=tmp;
				return this;
			}
			Dice rotateSouth(){
				int tmp=south; south=top; top=north; north=bottom; bottom=tmp;
				return this;
			}
			Dice rotateNorth(){
				int tmp=north; north=top; top=south; south=bottom; bottom=tmp;
				return this;
			}
			Dice reverse(){
				rotateNorth(); rotateNorth(); rotateCW(); rotateCW();
				return this;
			}
			Dice rotateCW(){//時計回り
				int tmp=north; north=west; west=south; south=east; east=tmp;
				return this;
			}
			Dice rotateCCW(){//反時計回り
				int tmp=north; north=east; east=south; south=west; west=tmp;
				return this;
			}
			int getTop(){
				return top;
			}
			int getBottom(){
				return bottom;
			}
			int getEast(){
				return east;
			}
			int getWest(){
				return west;
			}
			int getSourth(){
				return south;
			}
			int getNorth(){
				return north;
			}
			@Override public String toString(){
				return "top"+top+" north"+north+" east"+east+" south"+south+" west"+west+" bottom"+bottom;
			}
			@Override public boolean equals(Object obj){
				if(obj==this)return true;
				if(!(obj instanceof Dice))return false;
				Dice d = (Dice)obj;
				if(this.top==d.getTop()&&this.bottom==d.getBottom()&&
						this.east==d.getWest()&&this.west==d.getWest()&&
						this.north==d.getNorth()&&this.south==d.getSourth())return true;
				return false;
			}
		}
	}

	class AOJ0119{
		HashMap<Integer, ArrayList<Integer>> map;
		HashMap<Integer, ArrayList<Integer>> map2;
		boolean sw[];
		boolean flg;
		int m,n;
		ArrayList<Integer> result;
		void dfs(int person,int cnt){
			if(cnt==m){
				if(map2.get(person).size()!=0)return;
				flg=true;
				return;
			}
			if(flg)return;
			ArrayList<Integer> get_list = map2.get(person);
			for(int i=0;i<get_list.size();i++)if(!sw[get_list.get(i)]){
				sw[get_list.get(i)]=true;
				result.add(get_list.get(i));
				dfs(get_list.get(i),cnt+1);
				if(flg)return;
				result.remove(result.size()-1);
				sw[get_list.get(i)]=false;
			}
			if(map2.get(person).size()!=0)return;
			for(int key:map2.keySet())if(!sw[key]){
				sw[key] = true;
				result.add(key);
				dfs(key,cnt+1);
				if(flg)return;
				result.remove(result.size()-1);
				sw[key]=false;
			}
		}

		public AOJ0119() {
			map = new HashMap<Integer, ArrayList<Integer>>();
			map2 = new HashMap<Integer, ArrayList<Integer>>();
			m = in.nextInt();//容疑者数
			n = in.nextInt();//証言数
			sw = new boolean[m+1];
			result = new ArrayList<Integer>();
			for(int i=1;i<=m;i++){
				map.put(i, new ArrayList<Integer>());
				map2.put(i,new ArrayList<Integer>());
			}
			for(int i=0;i<n;i++){
				int x = in.nextInt();
				int y = in.nextInt();
				ArrayList<Integer> a = map.remove(x);a.add(y);
				map.put(x,a);
			}
			//			System.out.println(map);//deba
			for(int i=1;i<=m;i++){
				for(int s=1;s<=m;s++)if(map.get(s).contains(i)){
					ArrayList<Integer> a = map2.remove(i);a.add(s);
					map2.put(i,a);
				}
			}
			//			System.out.println(map2);//deba
			flg = false;sw[2]=true;result.add(2);
			dfs(2,1);
			for(int i=result.size()-1;i>=0;i--)System.out.println(result.get(i));
		}
	}

}

</source>
</class>

<class classid="193" nclones="2" nlines="31" similarity="100">
<source file="../hum_codes_raw/s374155861.java" startline="1" endline="35" pcid="12587">
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;
 
class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        while (true) {
            int n = sc.nextInt();
            if (n == 0)
                break;
            Map<String, Integer> items = new HashMap<String, Integer>();
            for (int i = 0; i < n; i++) {
                String s = sc.next();
                int cost = sc.nextInt();
                items.put(s, cost);
            }
            int m = sc.nextInt();
            for (int i = 0; i < m; i++) {
                String recipeName = sc.next();
                int k = sc.nextInt();
                int sum = 0;
                for (int j = 0; j < k; j++) {
                    String name = sc.next();
                    if (items.containsKey(name))
                        sum += items.get(name);
                }
                items.put(recipeName, Math.min(sum, items.get(recipeName)));
            }
            String query = sc.next();
            System.out.println(items.get(query));
        }
    }
}

</source>
<source file="../hum_codes_raw/s699620841.java" startline="1" endline="35" pcid="23531">
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while (true) {
			int n = sc.nextInt();
			if (n == 0)
				break;
			Map<String, Integer> items = new HashMap<String, Integer>();
			for (int i = 0; i < n; i++) {
				String s = sc.next();
				int cost = sc.nextInt();
				items.put(s, cost);
			}
			int m = sc.nextInt();
			for (int i = 0; i < m; i++) {
				String recipeName = sc.next();
				int k = sc.nextInt();
				int sum = 0;
				for (int j = 0; j < k; j++) {
					String name = sc.next();
					if (items.containsKey(name))
						sum += items.get(name);
				}
				items.put(recipeName, Math.min(sum, items.get(recipeName)));
			}
			String query = sc.next();
			System.out.println(items.get(query));
		}
	}
}

</source>
</class>

<class classid="194" nclones="2" nlines="152" similarity="100">
<source file="../hum_codes_raw/s376338679.java" startline="1" endline="196" pcid="12657">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

  public static void main(String[] args) {
    
    new Main().run();
  }

  public void run() {

    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      final int n = Integer.parseInt(br.readLine());
      String op;
      String[] words;
      Tree tree = new Tree();
      int t;

      for(int i=0,k=0; i<n; i++,k=0){
        words = br.readLine().split(" ");
        op  = words[k++];

        switch( op ) {
          case "insert" :
            tree.insert(Integer.parseInt(words[k]));
            break;
          case "find" :
            t = Integer.parseInt(words[k]);
            System.out.println( tree.find(t) ? "yes" : "no" );
            break;
          case "delete" :
            tree.delete(Integer.parseInt(words[k]));
            break;
          default :
            tree.dispRoundPath();
        }
      }

    }
    catch(IOException e) {
      System.out.println("IOException!");
    }
  }
}

class Tree {

  static final BTreeNode NIL = new BTreeNode(Integer.MIN_VALUE);
  BTreeNode root;
  StringBuilder buf;

  public Tree() {
    root = NIL;
    buf = new StringBuilder();
  }

  public void insert(int val) {
    BTreeNode y = NIL;
    BTreeNode x = root;
    BTreeNode z = new BTreeNode(val);

    while( !x.equals(NIL) ) {
      y = x;
      x = z.key < x.key ? x.left : x.right;
    }
    z.parent = y;

    if( y.equals(NIL) )
      root = z;
    else if( z.key < y.key )
      y.left = z;
    else
      y.right = z;
  }
  boolean find(int target) {
    BTreeNode x = root;

    while( !x.equals(NIL) ) {
      if( target == x.key )
        return true;
      else
        x = target < x.key ? x.left : x.right;
    }

    return false;
  }
  void delete(int target) {
    BTreeNode x = root;

    while( !x.equals(NIL) ) {
      if( target == x.key )
        break;
      else
        x = target < x.key ? x.left : x.right;
    }

    deleteNode(x);
  }
  void deleteNode(BTreeNode x) {

    if( x.left.equals(NIL) && x.right.equals(NIL) ) {
      int target = x.key;
      x = x.parent;
      if(x.left.key == target) x.left = NIL;
      else x.right = NIL;
    }
    else if( !x.left.equals(NIL) && !x.right.equals(NIL) ) {
      BTreeNode t = getSuccessor(x);
      x.key = t.key;
      deleteNode(t);
    }
    else {
      int target = x.key;
      BTreeNode t;
      if( !x.left.equals(NIL) ) t = x.left;
      else t = x.right;
      x = x.parent;

      if(x.left.key == target) x.left = t;
      else x.right = t;

      t.parent = x;
    }
  }
  BTreeNode getSuccessor(BTreeNode x) {
    if(!x.right.equals(NIL)) return getMinimum(x.right);

    BTreeNode p = x.parent;
    while(!p.equals(NIL) && x.equals(p.right)) {
      x = p;
      p = p.parent;
    }

    return p;
  }
  BTreeNode getMinimum(BTreeNode x) {
    while(!x.left.equals(NIL)) {
      x = x.left;
    }

    return x;
  }  
  void preParse(BTreeNode u) {
    if( !u.equals(NIL) ) {
      buf.append(" ").append(u.key);
      preParse(u.left);
      preParse(u.right);
    }
  }
  void inParse(BTreeNode u) {
    if( !u.equals(NIL) ) {
      inParse(u.left);
      buf.append(" ").append(u.key);
      inParse(u.right);
    }
  }

  void dispRoundPath() {

    inParse(root);
    buf.append("\n");
    preParse(root);
    buf.append("\n");

    System.out.print(buf);
    buf.setLength(0);
  }
}

class BTreeNode {
  int key;
  BTreeNode parent,left,right;

  public BTreeNode(int key) {
    this.key = key;
    this.parent =
    this.left =
    this.right = Tree.NIL;
  }

  @Override
  public boolean equals(Object o) {
    if(o == this) return true;
    if(o == null) return false;
    if(!(o instanceof BTreeNode)) return false;

    BTreeNode node = (BTreeNode)o;
    if(!(this.key == node.key)) return false;

    return true;
  }
}

</source>
<source file="../hum_codes_raw/s799283876.java" startline="1" endline="196" pcid="26857">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

  public static void main(String[] args) {
    
    new Main().run();
  }

  public void run() {

    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      final int n = Integer.parseInt(br.readLine());
      String op;
      String[] words;
      Tree tree = new Tree();
      int t;

      for(int i=0,k=0; i<n; i++,k=0){
        words = br.readLine().split(" ");
        op  = words[k++];

        switch( op ) {
          case "insert" :
            tree.insert(Integer.parseInt(words[k]));
            break;
          case "find" :
            t = Integer.parseInt(words[k]);
            System.out.println( tree.find(t) ? "yes" : "no" );
            break;
          case "delete" :
            tree.delete(Integer.parseInt(words[k]));
            break;
          default :
            tree.dispRoundPath();
        }
      }

    }
    catch(IOException e) {
      System.out.println("IOException!");
    }
  }
}

class Tree {

  static final BTreeNode NIL = new BTreeNode(Integer.MIN_VALUE);
  BTreeNode root;
  StringBuilder buf;

  public Tree() {
    root = NIL;
    buf = new StringBuilder();
  }

  public void insert(int val) {
    BTreeNode y = NIL;
    BTreeNode x = root;
    BTreeNode z = new BTreeNode(val);

    while( !x.equals(NIL) ) {
      y = x;
      x = z.key < x.key ? x.left : x.right;
    }
    z.parent = y;

    if( y.equals(NIL) )
      root = z;
    else if( z.key < y.key )
      y.left = z;
    else
      y.right = z;
  }
  boolean find(int target) {
    BTreeNode x = root;

    while( !x.equals(NIL) ) {
      if( target == x.key )
        return true;
      else
        x = target < x.key ? x.left : x.right;
    }

    return false;
  }
  void delete(int target) {
    BTreeNode x = root;

    while( !x.equals(NIL) ) {
      if( target == x.key )
        break;
      else
        x = target < x.key ? x.left : x.right;
    }

    deleteNode(x);
  }
  void deleteNode(BTreeNode x) {

    if( x.left.equals(NIL) && x.right.equals(NIL) ) {
      int target = x.key;
      x = x.parent;
      if(x.left.key == target) x.left = NIL;
      else x.right = NIL;
    }
    else if( !x.left.equals(NIL) && !x.right.equals(NIL) ) {
      BTreeNode t = getSuccessor(x);
      x.key = t.key;
      deleteNode(t);
    }
    else {
      int target = x.key;
      BTreeNode t;
      if( !x.left.equals(NIL) ) t = x.left;
      else t = x.right;
      x = x.parent;

      if(x.left.key == target) x.left = t;
      else x.right = t;

      t.parent = x;
    }
  }
  BTreeNode getSuccessor(BTreeNode x) {
    if(!x.right.equals(NIL)) return getMinimum(x.right);

    BTreeNode p = x.parent;
    while(!p.equals(NIL) && x.equals(p.right)) {
      x = p;
      p = p.parent;
    }

    return p;
  }
  BTreeNode getMinimum(BTreeNode x) {
    while(!x.left.equals(NIL)) {
      x = x.left;
    }

    return x;
  }  
  void preParse(BTreeNode u) {
    if( !u.equals(NIL) ) {
      buf.append(" ").append(u.key);
      preParse(u.left);
      preParse(u.right);
    }
  }
  void inParse(BTreeNode u) {
    if( !u.equals(NIL) ) {
      inParse(u.left);
      buf.append(" ").append(u.key);
      inParse(u.right);
    }
  }

  void dispRoundPath() {

    inParse(root);
    buf.append("\n");
    preParse(root);
    buf.append("\n");

    System.out.print(buf);
    buf.setLength(0);
  }
}

class BTreeNode {
  int key;
  BTreeNode parent,left,right;

  public BTreeNode(int key) {
    this.key = key;
    this.parent =
    this.left =
    this.right = Tree.NIL;
  }

  @Override
  public boolean equals(Object o) {
    if(o == this) return true;
    if(o == null) return false;
    if(!(o instanceof BTreeNode)) return false;

    BTreeNode node = (BTreeNode)o;
    if(!(this.key == node.key)) return false;

    return true;
  }
}

</source>
</class>

<class classid="195" nclones="2" nlines="18" similarity="100">
<source file="../hum_codes_raw/s379155896.java" startline="1" endline="23" pcid="12746">
import java.util.Scanner;

class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		
		int ans = 1;
		int now = 1;
		
		for(int i = 0; i < n; i++) {
			if(sc.nextInt() == 1) now++;
			else {
				ans = Math.max(ans, now);
				now = 1;
			}
		}
		ans = Math.max(ans,now);
		
		System.out.println(ans);
	}
}

</source>
<source file="../hum_codes_raw/s541624732.java" startline="1" endline="22" pcid="18228">
import java.util.Scanner;
 
class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
         
        int ans = 1;
        int now = 1;
         
        for(int i = 0; i < n; i++) {
            if(sc.nextInt() == 1) now++;
            else {
                ans = Math.max(ans, now);
                now = 1;
            }
        }
        ans = Math.max(ans,now);
        System.out.println(ans);
    }
}

</source>
</class>

<class classid="196" nclones="2" nlines="25" similarity="100">
<source file="../hum_codes_raw/s384917989.java" startline="1" endline="31" pcid="12943">
import java.util.Scanner;

public class Main {
	public static void main(String args[]) {
		
		try(Scanner scan = new Scanner(System.in)){

			int n = scan.nextInt();
			int[] array = new int[n];
			for(int i=0; i<n; i++) {
				array[i] = scan.nextInt();
			}
			
			int dice = 0;
			int counter = 0; 
			
			for(int i=0; i<array.length; i++) {

				if(array[i] == 1) {
					counter++;
				}else {
					dice = Math.max(dice, counter);
					counter = 0;
				}
			}
			dice = Math.max(dice, counter);
			System.out.println(dice+1);
		}
	}
}

</source>
<source file="../hum_codes_raw/s699958608.java" startline="1" endline="31" pcid="23541">
import java.util.Scanner;

public class Main {
	public static void main(String args[]) {
		
		try(Scanner scan = new Scanner(System.in)){

			int n = scan.nextInt();
			int[] array = new int[n];
			for(int i=0; i<n; i++) {
				array[i] = scan.nextInt();
			}
			
			int dice = 0;
			int counter = 0; 
			
			for(int i=0; i<array.length; i++) {

				if(array[i] == 1) {
					counter++;
				}else {
					dice = Math.max(dice, counter);
					counter = 0;
				}
			}
			dice = Math.max(dice, counter);
			System.out.println(dice+1);
		}
	}
}

</source>
</class>

<class classid="197" nclones="2" nlines="31" similarity="100">
<source file="../hum_codes_raw/s385381357.java" startline="1" endline="33" pcid="12959">
//問３ 2717 佐久間　翼
import java.util.Scanner;
public class Main{
    
    public void solve(){
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        for(int cnt=0;cnt<N;cnt++){
            int x = sc.nextInt();
            int y = sc.nextInt();
            int b = sc.nextInt();
            int p = sc.nextInt();
            int gokei=x*b+y*p;
            if(b<5){
                b=5;
            }
            if(p<2){
                p=2;
            }
            int waribikigo=(x*b+y*p)*8/10;
            if(gokei>=waribikigo){
                System.out.println(waribikigo);
            }else{
                System.out.println(gokei);
            }
        }
    }
    public static void main(String[]args){
        Main obj = new Main();
        obj.solve();
    }
}

</source>
<source file="../hum_codes_raw/s689084658.java" startline="1" endline="33" pcid="23163">
//問３ 2717 佐久間　翼
import java.util.Scanner;
public class Main{
    
    public void solve(){
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        for(int cnt=0;cnt<N;cnt++){
            int x = sc.nextInt();
            int y = sc.nextInt();
            int b = sc.nextInt();
            int p = sc.nextInt();
            int gokei=x*b+y*p;
            if(b<5){
                b=5;
            }
            if(p<2){
                p=2;
            }
            int waribikigo=(x*b+y*p)*8/10;
            if(gokei>=waribikigo){
                System.out.println(waribikigo);
            }else{
                System.out.println(gokei);
            }
        }
    }
    public static void main(String[]args){
        Main obj = new Main();
        obj.solve();
    }
}

</source>
</class>

<class classid="198" nclones="3" nlines="97" similarity="100">
<source file="../hum_codes_raw/s388764829.java" startline="1" endline="173" pcid="13070">
/*import java.util.*;
import java.io.*;
import java.lang.*;
public class test{
	static double res=0;
	public static void help(int p,int r,int n){
		double tmp=p;
		for(int i=1;i<=n;i++){
			double x=1+(double)r/1200 ;
			tmp*=x;
		}
		res+=tmp;
		int k=100000,m=360;
		for(int i=m;i>0;i--){
			help(k,5,i);
		}
		System.out.println("paid amount "+k*m+" ");
		System.out.println((long)res);
	}
	public static void main(String[] args){
		Scanner s=new Scanner(System.in);
	    int n=s.nextInt();
		int[] arr=new int[n];
		for(int i=0;i<n;i++){
			arr[i]=s.nextInt();
		}
		long[] dp1=new long[n];
		long[] dp2=new long[n];
		if(arr[0]>0){dp1[0]=1;}
		else{dp2[0]=1;}
		long pos=dp1[0],neg=dp2[0];
		for(int i=1;i<n;i++){
			if(arr[i]>0){
				dp1[i]=dp1[i-1]+1;
				dp2[i]=dp2[i-1];
			}
			else{
				dp1[i]=dp2[i-1];
				dp2[i]=dp1[i-1]+1;
			}
			pos+=dp1[i];
			neg+=dp2[i];
		}
		System.out.println(neg+" "+pos);
	}
}			
	

*/
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskB solver = new TaskB();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskB {
        static final long MODULO = 998244353;

        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int n = in.nextInt();
            String s = in.next();
            int[][] pos = new int[3][n];
            int[] cnt = new int[3];
            for (int i = 0; i < s.length(); ++i) {
                int what = "RGB".indexOf(s.charAt(i));
                pos[what][cnt[what]++] = i;
            }
            int[] val = new int[s.length()];
            int[] minusOneType = new int[s.length()];
            Arrays.fill(minusOneType, -1);
            Arrays.fill(val, -2);
            Arrays.fill(cnt, 0);
            for (int i = 0; i < s.length(); ++i)
                if (val[i] == -2) {
                    val[i] = -1;
                    int what = "RGB".indexOf(s.charAt(i));
                    int p1 = -1;
                    int p2 = -1;
                    for (int j = 0; j < 3; ++j)
                        if (j != what) {
                            while (val[pos[j][cnt[j]]] != -2) ++cnt[j];
                            if (p1 < 0) p1 = pos[j][cnt[j]];
                            else p2 = pos[j][cnt[j]];
                        }
                    val[Math.min(p1, p2)] = 0;
                    minusOneType[Math.min(p1, p2)] = what;
                    val[Math.max(p1, p2)] = 1;
                }
            long res = 1;
            for (int i = 1; i <= n; ++i) {
                res = res * i % MODULO;
            }
            Arrays.fill(cnt, 0);
            for (int i = 0; i < s.length(); ++i) {
                int what = "RGB".indexOf(s.charAt(i));
                if (val[i] == -1) ++cnt[what];
                if (val[i] == 0) {
                    int need = minusOneType[i];
                    res = res * cnt[need]-- % MODULO;
                }
            }
            Arrays.fill(cnt, 0);
            for (int i = s.length() - 1; i >= 0; --i) {
                int what = "RGB".indexOf(s.charAt(i));
                if (val[i] == 1) ++cnt[what];
                if (val[i] == 0) {
                    int need = 3 - what - minusOneType[i];
                    res = res * cnt[need]-- % MODULO;
                }
            }
            out.println(res);
        }

    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

    }
}












</source>
<source file="../hum_codes_raw/s414697717.java" startline="1" endline="114" pcid="13940">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskB solver = new TaskB();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskB {
        static final long MODULO = 998244353;

        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int n = in.nextInt();
            String s = in.next();
            int[][] pos = new int[3][n];
            int[] cnt = new int[3];
            for (int i = 0; i < s.length(); ++i) {
                int what = "RGB".indexOf(s.charAt(i));
                pos[what][cnt[what]++] = i;
            }
            int[] val = new int[s.length()];
            int[] minusOneType = new int[s.length()];
            Arrays.fill(minusOneType, -1);
            Arrays.fill(val, -2);
            Arrays.fill(cnt, 0);
            for (int i = 0; i < s.length(); ++i)
                if (val[i] == -2) {
                    val[i] = -1;
                    int what = "RGB".indexOf(s.charAt(i));
                    int p1 = -1;
                    int p2 = -1;
                    for (int j = 0; j < 3; ++j)
                        if (j != what) {
                            while (val[pos[j][cnt[j]]] != -2) ++cnt[j];
                            if (p1 < 0) p1 = pos[j][cnt[j]];
                            else p2 = pos[j][cnt[j]];
                        }
                    val[Math.min(p1, p2)] = 0;
                    minusOneType[Math.min(p1, p2)] = what;
                    val[Math.max(p1, p2)] = 1;
                }
            long res = 1;
            for (int i = 1; i <= n; ++i) {
                res = res * i % MODULO;
            }
            Arrays.fill(cnt, 0);
            for (int i = 0; i < s.length(); ++i) {
                int what = "RGB".indexOf(s.charAt(i));
                if (val[i] == -1) ++cnt[what];
                if (val[i] == 0) {
                    int need = minusOneType[i];
                    res = res * cnt[need]-- % MODULO;
                }
            }
            Arrays.fill(cnt, 0);
            for (int i = s.length() - 1; i >= 0; --i) {
                int what = "RGB".indexOf(s.charAt(i));
                if (val[i] == 1) ++cnt[what];
                if (val[i] == 0) {
                    int need = 3 - what - minusOneType[i];
                    res = res * cnt[need]-- % MODULO;
                }
            }
            out.println(res);
        }

    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

    }
}


</source>
<source file="../hum_codes_raw/s767521242.java" startline="1" endline="173" pcid="25770">
/*import java.util.*;
import java.io.*;
import java.lang.*;
public class test{
	static double res=0;
	public static void help(int p,int r,int n){
		double tmp=p;
		for(int i=1;i<=n;i++){
			double x=1+(double)r/1200 ;
			tmp*=x;
		}
		res+=tmp;
		int k=100000,m=360;
		for(int i=m;i>0;i--){
			help(k,5,i);
		}
		System.out.println("paid amount "+k*m+" ");
		System.out.println((long)res);
	}
	public static void main(String[] args){
		Scanner s=new Scanner(System.in);
	    int n=s.nextInt();
		int[] arr=new int[n];
		for(int i=0;i<n;i++){
			arr[i]=s.nextInt();
		}
		long[] dp1=new long[n];
		long[] dp2=new long[n];
		if(arr[0]>0){dp1[0]=1;}
		else{dp2[0]=1;}
		long pos=dp1[0],neg=dp2[0];
		for(int i=1;i<n;i++){
			if(arr[i]>0){
				dp1[i]=dp1[i-1]+1;
				dp2[i]=dp2[i-1];
			}
			else{
				dp1[i]=dp2[i-1];
				dp2[i]=dp1[i-1]+1;
			}
			pos+=dp1[i];
			neg+=dp2[i];
		}
		System.out.println(neg+" "+pos);
	}
}			
	

*/
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskB solver = new TaskB();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskB {
        static final long MODULO = 998244353;

        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int n = in.nextInt();
            String s = in.next();
            int[][] pos = new int[3][n];
            int[] cnt = new int[3];
            for (int i = 0; i < s.length(); ++i) {
                int what = "RGB".indexOf(s.charAt(i));
                pos[what][cnt[what]++] = i;
            }
            int[] val = new int[s.length()];
            int[] minusOneType = new int[s.length()];
            Arrays.fill(minusOneType, -1);
            Arrays.fill(val, -2);
            Arrays.fill(cnt, 0);
            for (int i = 0; i < s.length(); ++i)
                if (val[i] == -2) {
                    val[i] = -1;
                    int what = "RGB".indexOf(s.charAt(i));
                    int p1 = -1;
                    int p2 = -1;
                    for (int j = 0; j < 3; ++j)
                        if (j != what) {
                            while (val[pos[j][cnt[j]]] != -2) ++cnt[j];
                            if (p1 < 0) p1 = pos[j][cnt[j]];
                            else p2 = pos[j][cnt[j]];
                        }
                    val[Math.min(p1, p2)] = 0;
                    minusOneType[Math.min(p1, p2)] = what;
                    val[Math.max(p1, p2)] = 1;
                }
            long res = 1;
            for (int i = 1; i <= n; ++i) {
                res = res * i % MODULO;
            }
            Arrays.fill(cnt, 0);
            for (int i = 0; i < s.length(); ++i) {
                int what = "RGB".indexOf(s.charAt(i));
                if (val[i] == -1) ++cnt[what];
                if (val[i] == 0) {
                    int need = minusOneType[i];
                    res = res * cnt[need]-- % MODULO;
                }
            }
            Arrays.fill(cnt, 0);
            for (int i = s.length() - 1; i >= 0; --i) {
                int what = "RGB".indexOf(s.charAt(i));
                if (val[i] == 1) ++cnt[what];
                if (val[i] == 0) {
                    int need = 3 - what - minusOneType[i];
                    res = res * cnt[need]-- % MODULO;
                }
            }
            out.println(res);
        }

    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

    }
}












</source>
</class>

<class classid="199" nclones="2" nlines="33" similarity="100">
<source file="../hum_codes_raw/s390338757.java" startline="1" endline="37" pcid="13121">
import java.util.Scanner;
public class Main {
 
    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int m=sc.nextInt();
        int[] fpoint=new int[n];
        int[] tage=new int[m];
        int[][] who=new int[m][n];
        for(int i=0;i<m;i++){
             tage[i]=sc.nextInt();
        }
        for(int j=0;j<m;j++){
            for(int i=0;i<n;i++){
                who[j][i]=sc.nextInt();
            }
        }
        sc.close();
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(tage[i]==who[i][j]){
                    fpoint[j]++;
                }else{
                    fpoint[tage[i]-1]++;
                }
 
            }
        }
 
        for(int i=0;i<n;i++){
            System.out.printf("%d\n", fpoint[i]);
            }
        }
 
}

</source>
<source file="../hum_codes_raw/s446577061.java" startline="1" endline="39" pcid="14961">
import java.util.Scanner;
public class Main {

	public static void main(String[] args) {
		// TODO ?????????????????????????????????????????????
		Scanner sc=new Scanner(System.in);
		int n=sc.nextInt();
		int m=sc.nextInt();
		int[] fpoint=new int[n];
		int[] tage=new int[m];
		int[][] who=new int[m][n];
		for(int i=0;i<m;i++){
			 tage[i]=sc.nextInt();
		}
		for(int j=0;j<m;j++){
			for(int i=0;i<n;i++){
				who[j][i]=sc.nextInt();
			}
		}
		sc.close();
		for(int i=0;i<m;i++){
			for(int j=0;j<n;j++){
				if(tage[i]==who[i][j]){
					fpoint[j]++;
				}else{
					fpoint[tage[i]-1]++;
				}

			}
		}

		for(int i=0;i<n;i++){
			System.out.printf("%d\n", fpoint[i]);
			//System.out.printf("%d\n", n);
			}
		}

}

</source>
</class>

<class classid="200" nclones="2" nlines="12" similarity="100">
<source file="../hum_codes_raw/s391050410.java" startline="1" endline="15" pcid="13145">
import java.math.BigInteger;
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			BigInteger b = sc.nextBigInteger();
			if(b.intValue()==-1)break;
			System.out.println(b.toString(4));
		}
	}
}

</source>
<source file="../hum_codes_raw/s590993918.java" startline="1" endline="16" pcid="19826">
import java.math.BigInteger;
import java.util.Scanner;

//A King in Hawaii
public class Main{

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			BigInteger b = sc.nextBigInteger();
			if(b.intValue()==-1)break;
			System.out.println(b.toString(4));
		}
	}
}

</source>
</class>

<class classid="201" nclones="2" nlines="158" similarity="100">
<source file="../hum_codes_raw/s395339830.java" startline="1" endline="205" pcid="13293">
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.NoSuchElementException;
import java.util.TreeMap;

/*
                   _ooOoo_
                  o8888888o
                  88" . "88
                  (| -_- |)
                  O\  =  /O
               ____/`---'\____
             .'  \\|     |//  `.
            /  \\|||  :  |||//  \
           /  _||||| -:- |||||-  \
           |   | \\\  -  /// |   |
           | \_|  ''\---/''  |   |
           \  .-\__  `-`  ___/-. /
         ___`. .'  /--.--\  `. . __
      ."" '<  `.___\_<|>_/___.'  >'"".
     | | :  `- \`.;`\ _ /`;.`/ - ` : | |
     \  \ `-.   \_ __\ /__ _/   .-` /  /
======`-.____`-.___\_____/___.-`____.-'======
                   `=---='
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            pass System Test!
*/

public class Main {

  private static class Task {
    int MOD = (int) (1e9 + 7);

    TreeMap<Long, TreeMap<Long, Long>> dp = new TreeMap<>();

    long func(long S, long X) {
      if (S == 0) return 1;
      TreeMap<Long, Long> d = dp.get(S);
      if (d == null) dp.put(S, d = new TreeMap<>());
      else {
        Long ans = d.get(X);
        if (ans != null) return ans;
      }
      long ans = func(S / 2, X / 2) % MOD;
      ans = (ans + func((S - 1) / 2, (X - 1) / 2)) % MOD;
      if (S >= 2) ans = (ans + func((S - 2) / 2, X / 2)) % MOD;
      d.put(X, ans);
      return ans;
    }

    void solve(FastScanner in, PrintWriter out) throws Exception {

      long N = in.nextLong();
      out.println(func(N, N));
    }
  }

  /**
   * ここから下はテンプレートです。
   */
  public static void main(String[] args) throws Exception {
    OutputStream outputStream = System.out;
    FastScanner in = new FastScanner();
    PrintWriter out = new PrintWriter(outputStream);
    Task solver = new Task();
    solver.solve(in, out);
    out.close();
  }
  private static class FastScanner {
    private final InputStream in = System.in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int bufferLength = 0;

    private boolean hasNextByte() {
      if (ptr < bufferLength) {
        return true;
      } else {
        ptr = 0;
        try {
          bufferLength = in.read(buffer);
        } catch (IOException e) {
          e.printStackTrace();
        }
        if (bufferLength <= 0) {
          return false;
        }
      }
      return true;
    }

    private int readByte() {
      if (hasNextByte()) return buffer[ptr++];
      else return -1;
    }

    private static boolean isPrintableChar(int c) {
      return 33 <= c && c <= 126;
    }

    private void skipUnprintable() {
      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
    }

    boolean hasNext() {
      skipUnprintable();
      return hasNextByte();
    }

    public String next() {
      if (!hasNext()) throw new NoSuchElementException();
      StringBuilder sb = new StringBuilder();
      int b = readByte();
      while (isPrintableChar(b)) {
        sb.appendCodePoint(b);
        b = readByte();
      }
      return sb.toString();
    }

    long nextLong() {
      if (!hasNext()) throw new NoSuchElementException();
      long n = 0;
      boolean minus = false;
      int b = readByte();
      if (b == '-') {
        minus = true;
        b = readByte();
      }
      if (b < '0' || '9' < b) {
        throw new NumberFormatException();
      }
      while (true) {
        if ('0' <= b && b <= '9') {
          n *= 10;
          n += b - '0';
        } else if (b == -1 || !isPrintableChar(b)) {
          return minus ? -n : n;
        } else {
          throw new NumberFormatException();
        }
        b = readByte();
      }
    }

    double nextDouble() {
      return Double.parseDouble(next());
    }

    double[] nextDoubleArray(int n) {
      double[] array = new double[n];
      for (int i = 0; i < n; i++) {
        array[i] = nextDouble();
      }
      return array;
    }

    double[][] nextDoubleMap(int n, int m) {
      double[][] map = new double[n][];
      for (int i = 0; i < n; i++) {
        map[i] = nextDoubleArray(m);
      }
      return map;
    }

    public int nextInt() {
      return (int) nextLong();
    }

    public int[] nextIntArray(int n) {
      int[] array = new int[n];
      for (int i = 0; i < n; i++) array[i] = nextInt();
      return array;
    }

    public long[] nextLongArray(int n) {
      long[] array = new long[n];
      for (int i = 0; i < n; i++) array[i] = nextLong();
      return array;
    }

    public String[] nextStringArray(int n) {
      String[] array = new String[n];
      for (int i = 0; i < n; i++) array[i] = next();
      return array;
    }

    public char[][] nextCharMap(int n) {
      char[][] array = new char[n][];
      for (int i = 0; i < n; i++) array[i] = next().toCharArray();
      return array;
    }

    public int[][] nextIntMap(int n, int m) {
      int[][] map = new int[n][];
      for (int i = 0; i < n; i++) {
        map[i] = nextIntArray(m);
      }
      return map;
    }
  }
}

</source>
<source file="../hum_codes_raw/s862939736.java" startline="1" endline="205" pcid="29021">
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.NoSuchElementException;
import java.util.TreeMap;

/*
                   _ooOoo_
                  o8888888o
                  88" . "88
                  (| -_- |)
                  O\  =  /O
               ____/`---'\____
             .'  \\|     |//  `.
            /  \\|||  :  |||//  \
           /  _||||| -:- |||||-  \
           |   | \\\  -  /// |   |
           | \_|  ''\---/''  |   |
           \  .-\__  `-`  ___/-. /
         ___`. .'  /--.--\  `. . __
      ."" '<  `.___\_<|>_/___.'  >'"".
     | | :  `- \`.;`\ _ /`;.`/ - ` : | |
     \  \ `-.   \_ __\ /__ _/   .-` /  /
======`-.____`-.___\_____/___.-`____.-'======
                   `=---='
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            pass System Test!
*/

public class Main {

  private static class Task {
    int MOD = (int) (1e9 + 7);

    TreeMap<Long, TreeMap<Long, Long>> dp = new TreeMap<>();

    long func(long S, long X) {
      if (S == 0) return 1;
      TreeMap<Long, Long> d = dp.get(S);
      if (d == null) dp.put(S, d = new TreeMap<>());
      else {
        Long ans = d.get(X);
        if (ans != null) return ans;
      }
      long ans = func(S / 2, X / 2) % MOD;
      ans = (ans + func((S - 1) / 2, (X - 1) / 2)) % MOD;
      if (S >= 2) ans = (ans + func((S - 2) / 2, X / 2)) % MOD;
      d.put(X, ans);
      return ans;
    }

    void solve(FastScanner in, PrintWriter out) throws Exception {

      long N = in.nextLong();
      out.println(func(N, N));
    }
  }

  /**
   * ここから下はテンプレートです。
   */
  public static void main(String[] args) throws Exception {
    OutputStream outputStream = System.out;
    FastScanner in = new FastScanner();
    PrintWriter out = new PrintWriter(outputStream);
    Task solver = new Task();
    solver.solve(in, out);
    out.close();
  }
  private static class FastScanner {
    private final InputStream in = System.in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int bufferLength = 0;

    private boolean hasNextByte() {
      if (ptr < bufferLength) {
        return true;
      } else {
        ptr = 0;
        try {
          bufferLength = in.read(buffer);
        } catch (IOException e) {
          e.printStackTrace();
        }
        if (bufferLength <= 0) {
          return false;
        }
      }
      return true;
    }

    private int readByte() {
      if (hasNextByte()) return buffer[ptr++];
      else return -1;
    }

    private static boolean isPrintableChar(int c) {
      return 33 <= c && c <= 126;
    }

    private void skipUnprintable() {
      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
    }

    boolean hasNext() {
      skipUnprintable();
      return hasNextByte();
    }

    public String next() {
      if (!hasNext()) throw new NoSuchElementException();
      StringBuilder sb = new StringBuilder();
      int b = readByte();
      while (isPrintableChar(b)) {
        sb.appendCodePoint(b);
        b = readByte();
      }
      return sb.toString();
    }

    long nextLong() {
      if (!hasNext()) throw new NoSuchElementException();
      long n = 0;
      boolean minus = false;
      int b = readByte();
      if (b == '-') {
        minus = true;
        b = readByte();
      }
      if (b < '0' || '9' < b) {
        throw new NumberFormatException();
      }
      while (true) {
        if ('0' <= b && b <= '9') {
          n *= 10;
          n += b - '0';
        } else if (b == -1 || !isPrintableChar(b)) {
          return minus ? -n : n;
        } else {
          throw new NumberFormatException();
        }
        b = readByte();
      }
    }

    double nextDouble() {
      return Double.parseDouble(next());
    }

    double[] nextDoubleArray(int n) {
      double[] array = new double[n];
      for (int i = 0; i < n; i++) {
        array[i] = nextDouble();
      }
      return array;
    }

    double[][] nextDoubleMap(int n, int m) {
      double[][] map = new double[n][];
      for (int i = 0; i < n; i++) {
        map[i] = nextDoubleArray(m);
      }
      return map;
    }

    public int nextInt() {
      return (int) nextLong();
    }

    public int[] nextIntArray(int n) {
      int[] array = new int[n];
      for (int i = 0; i < n; i++) array[i] = nextInt();
      return array;
    }

    public long[] nextLongArray(int n) {
      long[] array = new long[n];
      for (int i = 0; i < n; i++) array[i] = nextLong();
      return array;
    }

    public String[] nextStringArray(int n) {
      String[] array = new String[n];
      for (int i = 0; i < n; i++) array[i] = next();
      return array;
    }

    public char[][] nextCharMap(int n) {
      char[][] array = new char[n][];
      for (int i = 0; i < n; i++) array[i] = next().toCharArray();
      return array;
    }

    public int[][] nextIntMap(int n, int m) {
      int[][] map = new int[n][];
      for (int i = 0; i < n; i++) {
        map[i] = nextIntArray(m);
      }
      return map;
    }
  }
}

</source>
</class>

<class classid="202" nclones="2" nlines="117" similarity="100">
<source file="../hum_codes_raw/s400496604.java" startline="1" endline="135" pcid="13478">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.IOException;
import java.util.InputMismatchException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;
 
/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskD solver = new TaskD();
        solver.solve(1, in, out);
        out.close();
    }
 
    static class TaskD {
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int n = in.nextInt();
            long[] x = new long[n];
            long[] y = new long[n];
            for (int i = 0; i < n; i++) {
                x[i] = in.nextLong();
                y[i] = in.nextLong();
            }
 
            boolean isAllOdd = true;
            boolean isAllEven = true;
            for (int i = 0; i < n; i++) {
                if ((x[i] + y[i]) % 2 == 0) isAllOdd = false;
                else isAllEven = false;
            }
 
            if (!(isAllOdd ^ isAllEven)) {
                out.println(-1);
                return;
            }
 
            if (isAllEven) {
                for (int i = 0; i < n; i++) {
                    x[i] -= 1;
                }
            }
 
            for (int i = 0; i < n; i++) {
                long tmpX = x[i];
                long tmpY = y[i];
                x[i] = tmpX - tmpY;
                y[i] = tmpX + tmpY;
            }
 
            if (isAllEven) {
                out.println(38);
                out.print("1 ");
            } else {
                out.println(37);
            }
            for (int i = 0; i < 37; i++) {
                if (i > 0) out.print(" ");
                out.print(1L << 36 - i);
            }
            out.println();
 
            for (int i = 0; i < n; i++) {
                if (isAllEven) out.print("R");
 
                for (int j = 36; j >= 0; j--) {
                    if (x[i] > 0) {
                        if (y[i] > 0) {
                            out.print("R");
                            y[i] -= 1L << j;
                        } else {
                            out.print("D");
                            y[i] += 1L << j;
                        }
                        x[i] -= 1L << j;
                    } else {
                        if (y[i] > 0) {
                            out.print("U");
                            y[i] -= 1L << j;
                        } else {
                            out.print("L");
                            y[i] += 1L << j;
                        }
                        x[i] += 1L << j;
                    }
                }
 
                out.println();
            }
        }
 
    }
 
    static class InputReader {
        private BufferedReader br;
        private StringTokenizer st;
 
        public InputReader(InputStream inputStream) {
            br = new BufferedReader(new InputStreamReader(inputStream));
            st = new StringTokenizer("");
        }
 
        public String nextString() {
            while (!st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(br.readLine(), " ");
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
            }
            return st.nextToken();
        }
 
        public int nextInt() {
            return Integer.parseInt(nextString());
        }
 
        public long nextLong() {
            return Long.parseLong(nextString());
        }
 
    }
}

</source>
<source file="../hum_codes_raw/s766389190.java" startline="1" endline="136" pcid="25737">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.IOException;
import java.util.InputMismatchException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskD solver = new TaskD();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskD {
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int n = in.nextInt();
            long[] x = new long[n];
            long[] y = new long[n];
            for (int i = 0; i < n; i++) {
                x[i] = in.nextLong();
                y[i] = in.nextLong();
            }

            boolean isAllOdd = true;
            boolean isAllEven = true;
            for (int i = 0; i < n; i++) {
                if ((x[i] + y[i]) % 2 == 0) isAllOdd = false;
                else isAllEven = false;
            }

            if (!(isAllOdd ^ isAllEven)) {
                out.println(-1);
                return;
            }

            if (isAllEven) {
                for (int i = 0; i < n; i++) {
                    x[i] -= 1;
                }
            }

            for (int i = 0; i < n; i++) {
                long tmpX = x[i];
                long tmpY = y[i];
                x[i] = tmpX - tmpY;
                y[i] = tmpX + tmpY;
            }

            if (isAllEven) {
                out.println(38);
                out.print("1 ");
            } else {
                out.println(37);
            }
            for (int i = 0; i < 37; i++) {
                if (i > 0) out.print(" ");
                out.print(1L << 36 - i);
            }
            out.println();

            for (int i = 0; i < n; i++) {
                if (isAllEven) out.print("R");

                for (int j = 36; j >= 0; j--) {
                    if (x[i] > 0) {
                        if (y[i] > 0) {
                            out.print("R");
                            y[i] -= 1L << j;
                        } else {
                            out.print("D");
                            y[i] += 1L << j;
                        }
                        x[i] -= 1L << j;
                    } else {
                        if (y[i] > 0) {
                            out.print("U");
                            y[i] -= 1L << j;
                        } else {
                            out.print("L");
                            y[i] += 1L << j;
                        }
                        x[i] += 1L << j;
                    }
                }

                out.println();
            }
        }

    }

    static class InputReader {
        private BufferedReader br;
        private StringTokenizer st;

        public InputReader(InputStream inputStream) {
            br = new BufferedReader(new InputStreamReader(inputStream));
            st = new StringTokenizer("");
        }

        public String nextString() {
            while (!st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(br.readLine(), " ");
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
            }
            return st.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(nextString());
        }

        public long nextLong() {
            return Long.parseLong(nextString());
        }

    }
}


</source>
</class>

<class classid="203" nclones="2" nlines="31" similarity="100">
<source file="../hum_codes_raw/s401410685.java" startline="1" endline="39" pcid="13519">
import java.util.*;

public class Main{
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		int n = Integer.parseInt(sc.nextLine());

		while(n-- > 0){
			char[] s = sc.nextLine().toCharArray();
			for(int i=0;i<s.length;i++) s[i] -= 'a';

			String aft = "";

			for(int a=1;aft.equals("");a++){
				if(gcd(a,26) != 1) continue;
				for(int b=0;b<26;b++){
					for(int i=0;i<s.length;i++){
						if(0<=s[i] && s[i]<26){
							aft += (char)((a * s[i] + b) % 26 + 'a');
						}
						else{
							aft += (char)(s[i] + 'a');
						}
					}

					if(aft.contains("that") || aft.contains("this")) break;
					aft = "";
				}
			}

			System.out.println(aft);
		}
	}

	private static int gcd(int a,int b){
		return b==0 ? a : gcd(b,a%b);
	}
}

</source>
<source file="../hum_codes_raw/s807880419.java" startline="1" endline="39" pcid="27147">
import java.util.*;
 
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = Integer.parseInt(sc.nextLine());
 
        while(n-- > 0){
            char[] s = sc.nextLine().toCharArray();
            for(int i=0;i<s.length;i++) s[i] -= 'a';
 
            String aft = "";
 
            for(int a=1;aft.equals("");a++){
                if(gcd(a,26) != 1) continue;
                for(int b=0;b<26;b++){
                    for(int i=0;i<s.length;i++){
                        if(0<=s[i] && s[i]<26){
                            aft += (char)((a * s[i] + b) % 26 + 'a');
                        }
                        else{
                            aft += (char)(s[i] + 'a');
                        }
                    }
 
                    if(aft.contains("that") || aft.contains("this")) break;
                    aft = "";
                }
            }
 
            System.out.println(aft);
        }
    }
 
    private static int gcd(int a,int b){
        return b==0 ? a : gcd(b,a%b);
    }
}

</source>
</class>

<class classid="204" nclones="2" nlines="185" similarity="100">
<source file="../hum_codes_raw/s405233405.java" startline="1" endline="259" pcid="13648">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.PriorityQueue;
import java.util.InputMismatchException;
import java.io.IOException;
import java.util.AbstractCollection;
import java.util.Comparator;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author KharYusuf
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "KharYusuf", 1 << 27);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastReader in = new FastReader(inputStream);
            PrintWriter out = new PrintWriter(outputStream);
            FPondSkater solver = new FPondSkater();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class FPondSkater {
        int[] dx = {1, -1, 0, 0};
        int[] dy = {0, 0, 1, -1};

        public void solve(int testNumber, FastReader s, PrintWriter w) {
            int h = s.nextInt(), wi = s.nextInt(), k = s.nextInt();
            int x1 = s.nextInt() - 1, y1 = s.nextInt() - 1, x2 = s.nextInt() - 1, y2 = s.nextInt() - 1;
            char[][] c = new char[h][];
            for (int i = 0; i < h; i++) c[i] = s.next().toCharArray();
            PriorityQueue<pair<pair<Integer, Integer>, dist>> l = new PriorityQueue<>(new Comparator<pair<pair<Integer, Integer>, dist>>() {

                public int compare(pair<pair<Integer, Integer>, dist> o1, pair<pair<Integer, Integer>, dist> o2) {
                    return Integer.compare(o1.y.z, o2.y.z);
                }
            });
            int[][][] dis = new int[h][wi][4];
            for (int i = 0; i < h; i++) {
                for (int j = 0; j < wi; j++) Arrays.fill(dis[i][j], Integer.MAX_VALUE);
            }
            for (int i = 0; i < 4; i++) {
                l.add(new pair<>(new pair<>(x1, y1), new dist(i, k, 0)));
                dis[x1][y1][i] = 0;
            }
            while (!l.isEmpty()) {
                pair<pair<Integer, Integer>, dist> cur = l.poll();
                if (cur.y.z != dis[cur.x.x][cur.x.y][cur.y.x]) continue;
                for (int i = 0; i < 4; i++) {
                    int xx = cur.x.x + dx[i], yy = cur.x.y + dy[i];
                    if (xx >= 0 && xx < h && yy >= 0 && yy < wi && c[xx][yy] != '@') {
                   /* if(xx == 2 && yy == 3 ) {
                        w.println(cur.y.x+" "+cur.y.y+" "+cur.y.z+" "+i);
                    }
                    if(xx == 1 && yy == 3 ) {
                        w.println(cur.y.x+"y "+cur.y.y+" "+cur.y.z+" "+i);
                    }*/
                        if (i == cur.y.x && cur.y.y < k) {
                            if (dis[xx][yy][i] > cur.y.z) {
                                dis[xx][yy][i] = cur.y.z;
                                //w.println(xx+" "+yy);
                                l.add(new pair<>(new pair<>(xx, yy), new dist(i, cur.y.y + 1, dis[xx][yy][i])));
//                            for (int j = 0; j < 4; j++)
//                                if (i != j) l.add(new pair<>(new pair<>(xx, yy), new dist(j, 1, dis[xx][yy] + 1)));
                            }
                        } else {
                            if (dis[xx][yy][i] > cur.y.z + 1) {
                                dis[xx][yy][i] = cur.y.z + 1;
                                l.add(new pair<>(new pair<>(xx, yy), new dist(i, 1, dis[xx][yy][i])));
                            }
                        }
                    }
                }
            }
        /*r (int i = 0; i < h; i++) {
            for (int j = 0; j < wi; j++) for (int x = 0; x < 4; x++) w.print(dis[i][j][x]+" ");
            w.println();
        }*/
            w.println(func.min(dis[x2][y2]) == Integer.MAX_VALUE ? -1 : func.min(dis[x2][y2]));
        }

    }

    static class pair<U extends Comparable<U>, V extends Comparable<V>> implements Comparable<pair<U, V>> {
        public U x;
        public V y;

        public pair(U x, V y) {
            this.x = x;
            this.y = y;
        }

        public int compareTo(pair<U, V> other) {
            int i = x.compareTo(other.x);
            if (i != 0) return i;
            return y.compareTo(other.y);
        }

        public String toString() {
            return x.toString() + " " + y.toString();
        }

        public boolean equals(Object obj) {
            if (this.getClass() != obj.getClass()) return false;
            pair<U, V> other = (pair<U, V>) obj;
            return x.equals(other.x) && y.equals(other.y);
        }

        public int hashCode() {
            return 31 * x.hashCode() + y.hashCode();
        }

    }

    static class FastReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private FastReader.SpaceCharFilter filter;

        public FastReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {

            if (numChars == -1)
                throw new InputMismatchException();

            if (curChar >= numChars) {

                curChar = 0;

                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }

                if (numChars <= 0)
                    return -1;
            }

            return buf[curChar++];
        }

        public int nextInt() {

            int c = read();

            while (isSpaceChar(c))
                c = read();

            int sgn = 1;

            if (c == '-') {
                sgn = -1;
                c = read();
            }

            int res = 0;

            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();

                res *= 10;
                res += c - '0';
                c = read();
            }
            while (!isSpaceChar(c));

            return res * sgn;
        }

        public String next() {

            int c = read();

            while (isSpaceChar(c))
                c = read();

            StringBuilder res = new StringBuilder();

            do {
                res.appendCodePoint(c);
                c = read();
            }
            while (!isSpaceChar(c));

            return res.toString();
        }

        public boolean isSpaceChar(int c) {

            if (filter != null)
                return filter.isSpaceChar(c);

            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);

        }

    }

    static class func {
        public static int min(int... v) {
            int min = Integer.MAX_VALUE;
            for (int i : v) min = Math.min(min, i);
            return min;
        }

    }

    static class dist implements Comparable<dist> {
        public int x;
        public int y;
        public int z;

        public dist(int xi, int yi, int zi) {
            x = xi;
            y = yi;
            z = zi;
        }

        public int compareTo(dist other) {
            if (this.z > other.z) {
                return 1;
            }
            if (this.z < other.z) {
                return -1;
            }
            return 0;
        }

    }
}


</source>
<source file="../hum_codes_raw/s787765746.java" startline="1" endline="259" pcid="26448">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.PriorityQueue;
import java.util.InputMismatchException;
import java.io.IOException;
import java.util.AbstractCollection;
import java.util.Comparator;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author KharYusuf
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "KharYusuf", 1 << 27);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastReader in = new FastReader(inputStream);
            PrintWriter out = new PrintWriter(outputStream);
            FPondSkater solver = new FPondSkater();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class FPondSkater {
        int[] dx = {1, -1, 0, 0};
        int[] dy = {0, 0, 1, -1};

        public void solve(int testNumber, FastReader s, PrintWriter w) {
            int h = s.nextInt(), wi = s.nextInt(), k = s.nextInt();
            int x1 = s.nextInt() - 1, y1 = s.nextInt() - 1, x2 = s.nextInt() - 1, y2 = s.nextInt() - 1;
            char[][] c = new char[h][];
            for (int i = 0; i < h; i++) c[i] = s.next().toCharArray();
            PriorityQueue<pair<pair<Integer, Integer>, dist>> l = new PriorityQueue<>(new Comparator<pair<pair<Integer, Integer>, dist>>() {

                public int compare(pair<pair<Integer, Integer>, dist> o1, pair<pair<Integer, Integer>, dist> o2) {
                    return Integer.compare(o1.y.z, o2.y.z);
                }
            });
            int[][][] dis = new int[h][wi][4];
            for (int i = 0; i < h; i++) {
                for (int j = 0; j < wi; j++) Arrays.fill(dis[i][j], Integer.MAX_VALUE);
            }
            for (int i = 0; i < 4; i++) {
                l.add(new pair<>(new pair<>(x1, y1), new dist(i, k, 0)));
                dis[x1][y1][i] = 0;
            }
            while (!l.isEmpty()) {
                pair<pair<Integer, Integer>, dist> cur = l.poll();
                if (cur.y.z != dis[cur.x.x][cur.x.y][cur.y.x]) continue;
                for (int i = 0; i < 4; i++) {
                    int xx = cur.x.x + dx[i], yy = cur.x.y + dy[i];
                    if (xx >= 0 && xx < h && yy >= 0 && yy < wi && c[xx][yy] != '@') {
                   /* if(xx == 2 && yy == 3 ) {
                        w.println(cur.y.x+" "+cur.y.y+" "+cur.y.z+" "+i);
                    }
                    if(xx == 1 && yy == 3 ) {
                        w.println(cur.y.x+"y "+cur.y.y+" "+cur.y.z+" "+i);
                    }*/
                        if (i == cur.y.x && cur.y.y < k) {
                            if (dis[xx][yy][i] > cur.y.z) {
                                dis[xx][yy][i] = cur.y.z;
                                //w.println(xx+" "+yy);
                                l.add(new pair<>(new pair<>(xx, yy), new dist(i, cur.y.y + 1, dis[xx][yy][i])));
//                            for (int j = 0; j < 4; j++)
//                                if (i != j) l.add(new pair<>(new pair<>(xx, yy), new dist(j, 1, dis[xx][yy] + 1)));
                            }
                        } else {
                            if (dis[xx][yy][i] > cur.y.z + 1) {
                                dis[xx][yy][i] = cur.y.z + 1;
                                l.add(new pair<>(new pair<>(xx, yy), new dist(i, 1, dis[xx][yy][i])));
                            }
                        }
                    }
                }
            }
        /*r (int i = 0; i < h; i++) {
            for (int j = 0; j < wi; j++) for (int x = 0; x < 4; x++) w.print(dis[i][j][x]+" ");
            w.println();
        }*/
            w.println(func.min(dis[x2][y2]) == Integer.MAX_VALUE ? -1 : func.min(dis[x2][y2]));
        }

    }

    static class pair<U extends Comparable<U>, V extends Comparable<V>> implements Comparable<pair<U, V>> {
        public U x;
        public V y;

        public pair(U x, V y) {
            this.x = x;
            this.y = y;
        }

        public int compareTo(pair<U, V> other) {
            int i = x.compareTo(other.x);
            if (i != 0) return i;
            return y.compareTo(other.y);
        }

        public String toString() {
            return x.toString() + " " + y.toString();
        }

        public boolean equals(Object obj) {
            if (this.getClass() != obj.getClass()) return false;
            pair<U, V> other = (pair<U, V>) obj;
            return x.equals(other.x) && y.equals(other.y);
        }

        public int hashCode() {
            return 31 * x.hashCode() + y.hashCode();
        }

    }

    static class FastReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private FastReader.SpaceCharFilter filter;

        public FastReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {

            if (numChars == -1)
                throw new InputMismatchException();

            if (curChar >= numChars) {

                curChar = 0;

                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }

                if (numChars <= 0)
                    return -1;
            }

            return buf[curChar++];
        }

        public int nextInt() {

            int c = read();

            while (isSpaceChar(c))
                c = read();

            int sgn = 1;

            if (c == '-') {
                sgn = -1;
                c = read();
            }

            int res = 0;

            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();

                res *= 10;
                res += c - '0';
                c = read();
            }
            while (!isSpaceChar(c));

            return res * sgn;
        }

        public String next() {

            int c = read();

            while (isSpaceChar(c))
                c = read();

            StringBuilder res = new StringBuilder();

            do {
                res.appendCodePoint(c);
                c = read();
            }
            while (!isSpaceChar(c));

            return res.toString();
        }

        public boolean isSpaceChar(int c) {

            if (filter != null)
                return filter.isSpaceChar(c);

            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);

        }

    }

    static class func {
        public static int min(int... v) {
            int min = Integer.MAX_VALUE;
            for (int i : v) min = Math.min(min, i);
            return min;
        }

    }

    static class dist implements Comparable<dist> {
        public int x;
        public int y;
        public int z;

        public dist(int xi, int yi, int zi) {
            x = xi;
            y = yi;
            z = zi;
        }

        public int compareTo(dist other) {
            if (this.z > other.z) {
                return 1;
            }
            if (this.z < other.z) {
                return -1;
            }
            return 0;
        }

    }
}


</source>
</class>

<class classid="205" nclones="2" nlines="78" similarity="100">
<source file="../hum_codes_raw/s406457629.java" startline="1" endline="91" pcid="13683">
import java.io.*;
import java.util.*;
 
/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskD solver = new TaskD();
        solver.solve(1, in, out);
        out.close();
    }
 
    static class TaskD {
        public void solve(int testNumber, InputReader in, PrintWriter out) {
 
            int N = in.nextInt();
            for (int i = 0; i < N; i++) {
                long A = in.nextLong();
                long B = in.nextLong();
 
                long a = Math.min(A, B);
                long b = Math.max(A, B);
 
                long ans = 2L * (a - 1) + przedzial(a, b);
 
                out.println(ans);
            }
        }
 
        private long przedzial(long a, long b) {
            if (a == b || a + 1 == b) {
                return 0;
            }
 
            return 1L + szukaj(a + 1, b - 2, a * b);
        }
 
        private long szukaj(long a, long b, long LIMIT) {
            if (a > b) return 0;
            if (a == b) {
                return a * b < LIMIT ? 1 : 0;
            }
            long lo = a, hi = b;
            while (lo + 1 < hi) {
                long m = lo + (hi - lo) / 2;
                if (m * m >= LIMIT) {
                    hi = m;
                } else {
                    lo = m;
                }
            }
            long ans1 = 1 + 2L * (lo - 1 - a + 1);
            long ans2 = 0;
            if (lo * (lo + 1) < LIMIT) {
                ans2 = 2L * (lo - a + 1);
            }
            return Math.max(ans1, ans2);
        }
    }
    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;
        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }
        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }
        public long nextLong() {
            return Long.parseLong(next());
        }
        public int nextInt() {
            return Integer.parseInt(next());
        }
    }
}

</source>
<source file="../hum_codes_raw/s546530291.java" startline="1" endline="87" pcid="18403">
import java.io.*;
import java.util.*;
 
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskD solver = new TaskD();
        solver.solve(1, in, out);
        out.close();
    }
 
    static class TaskD {
        public void solve(int testNumber, InputReader in, PrintWriter out) {
 
            int N = in.nextInt();
            for (int i = 0; i < N; i++) {
                long A = in.nextLong();
                long B = in.nextLong();
 
                long a = Math.min(A, B);
                long b = Math.max(A, B);
 
                long ans = 2L * (a - 1) + przedzial(a, b);
 
                out.println(ans);
            }
        }
 
        private long przedzial(long a, long b) {
            if (a == b || a + 1 == b) {
                return 0;
            }
 
            return 1L + szukaj(a + 1, b - 2, a * b);
        }
 
        private long szukaj(long a, long b, long LIMIT) {
            if (a > b) return 0;
            if (a == b) {
                return a * b < LIMIT ? 1 : 0;
            }
            long lo = a, hi = b;
            while (lo + 1 < hi) {
                long m = lo + (hi - lo) / 2;
                if (m * m >= LIMIT) {
                    hi = m;
                } else {
                    lo = m;
                }
            }
            long ans1 = 1 + 2L * (lo - 1 - a + 1);
            long ans2 = 0;
            if (lo * (lo + 1) < LIMIT) {
                ans2 = 2L * (lo - a + 1);
            }
            return Math.max(ans1, ans2);
        }
    }
    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;
        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }
        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }
        public long nextLong() {
            return Long.parseLong(next());
        }
        public int nextInt() {
            return Integer.parseInt(next());
        }
    }
}

</source>
</class>

<class classid="206" nclones="2" nlines="1237" similarity="100">
<source file="../hum_codes_raw/s406917789.java" startline="1" endline="1567" pcid="13700">

import java.io.*;

import static java.lang.Math.*;
import static java.lang.Math.min;

import java.math.BigDecimal;
import java.util.*;

import static java.util.Arrays.*;

import java.util.stream.*;

/**
 * @author baito
 */
@SuppressWarnings("unchecked")
public class Main {
    static boolean DEBUG = true;
    static StringBuilder sb = new StringBuilder();
    static int INF = 1234567890;
    static int MINF = -1234567890;
    static long LINF = 123456789123456789L;
    static long MLINF = -123456789123456789L;
    static int MOD = (int) 1e9 + 7;
    static double EPS = 1e-10;
    static int[] y4 = {-1, 1, 0, 0};
    static int[] x4 = {0, 0, -1, 1};
    static int[] y8 = {0, 1, 0, -1, -1, 1, 1, -1};
    static int[] x8 = {1, 0, -1, 0, 1, -1, 1, -1};
    static int[] Fa;
    static boolean[] isPrime;
    static ArrayList<Integer> primes;
    static char[][] S;
    static long maxRes = Long.MIN_VALUE;
    static long minRes = Long.MAX_VALUE;
    static int[] fac, finv, inv;

    //    static int N;
//    static int[] A;
    static int N, A, B, C, D;
    static int[][] dp;

    public static void solve() throws Exception {
//        longを忘れるなオーバーフローするぞ
//        N = ni();
//        A = nia(N);
//        $END$
        int N = ni();
        int A = ni();
        int B = ni();
        int C = ni();
        int D = ni();
        setMod();
        long[][] dp = new long[N + 1][N + 1];
        for (int i = 0; i < N + 1; i++) {
            dp[i][0] = 1;
        }
        long[][] mPowFinv = new long[N + 1][N + 1];
        for (int k = 0; k < N + 1; k++) {
            mPowFinv[k][1] = finv[k];
        }
        for (int k = 0; k < N + 1; k++) {
            for (int i = 2; i < D + 1; i++) {
                mPowFinv[k][i] = mPowFinv[k][i - 1] * finv[k] % MOD;
            }
        }
        for (int k = 1; k <= N; k++) {
            for (int n = 1; n <= N; n++) {
                //k人が0のとき
                dp[k][n] = dp[k - 1][n];
                if (!(A <= k && k <= B)) continue;
                for (int x = C; x <= D && n - k * x >= 0; x++) {
                    //n人からk人をxグループ作りその他はk-1人以下
                    long cal = mMuls(fac[n], finv[n - k * x], mPowFinv[k][x], finv[x]);
                    cal = mMul(cal, dp[k - 1][n - k * x]);
                    dp[k][n] = mSum(dp[k][n], cal);
                }
            }
        }
        System.out.println(dp[N][N]);
    }


    public static boolean calc(long va) {
        //貪欲にギリギリセーフを選んでいく。
        int v = (int) va;
        return true;
    }

    //条件を満たす最大値、あるいは最小値を求める
    static int mgr(long ok, long ng) {
        //int ok = 0; //解が存在する
        //int ng = N; //解が存在しない
        while (Math.abs(ok - ng) > 1) {
            long mid;
            if (ok < 0 && ng > 0 || ok > 0 && ng < 0) mid = (ok + ng) / 2;
            else mid = ok + (ng - ok) / 2;

            if (calc(mid)) {
                ok = mid;
            } else {
                ng = mid;
            }
        }
        if (calc(ok)) return (int) ok;
        else return -1;
    }

    static <T> void initStreamArray(ArrayList<T>[] a, int n) {
        a = Stream.generate(ArrayList::new).limit(n).toArray(ArrayList[]::new);
    }

    //消す候補
    static ArrayList<Integer> divisors(int n) {
        ArrayList<Integer> res = new ArrayList<>();
        for (int i = 1; i <= Math.sqrt(n); i++) {
            if (n % i == 0) {
                res.add(i);
                if (i != n / i) res.add(n / i);
            }
        }
        return res;
    }

    static ArrayList<Long> divisors(long n) {
        ArrayList<Long> res = new ArrayList<>();
        for (long i = 1; i <= Math.sqrt(n); i++) {
            if (n % i == 0) {
                res.add(i);
                if (i != n / i) res.add(n / i);
            }
        }
        return res;
    }

    static ArrayList<Integer> factorization(int n) {
        if (primes == null) setPrimes();
        ArrayList<Integer> fact = new ArrayList<>();
        for (int p : primes) {
            if (n % p == 0) fact.add(p);
            while (n % p == 0) n /= p;
            if (n == 1) break;
        }
        if (n != 1) fact.add(n);
        return fact;
    }

    boolean equal(double a, double b) {
        return a == 0 ? abs(b) < EPS : abs((a - b) / a) < EPS;
    }

    public static void chMax(long v) {
        maxRes = Math.max(maxRes, v);
    }

    public static void chMin(long v) {
        minRes = Math.min(minRes, v);
    }

    //便利系
    //左端、右端の情報をもたせる。半開区間
    public static void setLR(int[] a, ArrayList<Integer> l, ArrayList<Integer> r) {
        for (int i = 0; i < a.length; i++) {
            if (a[i] > 0) {
                int j = i;
                while (a[j] > 0) j++;
                l.add(i);
                r.add(j);
                i = j - 1;
            }
        }
    }

    public static long[] rui(int[] a) {
        long[] res = new long[a.length + 1];
        for (int i = 0; i < a.length; i++) {
            res[i + 1] = a[i];
        }
        for (int i = 0; i < a.length; i++) {
            res[i + 1] += res[i];
        }
        return res;
    }

    //p[i].nowx := i番目に小さいｖの値 p[i].nowy := その個数
    //0個の物は除く
    public static P[] mato(int[] a) {
        CouMap map = new CouMap(a);
        P[] res = new P[map.size()];
        int i = 0;
        for (Map.Entry<Long, Long> m : map.map.entrySet()) {
            res[i++] = new P((int) (long) m.getKey(), (int) (long) m.getValue());
        }
        sort(res);
        return res;
    }

    public static int[] imosu(int[] f, int[] t, int n) {
        int[] imosu = new int[n + 1];
        for (int i = 0; i < f.length; i++) {
            imosu[f[i]]++;
            imosu[t[i] + 1]--;
        }
        for (int i = 0; i < n; i++) {
            imosu[i + 1] += imosu[i];
        }
        return imosu;
    }

    static int[] inverse(int[] a) {
        int[] res = new int[a.length];
        for (int i = 0; i < a.length; i++)
            res[a[i]] = i;
        return res;
    }

    public static String notE(double v) {
        return BigDecimal.valueOf(v).toPlainString();
    }

    public static void print(char[][] a) {
        for (int i = 0; i < a.length; i++) {
            for (int j = 0; j < a[0].length; j++) {
                System.out.print(a[i][j]);
            }
            System.out.println("");
        }
    }

    public static void print(int[][] a) {
        for (int i = 0; i < a.length; i++) {
            for (int j = 0; j < a[0].length; j++) {
                System.out.print(a[i][j] + " ");
            }
            System.out.println("");
        }
    }

    public static <T> void print(ArrayList<T> a) {
        for (T t : a) {
            System.out.println(t);
        }
    }

    public static void print(int[] a) {
        for (int i = 0; i < a.length; i++)
            System.out.println(a[i]);
    }

    public static void print(long[] a) {
        for (int i = 0; i < a.length; i++)
            System.out.println(a[i]);
    }

    //bit関連
    public static boolean bget(BitSet bit, int keta) {
        return bit.nextSetBit(keta) == keta;
    }

    public static boolean bget(long bit, int keta) {
        return ((bit >> keta) & 1) == 1;
    }

    public static int bget3(long bit, int keta) {
        bit /= (long) pow(3, keta);
        return (int) (bit % 3);
    }

    public static int getHashA(long key) {
        return (int) (key >> 32);
    }

    public static int getHashB(long key) {
        return (int) (key & -1);
    }

    //正の数のみ
    public static long getHashKey(int a, int b) {
        return (long) a << 32 | b;
    }
    //数学関係--------------------------------

    //a/bを返す
    public static long ceil(long a, long b) {
        return (a % b == 0) ? a / b : a / b + 1;
    }

    public static double sqrt(double v) {
        return Math.sqrt(v);
    }

    public static long sqrt(long v) {
        long res = (long) Math.sqrt(v);
        while (res * res > v) res--;
        return res;
    }

    static double[][] PER_DP;

    static double ncrPer(int n, int r) {
        if (n < r) return 0;
        if (PER_DP == null) {
            PER_DP = new double[5001][5001];
            PER_DP[0][0] = 1;
            for (int ni = 0; ni < PER_DP.length - 1; ni++) {
                for (int ri = 0; ri < ni + 1; ri++) {
                    PER_DP[ni + 1][ri] += PER_DP[ni][ri] / 2;
                    PER_DP[ni + 1][ri + 1] += PER_DP[ni][ri] / 2;
                }
            }
        }
        return PER_DP[n][r];
    }

    //mod関連
    public static int mod(long a, int m) {
        return (int) ((a % m + m) % m);
    }

    static void setMod() {
        fac = new int[(int) 1e6 + 1000];
        finv = new int[(int) 1e6 + 1000];
        inv = new int[(int) 1e6 + 1000];
        fac[0] = fac[1] = 1;
        finv[0] = finv[1] = 1;
        inv[1] = 1;
        for (int i = 2; i < 1e6 + 1000; i++) {
            fac[i] = mMul(fac[i - 1], i);
            inv[i] = MOD - mMul(inv[MOD % i], (MOD / i));
            finv[i] = mMul(finv[i - 1], inv[i]);
        }
    }

    static int mNcr(int n, int r) {
        if (n < 0 || r < 0 || n < r) return 0;
        int result = mMul(Fa[n], finv[n - r]);
        result = mMul(result, finv[r]);
        return result;
    }

    public static int mSum(long a, long b) {
        return (int) (((a % MOD + b % MOD) % MOD + MOD) % MOD);
    }

    public static int mDiff(long a, long b) {
        return mSum(a, -b);
    }

    public static int mMul(long a, long b) {
        return (int) (((a % MOD * b % MOD) % MOD + MOD) % MOD);
    }

    public static int mDiv(long a, long b) {
        return mMul(a, mInv(b));
    }

    public static long mSums(long... lar) {
        long res = 0;
        for (long l : lar)
            res = (res + l % MOD) % MOD;
        return (res + MOD) % MOD;
    }

    public static long mDiffs(long... lar) {
        long res = lar[0] % MOD;
        for (int i = 1; i < lar.length; i++) {
            res = (res - lar[i] % MOD) % MOD;
        }
        return (res + MOD) % MOD;
    }

    public static long mMuls(long... lar) {
        long res = 1;
        for (long l : lar)
            res = (res * (l % MOD)) % MOD;
        return (res + MOD) % MOD;
    }

    public static long mDivs(long... lar) {
        long res = lar[0] % MOD;
        for (int i = 1; i < lar.length; i++) {
            res = mMul(res, mInv(lar[i]));
        }
        return (res + MOD) % MOD;
    }

    static long mInv(long n) {
        return mPow(n, MOD - 2);
    }

    static int mPow(long x, long n) {
        long res = 1L;
        while (n > 0) {
            if ((n & 1) == 1) {
                res = res * x % MOD;
            }
            x = x * x % MOD;
            n >>= 1;
        }
        return (int) ((res + MOD) % MOD);
    }

    static void factorial() {
        Fa = new int[(int) 1e6 + 1];
        Fa[0] = Fa[1] = 1;
        for (int i = 2; i < Fa.length; i++) {
            Fa[i] = (int) ((Fa[i - 1] * 1L * i) % MOD);
        }
    }


    //↑nCrをmod計算するために必要
    static long lcm(long n, long r) {
        return n / gcd(n, r) * r;
    }

    static int gcd(int n, int r) {
        return r == 0 ? n : gcd(r, n % r);
    }

    static long gcd(long n, long r) {
        return r == 0 ? n : gcd(r, n % r);
    }

    public static int u0(int a) {
        if (a < 0) return 0;
        return a;
    }

    public static long u0(long a) {
        if (a < 0) return 0;
        return a;
    }

    public static double u0(double a) {
        if (a < 0) return 0;
        return a;
    }

    public static boolean[][] tbt(char[][] s, char c) {
        boolean[][] res = new boolean[s.length][s[0].length];
        for (int hi = 0; hi < s.length; hi++)
            for (int wi = 0; wi < s[0].length; wi++)
                if (s[hi][wi] == c) res[hi][wi] = true;
        return res;
    }

    public static int[] tia(int a) {
        int[] res = new int[keta(a)];
        for (int i = res.length - 1; i >= 0; i--) {
            res[i] = a % 10;
            a /= 10;
        }
        return res;
    }

    public static int[][] tit(char[][] a) {
        int[][] res = new int[a.length][a[0].length];
        for (int hi = 0; hi < a.length; hi++) {
            for (int wi = 0; wi < a[0].length; wi++) {
                res[hi][wi] = a[hi][wi] - '0';
            }
        }
        return res;
    }

    public static Integer[] toIntegerArray(int[] ar) {
        Integer[] res = new Integer[ar.length];
        for (int i = 0; i < ar.length; i++) {
            res[i] = ar[i];
        }
        return res;
    }

    //k個の次の組み合わせをビットで返す 大きさに上限はない 110110 -> 111001
    public static long bitNextComb(long comb) {
        long x = comb & -comb; //最下位の1
        long y = comb + x; //連続した下の1を繰り上がらせる
        return ((comb & ~y) / x >> 1) | y;
    }

    public static int keta(long num) {
        int res = 0;
        while (num > 0) {
            num /= 10;
            res++;
        }
        return res;
    }

    public static int ketaSum(long num) {
        int res = 0;
        while (num > 0) {
            res += num % 10;
            num /= 10;
        }
        return res;
    }

    public static boolean isOutofIndex(int x, int y, int w, int h) {
        if (x < 0 || y < 0) return true;
        if (w <= x || h <= y) return true;
        return false;
    }

    public static boolean isOutofIndex(int x, int y, char[][] ban) {
        if (x < 0 || y < 0) return true;
        if (ban[0].length <= x || ban.length <= y) return true;
        return false;
    }


    public static void setPrimes() {
        int n = 100001;
        isPrime = new boolean[n];
        Arrays.fill(isPrime, true);
        isPrime[0] = isPrime[1] = false;
        for (int i = 2; i * i <= n; i++) {
            if (!isPrime[i]) continue;
            for (int j = i * 2; j < n; j += i) {
                isPrime[j] = false;
            }
        }
        primes = new ArrayList<>();
        for (int i = 2; i < n; i++) {
            if (isPrime[i]) primes.add(i);
        }
    }

    public static void revSort(int[] a) {
        Arrays.sort(a);
        reverse(a);
    }

    public static void revSort(long[] a) {
        Arrays.sort(a);
        reverse(a);
    }

    public static P[] clone(P[] ar) {
        P[] res = new P[ar.length];
        for (int i = 0; i < ar.length; i++) {
            res[i] = new P(ar[i].x, ar[i].y);
        }
        return res;
    }

    public static int[][] clone(int[][] ar) {
        int[][] nr = new int[ar.length][ar[0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = ar[i].clone();
        return nr;
    }

    public static long[][] clone(long[][] ar) {
        long[][] nr = new long[ar.length][ar[0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = ar[i].clone();
        return nr;
    }

    public static double[][] clone(double[][] ar) {
        double[][] nr = new double[ar.length][ar[0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = ar[i].clone();
        return nr;
    }

    public static boolean[][] clone(boolean[][] ar) {
        boolean[][] nr = new boolean[ar.length][ar[0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = ar[i].clone();
        return nr;
    }

    public static char[][] clone(char[][] ar) {
        char[][] nr = new char[ar.length][ar[0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = ar[i].clone();
        return nr;
    }

    public static int[][][] clone(int[][][] ar) {
        int[][][] nr = new int[ar.length][ar[0].length][ar[0][0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = clone(ar[i]);
        return nr;
    }

    public static long[][][] clone(long[][][] ar) {
        long[][][] nr = new long[ar.length][ar[0].length][ar[0][0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = clone(ar[i]);
        return nr;
    }

    public static double[][][] clone(double[][][] ar) {
        double[][][] nr = new double[ar.length][ar[0].length][ar[0][0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = clone(ar[i]);
        return nr;
    }

    public static boolean[][][] clone(boolean[][][] ar) {
        boolean[][][] nr = new boolean[ar.length][ar[0].length][ar[0][0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = clone(ar[i]);
        return nr;
    }

    public static char[][][] clone(char[][][] ar) {
        char[][][] nr = new char[ar.length][ar[0].length][ar[0][0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = clone(ar[i]);
        return nr;
    }

    /**
     * <h1>指定した値以上の先頭のインデクスを返す</h1>
     * <p>配列要素が０のときは、０が返る。</p>
     *
     * @return<b>int</b> ： 探索した値以上で、先頭になるインデクス
     * 値が無ければ、挿入できる最小のインデックス
     */
    public static <T extends Number> int lowerBound(final List<T> lis, final T value) {
        int low = 0;
        int high = lis.size();
        int mid;

        while (low < high) {
            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 (オーバーフロー対策)
            if (lis.get(mid).doubleValue() < value.doubleValue()) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    //v未満で最大のiを返す。ただしv以上を満たすiがあるなら最小のiを返す
    public static <T extends Number> int rlowerBound(final List<T> lis, final T value) {
        int ind = lowerBound(lis, value);
        if (ind == lis.size() || !lis.get(ind).equals(value)) ind--;
        return ind;
    }

    /**
     * <h1>指定した値より大きい先頭のインデクスを返す</h1>
     * <p>配列要素が０のときは、０が返る。</p>
     *
     * @return<b>int</b> ： 探索した値より上で、先頭になるインデクス
     * 値が無ければ、挿入できる最小のインデックス
     */
    public static <T extends Number> int upperBound(final List<T> lis, final T value) {
        int low = 0;
        int high = lis.size();
        int mid;
        while (low < high) {
            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 (オーバーフロー対策)
            if (lis.get(mid).doubleValue() < value.doubleValue()) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(final int[] arr, final int value) {
        int low = 0;
        int high = arr.length;
        int mid;

        while (low < high) {
            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 (オーバーフロー対策)
            if (arr[mid] < value) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int rlowerBound(final int[] arr, final int value) {
        int ind = lowerBound(arr, value);
        if (ind == arr.length || arr[ind] != value) ind--;
        return ind;
    }


    public static int upperBound(final int[] arr, final int value) {
        int low = 0;
        int high = arr.length;
        int mid;
        while (low < high) {
            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 (オーバーフロー対策)
            if (arr[mid] <= value) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(final long[] arr, final long value) {
        int low = 0;
        int high = arr.length;
        int mid;
        while (low < high) {
            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 (オーバーフロー対策)
            if (arr[mid] < value) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int rlowerBound(final long[] arr, final long value) {
        int ind = lowerBound(arr, value);
        if (ind == arr.length || arr[ind] != value) ind--;
        return ind;
    }

    public static int upperBound(final long[] arr, final long value) {
        int low = 0;
        int high = arr.length;
        int mid;
        while (low < high) {
            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 (オーバーフロー対策)
            if (arr[mid] <= value) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    //次の順列に書き換える、最大値ならfalseを返す
    public static boolean nextPermutation(int A[]) {
        int len = A.length;
        int pos = len - 2;
        for (; pos >= 0; pos--) {
            if (A[pos] < A[pos + 1]) break;
        }
        if (pos == -1) return false;
        //posより大きい最小の数を二分探索
        int ok = pos + 1;
        int ng = len;
        while (Math.abs(ng - ok) > 1) {
            int mid = (ok + ng) / 2;
            if (A[mid] > A[pos]) ok = mid;
            else ng = mid;
        }
        swap(A, pos, ok);
        reverse(A, pos + 1, len - 1);
        return true;
    }

    //次の順列に書き換える、最小値ならfalseを返す
    public static boolean prevPermutation(int A[]) {
        int len = A.length;
        int pos = len - 2;
        for (; pos >= 0; pos--) {
            if (A[pos] > A[pos + 1]) break;
        }
        if (pos == -1) return false;
        //posより小さい最大の数を二分探索
        int ok = pos + 1;
        int ng = len;
        while (Math.abs(ng - ok) > 1) {
            int mid = (ok + ng) / 2;
            if (A[mid] < A[pos]) ok = mid;
            else ng = mid;
        }
        swap(A, pos, ok);
        reverse(A, pos + 1, len - 1);
        return true;
    }

    static <T> void swap(T[] x, int i, int j) {
        T t = x[i];
        x[i] = x[j];
        x[j] = t;
    }

    static void swap(char[] x, int i, int j) {
        char t = x[i];
        x[i] = x[j];
        x[j] = t;
    }

    static void swap(int[] x, int i, int j) {
        int t = x[i];
        x[i] = x[j];
        x[j] = t;
    }

    public static String reverse(String a) {
        sb.append(a);
        String res = sb.reverse().toString();
        sb.setLength(0);
        return new String(res);
    }

    public static void reverse(int[] x) {
        int l = 0;
        int r = x.length - 1;
        while (l < r) {
            int temp = x[l];
            x[l] = x[r];
            x[r] = temp;
            l++;
            r--;
        }
    }

    public static void reverse(long[] x) {
        int l = 0;
        int r = x.length - 1;
        while (l < r) {
            long temp = x[l];
            x[l] = x[r];
            x[r] = temp;
            l++;
            r--;
        }
    }

    public static void reverse(char[] x) {
        int l = 0;
        int r = x.length - 1;
        while (l < r) {
            char temp = x[l];
            x[l] = x[r];
            x[r] = temp;
            l++;
            r--;
        }
    }

    public static void reverse(int[] x, int s, int e) {
        int l = s;
        int r = e;
        while (l < r) {
            int temp = x[l];
            x[l] = x[r];
            x[r] = temp;
            l++;
            r--;
        }
    }

    static int cou(boolean[] a) {
        int res = 0;
        for (boolean b : a) {
            if (b) res++;
        }
        return res;
    }

    static int cou(boolean[][] a) {
        int res = 0;
        for (boolean[] b : a) {
            res += cou(b);
        }
        return res;
    }

    static int cou(String s, char c) {
        int res = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == c) res++;
        }
        return res;
    }

    static int cou(char[][] a, char c) {
        int co = 0;
        for (int i = 0; i < a.length; i++)
            for (int j = 0; j < a[0].length; j++)
                if (a[i][j] == c) co++;
        return co;
    }

    static int cou(int[] a, int key) {
        int co = 0;
        for (int i = 0; i < a.length; i++)
            if (a[i] == key) co++;
        return co;
    }

    static int cou(long[] a, long key) {
        int co = 0;
        for (int i = 0; i < a.length; i++)
            if (a[i] == key) co++;
        return co;
    }

    static int cou(int[][] a, int key) {
        int co = 0;
        for (int i = 0; i < a.length; i++)
            co += (cou(a[i], key));
        return co;
    }

    static int[] couArray(int[] a) {
        int[] res = new int[maxs(a) + 1];
        for (int i : a) {
            res[i]++;
        }
        return res;
    }

    static void fill(int[] a, int v) {
        Arrays.fill(a, v);
    }

    static void fill(long[] a, int v) {
        Arrays.fill(a, v);
    }

    static void fill(boolean[] a, boolean v) {
        Arrays.fill(a, v);
    }

    static void fill(int[][] a, int v) {
        for (int i = 0; i < a.length; i++)
            Arrays.fill(a[i], v);
    }

    static void fill(char[][] a, char c) {
        for (int i = 0; i < a.length; i++)
            Arrays.fill(a[i], c);
    }

    static void fill(long[][] a, long v) {
        for (int i = 0; i < a.length; i++)
            Arrays.fill(a[i], v);
    }

    static void fill(double[][] a, double v) {
        for (int i = 0; i < a.length; i++)
            Arrays.fill(a[i], v);
    }

    static void fill(boolean[][] a, boolean v) {
        for (int i = 0; i < a.length; i++)
            Arrays.fill(a[i], v);
    }

    static void fill(int[][][] a, int v) {
        for (int i = 0; i < a.length; i++)
            fill(a[i], v);
    }

    static void fill(long[][][] a, long v) {
        for (int i = 0; i < a.length; i++)
            fill(a[i], v);
    }

    static int maxs(int... a) {
        int res = Integer.MIN_VALUE;
        for (int i : a) {
            res = Math.max(res, i);
        }
        return res;
    }

    static long maxs(long... a) {
        long res = Long.MIN_VALUE;
        for (long i : a) {
            res = Math.max(res, i);
        }
        return res;
    }

    static double maxs(double... a) {
        double res = Double.MIN_VALUE;
        for (double i : a) {
            res = Math.max(res, i);
        }
        return res;
    }

    static long mins(long... a) {
        long res = Long.MAX_VALUE;
        for (long i : a) {
            res = Math.min(res, i);
        }
        return res;
    }

    static int maxs(int[][] ar) {
        int res = Integer.MIN_VALUE;
        for (int i[] : ar)
            res = Math.max(res, maxs(i));
        return res;
    }

    static long maxs(long[][] ar) {
        long res = Integer.MIN_VALUE;
        for (long i[] : ar)
            res = Math.max(res, maxs(i));
        return res;
    }

    static int mins(int... a) {
        int res = Integer.MAX_VALUE;
        for (int i : a) {
            res = Math.min(res, i);
        }
        return res;
    }


    static int mins(int[][] ar) {
        int res = Integer.MAX_VALUE;
        for (int i[] : ar)
            res = Math.min(res, mins(i));
        return res;
    }

    public static <T extends Number> long sum(ArrayList<T> lis) {
        long res = 0;
        for (T li : lis) {
            res += li.longValue();
        }
        return res;
    }

    static long sum(int[] a) {
        long cou = 0;
        for (int i : a)
            cou += i;
        return cou;
    }

    static long sum(long[] a) {
        long cou = 0;
        for (long i : a)
            cou += i;
        return cou;
    }


//FastScanner

    static BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
    static StringTokenizer tokenizer = null;

    public static String next() {
        if (tokenizer == null || !tokenizer.hasMoreTokens()) {
            try {
                tokenizer = new StringTokenizer(reader.readLine());
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
        return tokenizer.nextToken();
    }

    public static String nextLine() {
        if (tokenizer == null || !tokenizer.hasMoreTokens()) {
            try {
                return reader.readLine();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }

        return tokenizer.nextToken("\n");
    }

    public static long nl() {
        return Long.parseLong(next());
    }

    public static String n() {
        return next();
    }

    public static int ni() {
        return Integer.parseInt(next());
    }

    public static double nd() {
        return Double.parseDouble(next());
    }

    public static int[] nia(int n) {
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = ni();
        }
        return a;
    }

    //1-index
    public static int[] niao(int n) {
        int[] a = new int[n + 1];
        for (int i = 1; i < n + 1; i++) {
            a[i] = ni();
        }
        return a;
    }

    //番兵法
    public static int[] nias(int n, int end) {
        int[] a = new int[n + 1];
        for (int i = 0; i < n; i++) {
            a[i] = ni();
        }
        a[n] = end;
        return a;
    }

    public static int[] niad(int n) {
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = ni() - 1;
        }
        return a;
    }

    public static P[] npa(int n) {
        P[] p = new P[n];
        for (int i = 0; i < n; i++) {
            p[i] = new P(ni(), ni());
        }
        return p;
    }

    public static P[] npad(int n) {
        P[] p = new P[n];
        for (int i = 0; i < n; i++) {
            p[i] = new P(ni() - 1, ni() - 1);
        }
        return p;
    }

    public static int[][] nit(int h, int w) {
        int[][] a = new int[h][w];
        for (int hi = 0; hi < h; hi++) {
            for (int wi = 0; wi < w; wi++) {
                a[hi][wi] = ni();
            }
        }
        return a;
    }

    public static int[][] nitd(int h, int w) {
        int[][] a = new int[h][w];
        for (int hi = 0; hi < h; hi++) {
            for (int wi = 0; wi < w; wi++) {
                a[hi][wi] = ni() - 1;
            }
        }
        return a;
    }

    static int[][] S_ARRAY;
    static long[][] S_LARRAY;
    static int S_INDEX;
    static int S_LINDEX;

    //複数の配列を受け取る
    public static int[] niah(int n, int k) throws Exception {
        if (S_ARRAY == null) {
            S_ARRAY = new int[k][n];
            for (int j = 0; j < n; j++) {
                for (int i = 0; i < k; i++) {
                    S_ARRAY[i][j] = ni();
                }
            }
        }
        return S_ARRAY[S_INDEX++];
    }

    public static long[] nlah(int n, int k) throws Exception {
        if (S_LARRAY == null) {
            S_LARRAY = new long[k][n];
            for (int j = 0; j < n; j++) {
                for (int i = 0; i < k; i++) {
                    S_LARRAY[i][j] = nl();
                }
            }
        }
        return S_LARRAY[S_LINDEX++];
    }

    //複数の配列を受け取る
    public static int[] niahd(int n, int k) throws Exception {
        if (S_ARRAY == null) {
            S_ARRAY = new int[k][n];
            for (int j = 0; j < n; j++) {
                for (int i = 0; i < k; i++) {
                    S_ARRAY[i][j] = ni() - 1;
                }
            }
        }
        return S_ARRAY[S_INDEX++];
    }

    public static long[] nlahd(int n, int k) throws Exception {
        if (S_LARRAY == null) {
            S_LARRAY = new long[k][n];
            for (int j = 0; j < n; j++) {
                for (int i = 0; i < k; i++) {
                    S_LARRAY[i][j] = nl() - 1;
                }
            }
        }
        return S_LARRAY[S_LINDEX++];
    }

    public static char[] nca() {
        char[] a = next().toCharArray();
        return a;
    }


    public static String[] nsa(int n) {
        String[] res = new String[n];
        for (int i = 0; i < n; i++) {
            res[i] = n();
        }
        return res;
    }

    //スペースが入っている場合
    public static char[][] ncts(int h, int w) {
        char[][] a = new char[h][w];
        for (int hi = 0; hi < h; hi++) {
            String s = nextLine().replace(" ", "");
            for (int wi = 0; wi < s.length(); wi++) {
                a[hi][wi] = s.charAt(wi);
            }
        }
        return a;
    }

    public static char[][] nct(int h, int w) {
        char[][] a = new char[h][w];
        for (int hi = 0; hi < h; hi++) {
            String s = nextLine();
            for (int wi = 0; wi < s.length(); wi++) {
                a[hi][wi] = s.charAt(wi);
            }
        }
        return a;
    }

    public static char[][] nctp(int h, int w, char c) {
        char[][] a = new char[h + 2][w + 2];
        for (int hi = 1; hi < h + 1; hi++) {
            String s = nextLine();
            for (int wi = 1; wi < s.length() + 1; wi++) {
                a[hi][wi] = s.charAt(wi - 1);
            }
        }
        for (int wi = 0; wi < w + 2; wi++)
            a[0][wi] = a[h + 1][wi] = c;
        for (int hi = 0; hi < h + 2; hi++)
            a[hi][0] = a[hi][w + 1] = c;
        return a;
    }

    //スペースが入ってる時用
    public static char[][] nctsp(int h, int w, char c) {
        char[][] a = new char[h + 2][w + 2];
        //char c = '*';
        int i;
        for (i = 0; i < w + 2; i++)
            a[0][i] = c;
        for (i = 1; i < h + 1; i++) {
            a[i] = (c + nextLine().replace(" ", "") + c).toCharArray();
        }
        for (i = 0; i < w + 2; i++)
            a[h + 1][i] = c;
        return a;
    }

    public static long[] nla(int n) {
        long[] a = new long[n];
        for (int i = 0; i < n; i++) {
            a[i] = nl();
        }
        return a;
    }

    public static long[] nlas(int n, long e) {
        long[] a = new long[n + 1];
        for (int i = 0; i < n; i++) {
            a[i] = nl();
        }
        a[n] = e;
        return a;
    }

    public static long[] nlao(int n) {
        long[] a = new long[n + 1];
        for (int i = 0; i < n; i++) {
            a[i + 1] = nl();
        }
        return a;
    }

    public static long[] nlad(int n) {
        long[] a = new long[n];
        for (int i = 0; i < n; i++) {
            a[i] = nl() - 1;
        }
        return a;
    }

    public static long[][] nlt(int h, int w) {
        long[][] a = new long[h][w];
        for (int hi = 0; hi < h; hi++) {
            for (int wi = 0; wi < w; wi++) {
                a[hi][wi] = nl();
            }
        }
        return a;
    }

    //便利クラス
    static class CouMap {
        public HashMap<Long, Long> map;
        public HashMap<String, Long> smap;

        CouMap() {
            map = new HashMap();
            smap = new HashMap();
        }

        CouMap(int[] a) {
            map = new HashMap();
            smap = new HashMap();
            for (int i : a) {
                put(i);
            }
        }

        public int size() {
            return map.size();
        }

        public void put(long key, long value) {
            Long nowValue = map.get(key);
            map.put(key, nowValue == null ? value : nowValue + value);
        }

        public void put(String key, long value) {
            Long nowValue = smap.get(key);
            smap.put(key, nowValue == null ? value : nowValue + value);
        }

        public void mput(long key, long value) {
            Long nowValue = map.get(key);
            map.put(key, nowValue == null ? value % MOD : mSum(nowValue, value));
        }

        public void put(long key) {
            put(key, 1);
        }

        public void put(String key) {
            put(key, 1);
        }

        public void put(int... arg) {
            for (int i : arg) {
                put(i, 1);
            }
        }

        public void put(long... arg) {
            for (long i : arg) {
                put(i, 1);
            }
        }

        public void mput(int... arg) {
            for (int i : arg) {
                mput(i, 1);
            }
        }

        public void mput(long... arg) {
            for (long i : arg) {
                mput(i, 1);
            }
        }

        public long get(long key) {
            Long v = map.get(key);
            return v == null ? 0 : v;
        }

        public long get(String key) {
            Long v = map.get(key);
            return v == null ? 0 : v;
        }
    }

    static class P implements Comparable<P> {
        int x, y;

        @Override
        public int compareTo(P p) {
            //xyで昇順
            return x == p.x ? y - p.y : x - p.x;
            //xyで降順
            //return (nowx == p.nowx ? nowy - p.nowy : nowx - p.nowx) * -1;
            //yxで昇順
            //return nowy == p.nowy ? nowx - p.nowx : nowy - p.nowy;
            //yxで昇順
            //return (nowy == p.nowy ? nowx - p.nowx : nowy - p.nowy) * -1;

            //x昇 y降
            //return nowx == p.nowx ? p.nowy - nowy : nowx - p.nowx;
            //x降 y昇
            //return (nowx == p.nowx ? p.nowy - nowy : nowx - p.nowx) * -1;
            //y昇 x降
            //return nowy == p.nowy ? p.nowx - nowx : nowy - p.nowy;
            //y降 x昇
            //return (nowy == p.nowy ? p.nowx - nowx : nowy - p.nowy) * -1;
        }

        P(int a, int b) {
            x = a;
            y = b;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof P)) return false;
            P p = (P) o;
            return x == p.x && y == p.y;
        }

        @Override
        public int hashCode() {
            return Objects.hash(x, y);
        }

    }

    static class PL implements Comparable<PL> {
        long x, y;

        public int compareTo(PL p) {
            //xyで昇順
            long res = x == p.x ? y - p.y : x - p.x;
            //xyで降順
            //long res = (nowx == p.nowx ? nowy - p.nowy : nowx - p.nowx) * -1;
            //yxで昇順
            //long res = nowy == p.nowy ? nowx - p.nowx : nowy - p.nowy;
            //yxで昇順
            //long res = (nowy == p.nowy ? nowx - p.nowx : nowy - p.nowy) * -1;

            //x昇 y降
            //long res = nowx == p.nowx ? p.nowy - nowy : nowx - p.nowx;
            //x降 y昇
            //long res = (nowx == p.nowx ? p.nowy - nowy : nowx - p.nowx) * -1;
            //y昇 x降
            //long res = nowy == p.nowy ? p.nowx - nowx : nowy - p.nowy;
            //y降 x昇
            //long res = (nowy == p.nowy ? p.nowx - nowx : nowy - p.nowy) * -1;

            return (res == 0) ? 0 : res > 0 ? 1 : -1;
        }

        PL(long a, long b) {
            x = a;
            y = b;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof PL)) return false;
            PL p = (PL) o;
            return x == p.x && y == p.y;
        }

        @Override
        public int hashCode() {
            return Objects.hash(x, y);
        }

    }

    //値を渡す際は半開区間
    static class RectangleSum {
        //半開区間 0は0
        long[][] rui;
        int H, W;

        RectangleSum(long[][] ori) {
            H = ori.length;
            W = ori[0].length;
            rui = new long[H + 1][W + 1];
            for (int hi = 0; hi < H; hi++) {
                for (int wi = 0; wi < W; wi++) {
                    rui[hi + 1][wi + 1] = ori[hi][wi];
                }
            }
            for (int hi = 1; hi < H + 1; hi++) {
                for (int wi = 1; wi < W + 1; wi++) {
                    rui[hi][wi] += rui[hi - 1][wi];
                    rui[hi][wi] += rui[hi][wi - 1];
                    rui[hi][wi] -= rui[hi - 1][wi - 1];
                }
            }
        }

        RectangleSum(int[][] ori) {
            H = ori.length;
            W = ori[0].length;
            rui = new long[H + 1][W + 1];
            for (int hi = 0; hi < H; hi++) {
                for (int wi = 0; wi < W; wi++) {
                    rui[hi + 1][wi + 1] = ori[hi][wi];
                }
            }
            for (int hi = 1; hi < H + 1; hi++) {
                for (int wi = 1; wi < W + 1; wi++) {
                    rui[hi][wi] += rui[hi - 1][wi];
                    rui[hi][wi] += rui[hi][wi - 1];
                    rui[hi][wi] -= rui[hi - 1][wi - 1];
                }
            }
        }

        //半開区間
        public long getSum(int left, int right, int top, int bottom) {
            if (right > W || bottom > H) return 0;
            if (left < 0 || top < 0) return 0;
            if (top >= bottom || left >= right) return 0;
            long res = rui[bottom][right];
            res -= rui[top][right];
            res -= rui[bottom][left];
            res += rui[top][left];
            return res;
        }

    }

    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        solve();
        System.out.flush();
        long endTime = System.currentTimeMillis();
        if (DEBUG) System.err.println(endTime - startTime);
    }

}

</source>
<source file="../hum_codes_raw/s613685593.java" startline="1" endline="1566" pcid="20610">
import java.io.*;

import static java.lang.Math.*;
import static java.lang.Math.min;

import java.math.BigDecimal;
import java.util.*;

import static java.util.Arrays.*;

import java.util.stream.*;

/**
 * @author baito
 */
@SuppressWarnings("unchecked")
public class Main {
    static boolean DEBUG = true;
    static StringBuilder sb = new StringBuilder();
    static int INF = 1234567890;
    static int MINF = -1234567890;
    static long LINF = 123456789123456789L;
    static long MLINF = -123456789123456789L;
    static int MOD = (int) 1e9 + 7;
    static double EPS = 1e-10;
    static int[] y4 = {-1, 1, 0, 0};
    static int[] x4 = {0, 0, -1, 1};
    static int[] y8 = {0, 1, 0, -1, -1, 1, 1, -1};
    static int[] x8 = {1, 0, -1, 0, 1, -1, 1, -1};
    static int[] Fa;
    static boolean[] isPrime;
    static ArrayList<Integer> primes;
    static char[][] S;
    static long maxRes = Long.MIN_VALUE;
    static long minRes = Long.MAX_VALUE;
    static int[] fac, finv, inv;

    //    static int N;
//    static int[] A;
    static int N, A, B, C, D;
    static int[][] dp;

    public static void solve() throws Exception {
//        longを忘れるなオーバーフローするぞ
//        N = ni();
//        A = nia(N);
//        $END$
        int N = ni();
        int A = ni();
        int B = ni();
        int C = ni();
        int D = ni();
        setMod();
        long[][] dp = new long[N + 1][N + 1];
        for (int i = 0; i < N + 1; i++) {
            dp[i][0] = 1;
        }
        long[][] mPowFinv = new long[N + 1][N + 1];
        for (int k = 0; k < N + 1; k++) {
            mPowFinv[k][1] = finv[k];
        }
        for (int k = 0; k < N + 1; k++) {
            for (int i = 2; i < D + 1; i++) {
                mPowFinv[k][i] = mPowFinv[k][i - 1] * finv[k] % MOD;
            }
        }
        for (int k = 1; k <= N; k++) {
            for (int n = 1; n <= N; n++) {
                //k人が0のとき
                dp[k][n] = dp[k - 1][n];
                if (!(A <= k && k <= B)) continue;
                for (int x = C; x <= D && n - k * x >= 0; x++) {
                    //n人からk人をxグループ作りその他はk-1人以下
                    long cal = mMuls(fac[n], finv[n - k * x], mPowFinv[k][x], finv[x]);
                    cal = mMul(cal, dp[k - 1][n - k * x]);
                    dp[k][n] = mSum(dp[k][n], cal);
                }
            }
        }
        System.out.println(dp[N][N]);
    }


    public static boolean calc(long va) {
        //貪欲にギリギリセーフを選んでいく。
        int v = (int) va;
        return true;
    }

    //条件を満たす最大値、あるいは最小値を求める
    static int mgr(long ok, long ng) {
        //int ok = 0; //解が存在する
        //int ng = N; //解が存在しない
        while (Math.abs(ok - ng) > 1) {
            long mid;
            if (ok < 0 && ng > 0 || ok > 0 && ng < 0) mid = (ok + ng) / 2;
            else mid = ok + (ng - ok) / 2;

            if (calc(mid)) {
                ok = mid;
            } else {
                ng = mid;
            }
        }
        if (calc(ok)) return (int) ok;
        else return -1;
    }

    static <T> void initStreamArray(ArrayList<T>[] a, int n) {
        a = Stream.generate(ArrayList::new).limit(n).toArray(ArrayList[]::new);
    }

    //消す候補
    static ArrayList<Integer> divisors(int n) {
        ArrayList<Integer> res = new ArrayList<>();
        for (int i = 1; i <= Math.sqrt(n); i++) {
            if (n % i == 0) {
                res.add(i);
                if (i != n / i) res.add(n / i);
            }
        }
        return res;
    }

    static ArrayList<Long> divisors(long n) {
        ArrayList<Long> res = new ArrayList<>();
        for (long i = 1; i <= Math.sqrt(n); i++) {
            if (n % i == 0) {
                res.add(i);
                if (i != n / i) res.add(n / i);
            }
        }
        return res;
    }

    static ArrayList<Integer> factorization(int n) {
        if (primes == null) setPrimes();
        ArrayList<Integer> fact = new ArrayList<>();
        for (int p : primes) {
            if (n % p == 0) fact.add(p);
            while (n % p == 0) n /= p;
            if (n == 1) break;
        }
        if (n != 1) fact.add(n);
        return fact;
    }

    boolean equal(double a, double b) {
        return a == 0 ? abs(b) < EPS : abs((a - b) / a) < EPS;
    }

    public static void chMax(long v) {
        maxRes = Math.max(maxRes, v);
    }

    public static void chMin(long v) {
        minRes = Math.min(minRes, v);
    }

    //便利系
    //左端、右端の情報をもたせる。半開区間
    public static void setLR(int[] a, ArrayList<Integer> l, ArrayList<Integer> r) {
        for (int i = 0; i < a.length; i++) {
            if (a[i] > 0) {
                int j = i;
                while (a[j] > 0) j++;
                l.add(i);
                r.add(j);
                i = j - 1;
            }
        }
    }

    public static long[] rui(int[] a) {
        long[] res = new long[a.length + 1];
        for (int i = 0; i < a.length; i++) {
            res[i + 1] = a[i];
        }
        for (int i = 0; i < a.length; i++) {
            res[i + 1] += res[i];
        }
        return res;
    }

    //p[i].nowx := i番目に小さいｖの値 p[i].nowy := その個数
    //0個の物は除く
    public static P[] mato(int[] a) {
        CouMap map = new CouMap(a);
        P[] res = new P[map.size()];
        int i = 0;
        for (Map.Entry<Long, Long> m : map.map.entrySet()) {
            res[i++] = new P((int) (long) m.getKey(), (int) (long) m.getValue());
        }
        sort(res);
        return res;
    }

    public static int[] imosu(int[] f, int[] t, int n) {
        int[] imosu = new int[n + 1];
        for (int i = 0; i < f.length; i++) {
            imosu[f[i]]++;
            imosu[t[i] + 1]--;
        }
        for (int i = 0; i < n; i++) {
            imosu[i + 1] += imosu[i];
        }
        return imosu;
    }

    static int[] inverse(int[] a) {
        int[] res = new int[a.length];
        for (int i = 0; i < a.length; i++)
            res[a[i]] = i;
        return res;
    }

    public static String notE(double v) {
        return BigDecimal.valueOf(v).toPlainString();
    }

    public static void print(char[][] a) {
        for (int i = 0; i < a.length; i++) {
            for (int j = 0; j < a[0].length; j++) {
                System.out.print(a[i][j]);
            }
            System.out.println("");
        }
    }

    public static void print(int[][] a) {
        for (int i = 0; i < a.length; i++) {
            for (int j = 0; j < a[0].length; j++) {
                System.out.print(a[i][j] + " ");
            }
            System.out.println("");
        }
    }

    public static <T> void print(ArrayList<T> a) {
        for (T t : a) {
            System.out.println(t);
        }
    }

    public static void print(int[] a) {
        for (int i = 0; i < a.length; i++)
            System.out.println(a[i]);
    }

    public static void print(long[] a) {
        for (int i = 0; i < a.length; i++)
            System.out.println(a[i]);
    }

    //bit関連
    public static boolean bget(BitSet bit, int keta) {
        return bit.nextSetBit(keta) == keta;
    }

    public static boolean bget(long bit, int keta) {
        return ((bit >> keta) & 1) == 1;
    }

    public static int bget3(long bit, int keta) {
        bit /= (long) pow(3, keta);
        return (int) (bit % 3);
    }

    public static int getHashA(long key) {
        return (int) (key >> 32);
    }

    public static int getHashB(long key) {
        return (int) (key & -1);
    }

    //正の数のみ
    public static long getHashKey(int a, int b) {
        return (long) a << 32 | b;
    }
    //数学関係--------------------------------

    //a/bを返す
    public static long ceil(long a, long b) {
        return (a % b == 0) ? a / b : a / b + 1;
    }

    public static double sqrt(double v) {
        return Math.sqrt(v);
    }

    public static long sqrt(long v) {
        long res = (long) Math.sqrt(v);
        while (res * res > v) res--;
        return res;
    }

    static double[][] PER_DP;

    static double ncrPer(int n, int r) {
        if (n < r) return 0;
        if (PER_DP == null) {
            PER_DP = new double[5001][5001];
            PER_DP[0][0] = 1;
            for (int ni = 0; ni < PER_DP.length - 1; ni++) {
                for (int ri = 0; ri < ni + 1; ri++) {
                    PER_DP[ni + 1][ri] += PER_DP[ni][ri] / 2;
                    PER_DP[ni + 1][ri + 1] += PER_DP[ni][ri] / 2;
                }
            }
        }
        return PER_DP[n][r];
    }

    //mod関連
    public static int mod(long a, int m) {
        return (int) ((a % m + m) % m);
    }

    static void setMod() {
        fac = new int[(int) 1e6 + 1000];
        finv = new int[(int) 1e6 + 1000];
        inv = new int[(int) 1e6 + 1000];
        fac[0] = fac[1] = 1;
        finv[0] = finv[1] = 1;
        inv[1] = 1;
        for (int i = 2; i < 1e6 + 1000; i++) {
            fac[i] = mMul(fac[i - 1], i);
            inv[i] = MOD - mMul(inv[MOD % i], (MOD / i));
            finv[i] = mMul(finv[i - 1], inv[i]);
        }
    }

    static int mNcr(int n, int r) {
        if (n < 0 || r < 0 || n < r) return 0;
        int result = mMul(Fa[n], finv[n - r]);
        result = mMul(result, finv[r]);
        return result;
    }

    public static int mSum(long a, long b) {
        return (int) (((a % MOD + b % MOD) % MOD + MOD) % MOD);
    }

    public static int mDiff(long a, long b) {
        return mSum(a, -b);
    }

    public static int mMul(long a, long b) {
        return (int) (((a % MOD * b % MOD) % MOD + MOD) % MOD);
    }

    public static int mDiv(long a, long b) {
        return mMul(a, mInv(b));
    }

    public static long mSums(long... lar) {
        long res = 0;
        for (long l : lar)
            res = (res + l % MOD) % MOD;
        return (res + MOD) % MOD;
    }

    public static long mDiffs(long... lar) {
        long res = lar[0] % MOD;
        for (int i = 1; i < lar.length; i++) {
            res = (res - lar[i] % MOD) % MOD;
        }
        return (res + MOD) % MOD;
    }

    public static long mMuls(long... lar) {
        long res = 1;
        for (long l : lar)
            res = (res * (l % MOD)) % MOD;
        return (res + MOD) % MOD;
    }

    public static long mDivs(long... lar) {
        long res = lar[0] % MOD;
        for (int i = 1; i < lar.length; i++) {
            res = mMul(res, mInv(lar[i]));
        }
        return (res + MOD) % MOD;
    }

    static long mInv(long n) {
        return mPow(n, MOD - 2);
    }

    static int mPow(long x, long n) {
        long res = 1L;
        while (n > 0) {
            if ((n & 1) == 1) {
                res = res * x % MOD;
            }
            x = x * x % MOD;
            n >>= 1;
        }
        return (int) ((res + MOD) % MOD);
    }

    static void factorial() {
        Fa = new int[(int) 1e6 + 1];
        Fa[0] = Fa[1] = 1;
        for (int i = 2; i < Fa.length; i++) {
            Fa[i] = (int) ((Fa[i - 1] * 1L * i) % MOD);
        }
    }


    //↑nCrをmod計算するために必要
    static long lcm(long n, long r) {
        return n / gcd(n, r) * r;
    }

    static int gcd(int n, int r) {
        return r == 0 ? n : gcd(r, n % r);
    }

    static long gcd(long n, long r) {
        return r == 0 ? n : gcd(r, n % r);
    }

    public static int u0(int a) {
        if (a < 0) return 0;
        return a;
    }

    public static long u0(long a) {
        if (a < 0) return 0;
        return a;
    }

    public static double u0(double a) {
        if (a < 0) return 0;
        return a;
    }

    public static boolean[][] tbt(char[][] s, char c) {
        boolean[][] res = new boolean[s.length][s[0].length];
        for (int hi = 0; hi < s.length; hi++)
            for (int wi = 0; wi < s[0].length; wi++)
                if (s[hi][wi] == c) res[hi][wi] = true;
        return res;
    }

    public static int[] tia(int a) {
        int[] res = new int[keta(a)];
        for (int i = res.length - 1; i >= 0; i--) {
            res[i] = a % 10;
            a /= 10;
        }
        return res;
    }

    public static int[][] tit(char[][] a) {
        int[][] res = new int[a.length][a[0].length];
        for (int hi = 0; hi < a.length; hi++) {
            for (int wi = 0; wi < a[0].length; wi++) {
                res[hi][wi] = a[hi][wi] - '0';
            }
        }
        return res;
    }

    public static Integer[] toIntegerArray(int[] ar) {
        Integer[] res = new Integer[ar.length];
        for (int i = 0; i < ar.length; i++) {
            res[i] = ar[i];
        }
        return res;
    }

    //k個の次の組み合わせをビットで返す 大きさに上限はない 110110 -> 111001
    public static long bitNextComb(long comb) {
        long x = comb & -comb; //最下位の1
        long y = comb + x; //連続した下の1を繰り上がらせる
        return ((comb & ~y) / x >> 1) | y;
    }

    public static int keta(long num) {
        int res = 0;
        while (num > 0) {
            num /= 10;
            res++;
        }
        return res;
    }

    public static int ketaSum(long num) {
        int res = 0;
        while (num > 0) {
            res += num % 10;
            num /= 10;
        }
        return res;
    }

    public static boolean isOutofIndex(int x, int y, int w, int h) {
        if (x < 0 || y < 0) return true;
        if (w <= x || h <= y) return true;
        return false;
    }

    public static boolean isOutofIndex(int x, int y, char[][] ban) {
        if (x < 0 || y < 0) return true;
        if (ban[0].length <= x || ban.length <= y) return true;
        return false;
    }


    public static void setPrimes() {
        int n = 100001;
        isPrime = new boolean[n];
        Arrays.fill(isPrime, true);
        isPrime[0] = isPrime[1] = false;
        for (int i = 2; i * i <= n; i++) {
            if (!isPrime[i]) continue;
            for (int j = i * 2; j < n; j += i) {
                isPrime[j] = false;
            }
        }
        primes = new ArrayList<>();
        for (int i = 2; i < n; i++) {
            if (isPrime[i]) primes.add(i);
        }
    }

    public static void revSort(int[] a) {
        Arrays.sort(a);
        reverse(a);
    }

    public static void revSort(long[] a) {
        Arrays.sort(a);
        reverse(a);
    }

    public static P[] clone(P[] ar) {
        P[] res = new P[ar.length];
        for (int i = 0; i < ar.length; i++) {
            res[i] = new P(ar[i].x, ar[i].y);
        }
        return res;
    }

    public static int[][] clone(int[][] ar) {
        int[][] nr = new int[ar.length][ar[0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = ar[i].clone();
        return nr;
    }

    public static long[][] clone(long[][] ar) {
        long[][] nr = new long[ar.length][ar[0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = ar[i].clone();
        return nr;
    }

    public static double[][] clone(double[][] ar) {
        double[][] nr = new double[ar.length][ar[0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = ar[i].clone();
        return nr;
    }

    public static boolean[][] clone(boolean[][] ar) {
        boolean[][] nr = new boolean[ar.length][ar[0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = ar[i].clone();
        return nr;
    }

    public static char[][] clone(char[][] ar) {
        char[][] nr = new char[ar.length][ar[0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = ar[i].clone();
        return nr;
    }

    public static int[][][] clone(int[][][] ar) {
        int[][][] nr = new int[ar.length][ar[0].length][ar[0][0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = clone(ar[i]);
        return nr;
    }

    public static long[][][] clone(long[][][] ar) {
        long[][][] nr = new long[ar.length][ar[0].length][ar[0][0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = clone(ar[i]);
        return nr;
    }

    public static double[][][] clone(double[][][] ar) {
        double[][][] nr = new double[ar.length][ar[0].length][ar[0][0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = clone(ar[i]);
        return nr;
    }

    public static boolean[][][] clone(boolean[][][] ar) {
        boolean[][][] nr = new boolean[ar.length][ar[0].length][ar[0][0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = clone(ar[i]);
        return nr;
    }

    public static char[][][] clone(char[][][] ar) {
        char[][][] nr = new char[ar.length][ar[0].length][ar[0][0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = clone(ar[i]);
        return nr;
    }

    /**
     * <h1>指定した値以上の先頭のインデクスを返す</h1>
     * <p>配列要素が０のときは、０が返る。</p>
     *
     * @return<b>int</b> ： 探索した値以上で、先頭になるインデクス
     * 値が無ければ、挿入できる最小のインデックス
     */
    public static <T extends Number> int lowerBound(final List<T> lis, final T value) {
        int low = 0;
        int high = lis.size();
        int mid;

        while (low < high) {
            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 (オーバーフロー対策)
            if (lis.get(mid).doubleValue() < value.doubleValue()) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    //v未満で最大のiを返す。ただしv以上を満たすiがあるなら最小のiを返す
    public static <T extends Number> int rlowerBound(final List<T> lis, final T value) {
        int ind = lowerBound(lis, value);
        if (ind == lis.size() || !lis.get(ind).equals(value)) ind--;
        return ind;
    }

    /**
     * <h1>指定した値より大きい先頭のインデクスを返す</h1>
     * <p>配列要素が０のときは、０が返る。</p>
     *
     * @return<b>int</b> ： 探索した値より上で、先頭になるインデクス
     * 値が無ければ、挿入できる最小のインデックス
     */
    public static <T extends Number> int upperBound(final List<T> lis, final T value) {
        int low = 0;
        int high = lis.size();
        int mid;
        while (low < high) {
            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 (オーバーフロー対策)
            if (lis.get(mid).doubleValue() < value.doubleValue()) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(final int[] arr, final int value) {
        int low = 0;
        int high = arr.length;
        int mid;

        while (low < high) {
            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 (オーバーフロー対策)
            if (arr[mid] < value) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int rlowerBound(final int[] arr, final int value) {
        int ind = lowerBound(arr, value);
        if (ind == arr.length || arr[ind] != value) ind--;
        return ind;
    }


    public static int upperBound(final int[] arr, final int value) {
        int low = 0;
        int high = arr.length;
        int mid;
        while (low < high) {
            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 (オーバーフロー対策)
            if (arr[mid] <= value) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(final long[] arr, final long value) {
        int low = 0;
        int high = arr.length;
        int mid;
        while (low < high) {
            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 (オーバーフロー対策)
            if (arr[mid] < value) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int rlowerBound(final long[] arr, final long value) {
        int ind = lowerBound(arr, value);
        if (ind == arr.length || arr[ind] != value) ind--;
        return ind;
    }

    public static int upperBound(final long[] arr, final long value) {
        int low = 0;
        int high = arr.length;
        int mid;
        while (low < high) {
            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 (オーバーフロー対策)
            if (arr[mid] <= value) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    //次の順列に書き換える、最大値ならfalseを返す
    public static boolean nextPermutation(int A[]) {
        int len = A.length;
        int pos = len - 2;
        for (; pos >= 0; pos--) {
            if (A[pos] < A[pos + 1]) break;
        }
        if (pos == -1) return false;
        //posより大きい最小の数を二分探索
        int ok = pos + 1;
        int ng = len;
        while (Math.abs(ng - ok) > 1) {
            int mid = (ok + ng) / 2;
            if (A[mid] > A[pos]) ok = mid;
            else ng = mid;
        }
        swap(A, pos, ok);
        reverse(A, pos + 1, len - 1);
        return true;
    }

    //次の順列に書き換える、最小値ならfalseを返す
    public static boolean prevPermutation(int A[]) {
        int len = A.length;
        int pos = len - 2;
        for (; pos >= 0; pos--) {
            if (A[pos] > A[pos + 1]) break;
        }
        if (pos == -1) return false;
        //posより小さい最大の数を二分探索
        int ok = pos + 1;
        int ng = len;
        while (Math.abs(ng - ok) > 1) {
            int mid = (ok + ng) / 2;
            if (A[mid] < A[pos]) ok = mid;
            else ng = mid;
        }
        swap(A, pos, ok);
        reverse(A, pos + 1, len - 1);
        return true;
    }

    static <T> void swap(T[] x, int i, int j) {
        T t = x[i];
        x[i] = x[j];
        x[j] = t;
    }

    static void swap(char[] x, int i, int j) {
        char t = x[i];
        x[i] = x[j];
        x[j] = t;
    }

    static void swap(int[] x, int i, int j) {
        int t = x[i];
        x[i] = x[j];
        x[j] = t;
    }

    public static String reverse(String a) {
        sb.append(a);
        String res = sb.reverse().toString();
        sb.setLength(0);
        return new String(res);
    }

    public static void reverse(int[] x) {
        int l = 0;
        int r = x.length - 1;
        while (l < r) {
            int temp = x[l];
            x[l] = x[r];
            x[r] = temp;
            l++;
            r--;
        }
    }

    public static void reverse(long[] x) {
        int l = 0;
        int r = x.length - 1;
        while (l < r) {
            long temp = x[l];
            x[l] = x[r];
            x[r] = temp;
            l++;
            r--;
        }
    }

    public static void reverse(char[] x) {
        int l = 0;
        int r = x.length - 1;
        while (l < r) {
            char temp = x[l];
            x[l] = x[r];
            x[r] = temp;
            l++;
            r--;
        }
    }

    public static void reverse(int[] x, int s, int e) {
        int l = s;
        int r = e;
        while (l < r) {
            int temp = x[l];
            x[l] = x[r];
            x[r] = temp;
            l++;
            r--;
        }
    }

    static int cou(boolean[] a) {
        int res = 0;
        for (boolean b : a) {
            if (b) res++;
        }
        return res;
    }

    static int cou(boolean[][] a) {
        int res = 0;
        for (boolean[] b : a) {
            res += cou(b);
        }
        return res;
    }

    static int cou(String s, char c) {
        int res = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == c) res++;
        }
        return res;
    }

    static int cou(char[][] a, char c) {
        int co = 0;
        for (int i = 0; i < a.length; i++)
            for (int j = 0; j < a[0].length; j++)
                if (a[i][j] == c) co++;
        return co;
    }

    static int cou(int[] a, int key) {
        int co = 0;
        for (int i = 0; i < a.length; i++)
            if (a[i] == key) co++;
        return co;
    }

    static int cou(long[] a, long key) {
        int co = 0;
        for (int i = 0; i < a.length; i++)
            if (a[i] == key) co++;
        return co;
    }

    static int cou(int[][] a, int key) {
        int co = 0;
        for (int i = 0; i < a.length; i++)
            co += (cou(a[i], key));
        return co;
    }

    static int[] couArray(int[] a) {
        int[] res = new int[maxs(a) + 1];
        for (int i : a) {
            res[i]++;
        }
        return res;
    }

    static void fill(int[] a, int v) {
        Arrays.fill(a, v);
    }

    static void fill(long[] a, int v) {
        Arrays.fill(a, v);
    }

    static void fill(boolean[] a, boolean v) {
        Arrays.fill(a, v);
    }

    static void fill(int[][] a, int v) {
        for (int i = 0; i < a.length; i++)
            Arrays.fill(a[i], v);
    }

    static void fill(char[][] a, char c) {
        for (int i = 0; i < a.length; i++)
            Arrays.fill(a[i], c);
    }

    static void fill(long[][] a, long v) {
        for (int i = 0; i < a.length; i++)
            Arrays.fill(a[i], v);
    }

    static void fill(double[][] a, double v) {
        for (int i = 0; i < a.length; i++)
            Arrays.fill(a[i], v);
    }

    static void fill(boolean[][] a, boolean v) {
        for (int i = 0; i < a.length; i++)
            Arrays.fill(a[i], v);
    }

    static void fill(int[][][] a, int v) {
        for (int i = 0; i < a.length; i++)
            fill(a[i], v);
    }

    static void fill(long[][][] a, long v) {
        for (int i = 0; i < a.length; i++)
            fill(a[i], v);
    }

    static int maxs(int... a) {
        int res = Integer.MIN_VALUE;
        for (int i : a) {
            res = Math.max(res, i);
        }
        return res;
    }

    static long maxs(long... a) {
        long res = Long.MIN_VALUE;
        for (long i : a) {
            res = Math.max(res, i);
        }
        return res;
    }

    static double maxs(double... a) {
        double res = Double.MIN_VALUE;
        for (double i : a) {
            res = Math.max(res, i);
        }
        return res;
    }

    static long mins(long... a) {
        long res = Long.MAX_VALUE;
        for (long i : a) {
            res = Math.min(res, i);
        }
        return res;
    }

    static int maxs(int[][] ar) {
        int res = Integer.MIN_VALUE;
        for (int i[] : ar)
            res = Math.max(res, maxs(i));
        return res;
    }

    static long maxs(long[][] ar) {
        long res = Integer.MIN_VALUE;
        for (long i[] : ar)
            res = Math.max(res, maxs(i));
        return res;
    }

    static int mins(int... a) {
        int res = Integer.MAX_VALUE;
        for (int i : a) {
            res = Math.min(res, i);
        }
        return res;
    }


    static int mins(int[][] ar) {
        int res = Integer.MAX_VALUE;
        for (int i[] : ar)
            res = Math.min(res, mins(i));
        return res;
    }

    public static <T extends Number> long sum(ArrayList<T> lis) {
        long res = 0;
        for (T li : lis) {
            res += li.longValue();
        }
        return res;
    }

    static long sum(int[] a) {
        long cou = 0;
        for (int i : a)
            cou += i;
        return cou;
    }

    static long sum(long[] a) {
        long cou = 0;
        for (long i : a)
            cou += i;
        return cou;
    }


//FastScanner

    static BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
    static StringTokenizer tokenizer = null;

    public static String next() {
        if (tokenizer == null || !tokenizer.hasMoreTokens()) {
            try {
                tokenizer = new StringTokenizer(reader.readLine());
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
        return tokenizer.nextToken();
    }

    public static String nextLine() {
        if (tokenizer == null || !tokenizer.hasMoreTokens()) {
            try {
                return reader.readLine();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }

        return tokenizer.nextToken("\n");
    }

    public static long nl() {
        return Long.parseLong(next());
    }

    public static String n() {
        return next();
    }

    public static int ni() {
        return Integer.parseInt(next());
    }

    public static double nd() {
        return Double.parseDouble(next());
    }

    public static int[] nia(int n) {
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = ni();
        }
        return a;
    }

    //1-index
    public static int[] niao(int n) {
        int[] a = new int[n + 1];
        for (int i = 1; i < n + 1; i++) {
            a[i] = ni();
        }
        return a;
    }

    //番兵法
    public static int[] nias(int n, int end) {
        int[] a = new int[n + 1];
        for (int i = 0; i < n; i++) {
            a[i] = ni();
        }
        a[n] = end;
        return a;
    }

    public static int[] niad(int n) {
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = ni() - 1;
        }
        return a;
    }

    public static P[] npa(int n) {
        P[] p = new P[n];
        for (int i = 0; i < n; i++) {
            p[i] = new P(ni(), ni());
        }
        return p;
    }

    public static P[] npad(int n) {
        P[] p = new P[n];
        for (int i = 0; i < n; i++) {
            p[i] = new P(ni() - 1, ni() - 1);
        }
        return p;
    }

    public static int[][] nit(int h, int w) {
        int[][] a = new int[h][w];
        for (int hi = 0; hi < h; hi++) {
            for (int wi = 0; wi < w; wi++) {
                a[hi][wi] = ni();
            }
        }
        return a;
    }

    public static int[][] nitd(int h, int w) {
        int[][] a = new int[h][w];
        for (int hi = 0; hi < h; hi++) {
            for (int wi = 0; wi < w; wi++) {
                a[hi][wi] = ni() - 1;
            }
        }
        return a;
    }

    static int[][] S_ARRAY;
    static long[][] S_LARRAY;
    static int S_INDEX;
    static int S_LINDEX;

    //複数の配列を受け取る
    public static int[] niah(int n, int k) throws Exception {
        if (S_ARRAY == null) {
            S_ARRAY = new int[k][n];
            for (int j = 0; j < n; j++) {
                for (int i = 0; i < k; i++) {
                    S_ARRAY[i][j] = ni();
                }
            }
        }
        return S_ARRAY[S_INDEX++];
    }

    public static long[] nlah(int n, int k) throws Exception {
        if (S_LARRAY == null) {
            S_LARRAY = new long[k][n];
            for (int j = 0; j < n; j++) {
                for (int i = 0; i < k; i++) {
                    S_LARRAY[i][j] = nl();
                }
            }
        }
        return S_LARRAY[S_LINDEX++];
    }

    //複数の配列を受け取る
    public static int[] niahd(int n, int k) throws Exception {
        if (S_ARRAY == null) {
            S_ARRAY = new int[k][n];
            for (int j = 0; j < n; j++) {
                for (int i = 0; i < k; i++) {
                    S_ARRAY[i][j] = ni() - 1;
                }
            }
        }
        return S_ARRAY[S_INDEX++];
    }

    public static long[] nlahd(int n, int k) throws Exception {
        if (S_LARRAY == null) {
            S_LARRAY = new long[k][n];
            for (int j = 0; j < n; j++) {
                for (int i = 0; i < k; i++) {
                    S_LARRAY[i][j] = nl() - 1;
                }
            }
        }
        return S_LARRAY[S_LINDEX++];
    }

    public static char[] nca() {
        char[] a = next().toCharArray();
        return a;
    }


    public static String[] nsa(int n) {
        String[] res = new String[n];
        for (int i = 0; i < n; i++) {
            res[i] = n();
        }
        return res;
    }

    //スペースが入っている場合
    public static char[][] ncts(int h, int w) {
        char[][] a = new char[h][w];
        for (int hi = 0; hi < h; hi++) {
            String s = nextLine().replace(" ", "");
            for (int wi = 0; wi < s.length(); wi++) {
                a[hi][wi] = s.charAt(wi);
            }
        }
        return a;
    }

    public static char[][] nct(int h, int w) {
        char[][] a = new char[h][w];
        for (int hi = 0; hi < h; hi++) {
            String s = nextLine();
            for (int wi = 0; wi < s.length(); wi++) {
                a[hi][wi] = s.charAt(wi);
            }
        }
        return a;
    }

    public static char[][] nctp(int h, int w, char c) {
        char[][] a = new char[h + 2][w + 2];
        for (int hi = 1; hi < h + 1; hi++) {
            String s = nextLine();
            for (int wi = 1; wi < s.length() + 1; wi++) {
                a[hi][wi] = s.charAt(wi - 1);
            }
        }
        for (int wi = 0; wi < w + 2; wi++)
            a[0][wi] = a[h + 1][wi] = c;
        for (int hi = 0; hi < h + 2; hi++)
            a[hi][0] = a[hi][w + 1] = c;
        return a;
    }

    //スペースが入ってる時用
    public static char[][] nctsp(int h, int w, char c) {
        char[][] a = new char[h + 2][w + 2];
        //char c = '*';
        int i;
        for (i = 0; i < w + 2; i++)
            a[0][i] = c;
        for (i = 1; i < h + 1; i++) {
            a[i] = (c + nextLine().replace(" ", "") + c).toCharArray();
        }
        for (i = 0; i < w + 2; i++)
            a[h + 1][i] = c;
        return a;
    }

    public static long[] nla(int n) {
        long[] a = new long[n];
        for (int i = 0; i < n; i++) {
            a[i] = nl();
        }
        return a;
    }

    public static long[] nlas(int n, long e) {
        long[] a = new long[n + 1];
        for (int i = 0; i < n; i++) {
            a[i] = nl();
        }
        a[n] = e;
        return a;
    }

    public static long[] nlao(int n) {
        long[] a = new long[n + 1];
        for (int i = 0; i < n; i++) {
            a[i + 1] = nl();
        }
        return a;
    }

    public static long[] nlad(int n) {
        long[] a = new long[n];
        for (int i = 0; i < n; i++) {
            a[i] = nl() - 1;
        }
        return a;
    }

    public static long[][] nlt(int h, int w) {
        long[][] a = new long[h][w];
        for (int hi = 0; hi < h; hi++) {
            for (int wi = 0; wi < w; wi++) {
                a[hi][wi] = nl();
            }
        }
        return a;
    }

    //便利クラス
    static class CouMap {
        public HashMap<Long, Long> map;
        public HashMap<String, Long> smap;

        CouMap() {
            map = new HashMap();
            smap = new HashMap();
        }

        CouMap(int[] a) {
            map = new HashMap();
            smap = new HashMap();
            for (int i : a) {
                put(i);
            }
        }

        public int size() {
            return map.size();
        }

        public void put(long key, long value) {
            Long nowValue = map.get(key);
            map.put(key, nowValue == null ? value : nowValue + value);
        }

        public void put(String key, long value) {
            Long nowValue = smap.get(key);
            smap.put(key, nowValue == null ? value : nowValue + value);
        }

        public void mput(long key, long value) {
            Long nowValue = map.get(key);
            map.put(key, nowValue == null ? value % MOD : mSum(nowValue, value));
        }

        public void put(long key) {
            put(key, 1);
        }

        public void put(String key) {
            put(key, 1);
        }

        public void put(int... arg) {
            for (int i : arg) {
                put(i, 1);
            }
        }

        public void put(long... arg) {
            for (long i : arg) {
                put(i, 1);
            }
        }

        public void mput(int... arg) {
            for (int i : arg) {
                mput(i, 1);
            }
        }

        public void mput(long... arg) {
            for (long i : arg) {
                mput(i, 1);
            }
        }

        public long get(long key) {
            Long v = map.get(key);
            return v == null ? 0 : v;
        }

        public long get(String key) {
            Long v = map.get(key);
            return v == null ? 0 : v;
        }
    }

    static class P implements Comparable<P> {
        int x, y;

        @Override
        public int compareTo(P p) {
            //xyで昇順
            return x == p.x ? y - p.y : x - p.x;
            //xyで降順
            //return (nowx == p.nowx ? nowy - p.nowy : nowx - p.nowx) * -1;
            //yxで昇順
            //return nowy == p.nowy ? nowx - p.nowx : nowy - p.nowy;
            //yxで昇順
            //return (nowy == p.nowy ? nowx - p.nowx : nowy - p.nowy) * -1;

            //x昇 y降
            //return nowx == p.nowx ? p.nowy - nowy : nowx - p.nowx;
            //x降 y昇
            //return (nowx == p.nowx ? p.nowy - nowy : nowx - p.nowx) * -1;
            //y昇 x降
            //return nowy == p.nowy ? p.nowx - nowx : nowy - p.nowy;
            //y降 x昇
            //return (nowy == p.nowy ? p.nowx - nowx : nowy - p.nowy) * -1;
        }

        P(int a, int b) {
            x = a;
            y = b;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof P)) return false;
            P p = (P) o;
            return x == p.x && y == p.y;
        }

        @Override
        public int hashCode() {
            return Objects.hash(x, y);
        }

    }

    static class PL implements Comparable<PL> {
        long x, y;

        public int compareTo(PL p) {
            //xyで昇順
            long res = x == p.x ? y - p.y : x - p.x;
            //xyで降順
            //long res = (nowx == p.nowx ? nowy - p.nowy : nowx - p.nowx) * -1;
            //yxで昇順
            //long res = nowy == p.nowy ? nowx - p.nowx : nowy - p.nowy;
            //yxで昇順
            //long res = (nowy == p.nowy ? nowx - p.nowx : nowy - p.nowy) * -1;

            //x昇 y降
            //long res = nowx == p.nowx ? p.nowy - nowy : nowx - p.nowx;
            //x降 y昇
            //long res = (nowx == p.nowx ? p.nowy - nowy : nowx - p.nowx) * -1;
            //y昇 x降
            //long res = nowy == p.nowy ? p.nowx - nowx : nowy - p.nowy;
            //y降 x昇
            //long res = (nowy == p.nowy ? p.nowx - nowx : nowy - p.nowy) * -1;

            return (res == 0) ? 0 : res > 0 ? 1 : -1;
        }

        PL(long a, long b) {
            x = a;
            y = b;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof PL)) return false;
            PL p = (PL) o;
            return x == p.x && y == p.y;
        }

        @Override
        public int hashCode() {
            return Objects.hash(x, y);
        }

    }

    //値を渡す際は半開区間
    static class RectangleSum {
        //半開区間 0は0
        long[][] rui;
        int H, W;

        RectangleSum(long[][] ori) {
            H = ori.length;
            W = ori[0].length;
            rui = new long[H + 1][W + 1];
            for (int hi = 0; hi < H; hi++) {
                for (int wi = 0; wi < W; wi++) {
                    rui[hi + 1][wi + 1] = ori[hi][wi];
                }
            }
            for (int hi = 1; hi < H + 1; hi++) {
                for (int wi = 1; wi < W + 1; wi++) {
                    rui[hi][wi] += rui[hi - 1][wi];
                    rui[hi][wi] += rui[hi][wi - 1];
                    rui[hi][wi] -= rui[hi - 1][wi - 1];
                }
            }
        }

        RectangleSum(int[][] ori) {
            H = ori.length;
            W = ori[0].length;
            rui = new long[H + 1][W + 1];
            for (int hi = 0; hi < H; hi++) {
                for (int wi = 0; wi < W; wi++) {
                    rui[hi + 1][wi + 1] = ori[hi][wi];
                }
            }
            for (int hi = 1; hi < H + 1; hi++) {
                for (int wi = 1; wi < W + 1; wi++) {
                    rui[hi][wi] += rui[hi - 1][wi];
                    rui[hi][wi] += rui[hi][wi - 1];
                    rui[hi][wi] -= rui[hi - 1][wi - 1];
                }
            }
        }

        //半開区間
        public long getSum(int left, int right, int top, int bottom) {
            if (right > W || bottom > H) return 0;
            if (left < 0 || top < 0) return 0;
            if (top >= bottom || left >= right) return 0;
            long res = rui[bottom][right];
            res -= rui[top][right];
            res -= rui[bottom][left];
            res += rui[top][left];
            return res;
        }

    }

    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        solve();
        System.out.flush();
        long endTime = System.currentTimeMillis();
        if (DEBUG) System.err.println(endTime - startTime);
    }

}

</source>
</class>

<class classid="207" nclones="2" nlines="72" similarity="100">
<source file="../hum_codes_raw/s409947235.java" startline="1" endline="98" pcid="13786">
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

public class Main{

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int n = sc.nextInt();
			if(n == 0){
				break;
			}
			int[][] students = new int[n][n];
			boolean[][] tallest = new boolean[n][n];
			boolean[][] shortest = new boolean[n][n];
			int[][] x = new int[n][n];
			for(int i = 0; i < n; i++){
				for(int j = 0; j < n; j++){
					students[i][j] = sc.nextInt();
				}
			}
			
			for(int i = 0; i < n; i++){
				int columnMax = -1, maxj = -1;
				for(int j = 0; j < n; j++){
					if(columnMax < students[j][i]){
						columnMax = students[j][i];
                        maxj = j;
                    }
//					columnMax = Math.max(columnMax, students[j][i]);
				}
				for(int j = 0; j < n; j++){
					if(columnMax == students[j][i]){
						tallest[j][i] = true;
						x[j][i] |= 2;
					}
				}
			}
			for(int i = 0; i < n; i++){
				int rowMin = Integer.MAX_VALUE, minj = -1;
				for(int j = 0; j < n; j++){
					if(rowMin > students[i][j]){
						rowMin = students[i][j];
                        minj = j;
                    }
//					rowMin = Math.min(rowMin, students[i][j]);
//					minj = j;
				}
				for(int j = 0; j < n; j++){
					if(rowMin == students[i][minj]){
						shortest[i][minj] = true;
						x[i][minj] |= 1;
					}
				}
			}
			
			Set<Integer> both = new HashSet<Integer>();
            for(int i = 0;i < n;i++){
                for(int j = 0;j < n;j++){
                    if(x[i][j] == 3){
                        both.add(students[i][j]);
                    }
                }
            }
			
            if(both.size() == 1){
            	StringBuilder sb = new StringBuilder();
                for(int v : both){
                    sb.append(v + " ");
                }
                sb.deleteCharAt(sb.length() - 1);
                System.out.println(sb);
            }else{
            	System.out.println(0);
            }
/*			boolean noAns = true;
			StringBuilder sb = new StringBuilder();
			for(int i = 0; i < n; i++){
				for(int j = 0; j < n; j++){
					if(shortest[i][j] && tallest[i][j]){
						sb.append(students[i][j] + " ");
						noAns = false;
					}
				}
			}
			
			if(noAns){
				System.out.println(0);
			}else{
				sb.deleteCharAt(sb.length() - 1);
				System.out.print(sb);
			}
*/		}
		
	}
}

</source>
<source file="../hum_codes_raw/s742365105.java" startline="1" endline="98" pcid="24944">
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int n = sc.nextInt();
			if(n == 0){
				break;
			}
			int[][] students = new int[n][n];
			boolean[][] tallest = new boolean[n][n];
			boolean[][] shortest = new boolean[n][n];
			int[][] x = new int[n][n];
			for(int i = 0; i < n; i++){
				for(int j = 0; j < n; j++){
					students[i][j] = sc.nextInt();
				}
			}
			
			for(int i = 0; i < n; i++){
				int columnMax = -1, maxj = -1;
				for(int j = 0; j < n; j++){
					if(columnMax < students[j][i]){
						columnMax = students[j][i];
                        maxj = j;
                    }
//					columnMax = Math.max(columnMax, students[j][i]);
				}
				for(int j = 0; j < n; j++){
					if(columnMax == students[j][i]){
						tallest[j][i] = true;
						x[j][i] |= 2;
					}
				}
			}
			for(int i = 0; i < n; i++){
				int rowMin = Integer.MAX_VALUE, minj = -1;
				for(int j = 0; j < n; j++){
					if(rowMin > students[i][j]){
						rowMin = students[i][j];
                        minj = j;
                    }
//					rowMin = Math.min(rowMin, students[i][j]);
//					minj = j;
				}
				for(int j = 0; j < n; j++){
					if(rowMin == students[i][minj]){
						shortest[i][minj] = true;
						x[i][minj] |= 1;
					}
				}
			}
			
			Set<Integer> both = new HashSet<Integer>();
            for(int i = 0;i < n;i++){
                for(int j = 0;j < n;j++){
                    if(x[i][j] == 3){
                        both.add(students[i][j]);
                    }
                }
            }
			
            if(both.size() == 1){
            	StringBuilder sb = new StringBuilder();
                for(int v : both){
                    sb.append(v + " ");
                }
                sb.deleteCharAt(sb.length() - 1);
                System.out.println(sb);
            }else{
            	System.out.println(0);
            }
/*			boolean noAns = true;
			StringBuilder sb = new StringBuilder();
			for(int i = 0; i < n; i++){
				for(int j = 0; j < n; j++){
					if(shortest[i][j] && tallest[i][j]){
						sb.append(students[i][j] + " ");
						noAns = false;
					}
				}
			}
			
			if(noAns){
				System.out.println(0);
			}else{
				sb.deleteCharAt(sb.length() - 1);
				System.out.print(sb);
			}
*/		}
		
	}
}

</source>
</class>

<class classid="208" nclones="2" nlines="84" similarity="100">
<source file="../hum_codes_raw/s411393121.java" startline="1" endline="89" pcid="13832">
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main
{
    static class Node{
        int b = 0;
        int w = 0;
        List<Integer> child;
    }
    static int subsetSum(int[] arr, int target){
        int n = arr.length;
        int m = target + 1;
        boolean[][] dp = new boolean[n][m];
        for (int i = 0; i < n; i++) {
            if (arr[i] > target) continue;
            dp[i][arr[i]] = true;
        }
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (dp[i-1][j]){
                    dp[i][j] = true;
                    if (j + arr[i] <= target){
                        dp[i][j+arr[i]] = true;
                    }
                }
            }
        }
        for (int i = m-1; i >= 0;i--) {
            if (dp[n-1][i]){
                return i;
            }
        }
        return 0;
    }

    static Node[] nodes;
    static int[] X;
    public static void main(String[] args) throws FileNotFoundException {
        Scanner sc= new Scanner(System.in);
        int N = sc.nextInt();
        nodes = new Node[N];
        X = new int[N];
        for (int i = 0; i < N; i++) {
            nodes[i] = new Node();
            nodes[i].child = new ArrayList<>();
        }
        for (int i = 1; i < N; i++) {
            int par = sc.nextInt();
            nodes[par - 1].child.add(i);
        }
        for (int i = 0; i < N; i++) {
            X[i] = sc.nextInt();
        }
        System.out.println(recur(0) ? "POSSIBLE": "IMPOSSIBLE");
    }

    public static boolean recur(int nodeIdx){
        Node cur = nodes[nodeIdx];
        if (cur.child == null || cur.child.size() == 0){
            cur.b = 0; cur.w = X[nodeIdx];
            return true;
        }
        for (int i = 0; i < cur.child.size(); i++) {
            if (!recur(cur.child.get(i))) {
                return false;
            }
        }
        int b = 0, w = 0;
        int[] swap = new int[cur.child.size()];
        for (int i = 0; i < cur.child.size(); i++) {
            int black = nodes[cur.child.get(i)].b;
            int white = nodes[cur.child.get(i)].w;
            b += Math.min(white, black);
            w += Math.max(white, black);
            swap[i] = Math.max(white, black) - Math.min(white, black);
        }
        if (b > X[nodeIdx]) {
            return false;
        }
        int sww = subsetSum(swap, X[nodeIdx] - b);
        cur.b = X[nodeIdx];
        cur.w = w - sww;
        return true;
    }

}

</source>
<source file="../hum_codes_raw/s836232524.java" startline="1" endline="89" pcid="28074">
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main
{
    static class Node{
        int b = 0;
        int w = 0;
        List<Integer> child;
    }
    static int subsetSum(int[] arr, int target){
        int n = arr.length;
        int m = target + 1;
        boolean[][] dp = new boolean[n][m];
        for (int i = 0; i < n; i++) {
            if (arr[i] > target) continue;
            dp[i][arr[i]] = true;
        }
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (dp[i-1][j]){
                    dp[i][j] = true;
                    if (j + arr[i] <= target){
                        dp[i][j+arr[i]] = true;
                    }
                }
            }
        }
        for (int i = m-1; i >= 0;i--) {
            if (dp[n-1][i]){
                return i;
            }
        }
        return 0;
    }

    static Node[] nodes;
    static int[] X;
    public static void main(String[] args) throws FileNotFoundException {
        Scanner sc= new Scanner(System.in);
        int N = sc.nextInt();
        nodes = new Node[N];
        X = new int[N];
        for (int i = 0; i < N; i++) {
            nodes[i] = new Node();
            nodes[i].child = new ArrayList<>();
        }
        for (int i = 1; i < N; i++) {
            int par = sc.nextInt();
            nodes[par - 1].child.add(i);
        }
        for (int i = 0; i < N; i++) {
            X[i] = sc.nextInt();
        }
        System.out.println(recur(0) ? "POSSIBLE": "IMPOSSIBLE");
    }

    public static boolean recur(int nodeIdx){
        Node cur = nodes[nodeIdx];
        if (cur.child == null || cur.child.size() == 0){
            cur.b = 0; cur.w = X[nodeIdx];
            return true;
        }
        for (int i = 0; i < cur.child.size(); i++) {
            if (!recur(cur.child.get(i))) {
                return false;
            }
        }
        int b = 0, w = 0;
        int[] swap = new int[cur.child.size()];
        for (int i = 0; i < cur.child.size(); i++) {
            int black = nodes[cur.child.get(i)].b;
            int white = nodes[cur.child.get(i)].w;
            b += Math.min(white, black);
            w += Math.max(white, black);
            swap[i] = Math.max(white, black) - Math.min(white, black);
        }
        if (b > X[nodeIdx]) {
            return false;
        }
        int sww = subsetSum(swap, X[nodeIdx] - b);
        cur.b = X[nodeIdx];
        cur.w = w - sww;
        return true;
    }

}

</source>
</class>

<class classid="209" nclones="2" nlines="61" similarity="100">
<source file="../hum_codes_raw/s414915935.java" startline="1" endline="73" pcid="13948">
import java.util.*;
import java.util.Map.Entry;
import java.lang.*;
import java.math.*;

public class Main{
	Scanner sc=new Scanner(System.in);

	int INF=1<<28;
	double EPS=1e-9;

	int n;
	HashMap<String, String> map=new HashMap<String, String>();
	String start, end;
	int ans;

	void run(){
		for(;;){
			n=sc.nextInt();
			//println("n:"+n);
			if(n==0){
				break;
			}
			map.clear();
			for(int i=0; i<n; i++){
				String s=sc.next();
				String t=sc.next();
				map.put(s, t);
			}
			start=sc.next();
			end=sc.next();
			ans=-1;
			dfs(start, 0);
			println(""+ans);
			//println("here");
		}
	}

	void dfs(String s, int r){
		// if(r==4)
		// println("r:"+r+" s:"+s);
		if(r>=ans&&r>=10){
			return;
		}else if(s.length()>end.length()){
			return;
		}else if(s.equals(end)){
			if(ans==-1||r<ans){
				ans=r;
			}
			return;
		}
		for(Entry<String, String> entry : map.entrySet()){
			if(s.contains(entry.getKey())){
				String t=s.replaceAll(entry.getKey(), entry.getValue());
				dfs(t, r+1);
			}
		}
	}

	void print(String s){
		System.out.print(s);
	}

	void println(String s){
		System.out.println(s);
	}

	public static void main(String[] args){
		new Main().run();

	}
}

</source>
<source file="../hum_codes_raw/s464589311.java" startline="1" endline="69" pcid="15581">
import java.util.*;
import java.util.Map.Entry;
import java.lang.*;
import java.math.*;

public class Main{
	Scanner sc=new Scanner(System.in);

	int INF=1<<28;
	double EPS=1e-9;

	int n;
	HashMap<String, String> map=new HashMap<String, String>();
	String start, end;
	int ans;

	void run(){
		for(;;){
			n=sc.nextInt();
			if(n==0){
				break;
			}
			map.clear();
			for(int i=0; i<n; i++){
				String s=sc.next();
				String t=sc.next();
				map.put(s, t);
			}
			start=sc.next();
			end=sc.next();
			ans=-1;
			dfs(start, 0);
			println(""+ans);
		}
	}

	void dfs(String s, int r){
		if(r>=ans&&r>=10){
			return;
		}else if(s.length()>end.length()){
			return;
		}else if(s.equals(end)){
			if(ans==-1||r<ans){
				ans=r;
			}
			return;
		}
		for(Entry<String, String> entry : map.entrySet()){
			if(s.contains(entry.getKey())){
				String t=s.replaceAll(entry.getKey(), entry.getValue());
				dfs(t, r+1);
			}
		}
	}

	void print(String s){
		System.out.print(s);
	}

	void println(String s){
		System.out.println(s);
	}

	public static void main(String[] args){
		new Main().run();

	}
}

</source>
</class>

<class classid="210" nclones="2" nlines="209" similarity="100">
<source file="../hum_codes_raw/s418980822.java" startline="1" endline="251" pcid="14081">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            DEars solver = new DEars();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class DEars {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            long[] A = new long[n];
            in.populate(A);

            long[][] props = new long[3][n];
            for (int i = 0; i < n; i++) {
                props[0][i] = A[i];
                props[1][i] = A[i] == 0 ? 1 : (A[i] - 1) % 2;
                props[2][i] = A[i] < 2 ? 2 - A[i] : (A[i] - 2) % 2;
            }

            //02120
            int[] pick = new int[]{0, 2, 1, 2, 0};
            long inf = (long) 1e18;
            long[][] dp = new long[5][n + 1];
            SequenceUtils.deepFill(dp, inf);
            dp[0][0] = 0;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < 5; j++) {
                    for (int t = j; t < 5; t++) {
                        dp[t][i + 1] = Math.min(dp[t][i + 1],
                                dp[j][i] + props[pick[t]][i]);
                    }
                }
            }

            long ans = inf;
            for (int i = 0; i < 5; i++) {
                ans = Math.min(ans, dp[i][n]);
            }

            out.println(ans);
        }

    }

    static class SequenceUtils {
        public static void deepFill(Object array, long val) {
            if (!array.getClass().isArray()) {
                throw new IllegalArgumentException();
            }
            if (array instanceof long[]) {
                long[] longArray = (long[]) array;
                Arrays.fill(longArray, val);
            } else {
                Object[] objArray = (Object[]) array;
                for (Object obj : objArray) {
                    deepFill(obj, val);
                }
            }
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        public void populate(long[] data) {
            for (int i = 0; i < data.length; i++) {
                data[i] = readLong();
            }
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

        public long readLong() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            long val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(long c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(long c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }
}


</source>
<source file="../hum_codes_raw/s892434344.java" startline="1" endline="251" pcid="30016">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            DEars solver = new DEars();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class DEars {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            long[] A = new long[n];
            in.populate(A);

            long[][] props = new long[3][n];
            for (int i = 0; i < n; i++) {
                props[0][i] = A[i];
                props[1][i] = A[i] == 0 ? 1 : (A[i] - 1) % 2;
                props[2][i] = A[i] < 2 ? 2 - A[i] : (A[i] - 2) % 2;
            }

            //02120
            int[] pick = new int[]{0, 2, 1, 2, 0};
            long inf = (long) 1e18;
            long[][] dp = new long[5][n + 1];
            SequenceUtils.deepFill(dp, inf);
            dp[0][0] = 0;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < 5; j++) {
                    for (int t = j; t < 5; t++) {
                        dp[t][i + 1] = Math.min(dp[t][i + 1],
                                dp[j][i] + props[pick[t]][i]);
                    }
                }
            }

            long ans = inf;
            for (int i = 0; i < 5; i++) {
                ans = Math.min(ans, dp[i][n]);
            }

            out.println(ans);
        }

    }

    static class SequenceUtils {
        public static void deepFill(Object array, long val) {
            if (!array.getClass().isArray()) {
                throw new IllegalArgumentException();
            }
            if (array instanceof long[]) {
                long[] longArray = (long[]) array;
                Arrays.fill(longArray, val);
            } else {
                Object[] objArray = (Object[]) array;
                for (Object obj : objArray) {
                    deepFill(obj, val);
                }
            }
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        public void populate(long[] data) {
            for (int i = 0; i < data.length; i++) {
                data[i] = readLong();
            }
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

        public long readLong() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            long val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(long c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(long c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }
}


</source>
</class>

<class classid="211" nclones="2" nlines="12" similarity="100">
<source file="../hum_codes_raw/s419404211.java" startline="1" endline="13" pcid="14093">
import java.util.Scanner;
public class Main {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int a = sc.nextInt();
    int b = sc.nextInt();
    int area = a*b;
    int length = 2*(a + b);
    System.out.println(area + " " + length);
    sc.close();
  }
}

</source>
<source file="../hum_codes_raw/s698691854.java" startline="1" endline="14" pcid="23495">
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int a = sc.nextInt();
        int b = sc.nextInt();
        int area = a * b;
        int length = 2 * (a + b);
        System.out.println(area + " " + length);
        sc.close();
    }
}

</source>
</class>

<class classid="212" nclones="2" nlines="15" similarity="100">
<source file="../hum_codes_raw/s422743068.java" startline="1" endline="17" pcid="14201">
import java.util.Scanner;

public class Main {
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);

		int a = sc.nextInt();
		String op = sc.next();
		int b = sc.nextInt();
		if(op.equals("+")){
			System.out.println(a+b);
		}else{
			System.out.println(a-b);
		}
	}
}

</source>
<source file="../hum_codes_raw/s861601091.java" startline="1" endline="19" pcid="28969">
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);

		int a = sc.nextInt();
		String op = sc.next();
		int b = sc.nextInt();
		if (op.equals("+")) {
			System.out.println(a + b);
		} else {
			System.out.println(a - b);
		}
	}

}

</source>
</class>

<class classid="213" nclones="2" nlines="221" similarity="100">
<source file="../hum_codes_raw/s423699023.java" startline="1" endline="262" pcid="14246">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Collection;
import java.io.IOException;
import java.util.Deque;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.ArrayDeque;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            CLexicographicConstraints solver = new CLexicographicConstraints();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class CLexicographicConstraints {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            int[] a = new int[n];
            in.populate(a);
            Deque<Tag> dq = new ArrayDeque<>(n);
            IntBinarySearch ibs = new IntBinarySearch() {

                public boolean check(int mid) {
                    dq.clear();
                    int length = 0;
                    for (int x : a) {
                        if (length < x) {
                            length = x;
                            continue;
                        }
                        length = x;
                        if (mid == 1) {
                            return false;
                        }
                        while (!dq.isEmpty() && dq.peekLast().index >= length) {
                            dq.removeLast();
                        }
                        int cur = length - 1;
                        while (cur >= 0) {
                            Tag tail = dq.isEmpty() || dq.peekLast().index != cur ?
                                    new Tag(cur, 0) : dq.removeLast();
                            if (tail.val + 1 == mid) {
                                cur--;
                            } else {
                                tail.val++;
                                dq.addLast(tail);
                                break;
                            }
                        }
                        if (cur < 0) {
                            return false;
                        }
                    }
                    return true;
                }
            };

            int ans = ibs.binarySearch(1, n);
            out.println(ans);
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class DigitUtils {
        private DigitUtils() {
        }

        public static int floorAverage(int x, int y) {
            return (x & y) + ((x ^ y) >> 1);
        }

    }

    static abstract class IntBinarySearch {
        public abstract boolean check(int mid);

        public int binarySearch(int l, int r) {
            if (l > r) {
                throw new IllegalArgumentException();
            }
            while (l < r) {
                int mid = DigitUtils.floorAverage(l, r);
                if (check(mid)) {
                    r = mid;
                } else {
                    l = mid + 1;
                }
            }
            return l;
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        public void populate(int[] data) {
            for (int i = 0; i < data.length; i++) {
                data[i] = readInt();
            }
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }

    static class Tag {
        int index;
        int val;

        public Tag(int index, int val) {
            this.index = index;
            this.val = val;
        }

    }
}


</source>
<source file="../hum_codes_raw/s837746292.java" startline="1" endline="262" pcid="28123">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Collection;
import java.io.IOException;
import java.util.Deque;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.ArrayDeque;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            CLexicographicConstraints solver = new CLexicographicConstraints();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class CLexicographicConstraints {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            int[] a = new int[n];
            in.populate(a);
            Deque<Tag> dq = new ArrayDeque<>(n);
            IntBinarySearch ibs = new IntBinarySearch() {

                public boolean check(int mid) {
                    dq.clear();
                    int length = 0;
                    for (int x : a) {
                        if (length < x) {
                            length = x;
                            continue;
                        }
                        length = x;
                        if (mid == 1) {
                            return false;
                        }
                        while (!dq.isEmpty() && dq.peekLast().index >= length) {
                            dq.removeLast();
                        }
                        int cur = length - 1;
                        while (cur >= 0) {
                            Tag tail = dq.isEmpty() || dq.peekLast().index != cur ?
                                    new Tag(cur, 0) : dq.removeLast();
                            if (tail.val + 1 == mid) {
                                cur--;
                            } else {
                                tail.val++;
                                dq.addLast(tail);
                                break;
                            }
                        }
                        if (cur < 0) {
                            return false;
                        }
                    }
                    return true;
                }
            };

            int ans = ibs.binarySearch(1, n);
            out.println(ans);
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class DigitUtils {
        private DigitUtils() {
        }

        public static int floorAverage(int x, int y) {
            return (x & y) + ((x ^ y) >> 1);
        }

    }

    static abstract class IntBinarySearch {
        public abstract boolean check(int mid);

        public int binarySearch(int l, int r) {
            if (l > r) {
                throw new IllegalArgumentException();
            }
            while (l < r) {
                int mid = DigitUtils.floorAverage(l, r);
                if (check(mid)) {
                    r = mid;
                } else {
                    l = mid + 1;
                }
            }
            return l;
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        public void populate(int[] data) {
            for (int i = 0; i < data.length; i++) {
                data[i] = readInt();
            }
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }

    static class Tag {
        int index;
        int val;

        public Tag(int index, int val) {
            this.index = index;
            this.val = val;
        }

    }
}


</source>
</class>

<class classid="214" nclones="2" nlines="42" similarity="100">
<source file="../hum_codes_raw/s429139656.java" startline="1" endline="45" pcid="14422">
import java.util.Scanner;
import java.util.Stack;

public class Main {
    static int n;
    static Scanner sc = new Scanner(System.in);
    
    static boolean aun(){
        Stack<String> au = new Stack<>();
        for(int i=0;i<n;i++){
            String say = sc.next();
            //System.err.println(say);
            if(say.equals("A")){
                au.push("A");
            }
            if(say.equals("Un")){
                if(au.isEmpty()){
                    return false;
                }else{
                    au.pop();
                }
            }
            //System.err.println(au);
        }
        if(au.isEmpty()){
        	return true;
        }else {
        	return false;
        }
    }
    
    public static void main(String[] args) {
        n = sc.nextInt();
        if(n%2 == 1) {
        	System.out.println("NO");
        	return;
        }
        if(aun()){
            System.out.println("YES");
        }else{
            System.out.println("NO");
        }    
    }
}

</source>
<source file="../hum_codes_raw/s979472434.java" startline="1" endline="45" pcid="32938">
import java.util.Scanner;
import java.util.Stack;

public class Main {
    static int n;
    static Scanner sc = new Scanner(System.in);
    
    static boolean aun(){
        Stack<String> au = new Stack<>();
        for(int i=0;i<n;i++){
            String say = sc.next();
            //System.err.println(say);
            if(say.equals("A")){
                au.push("A");
            }
            if(say.equals("Un")){
                if(au.isEmpty()){
                    return false;
                }else{
                    au.pop();
                }
            }
            //System.err.println(au);
        }
        if(au.isEmpty()){
        	return true;
        }else {
        	return false;
        }
    }
    
    public static void main(String[] args) {
        n = sc.nextInt();
        if(n%2 == 1) {
        	System.out.println("NO");
        	return;
        }
        if(aun()){
            System.out.println("YES");
        }else{
            System.out.println("NO");
        }    
    }
}

</source>
</class>

<class classid="215" nclones="2" nlines="39" similarity="100">
<source file="../hum_codes_raw/s434195997.java" startline="1" endline="47" pcid="14577">
import java.io.IOException;
import java.util.Scanner;

public class Main {
	public static void main(String[] args) throws IOException {
		Scanner scanner = new Scanner(System.in);
		while (true) {
			int data = scanner.nextInt();
			if (data == 0) {
				scanner.close();
				break;
			}

			char[][] symbols = new char[data][];
			symbols[0] = scanner.next().toCharArray();

			for (int i = 1; i < data; i++) {
				symbols[i] = scanner.next().toCharArray();
				for (int j = 0; j < symbols[i].length; j++) {
					if (symbols[i][j + 1] != '.') {
						// 右隣が文字の'.'は必ず'+'である
						symbols[i][j] = '+';
						for (int k = i - 1; k >= 0; k--) {
							// '+'の上にあるスペースは'|'で埋めていく
							if (symbols[k][j] == ' ') {
								symbols[k][j] = '|';
							} else {
								break;
							}
						}
						break;
					} else {
						// それ以外ならとりあえずスペースで埋めておく
						symbols[i][j] = ' ';
					}
				}
			}

			for (int i = 0; i < symbols.length; i++) {
				System.out.println(symbols[i]);
			}

		}

	}
}

</source>
<source file="../hum_codes_raw/s514961353.java" startline="1" endline="43" pcid="17278">
import java.io.IOException;
import java.util.Scanner;

public class Main {
	public static void main(String[] args) throws IOException {
		Scanner scanner = new Scanner(System.in);
		while (true) {
			int data = scanner.nextInt();
			if (data == 0) {
				scanner.close();
				break;
			}

			char[][] symbols = new char[data][];
			symbols[0] = scanner.next().toCharArray();
			for (int i = 1; i < data; i++) {
				symbols[i] = scanner.next().toCharArray();
				for (int j = 0; j < symbols[i].length; j++) {
					if (symbols[i][j + 1] != '.') {
						symbols[i][j] = '+';
						for (int k = i - 1; k >= 0; k--) {
							if (symbols[k][j] == ' ') {
								symbols[k][j] = '|';
							} else {
								break;
							}
						}
						break;
					} else {
						symbols[i][j] = ' ';
					}
				}
			}

			for (int i = 0; i < symbols.length; i++) {
				System.out.println(symbols[i]);
			}

		}

	}
}

</source>
</class>

<class classid="216" nclones="2" nlines="351" similarity="100">
<source file="../hum_codes_raw/s437788072.java" startline="1" endline="434" pcid="14685">
import java.io.*;
import java.util.*;

class Main{
    final static long INF = Long.MAX_VALUE / 2;
    final static int MOD = 1_000_000_007;
    final static int SIZE = 1_000_000;
    long[] fac = new long[SIZE];
    long[] inv = new long[SIZE];
    long[] finv = new long[SIZE];
    FastScanner sc = new FastScanner();

    public static void main(String[] args) {
        new Main().solve();
    }

    void solve(){

        int n = sc.nextInt();
        long[] a = new long[n + 1];

        for(int i = 0; i < n + 1; i++){
            a[i] = sc.nextLong();
        }

        if(a[0] > 1 || (a[0] == 1 && n > 1)){ // a[0] が1以下でない または 深さ1以上で a[0] が1 の時 -1
            System.out.println(-1);
            System.exit(0);
        }

        // long b = 2;
        //
        // for(int i = 1; i < n + 1; i++){
        //     if(a[i] > b - a[i - 1] * 2){
        //         System.out.println(-1);
        //         System.exit(0);
        //     }
        //     b *= 2;
        //     if(b > 1000000000) break;
        // }

        long[] p = new long[n + 1]; // p[i] : 親になれるノードの数
        if(a[0] == 1) p[0] = 0;
        else p[0] = 1;

        for(int i = 1; i < n + 1; i++){
            p[i] = p[i - 1] * 2 - a[i]; // 深さiの親になれるノードの数 = 深さi - 1の親になれるノードの数 * 2 - 深さiの葉の数 ?
        }

        long[] m = new long[n + 1]; // m[i] : 深さiの頂点の最大数
        m[0] = 1;

        for(int i = 1; i < n + 1; i++){
            m[i] = p[i - 1] * 2; // 深さiの頂点の最大数 = 深さi - 1の親になれるノードの数 * 2 ?
        }

        long[] s = new long[n + 1]; // s[i] : a[i], a[i + 1], ... a[n] の累積
        s[n] = a[n];

        for(int i = n - 1; i >= 0; i--){
            s[i] = s[i + 1] + a[i];
        }

        long sum = 0;

        for(int i = 0; i < n + 1; i++){
            if(m[i] >= 0){
                sum += Math.min(m[i], s[i]);
                if(a[i] > m[i]){
                    System.out.println(-1);
                    System.exit(0);
                }
            }else{
                sum += s[i];
            }
        }

        System.out.println(sum);

    }

    long gcd(long a, long b){ // return aとbの最大公約数
        if(b == 0){
          return a;
        }
        return gcd(b, a % b);
    }

    long lcm(long a, long b){ // return aとbの最小公倍数
        return a * b / gcd(a, b);
    }

    long inv(long a){ // return aの逆元 (mod MOD)
        return pow(a, MOD - 2);
    }

    long pow(long a, long r){ // return a^r (mod MOD)
        long sum = 1;
        while(r > 0){
            if((r & 1) == 1){ // 2進数表記で末尾1の時
                sum *= a;
                sum %= MOD;
            }
            a *= a;
            a %= MOD;
            r >>= 1;
        }
        return sum;
    }

    long modFact(long n){ // retur n! (mod MOD)
        if(n == 0){
            return 1;
        }
        return n * modFact(n - 1) % MOD;
    }

    long fact(long n){ // return n!
        if(n == 0){
            return 1;
        }
        return n * fact(n - 1);
    }

    void initCOMB(){
        fac[0] = fac[1] = 1;
        inv[1] = 1;
        finv[0] = finv[1] = 1;
        for(int i = 2; i < SIZE; i++){
            fac[i] = fac[i - 1] * i % MOD;
            inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;
            finv[i] = finv[i - 1] * inv[i] % MOD;
        }
    }

    long modComb(int n, int r){ // return nCr (先にinitCOMB()必要)
        if(n < r || n < 0 || r < 0) return 0;
        return fac[n] * finv[r] % MOD * finv[n - r] % MOD;
    }

    long comb(long n, long r){ // return nCr
        long num = 1;
        for(long i = 1; i <= r; i++){
            num = num * (n - i + 1) / i;
        }
        return num;
    }

    boolean isPrime(long a){ // aの素数判定
        if(a <= 1) return false;
        for(int i = 2; i * i <= a; i++){
            if(a % i == 0) return false;
        }
        return true;
    }

    int lowerBound(long[] a, long v){ // return 配列a内のv以上の要素の内最低の要素のイテレータ
        int r = a.length;
        int l = -1;
        while(r - l > 1){
            int mid = (r + l) / 2;
            if(a[mid] >= v){
                r = mid;
            }else{
                l = mid;
            }
        }
        return r;
    }

    int upperBound(long[] a, long v){ // return 配列a内のvより大きい要素の内最低の要素のイテレータ
        int r = a.length;
        int l = -1;
        while(r - l > 1){
            int mid = (r + l) / 2;
            if(a[mid] > v){
                r = mid;
            }else{
                l = mid;
            }
        }
        return r;
    }

    String nextPermutation(String s){ // return sの次の順列
        ArrayList<Character> list = new ArrayList<>();
        for(int i = 0; i < s.length(); i++) list.add(s.charAt(i));

        int pivotPos = -1;
        char pivot = 0;
        for(int i = list.size() - 2; i >= 0; i--){
            if(list.get(i) < list.get(i+1)){
    			pivotPos = i;
    			pivot = list.get(i);
    			break;
    		}
    	}

        if(pivotPos == -1 && pivot == 0) return null;

        int L = pivotPos + 1;
        int R = list.size() - 1;
    	int minPos = -1;
    	char min = Character.MAX_VALUE;
    	for(int i = R; i >= L; i--){
    		if(pivot < list.get(i)){
    			if(list.get(i) < min){
    				min = list.get(i);
    				minPos = i;
    			}
    		}
    	}

    	Collections.swap(list, pivotPos, minPos);
    	Collections.sort(list.subList(L, R + 1));

    	StringBuilder sb = new StringBuilder();
    	for(int i=0; i<list.size(); i++) sb.append(list.get(i));

    	return sb.toString();
    }

    boolean nextPermutation(long[] a){
        for(int i = a.length - 1; i > 0; i--){
            if(a[i - 1] < a[i]){
                int swapIndex = find(a[i - 1], a, i, a.length - 1);
                long temp = a[swapIndex];
                a[swapIndex] = a[i - 1];
                a[i - 1] = temp;
                Arrays.sort(a, i, a.length);
                return true;
            }
        }
        return false;
    }

    int find(long dest, long[] a, int s, int e){
        if(s == e){
            return s;
        }
        int m = (s + e + 1) / 2;
        return a[m] <= dest ? find(dest, a, s, m - 1) : find(dest, a, m, e);
    }

    void elimination(int[][] a, int[] b) {
        int n = a.length;
        double f;
        for(int k = 0; k < n - 1; k++){
            for(int i = k + 1; i < n; i++){
                f = - a[i][k] / a[k][k];
                for(int j = k + 1; j < n; j++){
                    a[i][j] += f * a[k][j];
                }
                b[i] += f * b[k];
            }
            for(int i = n - 1; i >= 0; i--){
                for(int j = i + 1; j < n; j++){
                    b[i] -= a[i][j] * b[j];
                }
                b[i] = b[i] / a[i][i];
            }
        }
   }



   class SegmentTree{

       //------------------------------------------------------------
       // 2 * n - 1 : 木全体のノード数
       // i + n - 1 : 配列のi番目が対応するノードの番号
       // 2 * i + 1, 2 * i + 2 : i番目のノードの子ノードの番号
       // (i - 1) / 2 : i番目のノードの親ノードの番号
       //
       // int n = sc.nextInt();
       // long[] a = new long[n];
       // for(int i = 0; i < n; i++) a[i] = sc.nextLong();
       // SegmentTree st = new SegmentTree(a);
       // int l = sc.nextInt() - 1;
       // int r = sc.nextInt() - 1;
       // System.out.println(st.query(l, r));
       //------------------------------------------------------------

       final static long INF = Long.MAX_VALUE / 2;

       // long e = INF; // 単位元
       long e = 0;
       long func(long a, long b){ // 処理
           // return Math.min(a, b);
           return a + b;
       }

       int n; // 配列の要素数を超える最小の2のべき乗
       long[] node;

       SegmentTree(long[] a){
           init(a);
       }

       void init(long[] a){ // 配列aで初期化
           n = 1;
           while(n < a.length){
               n *= 2;
           }
           node = new long[2 * n - 1];
           Arrays.fill(node, e);
           for(int i = 0; i < a.length; i++){
               node[i + n - 1] = a[i];
           }
           for(int i = n - 2; i >= 0; i--){
               node[i] = func(node[2 * i + 1], node[2 * i + 2]);
           }
       }

       void update(int p, long v){ // 配列のp番目をvに変更し、木全体を更新
           p = p + n - 1;
           node[p] = v;
           while(p > 0){
               p = (p - 1) / 2;
               node[p] = func(node[2 * p + 1], node[2 * p + 2]);
           }
       }

       long query(int a, int b){ // 区間[a, b)についてクエリを処理
           return query(a, b, 0, 0, n);
       }

       long query(int a, int b, int k, int l, int r){
           if(r <= a || b <= l) return e;
           if(a <= l && r <= b) return node[k];
           return func(query(a, b, 2 * k + 1, l, (l + r) / 2), query(a, b, 2 * k + 2, (l + r) / 2, r));
       }

   }



}



class Pair implements Comparable<Pair>{
    long a, b;
    public Pair(long i, long j){
        a = i;
        b = j;
    }

    @Override
    public int compareTo(Pair p){
        if(this.b < p.b) return -1;
        else if(this.b > p.b) return 1;
        else return 0;
    }
}



class FastScanner {
    private final InputStream in = System.in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;
    private boolean hasNextByte(){
        if(ptr < buflen){
            return true;
        }else{
            ptr = 0;
            try{
                buflen = in.read(buffer);
            }catch(IOException e){
                e.printStackTrace();
            }
            if(buflen <= 0){
                return false;
            }
        }
        return true;
    }
    private int readByte(){
        if(hasNextByte()) return buffer[ptr++];
        else return -1;
    }
    private static boolean isPrintableChar(int c){
        return 33 <= c && c <= 126;
    }
    public boolean hasNext(){
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next(){
        if(!hasNext()) throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)){
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
    public long nextLong(){
        if(!hasNext()) throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if(b == '-'){
            minus = true;
            b = readByte();
        }
        if(b < '0' || '9' < b){
            throw new NumberFormatException();
        }
        while(true){
            if('0' <= b && b <= '9'){
                n *= 10;
                n += b - '0';
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt(){
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble(){
        return Double.parseDouble(next());
    }
}

</source>
<source file="../hum_codes_raw/s470221652.java" startline="1" endline="435" pcid="15801">
import java.io.*;
import java.util.*;

class Main{
    final static long INF = Long.MAX_VALUE / 2;
    final static int MOD = 1_000_000_007;
    final static int SIZE = 1_000_000;
    long[] fac = new long[SIZE];
    long[] inv = new long[SIZE];
    long[] finv = new long[SIZE];
    FastScanner sc = new FastScanner();

    public static void main(String[] args) {
        new Main().solve();
    }

    void solve(){

        int n = sc.nextInt();
        long[] a = new long[n + 1];

        for(int i = 0; i < n + 1; i++){
            a[i] = sc.nextLong();
        }

        if(a[0] > 1 || (a[0] == 1 && n > 1)){ // a[0] が1以下でない または 深さ1以上で a[0] が1 の時 -1
            System.out.println(-1);
            System.exit(0);
        }

        // long b = 2;
        //
        // for(int i = 1; i < n + 1; i++){
        //     if(a[i] > b - a[i - 1] * 2){
        //         System.out.println(-1);
        //         System.exit(0);
        //     }
        //     b *= 2;
        //     if(b > 1000000000) break;
        // }

        long[] p = new long[n + 1]; // p[i] : 親になれるノードの数
        if(a[0] == 1) p[0] = 0;
        else p[0] = 1;

        for(int i = 1; i < n + 1; i++){
            p[i] = p[i - 1] * 2 - a[i]; // 深さiの親になれるノードの数 = 深さi - 1の親になれるノードの数 * 2 - 深さiの葉の数 ?
        }

        long[] m = new long[n + 1]; // m[i] : 深さiの頂点の最大数
        m[0] = 1;

        for(int i = 1; i < n + 1; i++){
            m[i] = p[i - 1] * 2; // 深さiの頂点の最大数 = 深さi - 1の親になれるノードの数 * 2 ?
        }

        long[] s = new long[n + 1]; // s[i] : a[i], a[i + 1], ... a[n] の累積
        s[n] = a[n];

        for(int i = n - 1; i >= 0; i--){
            s[i] = s[i + 1] + a[i];
        }

        long sum = 0;

        for(int i = 0; i < n + 1; i++){
            if(m[i] >= 0){
                sum += Math.min(m[i], s[i]);
                if(a[i] > m[i]){
                    System.out.println(-1);
                    System.exit(0);
                }
            }else{
                sum += s[i];
            }
        }

        System.out.println(sum);

    }

    long gcd(long a, long b){ // return aとbの最大公約数
        if(b == 0){
          return a;
        }
        return gcd(b, a % b);
    }

    long lcm(long a, long b){ // return aとbの最小公倍数
        return a * b / gcd(a, b);
    }

    long inv(long a){ // return aの逆元 (mod MOD)
        return pow(a, MOD - 2);
    }

    long pow(long a, long r){ // return a^r (mod MOD)
        long sum = 1;
        while(r > 0){
            if((r & 1) == 1){ // 2進数表記で末尾1の時
                sum *= a;
                sum %= MOD;
            }
            a *= a;
            a %= MOD;
            r >>= 1;
        }
        return sum;
    }

    long modFact(long n){ // retur n! (mod MOD)
        if(n == 0){
            return 1;
        }
        return n * modFact(n - 1) % MOD;
    }

    long fact(long n){ // return n!
        if(n == 0){
            return 1;
        }
        return n * fact(n - 1);
    }

    void initCOMB(){
        fac[0] = fac[1] = 1;
        inv[1] = 1;
        finv[0] = finv[1] = 1;
        for(int i = 2; i < SIZE; i++){
            fac[i] = fac[i - 1] * i % MOD;
            inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;
            finv[i] = finv[i - 1] * inv[i] % MOD;
        }
    }

    long modComb(int n, int r){ // return nCr (先にinitCOMB()必要)
        if(n < r || n < 0 || r < 0) return 0;
        return fac[n] * finv[r] % MOD * finv[n - r] % MOD;
    }

    long comb(long n, long r){ // return nCr
        long num = 1;
        for(long i = 1; i <= r; i++){
            num = num * (n - i + 1) / i;
        }
        return num;
    }

    boolean isPrime(long a){ // aの素数判定
        if(a <= 1) return false;
        for(int i = 2; i * i <= a; i++){
            if(a % i == 0) return false;
        }
        return true;
    }

    int lowerBound(long[] a, long v){ // return 配列a内のv以上の要素の内最低の要素のイテレータ
        int r = a.length;
        int l = -1;
        while(r - l > 1){
            int mid = (r + l) / 2;
            if(a[mid] >= v){
                r = mid;
            }else{
                l = mid;
            }
        }
        return r;
    }

    int upperBound(long[] a, long v){ // return 配列a内のvより大きい要素の内最低の要素のイテレータ
        int r = a.length;
        int l = -1;
        while(r - l > 1){
            int mid = (r + l) / 2;
            if(a[mid] > v){
                r = mid;
            }else{
                l = mid;
            }
        }
        return r;
    }

    String nextPermutation(String s){ // return sの次の順列
        ArrayList<Character> list = new ArrayList<>();
        for(int i = 0; i < s.length(); i++) list.add(s.charAt(i));

        int pivotPos = -1;
        char pivot = 0;
        for(int i = list.size() - 2; i >= 0; i--){
            if(list.get(i) < list.get(i+1)){
    			pivotPos = i;
    			pivot = list.get(i);
    			break;
    		}
    	}

        if(pivotPos == -1 && pivot == 0) return null;

        int L = pivotPos + 1;
        int R = list.size() - 1;
    	int minPos = -1;
    	char min = Character.MAX_VALUE;
    	for(int i = R; i >= L; i--){
    		if(pivot < list.get(i)){
    			if(list.get(i) < min){
    				min = list.get(i);
    				minPos = i;
    			}
    		}
    	}

    	Collections.swap(list, pivotPos, minPos);
    	Collections.sort(list.subList(L, R + 1));

    	StringBuilder sb = new StringBuilder();
    	for(int i=0; i<list.size(); i++) sb.append(list.get(i));

    	return sb.toString();
    }

    boolean nextPermutation(long[] a){
        for(int i = a.length - 1; i > 0; i--){
            if(a[i - 1] < a[i]){
                int swapIndex = find(a[i - 1], a, i, a.length - 1);
                long temp = a[swapIndex];
                a[swapIndex] = a[i - 1];
                a[i - 1] = temp;
                Arrays.sort(a, i, a.length);
                return true;
            }
        }
        return false;
    }

    int find(long dest, long[] a, int s, int e){
        if(s == e){
            return s;
        }
        int m = (s + e + 1) / 2;
        return a[m] <= dest ? find(dest, a, s, m - 1) : find(dest, a, m, e);
    }

    void elimination(int[][] a, int[] b) {
        int n = a.length;
        double f;
        for(int k = 0; k < n - 1; k++){
            for(int i = k + 1; i < n; i++){
                f = - a[i][k] / a[k][k];
                for(int j = k + 1; j < n; j++){
                    a[i][j] += f * a[k][j];
                }
                b[i] += f * b[k];
            }
            for(int i = n - 1; i >= 0; i--){
                for(int j = i + 1; j < n; j++){
                    b[i] -= a[i][j] * b[j];
                }
                b[i] = b[i] / a[i][i];
            }
        }
   }



   class SegmentTree{

       //------------------------------------------------------------
       // 2 * n - 1 : 木全体のノード数
       // i + n - 1 : 配列のi番目が対応するノードの番号
       // 2 * i + 1, 2 * i + 2 : i番目のノードの子ノードの番号
       // (i - 1) / 2 : i番目のノードの親ノードの番号
       //
       // int n = sc.nextInt();
       // long[] a = new long[n];
       // for(int i = 0; i < n; i++) a[i] = sc.nextLong();
       // SegmentTree st = new SegmentTree(a);
       // int l = sc.nextInt() - 1;
       // int r = sc.nextInt() - 1;
       // System.out.println(st.query(l, r));
       //------------------------------------------------------------

       final static long INF = Long.MAX_VALUE / 2;

       // long e = INF; // 単位元
       long e = 0;
       long func(long a, long b){ // 処理
           // return Math.min(a, b);
           return a + b;
       }

       int n; // 配列の要素数を超える最小の2のべき乗
       long[] node;

       SegmentTree(long[] a){
           init(a);
       }

       void init(long[] a){ // 配列aで初期化
           n = 1;
           while(n < a.length){
               n *= 2;
           }
           node = new long[2 * n - 1];
           Arrays.fill(node, e);
           for(int i = 0; i < a.length; i++){
               node[i + n - 1] = a[i];
           }
           for(int i = n - 2; i >= 0; i--){
               node[i] = func(node[2 * i + 1], node[2 * i + 2]);
           }
       }

       void update(int p, long v){ // 配列のp番目をvに変更し、木全体を更新
           p = p + n - 1;
           node[p] = v;
           while(p > 0){
               p = (p - 1) / 2;
               node[p] = func(node[2 * p + 1], node[2 * p + 2]);
           }
       }

       long query(int a, int b){ // 区間[a, b)についてクエリを処理
           return query(a, b, 0, 0, n);
       }

       long query(int a, int b, int k, int l, int r){
           if(r <= a || b <= l) return e;
           if(a <= l && r <= b) return node[k];
           return func(query(a, b, 2 * k + 1, l, (l + r) / 2), query(a, b, 2 * k + 2, (l + r) / 2, r));
       }

   }



}



class Pair implements Comparable<Pair>{
    long a, b;
    public Pair(long i, long j){
        a = i;
        b = j;
    }

    @Override
    public int compareTo(Pair p){
        if(this.b < p.b) return -1;
        else if(this.b > p.b) return 1;
        else return 0;
    }
}



class FastScanner {
    private final InputStream in = System.in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;
    private boolean hasNextByte(){
        if(ptr < buflen){
            return true;
        }else{
            ptr = 0;
            try{
                buflen = in.read(buffer);
            }catch(IOException e){
                e.printStackTrace();
            }
            if(buflen <= 0){
                return false;
            }
        }
        return true;
    }
    private int readByte(){
        if(hasNextByte()) return buffer[ptr++];
        else return -1;
    }
    private static boolean isPrintableChar(int c){
        return 33 <= c && c <= 126;
    }
    public boolean hasNext(){
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next(){
        if(!hasNext()) throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)){
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
    public long nextLong(){
        if(!hasNext()) throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if(b == '-'){
            minus = true;
            b = readByte();
        }
        if(b < '0' || '9' < b){
            throw new NumberFormatException();
        }
        while(true){
            if('0' <= b && b <= '9'){
                n *= 10;
                n += b - '0';
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt(){
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble(){
        return Double.parseDouble(next());
    }
}


</source>
</class>

<class classid="217" nclones="2" nlines="25" similarity="100">
<source file="../hum_codes_raw/s440260687.java" startline="1" endline="29" pcid="14765">
import java.util.Scanner;

//Hit and Blow
public class Main{

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			char[] r = sc.next().toCharArray();
			char[] a = sc.next().toCharArray();
			if(r.length==1)break;
			int h = 0;
			int b = 0;
			int[] c1 = new int[10];
			int[] c2 = new int[10];
			for(int i=0;i<4;i++){
				if(r[i]==a[i]){
					h++;
					continue;
				}
				c1[r[i]-'0']++;
				c2[a[i]-'0']++;
			}
			for(int i=0;i<10;i++)b+=Math.min(c1[i], c2[i]);
			System.out.println(h+" "+b);
		}
	}
}

</source>
<source file="../hum_codes_raw/s709290021.java" startline="1" endline="28" pcid="23847">
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			char[] r = sc.next().toCharArray();
			char[] a = sc.next().toCharArray();
			if(r.length==1)break;
			int h = 0;
			int b = 0;
			int[] c1 = new int[10];
			int[] c2 = new int[10];
			for(int i=0;i<4;i++){
				if(r[i]==a[i]){
					h++;
					continue;
				}
				c1[r[i]-'0']++;
				c2[a[i]-'0']++;
			}
			for(int i=0;i<10;i++)b+=Math.min(c1[i], c2[i]);
			System.out.println(h+" "+b);
		}
	}
}

</source>
</class>

<class classid="218" nclones="2" nlines="109" similarity="100">
<source file="../hum_codes_raw/s447540612.java" startline="1" endline="132" pcid="14997">
import java.io.*;
import java.util.*;

public class Main {
    private static final int MAX = (int) (2e9 + 1);
    public static void main(String[] args) throws Exception {
        new Main().solve();
    }

    //Floyd-Warshall's Algorithm
    private void solve() throws Exception{
        FastScanner scanner = new FastScanner(System.in);

        int V = scanner.nextInt();
        int E = scanner.nextInt();

        int[][] dist = new int[V][V];
        for(int i = 0; i < V; ++i){
            Arrays.fill(dist[i], MAX);
            dist[i][i] = 0;
        }

        for(int i = 0; i < E; ++i){
            int u = scanner.nextInt();
            int v = scanner.nextInt();
            int w = scanner.nextInt();

            dist[u][v] = w;
        }

        for(int k = 0; k < V; ++k){
            for(int i = 0; i < V; ++i){
                for(int j = 0; j < V; ++j){
                    if(dist[i][k] != MAX && dist[k][j] != MAX && dist[i][j] > dist[i][k] + dist[k][j]){
                        dist[i][j] = dist[i][k] + dist[k][j];
                    }
                }

                if(dist[i][i] < 0){
                    System.out.println("NEGATIVE CYCLE");
                    return;
                }
            }
        }

        PrintWriter printWriter = new PrintWriter(System.out);
        for(int i = 0; i < V; ++i){
            for(int j = 0; j < V; ++j){
                printWriter.print(dist[i][j] == MAX ? "INF" : dist[i][j]);

                if(j != V - 1){
                    printWriter.print(" ");
                }
                else{
                    printWriter.println();
                }
            }
        }

        printWriter.flush();
    }

    static class FastScanner {
        private InputStream in;
        private final byte[] buffer = new byte[1024 * 8];
        private int ptr = 0;
        private int buflen = 0;

        public FastScanner(InputStream in){
            this.in = in;
        }

        private boolean hasNextByte() {
            if (ptr < buflen) {
                return true;
            } else {
                ptr = 0;
                try {
                    buflen = in.read(buffer);
                } catch (IOException e) {
                    e.printStackTrace();
                }
                if (buflen <= 0) {
                    return false;
                }
            }
            return true;
        }

        private int readByte() {
            if (hasNextByte()) return buffer[ptr++];
            else return -1;
        }

        private static boolean isPrintableChar(int c) {
            return 33 <= c && c <= 126;
        }

        private void skipUnprintable() {
            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        }

        public boolean hasNext() {
            skipUnprintable();
            return hasNextByte();
        }

        public String next() {
            if (!hasNext()) throw new NoSuchElementException();
            StringBuilder sb = new StringBuilder();
            int b = readByte();
            while (isPrintableChar(b)) {
                sb.appendCodePoint(b);
                b = readByte();
            }
            return sb.toString();
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }
    }
}

</source>
<source file="../hum_codes_raw/s666412542.java" startline="1" endline="132" pcid="22378">
import java.io.*;
import java.util.*;

public class Main {
    private static final int MAX = (int) (2e9 + 1);
    public static void main(String[] args) throws Exception {
        new Main().solve();
    }

    //Floyd-Warshall's Algorithm
    private void solve() throws Exception{
        FastScanner scanner = new FastScanner(System.in);

        int V = scanner.nextInt();
        int E = scanner.nextInt();

        int[][] dist = new int[V][V];
        for(int i = 0; i < V; ++i){
            Arrays.fill(dist[i], MAX);
            dist[i][i] = 0;
        }

        for(int i = 0; i < E; ++i){
            int u = scanner.nextInt();
            int v = scanner.nextInt();
            int w = scanner.nextInt();

            dist[u][v] = w;
        }

        for(int k = 0; k < V; ++k){
            for(int i = 0; i < V; ++i){
                for(int j = 0; j < V; ++j){
                    if(dist[i][k] != MAX && dist[k][j] != MAX && dist[i][j] > dist[i][k] + dist[k][j]){
                        dist[i][j] = dist[i][k] + dist[k][j];
                    }
                }

                if(dist[i][i] < 0){
                    System.out.println("NEGATIVE CYCLE");
                    return;
                }
            }
        }

        PrintWriter printWriter = new PrintWriter(System.out);
        for(int i = 0; i < V; ++i){
            for(int j = 0; j < V; ++j){
                printWriter.print(dist[i][j] == MAX ? "INF" : dist[i][j]);

                if(j != V - 1){
                    printWriter.print(" ");
                }
                else{
                    printWriter.println();
                }
            }
        }

        printWriter.flush();
    }

    static class FastScanner {
        private InputStream in;
        private final byte[] buffer = new byte[1024 * 8];
        private int ptr = 0;
        private int buflen = 0;

        public FastScanner(InputStream in){
            this.in = in;
        }

        private boolean hasNextByte() {
            if (ptr < buflen) {
                return true;
            } else {
                ptr = 0;
                try {
                    buflen = in.read(buffer);
                } catch (IOException e) {
                    e.printStackTrace();
                }
                if (buflen <= 0) {
                    return false;
                }
            }
            return true;
        }

        private int readByte() {
            if (hasNextByte()) return buffer[ptr++];
            else return -1;
        }

        private static boolean isPrintableChar(int c) {
            return 33 <= c && c <= 126;
        }

        private void skipUnprintable() {
            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        }

        public boolean hasNext() {
            skipUnprintable();
            return hasNextByte();
        }

        public String next() {
            if (!hasNext()) throw new NoSuchElementException();
            StringBuilder sb = new StringBuilder();
            int b = readByte();
            while (isPrintableChar(b)) {
                sb.appendCodePoint(b);
                b = readByte();
            }
            return sb.toString();
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }
    }
}

</source>
</class>

<class classid="219" nclones="2" nlines="53" similarity="100">
<source file="../hum_codes_raw/s448593795.java" startline="1" endline="61" pcid="15035">
import java.io.*;
import java.math.*;
import java.util.*;

public class Main {
    private static boolean debug = false;
    private static boolean elapsed = false;

    private static PrintWriter _out = new PrintWriter(System.out);
    private static PrintWriter _err = new PrintWriter(System.err);

    private void solve(Scanner sc) {
        int a = sc.nextInt();
        int b = sc.nextInt();

        if (a == b) {
            _out.println("Draw");
        } else if (a == 1) {
            _out.println("Alice");
        } else if (b == 1) {
            _out.println("Bob");
        } else {
            _out.println((a > b ? "Alice" : "Bob"));
        }
    }
    private static BigInteger C(long n, long r) {
        BigInteger res = BigInteger.ONE;
        for (long i = n; i > n - r; --i) {
            res = res.multiply(BigInteger.valueOf(i));
        }
        for (long i = r; i > 1; --i) {
            res = res.divide(BigInteger.valueOf(i));
        }
        return res;
    }
    private static BigInteger P(long n, long r) {
        BigInteger res = BigInteger.ONE;
        for (long i = n; i > n - r; --i) {
            res = res.multiply(BigInteger.valueOf(i));
        }
        return res;
    }
    /*
     * 10^10 > Integer.MAX_VALUE = 2147483647 > 10^9
     * 10^19 > Long.MAX_VALUE = 9223372036854775807L > 10^18
     */
    public static void main(String[] args) {
        long S = System.currentTimeMillis();

        Scanner sc = new Scanner(System.in);
        new Main().solve(sc);
        _out.flush();

        long G = System.currentTimeMillis();
        if (elapsed) {
            _err.println((G - S) + "ms");
        }
        _err.flush();
    }
}

</source>
<source file="../hum_codes_raw/s919592382.java" startline="1" endline="61" pcid="30927">
import java.io.*;
import java.math.*;
import java.util.*;
 
public class Main {
    private static boolean debug = false;
    private static boolean elapsed = false;
 
    private static PrintWriter _out = new PrintWriter(System.out);
    private static PrintWriter _err = new PrintWriter(System.err);
 
    private void solve(Scanner sc) {
        int a = sc.nextInt();
        int b = sc.nextInt();
 
        if (a == b) {
            _out.println("Draw");
        } else if (a == 1) {
            _out.println("Alice");
        } else if (b == 1) {
            _out.println("Bob");
        } else {
            _out.println((a > b ? "Alice" : "Bob"));
        }
    }
    private static BigInteger C(long n, long r) {
        BigInteger res = BigInteger.ONE;
        for (long i = n; i > n - r; --i) {
            res = res.multiply(BigInteger.valueOf(i));
        }
        for (long i = r; i > 1; --i) {
            res = res.divide(BigInteger.valueOf(i));
        }
        return res;
    }
    private static BigInteger P(long n, long r) {
        BigInteger res = BigInteger.ONE;
        for (long i = n; i > n - r; --i) {
            res = res.multiply(BigInteger.valueOf(i));
        }
        return res;
    }
    /*
     * 10^10 > Integer.MAX_VALUE = 2147483647 > 10^9
     * 10^19 > Long.MAX_VALUE = 9223372036854775807L > 10^18
     */
    public static void main(String[] args) {
        long S = System.currentTimeMillis();
 
        Scanner sc = new Scanner(System.in);
        new Main().solve(sc);
        _out.flush();
 
        long G = System.currentTimeMillis();
        if (elapsed) {
            _err.println((G - S) + "ms");
        }
        _err.flush();
    }
}

</source>
</class>

<class classid="220" nclones="2" nlines="40" similarity="100">
<source file="../hum_codes_raw/s450059172.java" startline="1" endline="45" pcid="15085">
import java.util.Arrays;
import java.util.Scanner;

public class Main {
	public static void main(String[] args) throws Exception {

		Scanner sc = new Scanner(System.in);
		long INF = 1 << 58;
		while (true) {
			int n = sc.nextInt();
			int k = sc.nextInt();
			if ((n | k) == 0)
				break;
			long fare[][] = new long[n][n];
			for (int i = 0; i < n; i++) {
				Arrays.fill(fare[i], INF);
				fare[i][i] = 0;
			}
			for (int i = 0; i < k; i++) {
				int init = sc.nextInt();
				if (init == 1) {
					int c = sc.nextInt() - 1;
					int d = sc.nextInt() - 1;
					int e = sc.nextInt();
					if (e < fare[c][d]) {
						fare[c][d] = fare[d][c] = e;
						for (int p = 0; p < n; p++) {
							for (int q = 0; q < n; q++) {
								fare[p][q] = Math.min(fare[p][q], fare[p][c]
										+ fare[c][d] + fare[d][q]);
								fare[p][q] = Math.min(fare[p][q], fare[p][d]
										+ fare[c][d] + fare[c][q]);
							}
						}
					}
				} else {
					int a = sc.nextInt() - 1;
					int b = sc.nextInt() - 1;
					System.out.println(fare[a][b] != INF ? fare[a][b] : -1);
				}
			}
		}
	}
}

</source>
<source file="../hum_codes_raw/s510751196.java" startline="1" endline="45" pcid="17122">
import java.util.Arrays;
import java.util.Scanner;

public class Main {
	public static void main(String[] args) throws Exception {

		Scanner sc = new Scanner(System.in);
		long INF = 1 << 58;
		while (true) {
			int n = sc.nextInt();
			int k = sc.nextInt();
			if ((n | k) == 0)
				break;
			long fare[][] = new long[n][n];
			for (int i = 0; i < n; i++) {
				Arrays.fill(fare[i], INF);
				fare[i][i] = 0;
			}
			for (int i = 0; i < k; i++) {
				int init = sc.nextInt();
				if (init == 1) {
					int c = sc.nextInt() - 1;
					int d = sc.nextInt() - 1;
					int e = sc.nextInt();
					if (e < fare[c][d]) {
						fare[c][d] = fare[d][c] = e;
						for (int p = 0; p < n; p++) {
							for (int q = 0; q < n; q++) {
								fare[p][q] = Math.min(fare[p][q], fare[p][c]
										+ fare[c][d] + fare[d][q]);
								fare[p][q] = Math.min(fare[p][q], fare[p][d]
										+ fare[c][d] + fare[c][q]);
							}
						}
					}
				} else {
					int a = sc.nextInt() - 1;
					int b = sc.nextInt() - 1;
					System.out.println(fare[a][b] != INF ? fare[a][b] : -1);
				}
			}
		}
	}
}

</source>
</class>

<class classid="221" nclones="2" nlines="64" similarity="100">
<source file="../hum_codes_raw/s455106067.java" startline="1" endline="73" pcid="15265">
import java.util.ArrayDeque;
import java.util.Deque;
import java.io.BufferedReader;
import java.io.InputStreamReader;

public class Main {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] hwn = br.readLine().split(" ");
        int h = Integer.parseInt(hwn[0]);
        int w = Integer.parseInt(hwn[1]);
        int n = Integer.parseInt(hwn[2]);
        char[][] grid = new char[h][w];
        int sx=-1, sy=-1;
        
        for (int i = 0; i < h; i++) {
            String raw = br.readLine();
            for (int j = 0; j < w; j++) {
                grid[i][j] = raw.charAt(j);
                if (grid[i][j] == 'S') {
                    sy = i;
                    sx = j;
                }
            }
        }
        
        int next = 1;
        int[][] dfyxs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        boolean[][] visited = new boolean[h][w];
        visited[sy][sx] = true;
        int[][] distance = new int[h][w];
        distance[sy][sx] = 0;
        Deque<Integer> xq = new ArrayDeque<Integer>();
        Deque<Integer> yq = new ArrayDeque<Integer>();
        int d = 0;
        int ans = 0;
        outer: while (true) {
            inner: for (int[] dfyx: dfyxs) {
                if (sy-dfyx[0] < 0 || sx-dfyx[1] < 0 || sy-dfyx[0] >= h || sx-dfyx[1] >= w) continue;
                if (visited[sy-dfyx[0]][sx-dfyx[1]] == true) continue;
                if (grid[sy-dfyx[0]][sx-dfyx[1]] == 'X') {
                    continue;
                }
                distance[sy-dfyx[0]][sx-dfyx[1]] = distance[sy][sx] + 1;
                //System.out.println((sy-dfyx[0]) + " " + (sx-dfyx[1]));
                if ((int)grid[sy-dfyx[0]][sx-dfyx[1]]-48 == next) {
                    //System.out.println("aaa");
                    //System.out.println(distance[sy-dfyx[0]][sx-dfyx[1]]);
                    yq.clear();
                    xq.clear();
                    ans += distance[sy-dfyx[0]][sx-dfyx[1]];
                    if (next == n) break outer;
                    next++;
                    distance = new int[h][w];
                    distance[sy-dfyx[0]][sx-dfyx[1]] = 0;
                    visited = new boolean[h][w];
                    sy = sy-dfyx[0];
                    sx = sx-dfyx[1];
                    continue outer;
                }
                visited[sy-dfyx[0]][sx-dfyx[1]] = true;
                xq.addLast(sx-dfyx[1]);
                yq.addLast(sy-dfyx[0]);
            }
            sy = yq.removeFirst();
            sx = xq.removeFirst();
        }
        //System.out.println(distance[3][1]);
        System.out.println(ans);
    }
}


</source>
<source file="../hum_codes_raw/s749145584.java" startline="1" endline="73" pcid="25166">
import java.util.ArrayDeque;
import java.util.Deque;
import java.io.BufferedReader;
import java.io.InputStreamReader;

public class Main {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] hwn = br.readLine().split(" ");
        int h = Integer.parseInt(hwn[0]);
        int w = Integer.parseInt(hwn[1]);
        int n = Integer.parseInt(hwn[2]);
        char[][] grid = new char[h][w];
        int sx=-1, sy=-1;
        
        for (int i = 0; i < h; i++) {
            String raw = br.readLine();
            for (int j = 0; j < w; j++) {
                grid[i][j] = raw.charAt(j);
                if (grid[i][j] == 'S') {
                    sy = i;
                    sx = j;
                }
            }
        }
        
        int next = 1;
        int[][] dfyxs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        boolean[][] visited = new boolean[h][w];
        visited[sy][sx] = true;
        int[][] distance = new int[h][w];
        distance[sy][sx] = 0;
        Deque<Integer> xq = new ArrayDeque<Integer>();
        Deque<Integer> yq = new ArrayDeque<Integer>();
        int d = 0;
        int ans = 0;
        outer: while (true) {
            inner: for (int[] dfyx: dfyxs) {
                if (sy-dfyx[0] < 0 || sx-dfyx[1] < 0 || sy-dfyx[0] >= h || sx-dfyx[1] >= w) continue;
                if (visited[sy-dfyx[0]][sx-dfyx[1]] == true) continue;
                if (grid[sy-dfyx[0]][sx-dfyx[1]] == 'X') {
                    continue;
                }
                distance[sy-dfyx[0]][sx-dfyx[1]] = distance[sy][sx] + 1;
                //System.out.println((sy-dfyx[0]) + " " + (sx-dfyx[1]));
                if ((int)grid[sy-dfyx[0]][sx-dfyx[1]]-48 == next) {
                    //System.out.println("aaa");
                    //System.out.println(distance[sy-dfyx[0]][sx-dfyx[1]]);
                    yq.clear();
                    xq.clear();
                    ans += distance[sy-dfyx[0]][sx-dfyx[1]];
                    if (next == n) break outer;
                    next++;
                    distance = new int[h][w];
                    distance[sy-dfyx[0]][sx-dfyx[1]] = 0;
                    visited = new boolean[h][w];
                    sy = sy-dfyx[0];
                    sx = sx-dfyx[1];
                    continue outer;
                }
                visited[sy-dfyx[0]][sx-dfyx[1]] = true;
                xq.addLast(sx-dfyx[1]);
                yq.addLast(sy-dfyx[0]);
            }
            sy = yq.removeFirst();
            sx = xq.removeFirst();
        }
        //System.out.println(distance[3][1]);
        System.out.println(ans);
    }
}


</source>
</class>

<class classid="222" nclones="2" nlines="71" similarity="100">
<source file="../hum_codes_raw/s456667608.java" startline="1" endline="73" pcid="15314">
import java.io.*;
import java.util.*;
class Solution {
	final int SIZE = 20;
	int[] dr = { 0, 1, 0, -1 };
	int[] dc = { 1, 0, -1, 0 };
	int w;
	int h;
	int[][] graph = new int[SIZE][SIZE];
	int ans;
	int sr;
	int sc;
	void compute() {
		Scanner scanner = new Scanner(new BufferedInputStream(System.in));
		while (true) {
			w = scanner.nextInt();
			h = scanner.nextInt();
			if (w == 0 && h == 0) {
				break;
			}
			for (int i = 0; i < h; i++) {
				for (int j = 0; j < w; j++) {
					graph[i][j] = scanner.nextInt();
					if (graph[i][j] == 2) {
						sr = i;
						sc = j;
					}
				}
			}
			ans = 11;
			dfs(sr, sc, 0);
			if (ans <= 10) {
				System.out.println(ans);
			} else {
				System.out.println(-1);
			}
		}
		scanner.close();
	}

	void dfs(int r, int c, int step) {
		if (step == 10) {
			return;
		}
		for (int direction = 0; direction < 4; direction++) {
			int nr = r;
			int nc = c;
			int cnt = 0;
			while (nr >= 0 && nr < h && nc >= 0 && nc < w && graph[nr][nc] != 1) {
				if (graph[nr][nc] == 3) {
					ans = Math.min(ans, step + 1);
					return;
				}
				nr += dr[direction];
				nc += dc[direction];
				cnt++;
			}
			if (nr >= 0 && nr < h && nc >= 0 && nc < w && graph[nr][nc] == 1 && cnt > 1) {
				graph[nr][nc] = 0;
				dfs(nr - dr[direction], nc - dc[direction], step + 1);
				graph[nr][nc] = 1;
			}
		}
	}
}
public class Main {
	public static void main(String args[]) {
		Solution solution = new Solution();
		solution.compute();
	}
}


</source>
<source file="../hum_codes_raw/s798822729.java" startline="1" endline="76" pcid="26835">
import java.io.*;
import java.util.*;

class Solution {
	final int SIZE = 20;
	int[] dr = { 0, 1, 0, -1 };
	int[] dc = { 1, 0, -1, 0 };
	int w;
	int h;
	int[][] graph = new int[SIZE][SIZE];
	int ans;
	int sr;
	int sc;

	void compute() {
		Scanner scanner = new Scanner(new BufferedInputStream(System.in));
		while (true) {
			w = scanner.nextInt();
			h = scanner.nextInt();
			if (w == 0 && h == 0) {
				break;
			}
			for (int i = 0; i < h; i++) {
				for (int j = 0; j < w; j++) {
					graph[i][j] = scanner.nextInt();
					if (graph[i][j] == 2) {
						sr = i;
						sc = j;
					}
				}
			}
			ans = 11;
			dfs(sr, sc, 0);
			if (ans <= 10) {
				System.out.println(ans);
			} else {
				System.out.println(-1);
			}
		}
		scanner.close();
	}

	void dfs(int r, int c, int step) {
		if (step == 10) {
			return;
		}
		for (int direction = 0; direction < 4; direction++) {
			int nr = r;
			int nc = c;
			int cnt = 0;
			while (nr >= 0 && nr < h && nc >= 0 && nc < w && graph[nr][nc] != 1) {
				if (graph[nr][nc] == 3) {
					ans = Math.min(ans, step + 1);
					return;
				}
				nr += dr[direction];
				nc += dc[direction];
				cnt++;
			}
			if (nr >= 0 && nr < h && nc >= 0 && nc < w && graph[nr][nc] == 1 && cnt > 1) {
				graph[nr][nc] = 0;
				dfs(nr - dr[direction], nc - dc[direction], step + 1);
				graph[nr][nc] = 1;
			}
		}
	}
}

public class Main {
	public static void main(String args[]) {
		Solution solution = new Solution();
		solution.compute();
	}
}


</source>
</class>

<class classid="223" nclones="2" nlines="122" similarity="100">
<source file="../hum_codes_raw/s457663140.java" startline="1" endline="135" pcid="15349">
import java.util.Arrays;

import java.io.IOException;
import java.io.InputStream;
import java.util.NoSuchElementException;

 class FS {
    private final InputStream in = System.in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        } else {
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }

    private int readByte() {
        return hasNextByte() ? buffer[ptr++] : -1;
    }

    private boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }

    private void skipUnprintable() {
        while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
    }

    public boolean hasNext() {
        skipUnprintable();
        return hasNextByte();
    }

    public String next() {
        if (!hasNext()) throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while (isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }

    public int nextInt() {
        return (int) nextLong();
    }

    public long nextLong() {
        if (!hasNext()) throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                n *= 10;
                n += b - '0';
            } else if (b == -1 || !isPrintableChar(b)) {
                return minus ? -n : n;
            } else {
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
}
public class Main {
    public static void main(String[] args) {
        FS fs = new FS();
        int n = fs.nextInt();
        Stuff a[] = new Stuff[n];
        boolean b[]  =new boolean[n];
        for (int i = 0; i < n; i++) {
            int wei = fs.nextInt();
            a[i]=new Stuff(i,wei);
        }
        Arrays.sort(a);
        int min=a[0].weight;
        int wcount=0;
        for (int i = 0; i < a.length; i++) {
            if (min>a[i].weight)min=a[i].weight;
            if (b[i])continue;
            if (a[i].index==i)continue;
            int minw=a[i].weight;
            int k=0;
            for (int j = a[i].index; !b[j]; j=a[j].index,k++){
                if (min>a[j].weight)min=a[j].weight;
                if (minw>a[j].weight)min=a[j].weight;
                b[j]=true;
                wcount+=a[j].weight;
            }
            wcount+=Math.min((k-2)*minw,minw+(k+1)*min);
        }
        System.out.println(wcount);
    }

   static class Stuff implements Comparable<Stuff> {
        int index;
        int weight;

        public Stuff(int index, int weight) {
            this.index = index;
            this.weight = weight;
        }



       @Override
       public int compareTo(Stuff o) {
            if (o.weight>this.weight)return -1;
            else return 1;
       }
   }
}

</source>
<source file="../hum_codes_raw/s467750820.java" startline="1" endline="135" pcid="15698">
import java.util.Arrays;

import java.io.IOException;
import java.io.InputStream;
import java.util.NoSuchElementException;

 class FS {
    private final InputStream in = System.in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        } else {
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }

    private int readByte() {
        return hasNextByte() ? buffer[ptr++] : -1;
    }

    private boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }

    private void skipUnprintable() {
        while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
    }

    public boolean hasNext() {
        skipUnprintable();
        return hasNextByte();
    }

    public String next() {
        if (!hasNext()) throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while (isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }

    public int nextInt() {
        return (int) nextLong();
    }

    public long nextLong() {
        if (!hasNext()) throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                n *= 10;
                n += b - '0';
            } else if (b == -1 || !isPrintableChar(b)) {
                return minus ? -n : n;
            } else {
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
}
public class Main {
    public static void main(String[] args) {
        FS fs = new FS();
        int n = fs.nextInt();
        Stuff a[] = new Stuff[n];
        boolean b[]  =new boolean[n];
        for (int i = 0; i < n; i++) {
            int wei = fs.nextInt();
            a[i]=new Stuff(i,wei);
        }
        Arrays.sort(a);
        int min=a[0].weight;
        int wcount=0;
        for (int i = 0; i < a.length; i++) {
            if (min>a[i].weight)min=a[i].weight;
            if (b[i])continue;
            if (a[i].index==i)continue;
            int minw=a[i].weight;
            int k=0;
            for (int j = a[i].index; !b[j]; j=a[j].index,k++){
                if (min>a[j].weight)min=a[j].weight;
                if (minw>a[j].weight)min=a[j].weight;
                b[j]=true;
                wcount+=a[j].weight;
            }
            wcount+=Math.min((k-2)*minw,minw+(k+1)*min);
        }
        System.out.println(wcount);
    }

   static class Stuff implements Comparable<Stuff> {
        int index;
        int weight;

        public Stuff(int index, int weight) {
            this.index = index;
            this.weight = weight;
        }



       @Override
       public int compareTo(Stuff o) {
            if (o.weight>this.weight)return -1;
            else return 1;
       }
   }
}

</source>
</class>

<class classid="224" nclones="2" nlines="194" similarity="100">
<source file="../hum_codes_raw/s459791849.java" startline="1" endline="237" pcid="15431">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            CRemainderGame solver = new CRemainderGame();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class CRemainderGame {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            int[] a = new int[n];
            int[] b = new int[n];
            in.populate(a);
            in.populate(b);

            long ans = 0;
            for (int i = 50; i >= 0; i--) {
                long mask = ans | ((1L << i) - 1);
                if (!check(mask, a, b)) {
                    ans = Bits.set(ans, i);
                }
            }

            if (!check(ans, a, b)) {
                out.println(-1);
                return;
            }

            out.println(ans);
        }

        public boolean check(long divisor, int[] a, int[] b) {
            long[] next = new long[51];
            for (int i = 0; i <= 50; i++) {
                next[i] = Bits.set(next[i], i);
                for (int j = 1; j <= 50; j++) {
                    if (Bits.get(divisor, j) == 1) {
                        next[i] |= next[i % j];
                    }
                }
            }

            for (int i = 0; i < a.length; i++) {
                if (Bits.get(next[a[i]], b[i]) == 0) {
                    return false;
                }
            }
            return true;
        }

    }

    static class Bits {
        private Bits() {
        }

        public static int get(long x, int i) {
            return (int) ((x >>> i) & 1);
        }

        public static long set(long x, int i) {
            return x | (1L << i);
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(long c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println(long c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        public void populate(int[] data) {
            for (int i = 0; i < data.length; i++) {
                data[i] = readInt();
            }
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }
}


</source>
<source file="../hum_codes_raw/s621444911.java" startline="1" endline="237" pcid="20868">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            CRemainderGame solver = new CRemainderGame();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class CRemainderGame {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            int[] a = new int[n];
            int[] b = new int[n];
            in.populate(a);
            in.populate(b);

            long ans = 0;
            for (int i = 50; i >= 0; i--) {
                long mask = ans | ((1L << i) - 1);
                if (!check(mask, a, b)) {
                    ans = Bits.set(ans, i);
                }
            }

            if (!check(ans, a, b)) {
                out.println(-1);
                return;
            }

            out.println(ans);
        }

        public boolean check(long divisor, int[] a, int[] b) {
            long[] next = new long[51];
            for (int i = 0; i <= 50; i++) {
                next[i] = Bits.set(next[i], i);
                for (int j = 1; j <= 50; j++) {
                    if (Bits.get(divisor, j) == 1) {
                        next[i] |= next[i % j];
                    }
                }
            }

            for (int i = 0; i < a.length; i++) {
                if (Bits.get(next[a[i]], b[i]) == 0) {
                    return false;
                }
            }
            return true;
        }

    }

    static class Bits {
        private Bits() {
        }

        public static int get(long x, int i) {
            return (int) ((x >>> i) & 1);
        }

        public static long set(long x, int i) {
            return x | (1L << i);
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(long c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println(long c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        public void populate(int[] data) {
            for (int i = 0; i < data.length; i++) {
                data[i] = readInt();
            }
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }
}


</source>
</class>

<class classid="225" nclones="2" nlines="61" similarity="100">
<source file="../hum_codes_raw/s459917263.java" startline="1" endline="61" pcid="15434">
import java.util.*;
public class Main {
    void run() {
        Scanner sc = new Scanner(System.in);
        while (true) {
            String s = sc.next();
            if (s.equals("0")) break;
            System.out.println(dfs(convert(s)));
        }
    }
    
    String dfs(String str) {
        Set<String> visited = new HashSet<String>();
        visited.add(str);
        
        LinkedList<String> q = new LinkedList<String>();
        LinkedList<Integer> qi = new LinkedList<Integer>();
        q.add(str); qi.add(0);
        
        while (!q.isEmpty()) {
            String s = q.removeFirst();
            int c = qi.removeFirst();  
            if (ok(s)) return "" + c;
            for (int i = 0; i < s.length() - 1; i++) if (s.charAt(i) != s.charAt(i + 1)) {
                int n = s.charAt(i) - '0' + s.charAt(i + 1) - '0';
                n = (3 - n % 3) % 3;
                String next = s.substring(0, i) + n + n + s.substring(i + 2, s.length());
                if (!visited.contains(next)) {
                    q.addLast(next);
                    qi.addLast(c+1);
                    visited.add(next);
                }
            }
        }
        return "NA";
    }
    
    String convert(String str) {
        String ret = "";
        for (int i = 0; i < str.length(); i++) {
            switch (str.charAt(i)) {
            case 'r': ret += "" + 0; break;
            case 'g': ret += "" + 1; break;
            case 'b': ret += "" + 2; break;
            }
        }
        return ret;
    }
    
    boolean ok(String s) {
        for (int i = 0; i < s.length() - 1; i++) {
            if (s.charAt(i) != s.charAt(i + 1)) return false;
        }
        return true;
    }
    
    public static void main(String[] args) {
        new Main().run();
    }
}

</source>
<source file="../hum_codes_raw/s775842977.java" startline="1" endline="61" pcid="26044">
import java.util.*;
public class Main {
    void run() {
        Scanner sc = new Scanner(System.in);
        while (true) {
            String s = sc.next();
            if (s.equals("0")) break;
            System.out.println(dfs(convert(s)));
        }
    }
    
    String dfs(String str) {
        Set<String> visited = new HashSet<String>();
        visited.add(str);
        
        LinkedList<String> q = new LinkedList<String>();
        LinkedList<Integer> qi = new LinkedList<Integer>();
        q.add(str); qi.add(0);
        
        while (!q.isEmpty()) {
            String s = q.removeFirst();
            int c = qi.removeFirst();  
            if (ok(s)) return "" + c;
            for (int i = 0; i < s.length() - 1; i++) if (s.charAt(i) != s.charAt(i + 1)) {
                int n = s.charAt(i) - '0' + s.charAt(i + 1) - '0';
                n = (3 - n % 3) % 3;
                String next = s.substring(0, i) + n + n + s.substring(i + 2, s.length());
                if (!visited.contains(next)) {
                    q.addLast(next);
                    qi.addLast(c+1);
                    visited.add(next);
                }
            }
        }
        return "NA";
    }
    
    String convert(String str) {
        String ret = "";
        for (int i = 0; i < str.length(); i++) {
            switch (str.charAt(i)) {
            case 'r': ret += "" + 0; break;
            case 'g': ret += "" + 1; break;
            case 'b': ret += "" + 2; break;
            }
        }
        return ret;
    }
    
    boolean ok(String s) {
        for (int i = 0; i < s.length() - 1; i++) {
            if (s.charAt(i) != s.charAt(i + 1)) return false;
        }
        return true;
    }
    
    public static void main(String[] args) {
        new Main().run();
    }
}

</source>
</class>

<class classid="226" nclones="2" nlines="35" similarity="100">
<source file="../hum_codes_raw/s461870565.java" startline="1" endline="43" pcid="15500">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
class Main {
	public static void main(String args[]) {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String base;
		String comparison;
		
		try {
			base = br.readLine();
			comparison = br.readLine();
			
			Inversions(base, comparison, br);
		} catch (IOException e) {
			// TODO 自動生成された catch ブロック
			e.printStackTrace();
		}
	}

	public static void Inversions(String base, String comparison,  BufferedReader br){ 
		StringBuilder sb = new StringBuilder();
		int length = base.length() - comparison.length();
		String 	container;
		int ans_num = 0;
		int[] ans = new int[1000000];
		
		for(int i = 0; i <= length ; i ++ ) {
			container = base.substring( i, i + comparison.length() );
			if( container.equals(comparison) ) {
				ans[ans_num] = i;
				ans_num ++;
			}
		}
		
		for(int i = 0; i <ans_num; i++){;
			sb.append(ans[i] + "\n");
		}
		 
		System.out.print(sb);
	}
}

</source>
<source file="../hum_codes_raw/s510671027.java" startline="1" endline="43" pcid="17121">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
class Main {
	public static void main(String args[]) {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String base;
		String comparison;
		
		try {
			base = br.readLine();
			comparison = br.readLine();
			
			Inversions(base, comparison, br);
		} catch (IOException e) {
			// TODO 自動生成された catch ブロック
			e.printStackTrace();
		}
	}

	public static void Inversions(String base, String comparison,  BufferedReader br){ 
		StringBuilder sb = new StringBuilder();
		int length = base.length() - comparison.length();
		String 	container;
		int ans_num = 0;
		int[] ans = new int[1000000];
		
		for(int i = 0; i <= length ; i ++ ) {
			container = base.substring( i, i + comparison.length() );
			if( container.equals(comparison) ) {
				ans[ans_num] = i;
				ans_num ++;
			}
		}
		
		for(int i = 0; i <ans_num; i++){;
			sb.append(ans[i] + "\n");
		}
		 
		System.out.print(sb);
	}
}

</source>
</class>

<class classid="227" nclones="2" nlines="13" similarity="100">
<source file="../hum_codes_raw/s466772245.java" startline="1" endline="14" pcid="15666">
import java.util.*;
public class Main {
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		
		 String S = sc.next();
      	
      if(S.charAt(2) == S.charAt(3) && S.charAt(4) == S.charAt(5)){
      System.out.println("Yes");}
      else{
      System.out.println("No");}
	}
}

</source>
<source file="../hum_codes_raw/s474958041.java" startline="1" endline="18" pcid="15940">
import java.util.*;

public class Main{
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    String S = sc.next();
    

    if(S.charAt(2) == S.charAt(3) && S.charAt(4) == S.charAt(5)){
      System.out.println("Yes");
    }else{
      System.out.println("No");
    }
  }
}



</source>
</class>

<class classid="228" nclones="2" nlines="48" similarity="100">
<source file="../hum_codes_raw/s467690671.java" startline="1" endline="53" pcid="15695">
import java.util.Scanner;

//Drawing Lots II
public class Main{

	static int sim(char[][] s, int n, int d, int start){
		int t = start;
		for(int i=0;i<d;i++){
			if(t>0&&s[i][t-1]=='1')t--;
			else if(t<n-1 && s[i][t]=='1')t++;
		}
		return t;
	}
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int n = sc.nextInt();
			if(n==0)break;
			int m = sc.nextInt()-1;
			int g = sc.nextInt()-1;
			int d = sc.nextInt();
			char[][] s = new char[d][n-1];
			for(int i=0;i<d;i++)s[i]=sc.next().toCharArray();
			if(sim(s,n,d,m)==g){
				System.out.println(0);
				continue;
			}
			boolean ok = false;
			for(int i=0;i<d;i++){
				for(int j=0;j<n-1;j++){
					if(ok || s[i][j]=='1')continue;
					boolean left, right;
					if(j==0||s[i][j-1]=='0')left = true;
					else left = false;
					if(j==n-2||s[i][j+1]=='0')right = true;
					else right = false;
					if(left&&right){
						s[i][j]='1';
						if(sim(s,n,d,m)==g){
							System.out.println((i+1)+" "+(j+1));
							ok = true;
							break;
						}
						s[i][j]='0';
					}
				}
			}
			if(!ok)System.out.println("1");
		}
	}
}

</source>
<source file="../hum_codes_raw/s607267764.java" startline="1" endline="52" pcid="20404">
import java.util.Scanner;

public class Main {

	static int sim(char[][] s, int n, int d, int start){
		int t = start;
		for(int i=0;i<d;i++){
			if(t>0&&s[i][t-1]=='1')t--;
			else if(t<n-1 && s[i][t]=='1')t++;
		}
		return t;
	}
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int n = sc.nextInt();
			if(n==0)break;
			int m = sc.nextInt()-1;
			int g = sc.nextInt()-1;
			int d = sc.nextInt();
			char[][] s = new char[d][n-1];
			for(int i=0;i<d;i++)s[i]=sc.next().toCharArray();
			if(sim(s,n,d,m)==g){
				System.out.println(0);
				continue;
			}
			boolean ok = false;
			for(int i=0;i<d;i++){
				for(int j=0;j<n-1;j++){
					if(ok || s[i][j]=='1')continue;
					boolean left, right;
					if(j==0||s[i][j-1]=='0')left = true;
					else left = false;
					if(j==n-2||s[i][j+1]=='0')right = true;
					else right = false;
					if(left&&right){
						s[i][j]='1';
						if(sim(s,n,d,m)==g){
							System.out.println((i+1)+" "+(j+1));
							ok = true;
							break;
						}
						s[i][j]='0';
					}
				}
			}
			if(!ok)System.out.println("1");
		}
	}
}

</source>
</class>

<class classid="229" nclones="2" nlines="50" similarity="100">
<source file="../hum_codes_raw/s473121306.java" startline="1" endline="49" pcid="15888">
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		String a = scan.nextLine();
		String[] a2 = a.split("");
		String b = scan.nextLine();
		String[] b2 = b.split("");
		int al = a.length();
		int bl = b.length();
		if(al<bl){
			int n=al; al=bl; bl=n;
			String[] nu=a2; a2=b2; b2=nu;
		}
		int[][] dp = new int[bl+1][al+1];
		for(int i=1;i<=al;++i){
			dp[0][i]=dp[0][i-1]+1;
		}
		for(int i=1;i<=bl;++i){
			dp[i][0]=dp[i-1][0]+1;
		}
		for(int i=1;i<=bl;++i){
			for(int j=1;j<=al;++j){
				int min=0;
				if(b2[i-1].equals(a2[j-1])==true){
					min = Min(dp[i-1][j-1],dp[i][j-1]+1,dp[i-1][j]+1);
				} else {
					min = Min(dp[i-1][j-1]+1,dp[i][j-1]+1,dp[i-1][j]+1);
				}
				dp[i][j]=min;
			}
		}
		System.out.println(dp[bl][al]);
	}

	public static int Min(int a, int b, int c){
		int min=a;
		if(a>b){
			min=b;
		}
		if(min>c){
			min=c;
		}
		return min;
	}
}


</source>
<source file="../hum_codes_raw/s723939010.java" startline="1" endline="48" pcid="24349">
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		String a = scan.nextLine();
		String[] a2 = a.split("");
		String b = scan.nextLine();
		String[] b2 = b.split("");
		int al = a.length();
		int bl = b.length();
		if(al<bl){
			int n=al; al=bl; bl=n;
			String[] nu=a2; a2=b2; b2=nu;
		}
		int[][] dp = new int[bl+1][al+1];
		for(int i=1;i<=al;++i){
			dp[0][i]=dp[0][i-1]+1;
		}
		for(int i=1;i<=bl;++i){
			dp[i][0]=dp[i-1][0]+1;
		}
		for(int i=1;i<=bl;++i){
			for(int j=1;j<=al;++j){
				int min=0;
				if(b2[i-1].equals(a2[j-1])==true){
					min = Min(dp[i-1][j-1],dp[i][j-1]+1,dp[i-1][j]+1);
				} else {
					min = Min(dp[i-1][j-1]+1,dp[i][j-1]+1,dp[i-1][j]+1);
				}
				dp[i][j]=min;
			}
		}
		System.out.println(dp[bl][al]);
	}

	public static int Min(int a, int b, int c){
		int min=a;
		if(a>b){
			min=b;
		}
		if(min>c){
			min=c;
		}
		return min;
	}
}

</source>
</class>

<class classid="230" nclones="2" nlines="31" similarity="100">
<source file="../hum_codes_raw/s474294531.java" startline="1" endline="55" pcid="15918">
import java.util.*;
import java.lang.*;
import java.io.*;

class Main
{

    private static int n;

    private static int rec(int sum,int pre,int cnt)
    {

	if(sum > n)
	    return 0;

	if(sum == n)
	    return 1;

	if(cnt >= 3)
	    {	   
		int dif = n-sum;
		
		    int res = (int)Math.sqrt(dif);
		    if(res >= pre)
			{
			    if(res*res == dif)return 1;
			}
		    return 0;
	    }
	
	
	int counter = 0;
	for(int i=pre;sum+Math.pow(i,2)<=n;i++)
	    {
		counter += rec(sum+i*i,i,cnt+1);
	    }
	return counter;
    }
    
      public static void main(String args[])throws IOException
    {
	BufferedReader in = new BufferedReader(new InputStreamReader(System.in));


	while(true)
	    {
		n = Integer.parseInt(in.readLine());
		if(n == 0)
		    break;
		System.out.println(rec(0,1,0));
	    }
    }
    
}

</source>
<source file="../hum_codes_raw/s896704308.java" startline="1" endline="94" pcid="30177">
import java.util.*;
import java.lang.*;
import java.io.*;

class Main
{

    private static int n;

    private static int rec(int sum,int pre,int cnt)
    {

	if(sum > n)
	    return 0;

	if(sum == n)
	    return 1;

	if(cnt >= 3)
	    {
		//return sum == n?1:0;
		   
		int dif = n-sum;
		
		    int res = (int)Math.sqrt(dif);
		    if(res >= pre){
			if(res*res == dif)return 1;
		    }
		return 0;
		
	    }


	int counter = 0;
	for(int i=pre;sum+Math.pow(i,2)<=n;i++)
	    {
		counter += rec(sum+i*i,i,cnt+1);
	    }
	return counter;
    }

      public static void main(String args[])throws IOException
    {
	BufferedReader in = new BufferedReader(new InputStreamReader(System.in));


	while(true)
	    {

		n = Integer.parseInt(in.readLine());
		if(n == 0)
		    break;
		/*
		int cnt = 0;
		for(int i=1;i*i<=n;i++)
		    {
			if(i*i == n)
			    {
				cnt++;
				break;
			    }
			for(int j=i;j*j+i*i<=n;j++)
			    {
				if(j*j+i*i == n)
				    {
					cnt++;
					continue;
				    }
				for(int k=j;k*k+j*j+i*i<=n;k++)
				    {
					if(k*k+j*j+i*i == n)
					    {
						cnt++;
						continue;
					    }
					int dif = n-(k*k+j*j+i*i);
					int res = (int)Math.sqrt(dif);
					if(res*res == dif)cnt++;

					    
				    }
			    }
		    }
		


		System.out.println(cnt);
*/
		System.out.println(rec(0,1,0));
	    }
    }

}

</source>
</class>

<class classid="231" nclones="2" nlines="145" similarity="100">
<source file="../hum_codes_raw/s477615844.java" startline="1" endline="219" pcid="16044">
import java.io.IOException;
import java.util.NoSuchElementException;

import java.io.InputStream;

import java.io.PrintWriter;

import java.util.Arrays;

@SuppressWarnings("unchecked")
public class Main {
    static int N;
    static long MAX_A;

    static long[] a;
    static long[] s;

    static long[] BIT;

    // v[x] += w
    // 次に更新すべき区間は
    // 番号に区間の長さを足すと求まる
    static void bitAdd(long x) {
        // BIT は普通は負のインデックスに値を格納できない
        // オフセットを付ける
        // 1-indexed n + 1
        // 0-indexed n
        long idx = x + N + 1;

        // Integer.lowestOneBit(idx)
        for (; idx < N * 2 + 2; idx += idx & -idx) BIT[(int) idx]++;
    }

    // v[1] + … + v[x]
    // 次に足すべき区間は
    // 番号から区間の長さを引くと求まる
    static long bitQuery(long x) {
        // BIT は普通は負のインデックスに値を格納できない
        // オフセットを付ける
        // 1-indexed n + 1
        // 0-indexed n
        long idx = x + N + 1;
        long ret = 0;

        // Integer.lowestOneBit(idx)
        for (; 0 < idx; idx -= idx & -idx) ret += BIT[(int) idx];

        return ret;
    }

    static long f(long mid) {
        long ret = 0;
        long prev = 0;

        // 初期化
        Arrays.fill(s, 0);

        for (int i = 0; i < N; i++) {
            if (mid <= a[i]) prev++;
            else prev--;

            s[i] = prev;
        }

        // 初期化
        Arrays.fill(BIT, 0);

        bitAdd(0);

        for (int i = 0; i < N; i++) {
            ret += bitQuery(s[i]);

            // ここで足すのはタイミング遅い気がするが
            // 他の点の始点となるのでこれで良い
            // ここに点があったことを記録する
            bitAdd(s[i]);
        }

        return ret;
    }

    // Bisection Method
    // [left, right]
    // to narrow the range
    static long bisectionMethod() {
        // パターン数
        // 半数以上
        // 割る2 割る2 ceil
        long p = (long)Math.ceil(((double) N * (N + 1) / 2) / 2);

        long l = 0;
        long r = MAX_A + 1;
        long ret = 0;

        while (l <= r) {
            long mid = (l + r) / 2;
            long num = f(mid);

            // 半数以上 判定
            if (p <= num) {
                ret = mid;
                l = mid + 1;
            } else
                r = mid - 1;
        }

        return ret;
    }

    public static void main(String[] args) throws IOException {
        PrintWriter out = new PrintWriter(System.out);

        N = nextInt();

        a = new long[N];
        s = new long[N];
        BIT = new long[N * 2 + 2];

        for (int i = 0; i < N; i++) {
            a[i] = nextInt();
            MAX_A = Math.max(MAX_A, a[i]);
        }

        out.println(bisectionMethod());

        out.flush();
    }

    // FastScanner start
    static final InputStream in = System.in;
    static final byte[] buffer = new byte[1024];
    static int ptr = 0;
    static int buflen = 0;

    static boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        } else {
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }

    static int readByte() {
        if (hasNextByte())
            return buffer[ptr++];
        else
            return -1;
    }

    static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }

    static boolean hasNext() {
        while (hasNextByte() && !isPrintableChar(buffer[ptr]))
            ptr++;
        return hasNextByte();
    }

    static String next() {
        if (!hasNext())
            throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while (isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }

    static long nextLong() {
        if (!hasNext())
            throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                n *= 10;
                n += b - '0';
            } else if (b == -1 || !isPrintableChar(b)) {
                return minus ? -n : n;
            } else {
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }

    static int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)
            throw new NumberFormatException();
        return (int) nl;
    }

    static double nextDouble() {
        return Double.parseDouble(next());
    }
    // FastScanner end
}

</source>
<source file="../hum_codes_raw/s923583382.java" startline="1" endline="219" pcid="31056">
import java.io.IOException;
import java.util.NoSuchElementException;

import java.io.InputStream;

import java.io.PrintWriter;

import java.util.Arrays;

@SuppressWarnings("unchecked")
public class Main {
    static int N;
    static long MAX_A;

    static long[] a;
    static long[] s;

    static long[] BIT;

    // v[x] += w
    // 次に更新すべき区間は
    // 番号に区間の長さを足すと求まる
    static void bitAdd(long x) {
        // BIT は普通は負のインデックスに値を格納できない
        // オフセットを付ける
        // 1-indexed n + 1
        // 0-indexed n
        long idx = x + N + 1;

        // Integer.lowestOneBit(idx)
        for (; idx < N * 2 + 2; idx += idx & -idx) BIT[(int) idx]++;
    }

    // v[1] + … + v[x]
    // 次に足すべき区間は
    // 番号から区間の長さを引くと求まる
    static long bitQuery(long x) {
        // BIT は普通は負のインデックスに値を格納できない
        // オフセットを付ける
        // 1-indexed n + 1
        // 0-indexed n
        long idx = x + N + 1;
        long ret = 0;

        // Integer.lowestOneBit(idx)
        for (; 0 < idx; idx -= idx & -idx) ret += BIT[(int) idx];

        return ret;
    }

    static long f(long mid) {
        long ret = 0;
        long prev = 0;

        // 初期化
        Arrays.fill(s, 0);

        for (int i = 0; i < N; i++) {
            if (mid <= a[i]) prev++;
            else prev--;

            s[i] = prev;
        }

        // 初期化
        Arrays.fill(BIT, 0);

        bitAdd(0);

        for (int i = 0; i < N; i++) {
            ret += bitQuery(s[i]);

            // ここで足すのはタイミング遅い気がするが
            // 他の点の始点となるのでこれで良い
            // ここに点があったことを記録する
            bitAdd(s[i]);
        }

        return ret;
    }

    // Bisection Method
    // [left, right]
    // to narrow the range
    static long bisectionMethod() {
        // パターン数
        // 半数以上
        // 割る2 割る2 ceil
        long p = (long)Math.ceil(((double) N * (N + 1) / 2) / 2);

        long l = 0;
        long r = MAX_A + 1;
        long ret = 0;

        while (l <= r) {
            long mid = (l + r) / 2;
            long num = f(mid);

            // 半数以上 判定
            if (p <= num) {
                ret = mid;
                l = mid + 1;
            } else
                r = mid - 1;
        }

        return ret;
    }

    public static void main(String[] args) throws IOException {
        PrintWriter out = new PrintWriter(System.out);

        N = nextInt();

        a = new long[N];
        s = new long[N];
        BIT = new long[N * 2 + 2];

        for (int i = 0; i < N; i++) {
            a[i] = nextInt();
            MAX_A = Math.max(MAX_A, a[i]);
        }

        out.println(bisectionMethod());

        out.flush();
    }

    // FastScanner start
    static final InputStream in = System.in;
    static final byte[] buffer = new byte[1024];
    static int ptr = 0;
    static int buflen = 0;

    static boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        } else {
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }

    static int readByte() {
        if (hasNextByte())
            return buffer[ptr++];
        else
            return -1;
    }

    static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }

    static boolean hasNext() {
        while (hasNextByte() && !isPrintableChar(buffer[ptr]))
            ptr++;
        return hasNextByte();
    }

    static String next() {
        if (!hasNext())
            throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while (isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }

    static long nextLong() {
        if (!hasNext())
            throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                n *= 10;
                n += b - '0';
            } else if (b == -1 || !isPrintableChar(b)) {
                return minus ? -n : n;
            } else {
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }

    static int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)
            throw new NumberFormatException();
        return (int) nl;
    }

    static double nextDouble() {
        return Double.parseDouble(next());
    }
    // FastScanner end
}

</source>
</class>

<class classid="232" nclones="2" nlines="34" similarity="100">
<source file="../hum_codes_raw/s480713764.java" startline="1" endline="38" pcid="16140">
import java.util.Scanner;

public class Main{
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		double x_p1 = scan.nextDouble();
		double y_p1 = scan.nextDouble();
		double x_p2 = scan.nextDouble();
		double y_p2 = scan.nextDouble();
		double vx = x_p2 - x_p1;
		double vy = y_p2 - y_p1;
		int q = scan.nextInt();
		double l = norm(x_p1, y_p1, x_p2, y_p2);

		for(int i = 0; i < q; i++) {
			double x = scan.nextDouble();
			double y = scan.nextDouble();
			double ux = x - x_p1;
			double uy = y - y_p1;
			double t = dot(ux, uy, vx, vy);
			double k = t / l;
			double ax = k * vx + x_p1;
			double ay = k * vy + y_p1;
			double bx = 2 * ax - x;
			double by = 2 * ay - y;
			System.out.println(bx + " " + by);
		}
		scan.close();

	}
	static double dot(double x1, double y1, double x2, double y2) {
		return x1 * x2 + y1 * y2;
	}
	static double norm(double x1, double y1, double x2, double y2) {
		return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
	}
}

</source>
<source file="../hum_codes_raw/s861914098.java" startline="1" endline="44" pcid="28984">
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        double x_p1 = scan.nextDouble();
        double y_p1 = scan.nextDouble();
        double x_p2 = scan.nextDouble();
        double y_p2 = scan.nextDouble();
        
        double vx = x_p2 - x_p1;
        double vy = y_p2 - y_p1;
        
        int q = scan.nextInt();
        double l = norm(x_p1, y_p1, x_p2, y_p2);
        
        for(int i = 0; i < q; i++) {
            double x = scan.nextDouble();
            double y = scan.nextDouble();
            double ux = x - x_p1;
            double uy = y - y_p1;
            
            double t = dot(ux, uy, vx, vy);
            
            double k = t / l;
            double ax = k * vx + x_p1;
            double ay = k * vy + y_p1;
            
            double bx = 2 * ax - x;
            double by = 2 * ay - y;
            System.out.println(bx + " " + by);
        }
        scan.close();
    }
    
    static double dot(double x1, double y1, double x2, double y2) {
        return x1 * x2 + y1 * y2;
    }
    
    static double norm(double x1, double y1, double x2, double y2) {
        return (x1 - x2) * (x1 - x2) + (y1 -y2) * (y1 - y2);
    }
}

</source>
</class>

<class classid="233" nclones="2" nlines="62" similarity="100">
<source file="../hum_codes_raw/s489483606.java" startline="1" endline="106" pcid="16442">
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {
    public static void main(String args[]) {
        //スタックサイズ2^24で処理を行う
        new Thread(null, () -> {
            int n;
            int k;
            List<Integer> as = new ArrayList<>();

            //try-with-resources文(カッコ内で宣言した変数はtry句を抜けると自動的に閉じられる)
            try (Scanner sc = new Scanner(System.in)) {
                n = sc.nextInt();
                k = sc.nextInt();
                for (int i = 0; i < n; i++) {
                    as.add(sc.nextInt() - 1);
                }
            }
            System.out.println(new Calculator(n, k, as).calculate());
        }, "", 1 << 24).start();
    }
}

/**
 * 計算クラス
 */
class Calculator {
    /**
     * 整数K
     */
    private int k;

    /**
     * 転送先を変えなければならないテレポータの数
     */
    private int answer = 0;

    /**
     * 計算済みかどうか
     */
    private boolean isCalculate = false;

    /**
     * ある町へ転送するテレポータが設置されている町のリスト
     */
    private List<List<Integer>> lists = new ArrayList<>();

    /**
     * コンストラクタ
     *
     * @param n  町の数
     * @param k  整数K
     * @param as 各町のテレポータの転送先リスト
     */
    Calculator(int n, int k, List<Integer> as) {
        this.k = k;
        for (int i = 0; i < n; i++) {
            this.lists.add(new ArrayList<>());
        }
        for (int i = 0; i < n; i++) {
            int j = as.get(i);
            if (0 < i) {
                this.lists.get(j).add(i);
            } else if (0 < j) {
                this.answer++;
            }
        }
    }

    /**
     * 転送先を変えなければならないテレポータの数を求める
     *
     * @return 転送先を変えなければならないテレポータの数
     */
    int calculate() {
        if (!this.isCalculate) {
            this.dfs(0, 0);
            this.isCalculate = true;
        }
        return this.answer;
    }

    /**
     * 転送回数を算出する
     *
     * @param a   着目する町
     * @param pre 1つ前の町
     * @return 転送回数
     */
    private int dfs(int a, int pre) {
        int h = 0;
        for (int i : this.lists.get(a)) {
            h = Math.max(h, this.dfs(i, a));
        }
        if (0 < pre && h == this.k - 1) {
            h = 0;
            this.answer++;
        } else {
            h++;
        }
        return h;
    }
}

</source>
<source file="../hum_codes_raw/s787185351.java" startline="1" endline="110" pcid="26429">
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {
    public static void main(String args[]) {
        //スタックサイズ2^24で処理を行う
        new Thread(null, () -> {
            int n;
            int k;
            List<Integer> as = new ArrayList<>();

            //try-with-resources文(カッコ内で宣言した変数はtry句を抜けると自動的に閉じられる)
            try (Scanner sc = new Scanner(System.in)) {
                n = sc.nextInt();
                k = sc.nextInt();
                for (int i = 0; i < n; i++) {
                    as.add(sc.nextInt() - 1);
                }
            }
            System.out.println(new Calculator(n, k, as).calculate());
        }, "", 1 << 24).start();
    }
}

/**
 * 計算クラス
 */
class Calculator {
    /**
     * 整数K
     */
    private int k;

    /**
     * 転送先を変えなければならないテレポータの数
     */
    private int answer = 0;

    /**
     * 計算済みかどうか
     */
    private boolean isCalculate = false;

    /**
     * ある町へ転送するテレポータが設置されている町のリスト
     */
    private List<List<Integer>> lists = new ArrayList<>();

    /**
     * コンストラクタ
     *
     * @param n  町の数
     * @param k  整数K
     * @param as 各町のテレポータの転送先リスト
     */
    Calculator(int n, int k, List<Integer> as) {
        this.k = k;
        for (int i = 0; i < n; i++) {
            this.lists.add(new ArrayList<>());
        }
        for (int i = 0; i < n; i++) {
            int j = as.get(i);
            if (0 < i) {
                this.lists.get(j).add(i);
            } else if (0 < j) {
                this.answer++;
            }
        }
    }

    /**
     * 転送先を変えなければならないテレポータの数を求める
     *
     * @return 転送先を変えなければならないテレポータの数
     */
    int calculate() {
        if (!this.isCalculate) {
            this.dfs(0, 0);
            this.isCalculate = true;
        }
        return this.answer;
    }

    /**
     * 転送回数を算出する
     *
     * @param a   着目する町
     * @param pre 1つ前の町
     * @return 転送回数
     */
    private int dfs(int a, int pre) {
        int h = 0;

        //拡張for文(リストや配列から要素を1つずつ取り出す)
        for (int i : this.lists.get(a)) {
            h = Math.max(h, this.dfs(i, a));
        }

        if (0 < pre && h == this.k - 1) {
            h = 0;
            this.answer++;
        } else {
            h++;
        }

        return h;
    }
}

</source>
</class>

<class classid="234" nclones="2" nlines="1007" similarity="100">
<source file="../hum_codes_raw/s492478736.java" startline="1" endline="674" pcid="16541">
import java.util.*;
import java.io.*;
public class Main {
	static boolean DEBUG;
	public static void main(String[] args) {
		DEBUG = args.length > 0 && args[0].equals("-DEBUG");
		Solver solver = new Solver();
		solver.solve();
		solver.exit();
	}

	static class FastScanner {
		private final InputStream in = System.in;
		private final byte[] buffer = new byte[1024];
		private int ptr = 0;
		private int buflen = 0;
		private boolean hasNextByte() {
			if (ptr < buflen) {
				return true;
			}else{
				ptr = 0;
				try {
					buflen = in.read(buffer);
				} catch (IOException e) {
					e.printStackTrace();
				}
				if (buflen <= 0) {
					return false;
				}
			}
			return true;
		}
		private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}
		private boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}
		private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}
		public boolean hasNext() { skipUnprintable(); return hasNextByte();}
		public String next() {
			if (!hasNext()) throw new NoSuchElementException();
			StringBuilder sb = new StringBuilder();
			int b = readByte();
			while(isPrintableChar(b)) {
				sb.appendCodePoint(b);
				b = readByte();
			}
			return sb.toString();
		}
		public long nextLong() {
			if (!hasNext()) throw new NoSuchElementException();
			long n = 0;
			boolean minus = false;
			int b = readByte();
			if (b == '-') {
				minus = true;
				b = readByte();
			}
			if (b < '0' || '9' < b) {
				throw new NumberFormatException();
			}
			while(true){
				if ('0' <= b && b <= '9') {
					n *= 10;
					n += b - '0';
				}else if(b == -1 || !isPrintableChar(b)){
					return minus ? -n : n;
				}else{
					throw new NumberFormatException();
				}
				b = readByte();
			}
		}
	}

	static class Solver {
		FastScanner sc = new FastScanner();
		public Solver() { }

		String ns() { return sc.next(); }
		String[] ns(int n) {
			String a[] = new String[n];
			for(int i = 0; i < n; i ++) { a[i] = ns(); }
			return a;
		}
		String[][] ns(int n, int m) {
			String a[][] = new String[n][m];
			for(int i = 0; i < n; i ++) { a[i] = ns(m); }
			return a;
		}
		char[] nc(int n) {
			String str = ns();
			char a[] = new char[str.length()];
			for(int i = 0; i < str.length(); i ++) { a[i] = str.charAt(i); }
			return a;
		}
		char[][] nc(int n, int m) {
			char a[][] = new char[n][m];
			for(int i = 0; i < n; i ++) { a[i] = nc(m); }
			return a;
		}
		boolean[] nb(int n, char t) {
			boolean a[] = new boolean[n];
			char c[] = nc(n);
			for(int i = 0; i < n; i ++) { a[i] = c[i] == t; }
			return a;
		}
		boolean[][] nb(int n, int m, char t) {
			boolean a[][] = new boolean[n][m];
			for(int i = 0; i < n; i ++) { a[i] = nb(m, t); }
			return a;
		}
		int ni() { return (int)sc.nextLong(); }
		int[] ni(int n) {
			int a[] = new int[n];
			for(int i = 0; i < n; i ++) { a[i] = ni(); }
			return a;
		}
		int[][] ni(int n, int m) {
			int a[][] = new int[n][m];
			for(int i = 0; i < n; i ++) { a[i] = ni(m); }
			return a;
		}
		long nl() { return sc.nextLong(); }
		long[] nl(int n) {
			long a[] = new long[n];
			for(int i = 0; i < n; i ++) { a[i] = nl(); }
			return a;
		}
		long[][] nl(int n, int m) {
			long a[][] = new long[n][m];
			for(int i = 0; i < n; i ++) { a[i] = nl(m); }
			return a;
		}

		PrintWriter out = new PrintWriter(System.out);
		PrintWriter err = new PrintWriter(System.err);
		void prt() { out.print(""); }
		<T> void prt(T a) { out.print(a); }
		void prtln() { out.println(""); }
		<T> void prtln(T a) { out.println(a); }
		void prtln(int... a) {
			StringBuilder sb = new StringBuilder();
			for(int element : a){ sb.append(element+" "); }
			prtln(sb.toString().trim());
		}
		void prtln(long... a) {
			StringBuilder sb = new StringBuilder();
			for(long element : a){ sb.append(element+" "); }
			prtln(sb.toString().trim());
		}
		void prtln(double... a) {
			StringBuilder sb = new StringBuilder();
			for(double element : a){ sb.append(element+" "); }
			prtln(sb.toString().trim());
		}
		void prtln(String... a) {
			StringBuilder sb = new StringBuilder();
			for(String element : a){ sb.append(element+" "); }
			prtln(sb.toString().trim());
		}
		void prtln(char... a) {
			StringBuilder sb = new StringBuilder();
			for(char element : a){ sb.append(element); }
			prtln(sb.toString().trim());
		}
		void prtln(int[][] a) { for(int[] element : a){ prtln(element); } }
		void prtln(long[][] a) { for(long[] element : a){ prtln(element); } }
		void prtln(double[][] a) { for(double[] element : a){ prtln(element); } }
		void prtln(String[][] a) { for(String[] element : a){ prtln(element); } }
		void prtln(char[][] a) { for(char[] element : a){ prtln(element); } }
		String errconvert(int a) { return isINF(a) ? "_" : String.valueOf(a); }
		String errconvert(long a) { return isINF(a) ? "_" : String.valueOf(a); }
		void errprt(int a) { if(DEBUG) { err.print(errconvert(a)); } }
		void errprt(long a) { if(DEBUG) { err.print(errconvert(a)); } }
		void errprt() { if(DEBUG) { err.print(""); } }
		<T> void errprt(T a) { if(DEBUG) { err.print(a); } }
		void errprt(boolean a) { if(DEBUG) { errprt(a ? "#" : "."); } }
		void errprtln() { if(DEBUG) { err.println(""); } }
		void errprtln(int a) { if(DEBUG) { err.println(errconvert(a)); } }
		void errprtln(long a) { if(DEBUG) { err.println(errconvert(a)); } }
		<T> void errprtln(T a) { if(DEBUG) { err.println(a); } }
		void errprtln(boolean a) { if(DEBUG) { errprtln(a ? "#" : "."); } }
		void errprtln(int... a) {
			if(DEBUG) {
				StringBuilder sb = new StringBuilder();
				for(int element : a){ sb.append(errconvert(element)+" "); }
				errprtln(sb.toString().trim());
			}
		}
		void errprtln(long... a) {
			if(DEBUG) {
				StringBuilder sb = new StringBuilder();
				for(long element : a){ sb.append(errconvert(element)+" "); }
				errprtln(sb.toString().trim());
			}
		}
		void errprtln(double... a) {
			if(DEBUG) {
				StringBuilder sb = new StringBuilder();
				for(double element : a){ sb.append(element+" "); }
				errprtln(sb.toString().trim());
			}
		}
		void errprtln(String... a) {
			if(DEBUG) {
				StringBuilder sb = new StringBuilder();
				for(String element : a){ sb.append(element+" "); }
				errprtln(sb.toString().trim());
			}
		}
		void errprtln(char... a) {
			if(DEBUG) {
				StringBuilder sb = new StringBuilder();
				for(char element : a){ sb.append(element); }
				errprtln(sb.toString().trim());
			}
		}
		void errprtln(boolean... a) {
			if(DEBUG) {
				StringBuilder sb = new StringBuilder();
				for(boolean element : a){ sb.append((element ? "#" : ".")+" "); }
				errprtln(sb.toString().trim());
			}
		}
		void errprtln(int[][] a) { if(DEBUG) { for(int[] element : a){ errprtln(element); } } }
		void errprtln(long[][] a) { if(DEBUG) { for(long[] element : a){ errprtln(element); } } }
		void errprtln(double[][] a) { if(DEBUG) { for(double[] element : a){ errprtln(element); } } }
		void errprtln(String[][] a) { if(DEBUG) { for(String[] element : a){ errprtln(element); } } }
		void errprtln(char[][] a) { if(DEBUG) { for(char[] element : a){ errprtln(element); } } }
		void errprtln(boolean[][] a) { if(DEBUG) { for(boolean[] element : a){ errprtln(element); } } }

		void reply(boolean b) { prtln(b ? "Yes" : "No"); }
		void REPLY(boolean b) { prtln(b ? "YES" : "NO"); }

		void flush() { out.flush(); if(DEBUG) { err.flush(); } }
		void exit() { flush(); System.exit(0); }

		int min(int a, int b) { return Math.min(a, b); }
		long min(long a, long b) { return Math.min(a, b); }
		double min(double a, double b) { return Math.min(a, b); }
		int min(int... x) {
			int min = x[0];
			for(int val : x) { min = min(min, val); }
			return min;
		}
		long min(long... x) {
			long min = x[0];
			for(long val : x) { min = min(min, val); }
			return min;
		}
		double min(double... x) {
			double min = x[0];
			for(double val : x) { min = min(min, val); }
			return min;
		}
		int max(int a, int b) { return Math.max(a, b); }
		long max(long a, long b) { return Math.max(a, b); }
		double max(double a, double b) { return Math.max(a, b); }
		int max(int... x) {
			int max = x[0];
			for(int val : x) { max = max(max, val); }
			return max;
		}
		long max(long... x) {
			long max = x[0];
			for(long val : x) { max = max(max, val); }
			return max;
		}
		double max(double... x) {
			double max = x[0];
			for(double val : x) { max = max(max, val); }
			return max;
		}
		long sum(int... a) {
			long sum = 0;
			for(int element : a) { sum += element; }
			return sum;
		}
		long sum(long... a) {
			long sum = 0;
			for(long element : a) { sum += element; }
			return sum;
		}
		double sum(double... a) {
			double sum = 0;
			for(double element : a) { sum += element; }
			return sum;
		}
		long[] sums(int[] a) {
			long sum[] = new long[a.length + 1];
			sum[0] = 0;
			for(int i = 0; i < a.length; i ++) { sum[i + 1] = sum[i] + a[i]; }
			return sum;
		}
		long[] sums(long[] a) {
			long sum[] = new long[a.length + 1];
			sum[0] = 0;
			for(int i = 0; i < a.length; i ++) { sum[i + 1] = sum[i] + a[i]; }
			return sum;
		}
		double[] sums(double[] a) {
			double sum[] = new double[a.length + 1];
			sum[0] = 0;
			for(int i = 0; i < a.length; i ++) { sum[i + 1] = sum[i] + a[i]; }
			return sum;
		}

		long abs(double x) { return (long)Math.abs(x); }
		long round(double x) { return Math.round(x); }
		long floor(double x) { return (long)Math.floor(x); }
		long ceil(double x) { return (long)Math.ceil(x); }
		double sqrt(double x) { return Math.sqrt(x); }
		double pow(double x, double y) { return Math.pow(x, y); }
		long pow(long x, long y) { return (long)Math.pow(x, y); }
		int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }
		long gcd(long a, long b) { return b == 0 ? a : gcd(b, a % b); }
		long lcm(long a, long b) { return a * b / gcd(a, b); }

		int upperToInt(char a) { return a - 'A'; }
		int lowerToInt(char a) { return a - 'a'; }
		int numToInt(char a) { return a - '0'; }
		int charToInt(char a) { return a >= 'a' ? lowerToInt(a) : a >= 'A' ? upperToInt(a) : numToInt(a); }
		char intToUpper(int a) { return (char)(a + 'A'); }
		char intToLower(int a) { return (char)(a + 'a'); }
		char intToNum(int a) { return (char)(a + '0'); }

		long[] div(long a) {
			List<Long> divList = new ArrayList<Long>();
			for(long i = 1; i * i <= a; i ++) {
				if(a % i == 0) {
					divList.add(i);
					if(i * i != a) { divList.add(a / i); };
				}
			}

			long div[] = new long[divList.size()];
			for(int i = 0; i < divList.size(); i ++) { div[i] = divList.get(i); }
			return div;
		}

		long[][] factor(long a) {
			List<Long> factorList = new ArrayList<Long>();
			List<Long> degreeList = new ArrayList<Long>();
			for(long i = 2; i * i <= a; i ++) {
				if(a % i == 0) {
					long count = 0;
					while(a % i == 0) {
						a /= i;
						count ++;
					}
					factorList.add(i);
					degreeList.add(count);
				}
			}
			if(a > 1) {
				factorList.add(a);
				degreeList.add(1L);
			}
			long factor[][] = new long[factorList.size()][2];
			for(int i = 0; i < factorList.size(); i ++) {
				factor[i][0] = factorList.get(i);
				factor[i][1] = degreeList.get(i);
			}
			return factor;
		}

		long[][] countElements(long[] a, boolean sort) {
			int len = a.length;
			long array[] = new long[len];
			for(int i = 0; i < len; i ++) {
				array[i] = a[i];
			}
			if(sort) { Arrays.sort(array); }
			List<Long> elem = new ArrayList<Long>();
			List<Long> cnt = new ArrayList<Long>();
			long tmp = 1;
			for(int i = 1; i <= len; i ++) {
				if(i == len || array[i] != array[i - 1]) {
					elem.add(array[i - 1]);
					cnt.add(tmp);
					tmp = 1;
				}else {
					tmp ++;
				}
			}
			long counts[][] = new long[elem.size()][2];
			for(int i = 0; i < elem.size(); i ++) {
				counts[i][0] = elem.get(i);
				counts[i][1] = cnt.get(i);
			}
			return counts;
		}
		long[][] countElements(String str, boolean sort) {
			int len = str.length();
			char array[] = str.toCharArray();
			if(sort) { Arrays.sort(array); }
			List<Long> elem = new ArrayList<Long>();
			List<Long> cnt = new ArrayList<Long>();
			long tmp = 1;
			for(int i = 1; i <= len; i ++) {
				if(i == len || array[i] != array[i - 1]) {
					elem.add((long)array[i - 1]);
					cnt.add(tmp);
					tmp = 1;
				}else {
					tmp ++;
				}
			}
			long counts[][] = new long[elem.size()][2];
			for(int i = 0; i < elem.size(); i ++) {
				counts[i][0] = elem.get(i);
				counts[i][1] = cnt.get(i);
			}
			return counts;
		}

		int numDigits(long a) { return Long.toString(a).length(); }
		long bitFlag(int a) { return 1L << (long)a; }
		boolean isFlagged(long x, int a) { return (x & bitFlag(a)) != 0; }

		long countString(String str, String a) { return (str.length() - str.replace(a, "").length()) / a.length(); }
		long countStringAll(String str, String a) { return str.length() - str.replaceAll(a, "").length(); }

		void reverse(String array[]) {
			String reversed[] = new String[array.length];
			for(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }
			for(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }
		}
		void reverse(int array[]) {
			int reversed[] = new int[array.length];
			for(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }
			for(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }
		}
		void reverse(long array[]) {
			long reversed[] = new long[array.length];
			for(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }
			for(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }
		}
		void reverse(double array[]) {
			double reversed[] = new double[array.length];
			for(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }
			for(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }
		}
		void reverse(boolean array[]) {
			boolean reversed[] = new boolean[array.length];
			for(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }
			for(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }
		}
		void fill(int array[], int x) { Arrays.fill(array, x); }
		void fill(long array[], long x) { Arrays.fill(array, x); }
		void fill(double array[], double x) { Arrays.fill(array, x); }
		void fill(boolean array[], boolean x) { Arrays.fill(array, x); }
		void fill(int array[][], int x) { for(int a[] : array) { fill(a, x); } }
		void fill(long array[][], long x) { for(long a[] : array) { fill(a, x); } }
		void fill(double array[][], double x) { for(double a[] : array) { fill(a, x); } }
		void fill(boolean array[][], boolean x) { for(boolean a[] : array) { fill(a, x); } }
		void fill(int array[][][], int x) { for(int a[][] : array) { fill(a, x); } }
		void fill(long array[][][], long x) { for(long a[][] : array) { fill(a, x); } }
		void fill(double array[][][], double x) { for(double a[][] : array) { fill(a, x); } }
		void fill(boolean array[][][], boolean x) { for(boolean a[][] : array) { fill(a, x); } }

		long INF = (long)1e18 + 7;
		boolean isINF(long a) { return abs(a) > INF / 1000; }
		boolean isPlusINF(long a) { return a > 0 && isINF(a); }
		boolean isMinusINF(long a) { return isPlusINF(- a); }
		int I_INF = (int)1e9 + 7;
		boolean isINF(int a) { return abs(a) > I_INF / 1000; }
		boolean isPlusINF(int a) { return a > 0 && isINF(a); }
		boolean isMinusINF(int a) { return isPlusINF(- a); }


		// mods
		long MOD = (long)1e9 + 7; // 998244353;
		public long mod(long i) { return i % MOD + ((i % MOD) < 0 ? MOD : 0); }

		long pow_m(long x, long y) {
			if (y == 0) { return 1;
			}else {
				long tmp = pow_m(x, y / 2);
				return mod(mod(tmp * tmp) * (y % 2 == 0 ? 1 : x));
			}
		}
		long[] pows_m(long x, int max) {
			long pow[] = new long[max + 1];
			pow[0] = 1;
			for(int i = 0; i < max; i ++) {
				pow[i + 1] = mod(pow[i] * x);
			}
			return pow;
		}

		long inv(long x) { return pow_m(x, MOD - 2); }

		int MAX_FACT = 5_000_100;
		long fact[];
		long invFact[];
		void prepareFact() {
			fact = new long[MAX_FACT];
			Arrays.fill(fact, 0);
			invFact = new long[MAX_FACT];
			Arrays.fill(invFact, 0);
			fact[0] = 1;
			int maxIndex = min(MAX_FACT, (int)MOD);
			for(int i = 1; i < maxIndex; i ++) { fact[i] = mod(fact[i - 1] * i); }
			invFact[maxIndex - 1] = inv(fact[maxIndex - 1]);
			for(int i = maxIndex - 1; i > 0; i --) { invFact[i - 1] = mod(invFact[i] * i); }
		}

		long P(int n, int r) {
			if(n < 0 || r < 0 || n < r) { return 0; }
			return mod(fact[n] * invFact[n - r]);
		}
		long C(int n, int r) {
			if(n < 0 || r < 0 || n < r) { return 0; }
			return mod(P(n, r) * invFact[r]);
		}
		long H(int n, int r) { return C((n - 1) + r, r); }


		// grid
		class Grid implements Comparable<Grid> {
			int h;
			int w;
			long val;

			Grid() {  }
			Grid(int h, int w) {
				this.h = h;
				this.w = w;
			}
			Grid(int h, int w, long val) {
				this.h = h;
				this.w = w;
				this.val = val;
			}

			@Override
			public int compareTo(Grid g) {
				return Long.compare(this.val, g.val);
			}
		}


		// graph
		class Graph {
			int numNode;
			int numEdge;
			boolean directed;
			Edge edges[];
			Node nodes[];
			Node reversedNodes[];

			Graph(int numNode, int numEdge, Edge edges[], boolean directed) {
				this.numNode = numNode;
				this.numEdge = numEdge;
				this.directed = directed;
				this.edges = edges;
				nodes = new Node[numNode];
				reversedNodes = new Node[numNode];
				for(int i = 0; i < numNode; i ++) {
					nodes[i] = new Node(i);
					reversedNodes[i] = new Node(i);
				}

				for(Edge edge : edges) {
					nodes[edge.source].add(edge.target, edge.cost);
					if(directed) {
						reversedNodes[edge.target].add(edge.source, edge.cost);
					}else {
						nodes[edge.target].add(edge.source, edge.cost);
					}
				}
			}

			void clearNodes() {
				for(Node n : nodes) { n.clear(); }
				for(Node n : reversedNodes) { n.clear(); }
			}
		}

		class Node {
			int id;
			ArrayList<Edge> edges = new ArrayList<Edge>();

			Node(int id) {
				this.id = id;
			}
			void add(int target, long cost) {
				edges.add(new Edge(id, target, cost));
			}
			void clear() {
				edges.clear();
			}
		}

		class Edge implements Comparable<Edge> {
			int source;
			int target;
			long cost;
			Edge(int source, int target, long cost) {
				this.source = source;
				this.target = target;
				this.cost = cost;
			}

			@Override
			public int compareTo(Edge e) {
				return Long.compare(this.cost, e.cost);
			}
		}

public void solve() {
	int num = ni();
	int p[][] = ni(num, 2);
	double min = INF;

	for(int i = 0; i < num; i ++) {
		for(int j = 0; j < num; j ++) {
if(i == j) { continue; }
double px = (p[j][0] + p[i][0]) * 0.5;
double py = (p[j][1] + p[i][1]) * 0.5;
double r = 0;
for(int l = 0; l < num; l ++) {
	double tmp = pow(p[l][0] - px, 2) + pow(p[l][1] - py, 2);
	tmp = sqrt(tmp);
	r = max(r, tmp);
}
min = min(min, r);
		}
	}
	for(int i = 0; i < num; i ++) {
		for(int j = 0; j < num; j ++) {
			for(int k = 0; k < num; k ++) {
				if(i == j || j == k || k == i) { continue; }
double a = p[i][0];
double b = p[i][1];
double c = p[j][0];
double d = p[j][1];
double e = p[k][0];
double f = p[k][1];
double aa = p[i][0] * p[i][0];
double bb = p[i][1] * p[i][1];
double cc = p[j][0] * p[j][0];
double dd = p[j][1] * p[j][1];
double ee = p[k][0] * p[k][0];
double ff = p[k][1] * p[k][1];

if(a == c && c == e) { continue; }
if(b == d && d == f) { continue; }
if((d - a) * (e - a) == (c - a) * (f - b)) { continue; }

double py = ((e - a) * (aa + bb - cc - dd) - (c - a) * (aa + bb - ee- ff)) / (2 * (e - a)*(b - d) - 2 * (c - a) * (b - f));

double px = 0;
if (c == a){ px = (2 * (b - f) * py - aa - bb + ee + ff) / (2 * (e - a));
}else {px = (2 * (b - d) * py - aa - bb + cc + dd) / (2 * (c - a));}
if(Double.isNaN(px) || Double.isNaN(py)) { continue; }

double r = 0;
for(int l = 0; l < num; l ++) {
	double tmp = pow(p[l][0] - px, 2) + pow(p[l][1] - py, 2);
	tmp = sqrt(tmp);
	r = max(r, tmp);
}
min = min(min, r);
			}
		}
	}
	prtln(min);
}



	}
}

</source>
<source file="../hum_codes_raw/s893599862.java" startline="1" endline="674" pcid="30055">
import java.util.*;
import java.io.*;
public class Main {
	static boolean DEBUG;
	public static void main(String[] args) {
		DEBUG = args.length > 0 && args[0].equals("-DEBUG");
		Solver solver = new Solver();
		solver.solve();
		solver.exit();
	}

	static class FastScanner {
		private final InputStream in = System.in;
		private final byte[] buffer = new byte[1024];
		private int ptr = 0;
		private int buflen = 0;
		private boolean hasNextByte() {
			if (ptr < buflen) {
				return true;
			}else{
				ptr = 0;
				try {
					buflen = in.read(buffer);
				} catch (IOException e) {
					e.printStackTrace();
				}
				if (buflen <= 0) {
					return false;
				}
			}
			return true;
		}
		private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}
		private boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}
		private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}
		public boolean hasNext() { skipUnprintable(); return hasNextByte();}
		public String next() {
			if (!hasNext()) throw new NoSuchElementException();
			StringBuilder sb = new StringBuilder();
			int b = readByte();
			while(isPrintableChar(b)) {
				sb.appendCodePoint(b);
				b = readByte();
			}
			return sb.toString();
		}
		public long nextLong() {
			if (!hasNext()) throw new NoSuchElementException();
			long n = 0;
			boolean minus = false;
			int b = readByte();
			if (b == '-') {
				minus = true;
				b = readByte();
			}
			if (b < '0' || '9' < b) {
				throw new NumberFormatException();
			}
			while(true){
				if ('0' <= b && b <= '9') {
					n *= 10;
					n += b - '0';
				}else if(b == -1 || !isPrintableChar(b)){
					return minus ? -n : n;
				}else{
					throw new NumberFormatException();
				}
				b = readByte();
			}
		}
	}

	static class Solver {
		FastScanner sc = new FastScanner();
		public Solver() { }

		String ns() { return sc.next(); }
		String[] ns(int n) {
			String a[] = new String[n];
			for(int i = 0; i < n; i ++) { a[i] = ns(); }
			return a;
		}
		String[][] ns(int n, int m) {
			String a[][] = new String[n][m];
			for(int i = 0; i < n; i ++) { a[i] = ns(m); }
			return a;
		}
		char[] nc(int n) {
			String str = ns();
			char a[] = new char[str.length()];
			for(int i = 0; i < str.length(); i ++) { a[i] = str.charAt(i); }
			return a;
		}
		char[][] nc(int n, int m) {
			char a[][] = new char[n][m];
			for(int i = 0; i < n; i ++) { a[i] = nc(m); }
			return a;
		}
		boolean[] nb(int n, char t) {
			boolean a[] = new boolean[n];
			char c[] = nc(n);
			for(int i = 0; i < n; i ++) { a[i] = c[i] == t; }
			return a;
		}
		boolean[][] nb(int n, int m, char t) {
			boolean a[][] = new boolean[n][m];
			for(int i = 0; i < n; i ++) { a[i] = nb(m, t); }
			return a;
		}
		int ni() { return (int)sc.nextLong(); }
		int[] ni(int n) {
			int a[] = new int[n];
			for(int i = 0; i < n; i ++) { a[i] = ni(); }
			return a;
		}
		int[][] ni(int n, int m) {
			int a[][] = new int[n][m];
			for(int i = 0; i < n; i ++) { a[i] = ni(m); }
			return a;
		}
		long nl() { return sc.nextLong(); }
		long[] nl(int n) {
			long a[] = new long[n];
			for(int i = 0; i < n; i ++) { a[i] = nl(); }
			return a;
		}
		long[][] nl(int n, int m) {
			long a[][] = new long[n][m];
			for(int i = 0; i < n; i ++) { a[i] = nl(m); }
			return a;
		}

		PrintWriter out = new PrintWriter(System.out);
		PrintWriter err = new PrintWriter(System.err);
		void prt() { out.print(""); }
		<T> void prt(T a) { out.print(a); }
		void prtln() { out.println(""); }
		<T> void prtln(T a) { out.println(a); }
		void prtln(int... a) {
			StringBuilder sb = new StringBuilder();
			for(int element : a){ sb.append(element+" "); }
			prtln(sb.toString().trim());
		}
		void prtln(long... a) {
			StringBuilder sb = new StringBuilder();
			for(long element : a){ sb.append(element+" "); }
			prtln(sb.toString().trim());
		}
		void prtln(double... a) {
			StringBuilder sb = new StringBuilder();
			for(double element : a){ sb.append(element+" "); }
			prtln(sb.toString().trim());
		}
		void prtln(String... a) {
			StringBuilder sb = new StringBuilder();
			for(String element : a){ sb.append(element+" "); }
			prtln(sb.toString().trim());
		}
		void prtln(char... a) {
			StringBuilder sb = new StringBuilder();
			for(char element : a){ sb.append(element); }
			prtln(sb.toString().trim());
		}
		void prtln(int[][] a) { for(int[] element : a){ prtln(element); } }
		void prtln(long[][] a) { for(long[] element : a){ prtln(element); } }
		void prtln(double[][] a) { for(double[] element : a){ prtln(element); } }
		void prtln(String[][] a) { for(String[] element : a){ prtln(element); } }
		void prtln(char[][] a) { for(char[] element : a){ prtln(element); } }
		String errconvert(int a) { return isINF(a) ? "_" : String.valueOf(a); }
		String errconvert(long a) { return isINF(a) ? "_" : String.valueOf(a); }
		void errprt(int a) { if(DEBUG) { err.print(errconvert(a)); } }
		void errprt(long a) { if(DEBUG) { err.print(errconvert(a)); } }
		void errprt() { if(DEBUG) { err.print(""); } }
		<T> void errprt(T a) { if(DEBUG) { err.print(a); } }
		void errprt(boolean a) { if(DEBUG) { errprt(a ? "#" : "."); } }
		void errprtln() { if(DEBUG) { err.println(""); } }
		void errprtln(int a) { if(DEBUG) { err.println(errconvert(a)); } }
		void errprtln(long a) { if(DEBUG) { err.println(errconvert(a)); } }
		<T> void errprtln(T a) { if(DEBUG) { err.println(a); } }
		void errprtln(boolean a) { if(DEBUG) { errprtln(a ? "#" : "."); } }
		void errprtln(int... a) {
			if(DEBUG) {
				StringBuilder sb = new StringBuilder();
				for(int element : a){ sb.append(errconvert(element)+" "); }
				errprtln(sb.toString().trim());
			}
		}
		void errprtln(long... a) {
			if(DEBUG) {
				StringBuilder sb = new StringBuilder();
				for(long element : a){ sb.append(errconvert(element)+" "); }
				errprtln(sb.toString().trim());
			}
		}
		void errprtln(double... a) {
			if(DEBUG) {
				StringBuilder sb = new StringBuilder();
				for(double element : a){ sb.append(element+" "); }
				errprtln(sb.toString().trim());
			}
		}
		void errprtln(String... a) {
			if(DEBUG) {
				StringBuilder sb = new StringBuilder();
				for(String element : a){ sb.append(element+" "); }
				errprtln(sb.toString().trim());
			}
		}
		void errprtln(char... a) {
			if(DEBUG) {
				StringBuilder sb = new StringBuilder();
				for(char element : a){ sb.append(element); }
				errprtln(sb.toString().trim());
			}
		}
		void errprtln(boolean... a) {
			if(DEBUG) {
				StringBuilder sb = new StringBuilder();
				for(boolean element : a){ sb.append((element ? "#" : ".")+" "); }
				errprtln(sb.toString().trim());
			}
		}
		void errprtln(int[][] a) { if(DEBUG) { for(int[] element : a){ errprtln(element); } } }
		void errprtln(long[][] a) { if(DEBUG) { for(long[] element : a){ errprtln(element); } } }
		void errprtln(double[][] a) { if(DEBUG) { for(double[] element : a){ errprtln(element); } } }
		void errprtln(String[][] a) { if(DEBUG) { for(String[] element : a){ errprtln(element); } } }
		void errprtln(char[][] a) { if(DEBUG) { for(char[] element : a){ errprtln(element); } } }
		void errprtln(boolean[][] a) { if(DEBUG) { for(boolean[] element : a){ errprtln(element); } } }

		void reply(boolean b) { prtln(b ? "Yes" : "No"); }
		void REPLY(boolean b) { prtln(b ? "YES" : "NO"); }

		void flush() { out.flush(); if(DEBUG) { err.flush(); } }
		void exit() { flush(); System.exit(0); }

		int min(int a, int b) { return Math.min(a, b); }
		long min(long a, long b) { return Math.min(a, b); }
		double min(double a, double b) { return Math.min(a, b); }
		int min(int... x) {
			int min = x[0];
			for(int val : x) { min = min(min, val); }
			return min;
		}
		long min(long... x) {
			long min = x[0];
			for(long val : x) { min = min(min, val); }
			return min;
		}
		double min(double... x) {
			double min = x[0];
			for(double val : x) { min = min(min, val); }
			return min;
		}
		int max(int a, int b) { return Math.max(a, b); }
		long max(long a, long b) { return Math.max(a, b); }
		double max(double a, double b) { return Math.max(a, b); }
		int max(int... x) {
			int max = x[0];
			for(int val : x) { max = max(max, val); }
			return max;
		}
		long max(long... x) {
			long max = x[0];
			for(long val : x) { max = max(max, val); }
			return max;
		}
		double max(double... x) {
			double max = x[0];
			for(double val : x) { max = max(max, val); }
			return max;
		}
		long sum(int... a) {
			long sum = 0;
			for(int element : a) { sum += element; }
			return sum;
		}
		long sum(long... a) {
			long sum = 0;
			for(long element : a) { sum += element; }
			return sum;
		}
		double sum(double... a) {
			double sum = 0;
			for(double element : a) { sum += element; }
			return sum;
		}
		long[] sums(int[] a) {
			long sum[] = new long[a.length + 1];
			sum[0] = 0;
			for(int i = 0; i < a.length; i ++) { sum[i + 1] = sum[i] + a[i]; }
			return sum;
		}
		long[] sums(long[] a) {
			long sum[] = new long[a.length + 1];
			sum[0] = 0;
			for(int i = 0; i < a.length; i ++) { sum[i + 1] = sum[i] + a[i]; }
			return sum;
		}
		double[] sums(double[] a) {
			double sum[] = new double[a.length + 1];
			sum[0] = 0;
			for(int i = 0; i < a.length; i ++) { sum[i + 1] = sum[i] + a[i]; }
			return sum;
		}

		long abs(double x) { return (long)Math.abs(x); }
		long round(double x) { return Math.round(x); }
		long floor(double x) { return (long)Math.floor(x); }
		long ceil(double x) { return (long)Math.ceil(x); }
		double sqrt(double x) { return Math.sqrt(x); }
		double pow(double x, double y) { return Math.pow(x, y); }
		long pow(long x, long y) { return (long)Math.pow(x, y); }
		int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }
		long gcd(long a, long b) { return b == 0 ? a : gcd(b, a % b); }
		long lcm(long a, long b) { return a * b / gcd(a, b); }

		int upperToInt(char a) { return a - 'A'; }
		int lowerToInt(char a) { return a - 'a'; }
		int numToInt(char a) { return a - '0'; }
		int charToInt(char a) { return a >= 'a' ? lowerToInt(a) : a >= 'A' ? upperToInt(a) : numToInt(a); }
		char intToUpper(int a) { return (char)(a + 'A'); }
		char intToLower(int a) { return (char)(a + 'a'); }
		char intToNum(int a) { return (char)(a + '0'); }

		long[] div(long a) {
			List<Long> divList = new ArrayList<Long>();
			for(long i = 1; i * i <= a; i ++) {
				if(a % i == 0) {
					divList.add(i);
					if(i * i != a) { divList.add(a / i); };
				}
			}

			long div[] = new long[divList.size()];
			for(int i = 0; i < divList.size(); i ++) { div[i] = divList.get(i); }
			return div;
		}

		long[][] factor(long a) {
			List<Long> factorList = new ArrayList<Long>();
			List<Long> degreeList = new ArrayList<Long>();
			for(long i = 2; i * i <= a; i ++) {
				if(a % i == 0) {
					long count = 0;
					while(a % i == 0) {
						a /= i;
						count ++;
					}
					factorList.add(i);
					degreeList.add(count);
				}
			}
			if(a > 1) {
				factorList.add(a);
				degreeList.add(1L);
			}
			long factor[][] = new long[factorList.size()][2];
			for(int i = 0; i < factorList.size(); i ++) {
				factor[i][0] = factorList.get(i);
				factor[i][1] = degreeList.get(i);
			}
			return factor;
		}

		long[][] countElements(long[] a, boolean sort) {
			int len = a.length;
			long array[] = new long[len];
			for(int i = 0; i < len; i ++) {
				array[i] = a[i];
			}
			if(sort) { Arrays.sort(array); }
			List<Long> elem = new ArrayList<Long>();
			List<Long> cnt = new ArrayList<Long>();
			long tmp = 1;
			for(int i = 1; i <= len; i ++) {
				if(i == len || array[i] != array[i - 1]) {
					elem.add(array[i - 1]);
					cnt.add(tmp);
					tmp = 1;
				}else {
					tmp ++;
				}
			}
			long counts[][] = new long[elem.size()][2];
			for(int i = 0; i < elem.size(); i ++) {
				counts[i][0] = elem.get(i);
				counts[i][1] = cnt.get(i);
			}
			return counts;
		}
		long[][] countElements(String str, boolean sort) {
			int len = str.length();
			char array[] = str.toCharArray();
			if(sort) { Arrays.sort(array); }
			List<Long> elem = new ArrayList<Long>();
			List<Long> cnt = new ArrayList<Long>();
			long tmp = 1;
			for(int i = 1; i <= len; i ++) {
				if(i == len || array[i] != array[i - 1]) {
					elem.add((long)array[i - 1]);
					cnt.add(tmp);
					tmp = 1;
				}else {
					tmp ++;
				}
			}
			long counts[][] = new long[elem.size()][2];
			for(int i = 0; i < elem.size(); i ++) {
				counts[i][0] = elem.get(i);
				counts[i][1] = cnt.get(i);
			}
			return counts;
		}

		int numDigits(long a) { return Long.toString(a).length(); }
		long bitFlag(int a) { return 1L << (long)a; }
		boolean isFlagged(long x, int a) { return (x & bitFlag(a)) != 0; }

		long countString(String str, String a) { return (str.length() - str.replace(a, "").length()) / a.length(); }
		long countStringAll(String str, String a) { return str.length() - str.replaceAll(a, "").length(); }

		void reverse(String array[]) {
			String reversed[] = new String[array.length];
			for(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }
			for(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }
		}
		void reverse(int array[]) {
			int reversed[] = new int[array.length];
			for(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }
			for(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }
		}
		void reverse(long array[]) {
			long reversed[] = new long[array.length];
			for(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }
			for(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }
		}
		void reverse(double array[]) {
			double reversed[] = new double[array.length];
			for(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }
			for(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }
		}
		void reverse(boolean array[]) {
			boolean reversed[] = new boolean[array.length];
			for(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }
			for(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }
		}
		void fill(int array[], int x) { Arrays.fill(array, x); }
		void fill(long array[], long x) { Arrays.fill(array, x); }
		void fill(double array[], double x) { Arrays.fill(array, x); }
		void fill(boolean array[], boolean x) { Arrays.fill(array, x); }
		void fill(int array[][], int x) { for(int a[] : array) { fill(a, x); } }
		void fill(long array[][], long x) { for(long a[] : array) { fill(a, x); } }
		void fill(double array[][], double x) { for(double a[] : array) { fill(a, x); } }
		void fill(boolean array[][], boolean x) { for(boolean a[] : array) { fill(a, x); } }
		void fill(int array[][][], int x) { for(int a[][] : array) { fill(a, x); } }
		void fill(long array[][][], long x) { for(long a[][] : array) { fill(a, x); } }
		void fill(double array[][][], double x) { for(double a[][] : array) { fill(a, x); } }
		void fill(boolean array[][][], boolean x) { for(boolean a[][] : array) { fill(a, x); } }

		long INF = (long)1e18 + 7;
		boolean isINF(long a) { return abs(a) > INF / 1000; }
		boolean isPlusINF(long a) { return a > 0 && isINF(a); }
		boolean isMinusINF(long a) { return isPlusINF(- a); }
		int I_INF = (int)1e9 + 7;
		boolean isINF(int a) { return abs(a) > I_INF / 1000; }
		boolean isPlusINF(int a) { return a > 0 && isINF(a); }
		boolean isMinusINF(int a) { return isPlusINF(- a); }


		// mods
		long MOD = (long)1e9 + 7; // 998244353;
		public long mod(long i) { return i % MOD + ((i % MOD) < 0 ? MOD : 0); }

		long pow_m(long x, long y) {
			if (y == 0) { return 1;
			}else {
				long tmp = pow_m(x, y / 2);
				return mod(mod(tmp * tmp) * (y % 2 == 0 ? 1 : x));
			}
		}
		long[] pows_m(long x, int max) {
			long pow[] = new long[max + 1];
			pow[0] = 1;
			for(int i = 0; i < max; i ++) {
				pow[i + 1] = mod(pow[i] * x);
			}
			return pow;
		}

		long inv(long x) { return pow_m(x, MOD - 2); }

		int MAX_FACT = 5_000_100;
		long fact[];
		long invFact[];
		void prepareFact() {
			fact = new long[MAX_FACT];
			Arrays.fill(fact, 0);
			invFact = new long[MAX_FACT];
			Arrays.fill(invFact, 0);
			fact[0] = 1;
			int maxIndex = min(MAX_FACT, (int)MOD);
			for(int i = 1; i < maxIndex; i ++) { fact[i] = mod(fact[i - 1] * i); }
			invFact[maxIndex - 1] = inv(fact[maxIndex - 1]);
			for(int i = maxIndex - 1; i > 0; i --) { invFact[i - 1] = mod(invFact[i] * i); }
		}

		long P(int n, int r) {
			if(n < 0 || r < 0 || n < r) { return 0; }
			return mod(fact[n] * invFact[n - r]);
		}
		long C(int n, int r) {
			if(n < 0 || r < 0 || n < r) { return 0; }
			return mod(P(n, r) * invFact[r]);
		}
		long H(int n, int r) { return C((n - 1) + r, r); }


		// grid
		class Grid implements Comparable<Grid> {
			int h;
			int w;
			long val;

			Grid() {  }
			Grid(int h, int w) {
				this.h = h;
				this.w = w;
			}
			Grid(int h, int w, long val) {
				this.h = h;
				this.w = w;
				this.val = val;
			}

			@Override
			public int compareTo(Grid g) {
				return Long.compare(this.val, g.val);
			}
		}


		// graph
		class Graph {
			int numNode;
			int numEdge;
			boolean directed;
			Edge edges[];
			Node nodes[];
			Node reversedNodes[];

			Graph(int numNode, int numEdge, Edge edges[], boolean directed) {
				this.numNode = numNode;
				this.numEdge = numEdge;
				this.directed = directed;
				this.edges = edges;
				nodes = new Node[numNode];
				reversedNodes = new Node[numNode];
				for(int i = 0; i < numNode; i ++) {
					nodes[i] = new Node(i);
					reversedNodes[i] = new Node(i);
				}

				for(Edge edge : edges) {
					nodes[edge.source].add(edge.target, edge.cost);
					if(directed) {
						reversedNodes[edge.target].add(edge.source, edge.cost);
					}else {
						nodes[edge.target].add(edge.source, edge.cost);
					}
				}
			}

			void clearNodes() {
				for(Node n : nodes) { n.clear(); }
				for(Node n : reversedNodes) { n.clear(); }
			}
		}

		class Node {
			int id;
			ArrayList<Edge> edges = new ArrayList<Edge>();

			Node(int id) {
				this.id = id;
			}
			void add(int target, long cost) {
				edges.add(new Edge(id, target, cost));
			}
			void clear() {
				edges.clear();
			}
		}

		class Edge implements Comparable<Edge> {
			int source;
			int target;
			long cost;
			Edge(int source, int target, long cost) {
				this.source = source;
				this.target = target;
				this.cost = cost;
			}

			@Override
			public int compareTo(Edge e) {
				return Long.compare(this.cost, e.cost);
			}
		}

public void solve() {
	int num = ni();
	int p[][] = ni(num, 2);
	double min = INF;

	for(int i = 0; i < num; i ++) {
		for(int j = 0; j < num; j ++) {
if(i == j) { continue; }
double px = (p[j][0] + p[i][0]) * 0.5;
double py = (p[j][1] + p[i][1]) * 0.5;
double r = 0;
for(int l = 0; l < num; l ++) {
	double tmp = pow(p[l][0] - px, 2) + pow(p[l][1] - py, 2);
	tmp = sqrt(tmp);
	r = max(r, tmp);
}
min = min(min, r);
		}
	}
	for(int i = 0; i < num; i ++) {
		for(int j = 0; j < num; j ++) {
			for(int k = 0; k < num; k ++) {
				if(i == j || j == k || k == i) { continue; }
double a = p[i][0];
double b = p[i][1];
double c = p[j][0];
double d = p[j][1];
double e = p[k][0];
double f = p[k][1];
double aa = p[i][0] * p[i][0];
double bb = p[i][1] * p[i][1];
double cc = p[j][0] * p[j][0];
double dd = p[j][1] * p[j][1];
double ee = p[k][0] * p[k][0];
double ff = p[k][1] * p[k][1];

if(a == c && c == e) { continue; }
if(b == d && d == f) { continue; }
if((d - a) * (e - a) == (c - a) * (f - b)) { continue; }

double py = ((e - a) * (aa + bb - cc - dd) - (c - a) * (aa + bb - ee- ff)) / (2 * (e - a)*(b - d) - 2 * (c - a) * (b - f));

double px = 0;
if (c == a){ px = (2 * (b - f) * py - aa - bb + ee + ff) / (2 * (e - a));
}else {px = (2 * (b - d) * py - aa - bb + cc + dd) / (2 * (c - a));}
if(Double.isNaN(px) || Double.isNaN(py)) { continue; }

double r = 0;
for(int l = 0; l < num; l ++) {
	double tmp = pow(p[l][0] - px, 2) + pow(p[l][1] - py, 2);
	tmp = sqrt(tmp);
	r = max(r, tmp);
}
min = min(min, r);
			}
		}
	}
	prtln(min);
}



	}
}

</source>
</class>

<class classid="235" nclones="2" nlines="20" similarity="100">
<source file="../hum_codes_raw/s493465821.java" startline="1" endline="27" pcid="16579">
import java.util.Scanner;

public class Main {

	public static void main(String args[]) {

		Scanner sc = new Scanner(System.in);

		int N = sc.nextInt();
		int K = sc.nextInt();

		double p = 0;

		for(int i=1;i<=N;i++) {
			double pi = 1;
			int temp = i;
			while(temp < K) {
				pi /= 2;
				temp *= 2;
			}
			p += pi;
		}
		p /= N;
		System.out.println(p);
    }
}

</source>
<source file="../hum_codes_raw/s792996112.java" startline="1" endline="27" pcid="26638">
import java.util.Scanner;

public class Main {

	public static void main(String args[]) {

		Scanner sc = new Scanner(System.in);

		int N = sc.nextInt();
		int K = sc.nextInt();

		double p = 0;

		for(int i=1;i<=N;i++) {
			double pi = 1;
			int temp = i;
			while(temp < K) {
				pi /= 2;
				temp *= 2;
			}
			p += pi;
		}
		p /= N;
		System.out.println(p);
    }
}

</source>
</class>

<class classid="236" nclones="2" nlines="40" similarity="100">
<source file="../hum_codes_raw/s494089730.java" startline="1" endline="42" pcid="16597">
import java.io.PrintWriter;
import java.util.Scanner;

public class Main {
    private static int[] path;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int a = sc.nextInt();
        int b = sc.nextInt();
        path = new int[1 << n];
        if (Integer.bitCount(a ^ b) % 2 != 0) {
            System.out.println("YES");
        } else {
            System.out.println("NO");
            return;
        }
        path(a, b, 0, (1 << n) - 1);
        PrintWriter pw = new PrintWriter(System.out);
        for (int i = 0; i < path.length; i++) {
            pw.print(path[i] + " ");
        }
        pw.println();
        pw.flush();
    }

    private static void path(int a, int b, int st, int mask) {
        int diffBit = Integer.highestOneBit(mask & (a ^ b));
        mask = mask ^ diffBit;
        int size = Integer.bitCount(mask);
        if (size == 0) {
            path[st] = a;
            path[st + 1] = b;
        } else {
            int otherBit = Integer.highestOneBit(mask);
            path(a, a ^ otherBit, st, mask);
            path(a ^ diffBit ^ otherBit, b, st + (1 << size), mask);
        }
    }
}

</source>
<source file="../hum_codes_raw/s687838170.java" startline="1" endline="42" pcid="23105">
import java.io.PrintWriter;
import java.util.Scanner;
 
public class Main {
    private static int[] path;
 
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int a = sc.nextInt();
        int b = sc.nextInt();
        path = new int[1 << n];
        if (Integer.bitCount(a ^ b) % 2 != 0) {
            System.out.println("YES");
        } else {
            System.out.println("NO");
            return;
        }
        path(a, b, 0, (1 << n) - 1);
        PrintWriter pw = new PrintWriter(System.out);
        for (int i = 0; i < path.length; i++) {
            pw.print(path[i] + " ");
        }
        pw.println();
        pw.flush();
    }
 
    private static void path(int a, int b, int st, int mask) {
        int diffBit = Integer.highestOneBit(mask & (a ^ b));
        mask = mask ^ diffBit;
        int size = Integer.bitCount(mask);
        if (size == 0) {
            path[st] = a;
            path[st + 1] = b;
        } else {
            int otherBit = Integer.highestOneBit(mask);
            path(a, a ^ otherBit, st, mask);
            path(a ^ diffBit ^ otherBit, b, st + (1 << size), mask);
        }
    }
}

</source>
</class>

<class classid="237" nclones="2" nlines="56" similarity="100">
<source file="../hum_codes_raw/s502182318.java" startline="1" endline="99" pcid="16824">
import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;

public class Main{
    public static void main(String[] args){

	// テ、ツクツ?ゥツδ偲・ツ青崚」ツ?ョテ」ツδ榲」ツδ暗」ツδェテ」ツδァテ」ツつキテ」ツつォテ」ツ?ョテゥツォツ佚」ツ?陛ァツ板ィテ」ツ?ィテ・ツ債甘・ツセツ?ァツ板ィテッツシツ淌」ツ?ィテ」ツ??ヲツャツ。テゥツδ偲・ツ青崚」ツ?ョテ」ツ?ィテ」ツ?ァテ」ツ??ィツィツ暗・ツ崢崚」ツ?、テゥツ?催・ツ按療」ツ?古・ツソツ?ィツヲツ?」ツ?ォテ」ツ?ェテ」ツつ凝」ツ?ョテ」ツ?凝」ツ?ェテ「ツ?ヲ
	Scanner sc = new Scanner(System.in);
	int ichiroNum = 0, jiroNum = 0; //テ、ツコツコテ・ツスツ「テ」ツ?ョテヲツ閉ーテ・ツ?・テ」ツつ古」ツつ凝」ツ?淌」ツつ?」ツ?ョテ・ツ、ツ嘉ヲツ閉ー

	while(sc.hasNext()){

	    ichiroNum = sc.nextInt(); // テ、ツクツ?ゥツδ偲・ツ青崚」ツ?ョテ、ツコツコテ・ツスツ「テ」ツ?ョテヲツ閉ーテ・ツ?・テ・ツ環崚」ツ?づ」ツ?禿」ツつ古」ツ??テ」ツ??」ツ?」テ」ツ?淌」ツつ嘉ァツオツづ、ツコツ?
	    if(ichiroNum==0) break;

	    // **** テ」ツ?禿」ツ?禿」ツ?凝」ツつ嘉、ツクツ?ゥツδ偲」ツ?湘」ツつ禿」ツ?ョテ」ツδ?」ツδシテ」ツつソテ、ツスツ愿ヲツ按?****
	    
	    int[] ichiroHeight = new int[ichiroNum];
	    int[] ichiroWeight = new int[ichiroNum];

	    for(int i = 0;i<ichiroNum;i++){
		ichiroHeight[i] = sc.nextInt();
		ichiroWeight[i] = sc.nextInt();
	    }
	    // **********************************

	    jiroNum = sc.nextInt();

	    // ***** テ」ツ?禿」ツ?禿」ツ?凝」ツつ嘉ヲツャツ。テゥツδ偲・ツ青?***************
	    int[] jiroHeight = new int[jiroNum];
	    int[] jiroWeight = new int[jiroNum];

	    for(int i = 0;i<jiroNum;i++){
		jiroHeight[i] = sc.nextInt();
		jiroWeight[i] = sc.nextInt();
	    }
	    // **********************************
	    // ***** テ」ツ?禿」ツ?禿」ツ?凝」ツつ嘉・ツ按、テ・ツョツ?*****

	    // テ」ツ?ゥテ」ツ??」ツ?療」ツつ暗」ツ??」ツ?凝」ツ?ェテ」ツ??ゥツォツ佚」ツ?陛ゥツ??」ツ?ォテ、ツクツヲテ」ツ?ケテヲツ崢ソテ」ツ?暗」ツ?ヲテ」ツ?陛」ツつ嘉」ツ?ォテ・ツ債甘・ツセツ?ゥツ??」ツ?ォテ、ツクツヲテ」ツ?ケテヲツ崢ソテ」ツ?暗」ツ?淌」ツつ甘」ツ?療」ツつ暗」ツ??」ツ?凝」ツ?ェテ「ツ?ヲテッツシツ?
	    // テ」ツ?ィテ」ツつ甘」ツ?づ」ツ?暗」ツ?堙、ツコツ古、ツコツコテ」ツ?ョテ」ツつ津」ツ?づ」ツつ湘」ツ?崚」ツ?淌ゥツ?催・ツ按療」ツつ津」ツ?セテ」ツ?淌ヲツ鳴ーテ」ツ?療」ツ?湘、ツスツ愿」ツつ催」ツ??」ツ?凝」ツ?ェテ」ツ?づ」ツ?敕」ツつ古」ツ?ァテゥツォツ佚」ツ?陛ゥツ??」ツ?ォテ、ツクツヲテ」ツ?ケテ」ツ?ヲテ」ツ?ソテ」ツつ暗」ツ??
	    // テゥツォツ佚」ツ?陛」ツ?ィテ・ツケツ?」ツ?ョテ・ツ、ツァテ・ツーツ湘ゥツ鳴「テ、ツソツづ」ツ?古ゥツ??」ツ?ォテ」ツ?ェテ」ツ?」テ」ツ?。テ」ツつε」ツ??」ツつ?」ツ?、テ」ツつづ」ツ?ィテ」ツつ甘」ツ?づ」ツ?暗」ツ?堙ゥツ?催・ツ按療」ツ?ォテ・ツ青ォテ」ツつ?」ツ?ヲテ」ツ??ヲツ閉ーテ」ツつ津ヲツ閉ーテ」ツ?暗」ツつ凝」ツ?ィテ」ツ?催」ツ?ォテ・ツ按、テ・ツョツ堙」ツ?凖」ツつ?

	    int[] count = new int[ichiroNum+jiroNum];

	    int[][] dolls = new int[ichiroNum+jiroNum][2];
	    
	    // テ、ツクツ?ゥツδ偲」ツ?湘」ツつ禿」ツ?ョテ」ツ?ィテヲツャツ。テゥツδ偲・ツ青崚」ツ?ョテ」ツつ津・ツ青暗」ツつ湘」ツ?崚」ツつ?
	    for(int i = 0;i<ichiroNum;i++){
	    	dolls[i][0] = ichiroHeight[i];
	    	dolls[i][1] = ichiroWeight[i];
	    }
	    for(int i = ichiroNum;i<ichiroNum+jiroNum;i++){
	    	dolls[i][0] = jiroHeight[i-ichiroNum];
	    	dolls[i][1] = jiroWeight[i-ichiroNum];
	    }
	    
	    Arrays.sort(dolls, new Comparator<int[]>() {
	     public int compare(int[] o1, int[] o2) {
	      if(o1[0] != o2[0]) return o1[0] - o2[0];
	      return o1[1] - o2[1];
	     }
	    });
	    
	    // テ」ツ?禿」ツつ古」ツ?ァテゥツ?催・ツ按療」ツ?ァテ」ツ?催」ツ?淌」ツ?ョテ」ツ?凝」ツ?ェテ」ツδサテ」ツδサテ」ツδサテ」ツつケテ」ツつエテ」ツつ、テッツシツ?

	    // テ」ツ?陛」ツ?ヲテ」ツ?陛」ツ?ヲテ・ツ按、テ・ツョツ堙・ツ按、テ・ツョツ堙」ツ?づ」ツ?ァテ」ツ?催」ツつ凝」ツ?凝」ツ?ェ
	    // テ」ツ??」ツ?凝」ツつ嘉ィツヲツ?」ツ?凖」ツつ凝」ツ?ォテ」ツ??」ツ?セテ」ツ?堙、ツクツ?ァツ閉ェテ」ツ?。テ」ツ??」ツ?陛」ツ??・ツュツ静」ツ?凝」ツつ嘉ィツ?ε」ツ?暗」ツ?ヲテ」ツ??ィツ?ェテ・ツ按?」ツ?古」ツ?ゥテ」ツ?ョテ」ツ?湘」ツつ嘉」ツ??」ツ?ョテ・ツュツ静」ツつ津・ツ?・テ」ツつ古」ツつ嘉」ツつ古」ツつ凝」ツ?凝」ツつ津ィツ?ε」ツ?暗」ツつ?
	    // テ」ツ?ゥテ」ツつ禿」ツ?ゥテ」ツつ禿・ツ、ツァテ」ツ?催」ツ??・ツュツ静」ツ?ォテ」ツ?ェテ」ツ?」テ」ツ?ヲテ」ツ??」ツ?」テ」ツ?ヲテ」ツ??ィツ?ェテ・ツ按?」ツ?古・ツ?・テ」ツつ古」ツつ嘉」ツつ古」ツつ凝・ツュツ静」ツ?ョテ、ツクツュテ」ツ?ァテ、ツクツ?ァツ閉ェテ・ツ、ツァテ」ツ?催」ツ??・ツュツ静」ツ?古・ツ?・テ」ツつ古」ツつ嘉」ツつ古」ツつ凝ヲツ閉ーテ」ツ?ッティツ?ェテ・ツ按?」ツつづ・ツ?・テ」ツつ古」ツつ嘉」ツつ古」ツつ凝ヲツ閉ーテ」ツ??」ツ?凝」ツつ嘉」ツ??」ツ?敕」ツつ古」ツ?ォ+1テ」ツ?凖」ツつ古」ツ?ーテ」ツ??」ツ??」ツ?ィテ」ツ??」ツ??」ツ?禿」ツ?ィテ」ツ??」ツつ暗」ツ?ュ
	    
	    for(int i = 0;i<count.length;i++){
	    	for(int j = 0;j<i;j++){
	    		if(dolls[j][0] < dolls[i][0] && dolls[j][1] < dolls[i][1])
	    			 if(count[i] < count[j] + 1) count[i] = count[j] + 1;
	    	}
	    }

	    Arrays.sort(count);
	    
	    int countMax = count[count.length-1];
	    // countMaxテ」ツ?ッテ」ツ??」ツ?敕」ツ?ョテ」ツ?禿」ツ?古、ツスツ陛・ツ?凝ィツ?ェテ・ツ按?」ツ?ョテ、ツクツュテ」ツ?ォテ・ツ?・テ」ツつ古」ツつ嘉」ツつ古」ツつ凝」ツ?凝」ツ?ョテヲツ閉ーテ」ツ??」ツ?凝」ツつ?
	    // ティツヲツ姪ァツつケテ」ツ?ォテ」ツ?ェテ」ツ?」テ」ツ?ヲテ」ツつ凝・ツュツ静」ツ?ョテ・ツ按?」ツつづヲツ閉ーテ」ツ?ォテ・ツ?・テ」ツつ古」ツつ凝」ツ?禿」ツ?ィテ」ツ?ォテ」ツ?ェテ」ツ?」テ」ツ?ヲテ」ツ??・ツ?コテ・ツ環崚」ツ?ッ+1テ」ツ?療」ツ?ェテ」ツ?催」ツつεッツシツ?」ツ?づ」ツ?凝」ツつ禿ッツシツ?
	    // テ」ツ?禿」ツつ禿」ツ?ェテ」ツ?禿」ツ?ィテ」ツ?ォテ」ツつづヲツーツ療」ツ?・テ」ツ?凝」ツつ禿」ツ?ィテ」ツ?ッテ」ツ??」ツ?づ」ツ?サテ」ツつ?」ツつ催」ツ??ッツシツ?
	    System.out.println(countMax+1);

	    // テ・ツ按敕ヲツ慊淌・ツ個?
	    for(int i = 0;i<count.length;i++){
	    	count[i] = 0;
	    }
	    ichiroNum = 0;
	    jiroNum = 0;
	    
	}
	
    }

}

</source>
<source file="../hum_codes_raw/s628337290.java" startline="1" endline="99" pcid="21081">
import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;

public class Main{
    public static void main(String[] args){

	// テ、ツクツ?ゥツδ偲・ツ青崚」ツ?ョテ」ツδ榲」ツδ暗」ツδェテ」ツδァテ」ツつキテ」ツつォテ」ツ?ョテゥツォツ佚」ツ?陛ァツ板ィテ」ツ?ィテ・ツ債甘・ツセツ?ァツ板ィテッツシツ淌」ツ?ィテ」ツ??ヲツャツ。テゥツδ偲・ツ青崚」ツ?ョテ」ツ?ィテ」ツ?ァテ」ツ??ィツィツ暗・ツ崢崚」ツ?、テゥツ?催・ツ按療」ツ?古・ツソツ?ィツヲツ?」ツ?ォテ」ツ?ェテ」ツつ凝」ツ?ョテ」ツ?凝」ツ?ェテ「ツ?ヲ
	Scanner sc = new Scanner(System.in);
	int ichiroNum = 0, jiroNum = 0; //テ、ツコツコテ・ツスツ「テ」ツ?ョテヲツ閉ーテ・ツ?・テ」ツつ古」ツつ凝」ツ?淌」ツつ?」ツ?ョテ・ツ、ツ嘉ヲツ閉ー

	while(sc.hasNext()){

	    ichiroNum = sc.nextInt(); // テ、ツクツ?ゥツδ偲・ツ青崚」ツ?ョテ、ツコツコテ・ツスツ「テ」ツ?ョテヲツ閉ーテ・ツ?・テ・ツ環崚」ツ?づ」ツ?禿」ツつ古」ツ??テ」ツ??」ツ?」テ」ツ?淌」ツつ嘉ァツオツづ、ツコツ?
	    if(ichiroNum==0) break;

	    // **** テ」ツ?禿」ツ?禿」ツ?凝」ツつ嘉、ツクツ?ゥツδ偲」ツ?湘」ツつ禿」ツ?ョテ」ツδ?」ツδシテ」ツつソテ、ツスツ愿ヲツ按?****
	    
	    int[] ichiroHeight = new int[ichiroNum];
	    int[] ichiroWeight = new int[ichiroNum];

	    for(int i = 0;i<ichiroNum;i++){
		ichiroHeight[i] = sc.nextInt();
		ichiroWeight[i] = sc.nextInt();
	    }
	    // **********************************

	    jiroNum = sc.nextInt();

	    // ***** テ」ツ?禿」ツ?禿」ツ?凝」ツつ嘉ヲツャツ。テゥツδ偲・ツ青?***************
	    int[] jiroHeight = new int[jiroNum];
	    int[] jiroWeight = new int[jiroNum];

	    for(int i = 0;i<jiroNum;i++){
		jiroHeight[i] = sc.nextInt();
		jiroWeight[i] = sc.nextInt();
	    }
	    // **********************************
	    // ***** テ」ツ?禿」ツ?禿」ツ?凝」ツつ嘉・ツ按、テ・ツョツ?*****

	    // テ」ツ?ゥテ」ツ??」ツ?療」ツつ暗」ツ??」ツ?凝」ツ?ェテ」ツ??ゥツォツ佚」ツ?陛ゥツ??」ツ?ォテ、ツクツヲテ」ツ?ケテヲツ崢ソテ」ツ?暗」ツ?ヲテ」ツ?陛」ツつ嘉」ツ?ォテ・ツ債甘・ツセツ?ゥツ??」ツ?ォテ、ツクツヲテ」ツ?ケテヲツ崢ソテ」ツ?暗」ツ?淌」ツつ甘」ツ?療」ツつ暗」ツ??」ツ?凝」ツ?ェテ「ツ?ヲテッツシツ?
	    // テ」ツ?ィテ」ツつ甘」ツ?づ」ツ?暗」ツ?堙、ツコツ古、ツコツコテ」ツ?ョテ」ツつ津」ツ?づ」ツつ湘」ツ?崚」ツ?淌ゥツ?催・ツ按療」ツつ津」ツ?セテ」ツ?淌ヲツ鳴ーテ」ツ?療」ツ?湘、ツスツ愿」ツつ催」ツ??」ツ?凝」ツ?ェテ」ツ?づ」ツ?敕」ツつ古」ツ?ァテゥツォツ佚」ツ?陛ゥツ??」ツ?ォテ、ツクツヲテ」ツ?ケテ」ツ?ヲテ」ツ?ソテ」ツつ暗」ツ??
	    // テゥツォツ佚」ツ?陛」ツ?ィテ・ツケツ?」ツ?ョテ・ツ、ツァテ・ツーツ湘ゥツ鳴「テ、ツソツづ」ツ?古ゥツ??」ツ?ォテ」ツ?ェテ」ツ?」テ」ツ?。テ」ツつε」ツ??」ツつ?」ツ?、テ」ツつづ」ツ?ィテ」ツつ甘」ツ?づ」ツ?暗」ツ?堙ゥツ?催・ツ按療」ツ?ォテ・ツ青ォテ」ツつ?」ツ?ヲテ」ツ??ヲツ閉ーテ」ツつ津ヲツ閉ーテ」ツ?暗」ツつ凝」ツ?ィテ」ツ?催」ツ?ォテ・ツ按、テ・ツョツ堙」ツ?凖」ツつ?

	    int[] count = new int[ichiroNum+jiroNum];

	    int[][] dolls = new int[ichiroNum+jiroNum][2];
	    
	    // テ、ツクツ?ゥツδ偲」ツ?湘」ツつ禿」ツ?ョテ」ツ?ィテヲツャツ。テゥツδ偲・ツ青崚」ツ?ョテ」ツつ津・ツ青暗」ツつ湘」ツ?崚」ツつ?
	    for(int i = 0;i<ichiroNum;i++){
	    	dolls[i][0] = ichiroHeight[i];
	    	dolls[i][1] = ichiroWeight[i];
	    }
	    for(int i = ichiroNum;i<ichiroNum+jiroNum;i++){
	    	dolls[i][0] = jiroHeight[i-ichiroNum];
	    	dolls[i][1] = jiroWeight[i-ichiroNum];
	    }
	    
	    Arrays.sort(dolls, new Comparator<int[]>() {
	     public int compare(int[] o1, int[] o2) {
	      if(o1[0] != o2[0]) return o1[0] - o2[0];
	      return o1[1] - o2[1];
	     }
	    });
	    
	    // テ」ツ?禿」ツつ古」ツ?ァテゥツ?催・ツ按療」ツ?ァテ」ツ?催」ツ?淌」ツ?ョテ」ツ?凝」ツ?ェテ」ツδサテ」ツδサテ」ツδサテ」ツつケテ」ツつエテ」ツつ、テッツシツ?

	    // テ」ツ?陛」ツ?ヲテ」ツ?陛」ツ?ヲテ・ツ按、テ・ツョツ堙・ツ按、テ・ツョツ堙」ツ?づ」ツ?ァテ」ツ?催」ツつ凝」ツ?凝」ツ?ェ
	    // テ」ツ??」ツ?凝」ツつ嘉ィツヲツ?」ツ?凖」ツつ凝」ツ?ォテ」ツ??」ツ?セテ」ツ?堙、ツクツ?ァツ閉ェテ」ツ?。テ」ツ??」ツ?陛」ツ??・ツュツ静」ツ?凝」ツつ嘉ィツ?ε」ツ?暗」ツ?ヲテ」ツ??ィツ?ェテ・ツ按?」ツ?古」ツ?ゥテ」ツ?ョテ」ツ?湘」ツつ嘉」ツ??」ツ?ョテ・ツュツ静」ツつ津・ツ?・テ」ツつ古」ツつ嘉」ツつ古」ツつ凝」ツ?凝」ツつ津ィツ?ε」ツ?暗」ツつ?
	    // テ」ツ?ゥテ」ツつ禿」ツ?ゥテ」ツつ禿・ツ、ツァテ」ツ?催」ツ??・ツュツ静」ツ?ォテ」ツ?ェテ」ツ?」テ」ツ?ヲテ」ツ??」ツ?」テ」ツ?ヲテ」ツ??ィツ?ェテ・ツ按?」ツ?古・ツ?・テ」ツつ古」ツつ嘉」ツつ古」ツつ凝・ツュツ静」ツ?ョテ、ツクツュテ」ツ?ァテ、ツクツ?ァツ閉ェテ・ツ、ツァテ」ツ?催」ツ??・ツュツ静」ツ?古・ツ?・テ」ツつ古」ツつ嘉」ツつ古」ツつ凝ヲツ閉ーテ」ツ?ッティツ?ェテ・ツ按?」ツつづ・ツ?・テ」ツつ古」ツつ嘉」ツつ古」ツつ凝ヲツ閉ーテ」ツ??」ツ?凝」ツつ嘉」ツ??」ツ?敕」ツつ古」ツ?ォ+1テ」ツ?凖」ツつ古」ツ?ーテ」ツ??」ツ??」ツ?ィテ」ツ??」ツ??」ツ?禿」ツ?ィテ」ツ??」ツつ暗」ツ?ュ
	    
	    for(int i = 0;i<count.length;i++){
	    	for(int j = 0;j<i;j++){
	    		if(dolls[j][0] < dolls[i][0] && dolls[j][1] < dolls[i][1])
	    			 if(count[i] < count[j] + 1) count[i] = count[j] + 1;
	    	}
	    }

	    Arrays.sort(count);
	    
	    int countMax = count[count.length-1];
	    // countMaxテ」ツ?ッテ」ツ??」ツ?敕」ツ?ョテ」ツ?禿」ツ?古、ツスツ陛・ツ?凝ィツ?ェテ・ツ按?」ツ?ョテ、ツクツュテ」ツ?ォテ・ツ?・テ」ツつ古」ツつ嘉」ツつ古」ツつ凝」ツ?凝」ツ?ョテヲツ閉ーテ」ツ??」ツ?凝」ツつ?
	    // ティツヲツ姪ァツつケテ」ツ?ォテ」ツ?ェテ」ツ?」テ」ツ?ヲテ」ツつ凝・ツュツ静」ツ?ョテ・ツ按?」ツつづヲツ閉ーテ」ツ?ォテ・ツ?・テ」ツつ古」ツつ凝」ツ?禿」ツ?ィテ」ツ?ォテ」ツ?ェテ」ツ?」テ」ツ?ヲテ」ツ??・ツ?コテ・ツ環崚」ツ?ッ+1テ」ツ?療」ツ?ェテ」ツ?催」ツつεッツシツ?」ツ?づ」ツ?凝」ツつ禿ッツシツ?
	    // テ」ツ?禿」ツつ禿」ツ?ェテ」ツ?禿」ツ?ィテ」ツ?ォテ」ツつづヲツーツ療」ツ?・テ」ツ?凝」ツつ禿」ツ?ィテ」ツ?ッテ」ツ??」ツ?づ」ツ?サテ」ツつ?」ツつ催」ツ??ッツシツ?
	    System.out.println(countMax+1);

	    // テ・ツ按敕ヲツ慊淌・ツ個?
	    for(int i = 0;i<count.length;i++){
	    	count[i] = 0;
	    }
	    ichiroNum = 0;
	    jiroNum = 0;
	    
	}
	
    }

}

</source>
</class>

<class classid="238" nclones="2" nlines="19" similarity="100">
<source file="../hum_codes_raw/s502913181.java" startline="1" endline="26" pcid="16846">
import java.util.Arrays;
import java.util.Scanner;
public class Main
{
	public static void main(String arg[])
	{
		Scanner in = new Scanner(System.in);
		while(in.hasNext())
		{
			int n= in.nextInt();
			int a[] = new int[n];
			int ans = 0;
			for(int i=0; i<n; i++)
				a[i]=in.nextInt();
			Arrays.sort(a);
			int sum[]= new int [n];
			sum[0]=a[0];
			for(int i=1; i<n; i++)
				sum[i]=a[i]+sum[i-1];
			for(int i=0; i<n ;i++)
			ans+=sum[i];
			System.out.println(ans);
		}
	}
}

</source>
<source file="../hum_codes_raw/s759993942.java" startline="1" endline="29" pcid="25541">
import java.util.Arrays;
import java.util.Scanner;

public class Main
{
	public static void main(String arg[])
	{
		Scanner in = new Scanner(System.in);
		while(in.hasNext())
		{
			int n= in.nextInt();
			int a[] = new int[n];
			int ans = 0;
			for(int i=0; i<n; i++)
				a[i]=in.nextInt();
			Arrays.sort(a);
			int sum[]= new int [n];
			sum[0]=a[0];
			for(int i=1; i<n; i++)
				sum[i]=a[i]+sum[i-1];
			for(int i=0; i<n ;i++)
			ans+=sum[i];
			System.out.println(ans);
		}

	}

}

</source>
</class>

<class classid="239" nclones="2" nlines="26" similarity="100">
<source file="../hum_codes_raw/s510125076.java" startline="1" endline="31" pcid="17099">
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        String[] strArray = sc.next().split("");
        String[] akibaArray = "AKIHABARA".split("");
        boolean flag = true;
        int count = 0;
        int i = 0;

        for (; i < akibaArray.length; i++) {
            if (count >= strArray.length) {
                break;
            }
            if (strArray[count].equals(akibaArray[i])) {
                count++;
            } else if (!akibaArray[i].equals("A")) {
                break;
            }
        }

        if (i <= akibaArray.length - 2 || count < strArray.length) {
            flag = false;
        }

        System.out.println(flag ? "YES" : "NO");
    }
}

</source>
<source file="../hum_codes_raw/s901192790.java" startline="1" endline="31" pcid="30328">
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        String[] strArray = sc.next().split("");
        String[] akibaArray = "AKIHABARA".split("");
        boolean flag = true;
        int count = 0;
        int i = 0;

        for (; i < akibaArray.length; i++) {
            if (count >= strArray.length) {
                break;
            }
            if (strArray[count].equals(akibaArray[i])) {
                count++;
            } else if (!akibaArray[i].equals("A")) {
                break;
            }
        }

        if (i <= akibaArray.length - 2 || count < strArray.length) {
            flag = false;
        }

        System.out.println(flag ? "YES" : "NO");
    }
}

</source>
</class>

<class classid="240" nclones="2" nlines="26" similarity="100">
<source file="../hum_codes_raw/s513737318.java" startline="1" endline="28" pcid="17236">
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Main main = new Main();
        main.solve();
    }
    public void solve() {
        Scanner scan = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int N = scan.nextInt();
        int Z = scan.nextInt();
        int W = scan.nextInt();
        int[] a = new int[N];
        for (int i = 0; i < N; i++) {
            a[i] = scan.nextInt();
        }
        if (N == 1) {
            System.out.println(Math.abs(a[N-1]-W));
            return;
        }
        long answer = Math.max(Math.abs(a[N-1]-W),Math.abs(a[N-1]-a[N-2]));
        System.out.println(answer);
    }
}

</source>
<source file="../hum_codes_raw/s738552783.java" startline="1" endline="28" pcid="24827">
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Main main = new Main();
        main.solve();
    }
    public void solve() {
        Scanner scan = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int N = scan.nextInt();
        int Z = scan.nextInt();
        int W = scan.nextInt();
        int[] a = new int[N];
        for (int i = 0; i < N; i++) {
            a[i] = scan.nextInt();
        }
        if (N == 1) {
            System.out.println(Math.abs(a[N-1]-W));
            return;
        }
        long answer = Math.max(Math.abs(a[N-1]-W),Math.abs(a[N-1]-a[N-2]));
        System.out.println(answer);
    }
}

</source>
</class>

<class classid="241" nclones="2" nlines="99" similarity="100">
<source file="../hum_codes_raw/s514785616.java" startline="1" endline="149" pcid="17272">
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.ListIterator;
import java.util.PriorityQueue;
import java.util.Scanner;
 
public class Main {
     
    public static class WeightUnionFind{
        int[] parent;
        int[] rank;
        int[] diff_weight;
         
        WeightUnionFind(int n){
            parent=new int[n];
            rank = new int[n];
            diff_weight = new int[n];
             
            for(int i=0;i<n;i++){
                parent[i]=i;
                rank[i] = 0;
                diff_weight[i] = 0;
            }
        }
         
        public int find(int x){
            if(parent[x]==x){
                return x;
            }
             
            return find(parent[x]);
        }
         
        public int find_diff(int x){
            if(parent[x] == x){
                return 0;
            }
             
            return find_diff(parent[x]) + diff_weight[x];
        }
         
        public Boolean same(int x,int y){
            return find(x)==find(y);
        }
         
        public int get_diff(int x, int y){
            if(!same(x, y)){
                return Integer.MIN_VALUE;
            }else{
                return find_diff(x) - find_diff(y);
            }
        }
        /*
        public void unite(int x,int y){
            x = find(x);
            y = find(y);
             
            if(x == y){
                return;
            }
             
            if(rank[x] < rank[y]){
                parent[x] = y;
            }else{
                parent[y] = x;
                if(rank[x] == rank[y]){
                    rank[x]++;
                }
            }
        }
        */
        public void set_diff(int x,int y, int d){
            final int find_x = find(x);
            final int find_y = find(y);
             
            if(find_x == find_y){
                return;
            }
             
            //System.out.println(x + " " + find_x + " " + y + " " + find_y + " " + diff_weight[y] + " " + diff_weight[x]);
            d -= find_diff(x) - find_diff(y);
             
            if(rank[find_x] < rank[find_y]){
                //diff_weight[x] += d + find_diff(y);
                diff_weight[find_x] = d;
                 
                parent[find_x] = find_y;
            }else{
                diff_weight[find_y] = -d;
                 
                parent[find_y] = find_x;
                if(rank[find_x] == rank[find_y]){
                    rank[find_x]++;
                }
            }
        }
    }
 
     
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
         
        while (true) {
            final int N = sc.nextInt();
            final int M = sc.nextInt();
 
            if (N == 0 && M == 0) {
                break;
            }
             
            System.gc();
             
            WeightUnionFind wuf = new WeightUnionFind(N);
             
            for(int i = 0; i < M; i++){
                String op = sc.next();
                 
                if(op.equals("!")){
                    final int from = sc.nextInt() - 1;
                    final int to = sc.nextInt() - 1;
                    final int w = sc.nextInt();
                     
                    wuf.set_diff(from, to, w);
                    //System.out.println("DIFF " + from + " " + to + " " + w);
                }else{
                    final int from = sc.nextInt() - 1;
                    final int to = sc.nextInt() - 1;
                     
                    if(!wuf.same(from, to)){
                        System.out.println("UNKNOWN");
                    }else{
                        System.out.println(wuf.get_diff(from, to));
                    }
                }
                 
                //System.out.println("P : " + Arrays.toString(wuf.parent));
                //System.out.println("D : " + Arrays.toString(wuf.diff_weight));
            }
             
        }
 
        sc.close();
    }
 
}

</source>
<source file="../hum_codes_raw/s930221836.java" startline="1" endline="149" pcid="31299">
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.ListIterator;
import java.util.PriorityQueue;
import java.util.Scanner;
  
public class Main {
      
    public static class WeightUnionFind{
        int[] parent;
        int[] rank;
        int[] diff_weight;
          
        WeightUnionFind(int n){
            parent=new int[n];
            rank = new int[n];
            diff_weight = new int[n];
              
            for(int i=0;i<n;i++){
                parent[i]=i;
                rank[i] = 0;
                diff_weight[i] = 0;
            }
        }
          
        public int find(int x){
            if(parent[x]==x){
                return x;
            }
              
            return find(parent[x]);
        }
          
        public int find_diff(int x){
            if(parent[x] == x){
                return 0;
            }
              
            return find_diff(parent[x]) + diff_weight[x];
        }
          
        public Boolean same(int x,int y){
            return find(x)==find(y);
        }
          
        public int get_diff(int x, int y){
            if(!same(x, y)){
                return Integer.MIN_VALUE;
            }else{
                return find_diff(x) - find_diff(y);
            }
        }
        /*
        public void unite(int x,int y){
            x = find(x);
            y = find(y);
              
            if(x == y){
                return;
            }
              
            if(rank[x] < rank[y]){
                parent[x] = y;
            }else{
                parent[y] = x;
                if(rank[x] == rank[y]){
                    rank[x]++;
                }
            }
        }
        */
        public void set_diff(int x,int y, int d){
            final int find_x = find(x);
            final int find_y = find(y);
              
            if(find_x == find_y){
                return;
            }
              
            //System.out.println(x + " " + find_x + " " + y + " " + find_y + " " + diff_weight[y] + " " + diff_weight[x]);
            d -= find_diff(x) - find_diff(y);
              
            if(rank[find_x] < rank[find_y]){
                //diff_weight[x] += d + find_diff(y);
                diff_weight[find_x] = d;
                  
                parent[find_x] = find_y;
            }else{
                diff_weight[find_y] = -d;
                  
                parent[find_y] = find_x;
                if(rank[find_x] == rank[find_y]){
                    rank[find_x]++;
                }
            }
        }
    }
  
      
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
          
        while (true) {
            final int N = sc.nextInt();
            final int M = sc.nextInt();
  
            if (N == 0 && M == 0) {
                break;
            }
              
            System.gc();
              
            WeightUnionFind wuf = new WeightUnionFind(N);
              
            for(int i = 0; i < M; i++){
                String op = sc.next();
                  
                if(op.equals("!")){
                    final int from = sc.nextInt() - 1;
                    final int to = sc.nextInt() - 1;
                    final int w = sc.nextInt();
                      
                    wuf.set_diff(from, to, w);
                    //System.out.println("DIFF " + from + " " + to + " " + w);
                }else{
                    final int from = sc.nextInt() - 1;
                    final int to = sc.nextInt() - 1;
                      
                    if(!wuf.same(from, to)){
                        System.out.println("UNKNOWN");
                    }else{
                        System.out.println(wuf.get_diff(from, to));
                    }
                }
                  
                //System.out.println("P : " + Arrays.toString(wuf.parent));
                //System.out.println("D : " + Arrays.toString(wuf.diff_weight));
            }
              
        }
  
        sc.close();
    }
  
}

</source>
</class>

<class classid="242" nclones="2" nlines="43" similarity="100">
<source file="../hum_codes_raw/s515777634.java" startline="1" endline="59" pcid="17315">
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.lang.*;
import java.math.*;
import java.io.*;

import static java.lang.Math.*;
import static java.util.Arrays.*;

public class Main{

	Scanner sc=new Scanner(System.in);

	int INF=1<<28;
	double EPS=1e-9;

	void run(){
		for(int n=sc.nextInt(); n>0; n--){
			String s=sc.next();
			// debug(s);
			Matcher m=Pattern.compile("^>'(=+)#(=+)~$").matcher(s);
			if(m.find()){
				// debug(m.group(1), m.group(2));
				if(m.group(1).length()==m.group(2).length()){
					// debug("A");
					println("A");
					continue;
				}
			}
			m=Pattern.compile("^>\\^(Q=)+~~$").matcher(s);
			if(m.find()){
				// debug("B");
				println("B");
				continue;
			}
			// debug("NA");
			println("NA");
		}
	}

	void debug(Object... os){
		System.err.println(Arrays.deepToString(os));
	}

	void print(String s){
		System.out.print(s);
	}

	void println(String s){
		System.out.println(s);
	}

	public static void main(String[] args){
		// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));
		new Main().run();
	}
}

</source>
<source file="../hum_codes_raw/s917564111.java" startline="1" endline="54" pcid="30857">
import java.util.*;  
import java.util.regex.Matcher;  
import java.util.regex.Pattern;  
import java.lang.*;  
import java.math.*;  
import java.io.*;  
  
import static java.lang.Math.*;  
import static java.util.Arrays.*;  
  
public class Main{  
  
 Scanner sc=new Scanner(System.in);  
  
 int INF=1<<28;  
 double EPS=1e-9;  
  
 void run(){  
  for(int n=sc.nextInt(); n>0; n--){  
   String s=sc.next();  
   Matcher m=Pattern.compile("^>'(=+)#(=+)~$").matcher(s);  
   if(m.find()){  
    if(m.group(1).length()==m.group(2).length()){  
     println("A");  
     continue;  
    }  
   }  
   m=Pattern.compile("^>\\^(Q=)+~~$").matcher(s);  
   if(m.find()){  
    println("B");  
    continue;  
   }  
   println("NA");  
  }  
 }  
  
 void debug(Object... os){  
  System.err.println(Arrays.deepToString(os));  
 }  
  
 void print(String s){  
  System.out.print(s);  
 }  
  
 void println(String s){  
  System.out.println(s);  
 }  
  
 public static void main(String[] args){  
  // System.setOut(new PrintStream(new BufferedOutputStream(System.out)));  
  new Main().run();  
 }  
}  

</source>
</class>

<class classid="243" nclones="2" nlines="229" similarity="100">
<source file="../hum_codes_raw/s516269670.java" startline="1" endline="281" pcid="17326">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            EMsSolution solver = new EMsSolution();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class EMsSolution {
        Point[] pts;

        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            pts = new Point[n];

            for (int i = 0; i < n; i++) {
                pts[i] = new Point();
                pts[i].x = in.readInt();
                pts[i].y = in.readInt();
                pts[i].w = in.readInt();
            }
            Arrays.sort(pts, (a, b) -> Integer.compare(a.y, b.y));


            long[][] dp = new long[n][n + 1];
            long inf = (long) 1e18;


            long[] ans = new long[n + 1];
            Arrays.fill(ans, inf);
            for (int i = 0; i < 1 << n; i++) {
                for (int j = 0; j < n; j++) {
                    pts[j].minNow = Math.min(Math.abs(pts[j].x), Math.abs(pts[j].y));
                }


                for (int j = 0; j < n; j++) {
                    if (Bits.get(i, j) == 0) {
                        continue;
                    }
                    for (int k = 0; k < n; k++) {
                        pts[k].minNow = Math.min(pts[k].minNow, Math.abs(pts[k].x - pts[j].x));
                    }
                }
                long sum = 0;
                for (Point point : pts) {
                    sum += point.minNow * point.w;
                }
                int bitCount = Integer.bitCount(i);
                ans[bitCount] = Math.min(ans[bitCount], sum);

                //dp
                SequenceUtils.deepFill(dp, inf);
                for (int j = 0; j < n; j++) {
                    dp[j][1] = 0;
                    for (int k = 0; k <= j; k++) {
                        long cost = Math.min(pts[k].minNow, pts[j].y - pts[k].y);
                        dp[j][1] += cost * pts[k].w;
                    }

                    for (int t = 0; t < j; t++) {
                        //t + 1 to j
                        long cost = 0;
                        for (int k = t + 1; k <= j; k++) {
                            cost += Math.min(pts[k].minNow, Math.min(pts[j].y - pts[k].y, pts[k].y - pts[t].y)) * pts[k].w;
                        }
                        for (int k = 2; k <= n; k++) {
                            dp[j][k] = Math.min(dp[j][k], dp[t][k - 1] + cost);
                        }
                    }

                    //if it's the last one
                    long cost = 0;
                    for (int k = j + 1; k < n; k++) {
                        cost += Math.min(pts[k].minNow, pts[k].y - pts[j].y) * pts[k].w;
                    }
                    for (int k = 1; k + bitCount <= n; k++) {
                        ans[k + bitCount] = Math.min(ans[k + bitCount], cost + dp[j][k]);
                    }
                }
            }

            for (int i = 0; i <= n; i++) {
                out.println(ans[i]);
            }
        }

    }

    static class Bits {
        private Bits() {
        }

        public static int get(int x, int i) {
            return (x >>> i) & 1;
        }

    }

    static class Point {
        int x;
        int y;
        int minNow;
        long w;

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(long c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(long c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class SequenceUtils {
        public static void deepFill(Object array, long val) {
            if (!array.getClass().isArray()) {
                throw new IllegalArgumentException();
            }
            if (array instanceof long[]) {
                long[] longArray = (long[]) array;
                Arrays.fill(longArray, val);
            } else {
                Object[] objArray = (Object[]) array;
                for (Object obj : objArray) {
                    deepFill(obj, val);
                }
            }
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }
}


</source>
<source file="../hum_codes_raw/s578019056.java" startline="1" endline="281" pcid="19411">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            EMsSolution solver = new EMsSolution();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class EMsSolution {
        Point[] pts;

        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            pts = new Point[n];

            for (int i = 0; i < n; i++) {
                pts[i] = new Point();
                pts[i].x = in.readInt();
                pts[i].y = in.readInt();
                pts[i].w = in.readInt();
            }
            Arrays.sort(pts, (a, b) -> Integer.compare(a.y, b.y));


            long[][] dp = new long[n][n + 1];
            long inf = (long) 1e18;


            long[] ans = new long[n + 1];
            Arrays.fill(ans, inf);
            for (int i = 0; i < 1 << n; i++) {
                for (int j = 0; j < n; j++) {
                    pts[j].minNow = Math.min(Math.abs(pts[j].x), Math.abs(pts[j].y));
                }


                for (int j = 0; j < n; j++) {
                    if (Bits.get(i, j) == 0) {
                        continue;
                    }
                    for (int k = 0; k < n; k++) {
                        pts[k].minNow = Math.min(pts[k].minNow, Math.abs(pts[k].x - pts[j].x));
                    }
                }
                long sum = 0;
                for (Point point : pts) {
                    sum += point.minNow * point.w;
                }
                int bitCount = Integer.bitCount(i);
                ans[bitCount] = Math.min(ans[bitCount], sum);

                //dp
                SequenceUtils.deepFill(dp, inf);
                for (int j = 0; j < n; j++) {
                    dp[j][1] = 0;
                    for (int k = 0; k <= j; k++) {
                        long cost = Math.min(pts[k].minNow, pts[j].y - pts[k].y);
                        dp[j][1] += cost * pts[k].w;
                    }

                    for (int t = 0; t < j; t++) {
                        //t + 1 to j
                        long cost = 0;
                        for (int k = t + 1; k <= j; k++) {
                            cost += Math.min(pts[k].minNow, Math.min(pts[j].y - pts[k].y, pts[k].y - pts[t].y)) * pts[k].w;
                        }
                        for (int k = 2; k <= n; k++) {
                            dp[j][k] = Math.min(dp[j][k], dp[t][k - 1] + cost);
                        }
                    }

                    //if it's the last one
                    long cost = 0;
                    for (int k = j + 1; k < n; k++) {
                        cost += Math.min(pts[k].minNow, pts[k].y - pts[j].y) * pts[k].w;
                    }
                    for (int k = 1; k + bitCount <= n; k++) {
                        ans[k + bitCount] = Math.min(ans[k + bitCount], cost + dp[j][k]);
                    }
                }
            }

            for (int i = 0; i <= n; i++) {
                out.println(ans[i]);
            }
        }

    }

    static class Bits {
        private Bits() {
        }

        public static int get(int x, int i) {
            return (x >>> i) & 1;
        }

    }

    static class Point {
        int x;
        int y;
        int minNow;
        long w;

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(long c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(long c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class SequenceUtils {
        public static void deepFill(Object array, long val) {
            if (!array.getClass().isArray()) {
                throw new IllegalArgumentException();
            }
            if (array instanceof long[]) {
                long[] longArray = (long[]) array;
                Arrays.fill(longArray, val);
            } else {
                Object[] objArray = (Object[]) array;
                for (Object obj : objArray) {
                    deepFill(obj, val);
                }
            }
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }
}


</source>
</class>

<class classid="244" nclones="2" nlines="63" similarity="100">
<source file="../hum_codes_raw/s518337227.java" startline="1" endline="65" pcid="17415">
import java.io.*;
import  java.util.*;

import static java.lang.System.in;

class Main{
    static long[] X,sum;
    static Edge[] edges;
    static int[] id,unconnected;
    public static void main(String[] args)throws IOException{
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(), m = sc.nextInt();
        sum = new long[n+1];
        edges = new Edge[m];
        id = new int[n+1];
        unconnected = new int[n+1];

        for(int i=1;i<=n;i++) {
            sum[i] = sc.nextLong();
            id[i] = i;
        }
        for(int i=0;i<m;i++){
            int a = sc.nextInt(), b = sc.nextInt();
            long y = sc.nextLong();
            edges[i] = new Edge(a,b,y);
        }
        Arrays.sort(edges);
        for(int i=0;i<m;i++){
            Edge e = edges[i];
            union(e.left,e.right,e.weight);
        }
        int ans = unconnected[find(1)];
        System.out.println(ans);
    }
    static int find(int p){
        while(p!=id[p]){
            id[p] = id[id[p]];
            p = id[p];
        }
        return p;
    }
    static void union(int p, int q, long Y){
        int i = find(p), j = find(q);
        if(i==j){
            if(Y>sum[i]) unconnected[i]++;
        } else{
            if(Y<=sum[i]+sum[j]) unconnected[i]=0;
            else unconnected[i]+=1+unconnected[j];
            sum[i] += sum[j];
            id[j] = i;
        }
    }
    static class Edge implements Comparable<Edge>{
        int left, right;
        long weight;
        public Edge(int l, int r, long w){
            this.left = l; this.right = r;
            this.weight = w;
        }
        public int compareTo(Edge e){
            return Long.compare(this.weight,e.weight);
        }
    }
}

</source>
<source file="../hum_codes_raw/s552692819.java" startline="1" endline="65" pcid="18630">
import java.io.*;
import  java.util.*;
 
import static java.lang.System.in;
 
class Main{
    static long[] X,sum;
    static Edge[] edges;
    static int[] id,unconnected;
    public static void main(String[] args)throws IOException{
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(), m = sc.nextInt();
        sum = new long[n+1];
        edges = new Edge[m];
        id = new int[n+1];
        unconnected = new int[n+1];
 
        for(int i=1;i<=n;i++) {
            sum[i] = sc.nextLong();
            id[i] = i;
        }
        for(int i=0;i<m;i++){
            int a = sc.nextInt(), b = sc.nextInt();
            long y = sc.nextLong();
            edges[i] = new Edge(a,b,y);
        }
        Arrays.sort(edges);
        for(int i=0;i<m;i++){
            Edge e = edges[i];
            union(e.left,e.right,e.weight);
        }
        int ans = unconnected[find(1)];
        System.out.println(ans);
    }
    static int find(int p){
        while(p!=id[p]){
            id[p] = id[id[p]];
            p = id[p];
        }
        return p;
    }
    static void union(int p, int q, long Y){
        int i = find(p), j = find(q);
        if(i==j){
            if(Y>sum[i]) unconnected[i]++;
        } else{
            if(Y<=sum[i]+sum[j]) unconnected[i]=0;
            else unconnected[i]+=1+unconnected[j];
            sum[i] += sum[j];
            id[j] = i;
        }
    }
    static class Edge implements Comparable<Edge>{
        int left, right;
        long weight;
        public Edge(int l, int r, long w){
            this.left = l; this.right = r;
            this.weight = w;
        }
        public int compareTo(Edge e){
            return Long.compare(this.weight,e.weight);
        }
    }
}

</source>
</class>

<class classid="245" nclones="3" nlines="44" similarity="100">
<source file="../hum_codes_raw/s531092135.java" startline="1" endline="48" pcid="17876">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class Main{
	public static void main(String[] args)throws IOException{
		InputStreamReader isr = new InputStreamReader(System.in);
		BufferedReader reader = new BufferedReader(isr);
		String string;
		int n, m, a = 0, b = 0, c = 0;
		
		while(!(string = reader.readLine()).equals("0")){
			n = Integer.valueOf(string);
			m = Integer.valueOf(reader.readLine());
			
			int map[][] = new int[n][n];
			boolean visit[] = new boolean[n];
			for(int i = 0;i < n; i++) Arrays.fill(map[i], 1 << 29);
			for(int i = 0; i < m; i++){
				string = reader.readLine();
				a = Integer.valueOf(string.split(",")[0]);
				b = Integer.valueOf(string.split(",")[1]);
				c = (Integer.valueOf(string.split(",")[2]) - 100) / 100;
				map[a][b] = map[b][a] = c;
			}
			c = 0;
			visit[0] = true;
			for(int x = 0; x < n - 1; x++){
				m = 1 << 29;
				for(int i = 0; i < n; i++){
					if(map[0][i] < m && !visit[i]){
						m = map[0][i];
						b = i;
					}
				}
				visit[b] = true;
				c += map[0][b];
				for(int i = 0; i < n; i++){
					map[0][i] = Math.min(map[0][i], map[b][i]);
				};
			}
			System.out.println(c);
		}
		reader.close();
	}
}

</source>
<source file="../hum_codes_raw/s984361698.java" startline="1" endline="48" pcid="33104">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class Main{
	public static void main(String[] args)throws IOException{
		InputStreamReader isr = new InputStreamReader(System.in);
		BufferedReader reader = new BufferedReader(isr);
		String string;
		int n, m, a = 0, b = 0, c = 0;
		
		while(!(string = reader.readLine()).equals("0")){
			n = Integer.valueOf(string);
			m = Integer.valueOf(reader.readLine());
			
			int map[][] = new int[n][n];
			boolean visit[] = new boolean[n];
			for(int i = 0;i < n; i++) Arrays.fill(map[i], 1 << 29);
			for(int i = 0; i < m; i++){
				string = reader.readLine();
				a = Integer.valueOf(string.split(",")[0]);
				b = Integer.valueOf(string.split(",")[1]);
				c = (Integer.valueOf(string.split(",")[2]) - 100) / 100;
				map[a][b] = map[b][a] = c;
			}
			c = 0;
			visit[0] = true;
			for(int x = 0; x < n - 1; x++){
				m = 1 << 29;
				for(int i = 0; i < n; i++){
					if(map[0][i] < m && !visit[i]){
						m = map[0][i];
						b = i;
					}
				}
				visit[b] = true;
				c += map[0][b];
				for(int i = 0; i < n; i++){
					map[0][i] = Math.min(map[0][i], map[b][i]);
				}
			}
			System.out.println(c);
		}
		reader.close();
	}
}

</source>
<source file="../hum_codes_raw/s791655230.java" startline="1" endline="48" pcid="26597">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class Main{
	public static void main(String[] args)throws IOException{
		InputStreamReader isr = new InputStreamReader(System.in);
		BufferedReader reader = new BufferedReader(isr);
		String string;
		int n, m, a = 0, b = 0, c = 0;
		
		while(!(string = reader.readLine()).equals("0")){
			n = Integer.valueOf(string);
			m = Integer.valueOf(reader.readLine());
			
			int map[][] = new int[n][n];
			boolean visit[] = new boolean[n];
			for(int i = 0;i < n; i++) Arrays.fill(map[i], 1 << 29);
			for(int i = 0; i < m; i++){
				string = reader.readLine();
				a = Integer.valueOf(string.split(",")[0]);
				b = Integer.valueOf(string.split(",")[1]);
				c = (Integer.valueOf(string.split(",")[2]) - 100) / 100;
				map[a][b] = map[b][a] = c;
			}
			c = 0;
			visit[0] = true;
			for(int x = 0; x < n - 1; x++){
				m = 1 << 29;
				for(int i = 0; i < n; i++){
					if(map[0][i] < m && !visit[i]){
						m = map[0][i];
						b = i;
					}
				}
				visit[b] = true;
				c += map[0][b];
				for(int i = 0; i < n; i++){
					map[0][i] = Math.min(map[0][i], map[b][i]);
				};
			}
			System.out.println(c);
		}
		reader.close();
	}
}

</source>
</class>

<class classid="246" nclones="2" nlines="98" similarity="100">
<source file="../hum_codes_raw/s532090911.java" startline="1" endline="122" pcid="17910">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class Main {

	public static void main(String[] args) throws NumberFormatException, IOException {
		// TODO ?????????????????????????????????????????????
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());

        int[][] board = new int[8][8];
        
        for(int i = 0; i < 8 ; i++){
        	Arrays.fill(board[i], 0);
        }
        
        for(int i = 0; i < n; i++){
        	String[] tmpArray = br.readLine().split(" ");
        	int r = Integer.parseInt(tmpArray[0]);
        	int c = Integer.parseInt(tmpArray[1]);
        	board[r][c] = 1;
        }
        
        int nextC = getAvailableColumn(board, 8);
        if(nextC >= 0){
        	for(int i = 0; i < 8; i++){
        		boolean result = putQueen(board, 8, i, nextC);
        		if(result == true){
        			break;
        		}
        	}
        }
        //print
        for(int i = 0; i < 8; i++){
        	for(int j = 0; j < 8 ; j++){
        		if(board[i][j] == 1){
        			System.out.print("Q");
        		}
        		else{
        			System.out.print(".");
        		}
        	}
        	System.out.println();
        }
	}
	
	static int getAvailableColumn(int[][] board, int n){
		int j;
		for(j = 0; j < n ; j++){
			int queen = 0;
			for(int i = 0; i < n; i++){
				if(board[i][j] == 1){
					queen++;
					break;
				}
			}
			if(queen == 0){
				break;
			}
		}
		
		if(j >= n){
			return -1;
		}
		
		else {
			return j;
		}
	}
	
	static boolean putQueen(int[][] board, int n, int r, int c){
		//System.out.println("n "+n + " r "+r+" c "+c);
		//????????????????????????????????????????????????????????¨??????????????£??????
		for(int i = 0; i < n ; i++){
			if(board[i][c] == 1 && i != r){
				//System.out.println("error 1");
				return false;
			}
			if(board[r][i] == 1 && i != c){
				//System.out.println("error 2");
				return false;
			}
		}
		for(int i = 0; i < n; i++){
			if(  r+i < n && c+i < n && board[r+i][c+i] ==1){
				//System.out.println("error 3");
				return false;
			}
			if( r+i < n && c-i >= 0 && board[r+i][c-i] ==1 ){
				//System.out.println("error 4");
				return false;
			}
			if(  r-i >= 0 && c+i < n && board[r-i][c+i] ==1){
				//System.out.println("error 5");
				return false;
			}
			if( r-i >= 0 && c-i >= 0 && board[r-i][c-i] ==1 ){
				//System.out.println("error 6");
				return false;
			}
		}
		//System.out.println("("+r+","+c+") is OK");
		board[r][c] = 1;
		
		int nextColumn = getAvailableColumn(board, 8);
		if(nextColumn < 0){
			return true;
		}
		for(int i = 0; i < n ; i++){
			boolean result = putQueen(board, n, i, nextColumn);
			if(result == true){
				return true;
			}
		}
		board[r][c] = 0;
		return false;
	}

}

</source>
<source file="../hum_codes_raw/s599466638.java" startline="1" endline="123" pcid="33713">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class Main {

	public static void main(String[] args) throws NumberFormatException, IOException {
		// TODO ?????????????????????????????????????????????
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());

        int[][] board = new int[8][8];
        
        for(int i = 0; i < 8 ; i++){
        	Arrays.fill(board[i], 0);
        }
        
        for(int i = 0; i < n; i++){
        	String[] tmpArray = br.readLine().split(" ");
        	int r = Integer.parseInt(tmpArray[0]);
        	int c = Integer.parseInt(tmpArray[1]);
        	board[r][c] = 1;
        }
        
        int nextC = getAvailableColumn(board, 8);
        if(nextC >= 0){
        	for(int i = 0; i < 8; i++){
        		boolean result = putQueen(board, 8, i, nextC);
        		if(result == true){
        			break;
        		}
        	}
        }
        //print
        for(int i = 0; i < 8; i++){
        	for(int j = 0; j < 8 ; j++){
        		if(board[i][j] == 1){
        			System.out.print("Q");
        		}
        		else{
        			System.out.print(".");
        		}
        	}
        	System.out.println();
        }
	}
	
	static int getAvailableColumn(int[][] board, int n){
		int j;
		for(j = 0; j < n ; j++){
			int queen = 0;
			for(int i = 0; i < n; i++){
				if(board[i][j] == 1){
					queen++;
					break;
				}
			}
			if(queen == 0){
				break;
			}
		}
		
		if(j >= n){
			return -1;
		}
		
		else {
			return j;
		}
	}
	
	static boolean putQueen(int[][] board, int n, int r, int c){
		//System.out.println("n "+n + " r "+r+" c "+c);
		//????????????????????????????????????????????????????????¨??????????????£??????
		for(int i = 0; i < n ; i++){
			if(board[i][c] == 1 && i != r){
				//System.out.println("error 1");
				return false;
			}
			if(board[r][i] == 1 && i != c){
				//System.out.println("error 2");
				return false;
			}
		}
		for(int i = 0; i < n; i++){
			if(  r+i < n && c+i < n && board[r+i][c+i] ==1){
				//System.out.println("error 3");
				return false;
			}
			if( r+i < n && c-i >= 0 && board[r+i][c-i] ==1 ){
				//System.out.println("error 4");
				return false;
			}
			if(  r-i >= 0 && c+i < n && board[r-i][c+i] ==1){
				//System.out.println("error 5");
				return false;
			}
			if( r-i >= 0 && c-i >= 0 && board[r-i][c-i] ==1 ){
				//System.out.println("error 6");
				return false;
			}
		}
		//System.out.println("("+r+","+c+") is OK");
		board[r][c] = 1;
		
		int nextColumn = getAvailableColumn(board, 8);
		if(nextColumn < 0){
			return true;
		}
		for(int i = 0; i < n ; i++){
			boolean result = putQueen(board, n, i, nextColumn);
			if(result == true){
				return true;
			}
		}
		board[r][c] = 0;
		return false;
	}

}


</source>
</class>

<class classid="247" nclones="2" nlines="16" similarity="100">
<source file="../hum_codes_raw/s532333220.java" startline="1" endline="19" pcid="17923">
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int b = sc.nextInt();
			int r = sc.nextInt();
			int g = sc.nextInt();
			int c = sc.nextInt();
			int s = sc.nextInt();
			int t = sc.nextInt();
			if((b|r|g|c|s|t)==0)break;
			System.out.println(100 + b*15 + r*15 + (b*5+r*3)*15 + g*7 + c*2 - (b*5+r*3)*2 - (t-b*5-r*3-s)*3);
		}
	}
}

</source>
<source file="../hum_codes_raw/s941253588.java" startline="1" endline="20" pcid="31647">
import java.util.Scanner;

//Big Hit !
public class Main{

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int b = sc.nextInt();
			int r = sc.nextInt();
			int g = sc.nextInt();
			int c = sc.nextInt();
			int s = sc.nextInt();
			int t = sc.nextInt();
			if((b|r|g|c|s|t)==0)break;
			System.out.println(100 + b*15 + r*15 + (b*5+r*3)*15 + g*7 + c*2 - (b*5+r*3)*2 - (t-b*5-r*3-s)*3);
		}
	}
}

</source>
</class>

<class classid="248" nclones="2" nlines="24" similarity="100">
<source file="../hum_codes_raw/s539285290.java" startline="1" endline="29" pcid="18157">
import java.util.Scanner;
import java.util.Arrays;
 
public class Main{
  public static void main(String[] args){
    Scanner sc = new Scanner(System.in);
 
    long K = sc.nextLong();
    long P = 0L;
    long Dif = 1L;
 
    for(int i = 1; i <= K; i++){
      P += Dif;
      if(helper(P + Dif) > helper(P + 2 * Dif))
      Dif *= 10L;
      System.out.println(P);
    }
  }
  public static double helper(long n){
    double S = (double) n;
    double sum = 0.0;
    while(n != 0){
      sum += (double) n%10;
      n = n/10;
    }
    return S/sum;
  }
}

</source>
<source file="../hum_codes_raw/s605728998.java" startline="1" endline="29" pcid="20344">
import java.util.Scanner;
import java.util.Arrays;

public class Main{
  public static void main(String[] args){
    Scanner sc = new Scanner(System.in);

    long K = sc.nextLong();
    long P = 0L;
    long Dif = 1L;

    for(int i = 1; i <= K; i++){
      P += Dif;
      if(helper(P + Dif) > helper(P + 2 * Dif))
      Dif *= 10L;
      System.out.println(P);
    }
  }
  public static double helper(long n){
    double S = (double) n;
    double sum = 0.0;
    while(n != 0){
      sum += (double) n%10;
      n = n/10;
    }
    return S/sum;
  }
}

</source>
</class>

<class classid="249" nclones="2" nlines="57" similarity="100">
<source file="../hum_codes_raw/s547285486.java" startline="1" endline="55" pcid="18424">
import java.util.Scanner;
public class Main {
	public static void main(String[] args) throws java.io.IOException {
		Scanner scan = new Scanner(System.in);
		int N = scan.nextInt();
		int[] h = new int[N];
		int[] m = new int[N];
		for(int i = 0 ; i<N ; i++){
			h[i] = scan.nextInt();
			m[i] = scan.nextInt();
		}
		int M = scan.nextInt();
		int[] k = new int[M];
		int[] g = new int[M];
		int[] Z = new int[N+M];
		for(int i = 0 ; i<N ; i++){
			Z[i] =  h[i]*60+m[i];
		}
		for(int i = 0; i<M ; i++){
			k[i] = scan.nextInt();
			g[i] = scan.nextInt();
			Z[N+i] = k[i]*60+g[i];
		}
		int r;
		for(int i = 0; i < N+M ; i++){
			for(int j = i+1; j <M+N; j++){
				if(Z[i] > Z[j]){
					r = Z[i];
					Z[i] = Z[j];
					Z[j] = r;
				}
			}
		}
		for(int i = 0; i<N+M; i++){
			if(i == N+M-1){
				String s = String.valueOf(Z[i]%60);
				if(s.length() ==1){
					System.out.println(Z[i]/60+":0"+Z[i]%60);
				}else{
					System.out.println(Z[i]/60+":"+Z[i]%60);
				}
			}else{
				if(Z[i+1] != Z[i]){
					String s = String.valueOf(Z[i]%60);
					if(s.length() ==1){
						System.out.print(Z[i]/60+":0"+Z[i]%60+" ");
					}else{
						System.out.print(Z[i]/60+":"+Z[i]%60+" ");
					}
				}
			}
		}
	}
}

</source>
<source file="../hum_codes_raw/s840836143.java" startline="1" endline="55" pcid="28235">
import java.util.Scanner;
public class Main {
	public static void main(String[] args) throws java.io.IOException {
		Scanner scan = new Scanner(System.in);
		int N = scan.nextInt();
		int[] h = new int[N];
		int[] m = new int[N];
		for(int i = 0 ; i<N ; i++){
			h[i] = scan.nextInt();
			m[i] = scan.nextInt();
		}
		int M = scan.nextInt();
		int[] k = new int[M];
		int[] g = new int[M];
		int[] Z = new int[N+M];
		for(int i = 0 ; i<N ; i++){
			Z[i] =  h[i]*60+m[i];
		}
		for(int i = 0; i<M ; i++){
			k[i] = scan.nextInt();
			g[i] = scan.nextInt();
			Z[N+i] = k[i]*60+g[i];
		}
		int r;
		for(int i = 0; i < N+M ; i++){
			for(int j = i+1; j <M+N; j++){
				if(Z[i] > Z[j]){
					r = Z[i];
					Z[i] = Z[j];
					Z[j] = r;
				}
			}
		}
		for(int i = 0; i<N+M; i++){
			if(i == N+M-1){
				String s = String.valueOf(Z[i]%60);
				if(s.length() ==1){
					System.out.println(Z[i]/60+":0"+Z[i]%60);
				}else{
					System.out.println(Z[i]/60+":"+Z[i]%60);
				}
			}else{
				if(Z[i+1] != Z[i]){
					String s = String.valueOf(Z[i]%60);
					if(s.length() ==1){
						System.out.print(Z[i]/60+":0"+Z[i]%60+" ");
					}else{
						System.out.print(Z[i]/60+":"+Z[i]%60+" ");
					}
				}
			}
		}
	}
}

</source>
</class>

<class classid="250" nclones="2" nlines="80" similarity="100">
<source file="../hum_codes_raw/s548480030.java" startline="1" endline="99" pcid="18468">
import java.util.*;  
import java.lang.*;  
import java.math.*;  
import java.io.*;  
  
import static java.lang.Math.*;  
import static java.util.Arrays.*;  
  
public class Main{  
  
 Scanner sc=new Scanner(System.in);  
  
 int INF=1<<28;  
 double EPS=1e-9;  
  
 HashMap<Integer, Integer> map;  
 int[] a;  
 int w=4, h=2;  
  
 void run(){  
  a=new int[w*h];  
  init();  
  for(; sc.hasNext();){  
   for(int i=0; i<w*h; i++){  
    a[i]=sc.nextInt();  
   }  
   println(""+map.get(id(a)));  
  }  
 }  
  
 void init(){  
  
  LinkedList<S> que=new LinkedList<S>();  
  map=new HashMap<Integer, Integer>();  
  
  que.offer(new S(0, 0, new int[]{0, 1, 2, 3, 4, 5, 6, 7}));  
  map.put(id(que.peek().a), 0);  
  int[] dx={0, 0, -1, 1};  
  int[] dy={-1, 1, 0, 0};  
  
  for(; !que.isEmpty();){  
   S s=que.poll();  
   int p=s.y*w+s.x;  
   for(int i=0; i<4; i++){  
    int x2=s.x+dx[i];  
    int y2=s.y+dy[i];  
    int p2=y2*w+x2;  
    if(x2>=0&&x2<w&&y2>=0&&y2<h){  
     int[] a2=s.a.clone();  
     int t=a2[p];  
     a2[p]=a2[p2];  
     a2[p2]=t;  
     S s2=new S(x2, y2, a2);  
     if(!map.containsKey(id(s2.a))){  
      que.offer(s2);  
      map.put(id(s2.a), map.get(id(s.a))+1);  
     }  
    }  
   }  
  }  
 }  
  
 int id(int[] a){  
  int res=0;  
  for(int e : a){  
   res=res*10+e;  
  }  
  return res;  
 }  
  
 class S{  
  int x, y;  
  int[] a;  
  
  S(int x, int y, int[] a){  
   this.x=x;  
   this.y=y;  
   this.a=a;  
  }  
 }  
  
 void debug(Object... os){  
  System.err.println(Arrays.deepToString(os));  
 }  
  
 void print(String s){  
  System.out.print(s);  
 }  
  
 void println(String s){  
  System.out.println(s);  
 }  
  
 public static void main(String[] args){  
  // System.setOut(new PrintStream(new BufferedOutputStream(System.out)));  
  new Main().run();  
 }  
}  

</source>
<source file="../hum_codes_raw/s925499938.java" startline="1" endline="152" pcid="31129">
import java.util.*;
import java.lang.*;
import java.math.*;
import java.io.*;

import static java.lang.Math.*;
import static java.util.Arrays.*;

public class Main{

	Scanner sc=new Scanner(System.in);

	int INF=1<<28;
	double EPS=1e-9;

	HashMap<Integer, Integer> map;
	int[] a;
	int w=4, h=2;

	void run(){
		a=new int[w*h];
		init();
		for(; sc.hasNext();){
			for(int i=0; i<w*h; i++){
				a[i]=sc.nextInt();
			}
			println(""+map.get(id(a)));
		}
	}

	void init(){

		LinkedList<S> que=new LinkedList<S>();
		map=new HashMap<Integer, Integer>();

		que.offer(new S(0, 0, new int[]{0, 1, 2, 3, 4, 5, 6, 7}));
		map.put(id(que.peek().a), 0);
		int[] dx={0, 0, -1, 1};
		int[] dy={-1, 1, 0, 0};

		for(; !que.isEmpty();){
			S s=que.poll();
			int p=s.y*w+s.x;
			for(int i=0; i<4; i++){
				int x2=s.x+dx[i];
				int y2=s.y+dy[i];
				int p2=y2*w+x2;
				if(x2>=0&&x2<w&&y2>=0&&y2<h){
					int[] a2=s.a.clone();
					int t=a2[p];
					a2[p]=a2[p2];
					a2[p2]=t;
					S s2=new S(x2, y2, a2);
					if(!map.containsKey(id(s2.a))){
						que.offer(s2);
						map.put(id(s2.a), map.get(id(s.a))+1);
					}
				}
			}
		}
		/*
		 * debug("here");
		 * debug(map.get(1234567));
		 * debug(map.get(10234567));
		 * debug(map.get(76543210));
		 */
	}

	int id(int[] a){
		int res=0;
		for(int e : a){
			res=res*10+e;
		}
		return res;
	}

	/*
	 * void solve(){
	 * int x=-1, y=-1;
	 * for(int i=0; i<w*h; i++){
	 * if(a[i]==0){
	 * x=i%w;
	 * y=i/w;
	 * }
	 * }
	 * 
	 * LinkedList<S> que=new LinkedList<S>();
	 * TreeSet<Integer> set=new TreeSet<Integer>();
	 * 
	 * que.offer(new S(x, y, a, 0));
	 * set.add(que.peek().id);
	 * int[] dx={0, 0, -1, 1};
	 * int[] dy={-1, 1, 0, 0};
	 * 
	 * for(; !que.isEmpty();){
	 * S s=que.poll();
	 * 
	 * if(s.id==1234567){
	 * println(""+s.cnt);
	 * return;
	 * }
	 * 
	 * int p=s.y*w+s.x;
	 * for(int i=0; i<4; i++){
	 * int x2=s.x+dx[i];
	 * int y2=s.y+dy[i];
	 * int p2=y2*w+x2;
	 * if(x2>=0&&x2<w&&y2>=0&&y2<h){
	 * int[] a2=s.a.clone();
	 * int t=a2[p];
	 * a2[p]=a2[p2];
	 * a2[p2]=t;
	 * S s2=new S(x2, y2, a2, s.cnt+1);
	 * if(!set.contains(s2.id)){
	 * que.offer(s2);
	 * set.add(s2.id);
	 * }
	 * }
	 * }
	 * }
	 * }
	 */

	class S{
		int x, y;
		int[] a;

		S(int x, int y, int[] a){
			this.x=x;
			this.y=y;
			this.a=a;
		}
	}

	void debug(Object... os){
		System.err.println(Arrays.deepToString(os));
	}

	void print(String s){
		System.out.print(s);
	}

	void println(String s){
		System.out.println(s);
	}

	public static void main(String[] args){
		// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));
		new Main().run();
	}
}

</source>
</class>

<class classid="251" nclones="2" nlines="99" similarity="100">
<source file="../hum_codes_raw/s548942549.java" startline="1" endline="109" pcid="18497">
import java.util.Arrays;
import java.util.HashMap;
import java.util.Scanner;

class Team implements Comparable<Team>{
	int id;
	int syo;
	int slove;
	int penalty;
	Team(int a,int b,int c,int d){
		id=a;
		syo=b;
		slove=c;
		penalty=d;
	}
	@Override
	public int compareTo(Team o) {
		if(o.slove < this.slove){
			return -1;
		}
		else if(o.slove > this.slove){
			return 1;
		}
		else{
			if(o.penalty > this.penalty){
				return -1;
			}
			else if(o.penalty < this.penalty){
				return 1;
			}
			else{
				if(o.id > this.id){
					return -1;
				}
				else if(o.id < this.id){
					return 1;
				}
			}
		}
		return 0;
	}
}

public class Main {
	public static void main(String[] args) {
		new Main().run();
	}
	void run(){
		Scanner sc=new Scanner(System.in);
		while(true){
			int n=sc.nextInt();
			if(n==0) break;
			Team t[]=new Team[n];
			for(int i=0; i<n; i++){
				t[i]=new Team(sc.nextInt(),sc.nextInt(),sc.nextInt(),sc.nextInt());
			}
			Arrays.sort(t);
			
//			for(int i=0; i<n; i++){
//				System.err.println(t[i].id);
//			}
			
			int senbatsu[]=new int[n];
			HashMap<Integer, Integer> h=new HashMap<Integer, Integer>();
			int count=0;
			for(int i=0; i<n; i++){
				if(count<10){
					if(!h.containsKey(t[i].syo)){
						h.put(t[i].syo, 1);
						senbatsu[count]=t[i].id;
						count++;
					}
					else if(h.get(t[i].syo) < 3){
						int temp=h.get(t[i].syo);
						h.put(t[i].syo, temp+1);
						senbatsu[count]=t[i].id;
						count++;
					}
				}
				else if(count<20){
					if(!h.containsKey(t[i].syo)){
						h.put(t[i].syo, 1);
						senbatsu[count]=t[i].id;
						count++;
					}
					else if(h.get(t[i].syo) < 2){
						int temp=h.get(t[i].syo);
						h.put(t[i].syo, temp+1);
						senbatsu[count]=t[i].id;
						count++;
					}
				}
				else if(count<26){
					if(!h.containsKey(t[i].syo)){
						h.put(t[i].syo, 1);
						senbatsu[count]=t[i].id;
						count++;
					}
				}
			}
			//Arrays.sort(senbatsu, 0, count);
			for(int i=0; i<count; i++){
				System.out.println(senbatsu[i]);
			}
		}
	}

}

</source>
<source file="../hum_codes_raw/s782975474.java" startline="1" endline="109" pcid="26288">
import java.util.Arrays;
import java.util.HashMap;
import java.util.Scanner;

class Team implements Comparable<Team>{
	int id;
	int syo;
	int slove;
	int penalty;
	Team(int a,int b,int c,int d){
		id=a;
		syo=b;
		slove=c;
		penalty=d;
	}
	@Override
	public int compareTo(Team o) {
		if(o.slove < this.slove){
			return -1;
		}
		else if(o.slove > this.slove){
			return 1;
		}
		else{
			if(o.penalty > this.penalty){
				return -1;
			}
			else if(o.penalty < this.penalty){
				return 1;
			}
			else{
				if(o.id > this.id){
					return -1;
				}
				else if(o.id < this.id){
					return 1;
				}
			}
		}
		return 0;
	}
}

public class Main {
	public static void main(String[] args) {
		new Main().run();
	}
	void run(){
		Scanner sc=new Scanner(System.in);
		while(true){
			int n=sc.nextInt();
			if(n==0) break;
			Team t[]=new Team[n];
			for(int i=0; i<n; i++){
				t[i]=new Team(sc.nextInt(),sc.nextInt(),sc.nextInt(),sc.nextInt());
			}
			Arrays.sort(t);
			
//			for(int i=0; i<n; i++){
//				System.err.println(t[i].id);
//			}
			
			int senbatsu[]=new int[n];
			HashMap<Integer, Integer> h=new HashMap<Integer, Integer>();
			int count=0;
			for(int i=0; i<n; i++){
				if(count<10){
					if(!h.containsKey(t[i].syo)){
						h.put(t[i].syo, 1);
						senbatsu[count]=t[i].id;
						count++;
					}
					else if(h.get(t[i].syo) < 3){
						int temp=h.get(t[i].syo);
						h.put(t[i].syo, temp+1);
						senbatsu[count]=t[i].id;
						count++;
					}
				}
				else if(count<20){
					if(!h.containsKey(t[i].syo)){
						h.put(t[i].syo, 1);
						senbatsu[count]=t[i].id;
						count++;
					}
					else if(h.get(t[i].syo) < 2){
						int temp=h.get(t[i].syo);
						h.put(t[i].syo, temp+1);
						senbatsu[count]=t[i].id;
						count++;
					}
				}
				else if(count<26){
					if(!h.containsKey(t[i].syo)){
						h.put(t[i].syo, 1);
						senbatsu[count]=t[i].id;
						count++;
					}
				}
			}
			//Arrays.sort(senbatsu, 0, count);
			for(int i=0; i<count; i++){
				System.out.println(senbatsu[i]);
			}
		}
	}

}

</source>
</class>

<class classid="252" nclones="2" nlines="31" similarity="100">
<source file="../hum_codes_raw/s551783329.java" startline="1" endline="34" pcid="18595">
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			char[] s = sc.next().toCharArray();
			if(s[0]=='0')break;
			int a = 0;
			int b = 0;
			for(int i=1;i<s.length;i++){
				if(s[i]=='A')a++;
				else b++;
			}
			if(a>b)a++;
			else b++;
			System.out.println(a+" "+b);
			for(int j=0;j<2;j++){
				s = sc.next().toCharArray();
				a = 0;
				b = 0;
				for(int i=1;i<s.length;i++){
					if(s[i]=='A')a++;
					else b++;
				}
				if(a>b)a++;
				else b++;
				System.out.println(a+" "+b);
			}
		}
	}
}

</source>
<source file="../hum_codes_raw/s643016294.java" startline="1" endline="35" pcid="21571">
import java.util.Scanner;

//Badminton
public class Main{

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			char[] s = sc.next().toCharArray();
			if(s[0]=='0')break;
			int a = 0;
			int b = 0;
			for(int i=1;i<s.length;i++){
				if(s[i]=='A')a++;
				else b++;
			}
			if(a>b)a++;
			else b++;
			System.out.println(a+" "+b);
			for(int j=0;j<2;j++){
				s = sc.next().toCharArray();
				a = 0;
				b = 0;
				for(int i=1;i<s.length;i++){
					if(s[i]=='A')a++;
					else b++;
				}
				if(a>b)a++;
				else b++;
				System.out.println(a+" "+b);
			}
		}
	}
}

</source>
</class>

<class classid="253" nclones="2" nlines="66" similarity="100">
<source file="../hum_codes_raw/s555688246.java" startline="1" endline="79" pcid="18724">
import java.util.*;
import java.io.*;
import java.lang.*;
class Main{
  public static void main(String args[]){
    int id, l, r,root=0;
    StringBuilder build = new StringBuilder();
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();
    Node node[] = new Node[n];

    for(int i = 0; i<n; i++){
      node[i] = new Node();
    }

    for(int i = 0; i<n; i++){
      id = sc.nextInt();
      l = sc.nextInt();
      r =  sc.nextInt();
      node[id].left = l;
      node[id].right = r;
      if(l != -1)node[l].parent = id;
      if(r != -1)node[r].parent = id;
    }

    for(int i = 0;i<n; i++){
      if(node[i].parent==-1)root = i;
    }
    setDepth(root,0,node);

    for(int i = 0 ; i < n; i++){
      build.append("node ").append(i).append(": parent = ").append(node[i].parent).append(", sibling = ").append(getSibling(i,node)).append(", degree = ").append(getDegree(i,node)).append(", depth = ").append(node[i].depth).append(", height = ").append(getHeight(i, node));
      if(node[i].parent==-1)build.append(", root\n");
      else if(node[i].right == -1 && node[i].left == -1)build.append(", leaf\n");
      else build.append(", internal node\n");
    }

    System.out.print(build);

  }

  static int getHeight(int u, Node node[]){
    int h1 = 0;
    int h2 = 0;
    if(node[u].right != -1)h1 = getHeight(node[u].right, node) +1;
    if(node[u].left != -1)h2 = getHeight(node[u].left, node) +1;

    return Math.max(h1,h2);
  }

  static void setDepth(int u,int d,Node node_d[]){
    if( u == -1)return;
    node_d[u].depth = d;
    setDepth(node_d[u].right,node_d[u].depth+1, node_d);
    setDepth(node_d[u].left, node_d[u].depth+1, node_d);
  }

  static int getSibling(int u, Node node[]){
    if(node[u].parent == -1)return (-1);
    if(node[node[u].parent].left != u && node[node[u].parent].left!=-1)return node[node[u].parent].left;
    if(node[node[u].parent].right != u && node[node[u].parent].right!=-1)return node[node[u].parent].right;
    return (-1);
  }

  static int getDegree(int u, Node node[]){
    int count=0;
    if(node[u].left != -1)count++;
    if(node[u].right != -1)count++;
    return count;
  }
}

class Node{
  int parent = -1;
  int left = -1;
  int right = -1;
  int depth = 0;
}

</source>
<source file="../hum_codes_raw/s653475569.java" startline="1" endline="79" pcid="21932">
import java.util.*;
import java.io.*;
import java.lang.*;
class Main{
  public static void main(String args[]){
    int id, l, r,root=0;
    StringBuilder build = new StringBuilder();
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();
    Node node[] = new Node[n];

    for(int i = 0; i<n; i++){
      node[i] = new Node();
    }

    for(int i = 0; i<n; i++){
      id = sc.nextInt();
      l = sc.nextInt();
      r =  sc.nextInt();
      node[id].left = l;
      node[id].right = r;
      if(l != -1)node[l].parent = id;
      if(r != -1)node[r].parent = id;
    }

    for(int i = 0;i<n; i++){
      if(node[i].parent==-1)root = i;
    }
    setDepth(root,0,node);

    for(int i = 0 ; i < n; i++){
      build.append("node ").append(i).append(": parent = ").append(node[i].parent).append(", sibling = ").append(getSibling(i,node)).append(", degree = ").append(getDegree(i,node)).append(", depth = ").append(node[i].depth).append(", height = ").append(getHeight(i, node));
      if(node[i].parent==-1)build.append(", root\n");
      else if(node[i].right == -1 && node[i].left == -1)build.append(", leaf\n");
      else build.append(", internal node\n");
    }

    System.out.print(build);

  }

  static int getHeight(int u, Node node[]){
    int h1 = 0;
    int h2 = 0;
    if(node[u].right != -1)h1 = getHeight(node[u].right, node) +1;
    if(node[u].left != -1)h2 = getHeight(node[u].left, node) +1;

    return Math.max(h1,h2);
  }

  static void setDepth(int u,int d,Node node_d[]){
    if( u == -1)return;
    node_d[u].depth = d;
    setDepth(node_d[u].right,node_d[u].depth+1, node_d);
    setDepth(node_d[u].left, node_d[u].depth+1, node_d);
  }

  static int getSibling(int u, Node node[]){
    if(node[u].parent == -1)return (-1);
    if(node[node[u].parent].left != u && node[node[u].parent].left!=-1)return node[node[u].parent].left;
    if(node[node[u].parent].right != u && node[node[u].parent].right!=-1)return node[node[u].parent].right;
    return (-1);
  }

  static int getDegree(int u, Node node[]){
    int count=0;
    if(node[u].left != -1)count++;
    if(node[u].right != -1)count++;
    return count;
  }
}

class Node{
  int parent = -1;
  int left = -1;
  int right = -1;
  int depth = 0;
}

</source>
</class>

<class classid="254" nclones="2" nlines="33" similarity="100">
<source file="../hum_codes_raw/s561705604.java" startline="1" endline="37" pcid="18911">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

class Main{
	public static void main(String[] args)throws IOException {
		String str="";
		BufferedReader bfr = new BufferedReader(new InputStreamReader(System.in));
		String[] datas;
		int[] rika=new int[4];
		int[] syakai=new int[2];
		int rikamin=100;
		int syamin=100;

		int sum=0;

		for(int i=0; i<6; i++) {
			if(i<4) {
				rika[i]=Integer.parseInt(bfr.readLine());
				if(rika[i]<rikamin) {
					rikamin=rika[i];
				}
				sum+=rika[i];
			}
			else if(i>=4) {
				syakai[i-4]=Integer.parseInt(bfr.readLine());
				if(syakai[i-4]<syamin) {
					syamin=syakai[i-4];
				}
				sum+=syakai[i-4];
			}
		}
		sum=sum-syamin-rikamin;
		System.out.println(sum);
	}
}

</source>
<source file="../hum_codes_raw/s561966545.java" startline="1" endline="37" pcid="18920">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

class Main{
	public static void main(String[] args)throws IOException {
		String str="";
		BufferedReader bfr = new BufferedReader(new InputStreamReader(System.in));
		String[] datas;
		int[] rika=new int[4];
		int[] syakai=new int[2];
		int rikamin=100;
		int syamin=100;

		int sum=0;

		for(int i=0; i<6; i++) {
			if(i<4) {
				rika[i]=Integer.parseInt(bfr.readLine());
				if(rika[i]<rikamin) {
					rikamin=rika[i];
				}
				sum+=rika[i];
			}
			else if(i>=4) {
				syakai[i-4]=Integer.parseInt(bfr.readLine());
				if(syakai[i-4]<syamin) {
					syamin=syakai[i-4];
				}
				sum+=syakai[i-4];
			}
		}
		sum=sum-syamin-rikamin;
		System.out.println(sum);
	}
}

</source>
</class>

<class classid="255" nclones="2" nlines="102" similarity="100">
<source file="../hum_codes_raw/s565613690.java" startline="1" endline="119" pcid="19029">
import java.io.*;
import java.math.*;
import java.util.*;

public class Main {
    private static boolean debug = false;
    private static boolean elapsed = false;

    private static PrintWriter _out = new PrintWriter(System.out);
    private static PrintWriter _err = new PrintWriter(System.err);

    private Map<Integer, Node> nodes = new HashMap<>();

    private boolean[][] memo;

    private static class Node {
        int no;
        List<Node> list = new ArrayList<>();
        int color;
        public Node(int no) {
            this.no = no;
        }
    }
    private static class Query {
        int v;
        int d;
        int c;
        public Query(int v, int d, int c) {
            this.v = v;
            this.d = d;
            this.c = c;
        }
    }
    private void solve(Scanner sc) {
        int N = sc.nextInt();
        int M = sc.nextInt();
        for (int i = 0; i < N; ++i) {
            nodes.put(i + 1, new Node(i + 1));
        }
        for (int i = 0; i < M; ++i) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            nodes.get(a).list.add(nodes.get(b));
            nodes.get(b).list.add(nodes.get(a));
        }
        int Q = sc.nextInt();
        List<Query> queryList = new ArrayList<>();
        for (int i = 0; i < Q; ++i) {
            int v = sc.nextInt();
            int d = sc.nextInt();
            int c = sc.nextInt();
            Query query = new Query(v, d, c);
            queryList.add(query);
        }

        Collections.reverse(queryList);

        memo = new boolean[N + 1][11];

        for (Query query : queryList) {
            paint(query.v, query.d, query.c);
        }

        for (int i = 0; i < N; ++i) {
            _out.println(nodes.get(i + 1).color);
        }
    }
    private void paint(int v, int d, int c) {
        if (memo[v][d]) {
            return;
        }
        memo[v][d] = true;
        if (d == 0) {
            nodes.get(v).color = c;
            return;
        }

        Node node = nodes.get(v);
        paint(v, d - 1, c);
        for (Node child : node.list) {
            paint(child.no, d - 1, c);
        }
    }
    private static BigInteger C(long n, long r) {
        BigInteger res = BigInteger.ONE;
        for (long i = n; i > n - r; --i) {
            res = res.multiply(BigInteger.valueOf(i));
        }
        for (long i = r; i > 1; --i) {
            res = res.divide(BigInteger.valueOf(i));
        }
        return res;
    }
    private static BigInteger P(long n, long r) {
        BigInteger res = BigInteger.ONE;
        for (long i = n; i > n - r; --i) {
            res = res.multiply(BigInteger.valueOf(i));
        }
        return res;
    }
    /*
     * 10^10 > Integer.MAX_VALUE = 2147483647 > 10^9
     * 10^19 > Long.MAX_VALUE = 9223372036854775807L > 10^18
     */
    public static void main(String[] args) {
        long S = System.currentTimeMillis();

        Scanner sc = new Scanner(System.in);
        new Main().solve(sc);
        _out.flush();

        long G = System.currentTimeMillis();
        if (elapsed) {
            _err.println((G - S) + "ms");
        }
        _err.flush();
    }
}

</source>
<source file="../hum_codes_raw/s997922792.java" startline="1" endline="119" pcid="33598">
import java.io.*;
import java.math.*;
import java.util.*;
 
public class Main {
    private static boolean debug = false;
    private static boolean elapsed = false;
 
    private static PrintWriter _out = new PrintWriter(System.out);
    private static PrintWriter _err = new PrintWriter(System.err);
 
    private Map<Integer, Node> nodes = new HashMap<>();
 
    private boolean[][] memo;
 
    private static class Node {
        int no;
        List<Node> list = new ArrayList<>();
        int color;
        public Node(int no) {
            this.no = no;
        }
    }
    private static class Query {
        int v;
        int d;
        int c;
        public Query(int v, int d, int c) {
            this.v = v;
            this.d = d;
            this.c = c;
        }
    }
    private void solve(Scanner sc) {
        int N = sc.nextInt();
        int M = sc.nextInt();
        for (int i = 0; i < N; ++i) {
            nodes.put(i + 1, new Node(i + 1));
        }
        for (int i = 0; i < M; ++i) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            nodes.get(a).list.add(nodes.get(b));
            nodes.get(b).list.add(nodes.get(a));
        }
        int Q = sc.nextInt();
        List<Query> queryList = new ArrayList<>();
        for (int i = 0; i < Q; ++i) {
            int v = sc.nextInt();
            int d = sc.nextInt();
            int c = sc.nextInt();
            Query query = new Query(v, d, c);
            queryList.add(query);
        }
 
        Collections.reverse(queryList);
 
        memo = new boolean[N + 1][11];
 
        for (Query query : queryList) {
            paint(query.v, query.d, query.c);
        }
 
        for (int i = 0; i < N; ++i) {
            _out.println(nodes.get(i + 1).color);
        }
    }
    private void paint(int v, int d, int c) {
        if (memo[v][d]) {
            return;
        }
        memo[v][d] = true;
        if (d == 0) {
            nodes.get(v).color = c;
            return;
        }
 
        Node node = nodes.get(v);
        paint(v, d - 1, c);
        for (Node child : node.list) {
            paint(child.no, d - 1, c);
        }
    }
    private static BigInteger C(long n, long r) {
        BigInteger res = BigInteger.ONE;
        for (long i = n; i > n - r; --i) {
            res = res.multiply(BigInteger.valueOf(i));
        }
        for (long i = r; i > 1; --i) {
            res = res.divide(BigInteger.valueOf(i));
        }
        return res;
    }
    private static BigInteger P(long n, long r) {
        BigInteger res = BigInteger.ONE;
        for (long i = n; i > n - r; --i) {
            res = res.multiply(BigInteger.valueOf(i));
        }
        return res;
    }
    /*
     * 10^10 > Integer.MAX_VALUE = 2147483647 > 10^9
     * 10^19 > Long.MAX_VALUE = 9223372036854775807L > 10^18
     */
    public static void main(String[] args) {
        long S = System.currentTimeMillis();
 
        Scanner sc = new Scanner(System.in);
        new Main().solve(sc);
        _out.flush();
 
        long G = System.currentTimeMillis();
        if (elapsed) {
            _err.println((G - S) + "ms");
        }
        _err.flush();
    }
}

</source>
</class>

<class classid="256" nclones="2" nlines="318" similarity="100">
<source file="../hum_codes_raw/s566789840.java" startline="1" endline="375" pcid="19062">
import java.io.*;
import java.util.*;

class Solver {
  int n;
  long[] xs;
  long[] ys;
  String[] ds;
  
  
  long[] xds;
  long[] yds;
  
  public Solver(int n, long[] xs, long[] ys, String[] ds) {
    this.n = n;
    this.xs = xs;
    this.ys = ys;
    this.ds = ds;
  }
  
  public double solve() {
    xds = new long[n];
    yds = new long[n];
    
    for (int i = 0; i < n; i++) {
      switch(ds[i].charAt(0)) {
        case 'R':
          xds[i] = 1;
          yds[i] = 0;
          break;
        case 'L':
          xds[i] = -1;
          yds[i] = 0;
          break;
        case 'U':
          xds[i] = 0;
          yds[i] = 1;
          break;
        case 'D':
          xds[i] = 0;
          yds[i] = -1;
          break;
      }
    }
    
    List<Double> allHitTimes = new ArrayList<>();
    allHitTimes.add(0.0);
    allHitTimes.addAll(findMaxPointDirectionChangeTime(xs, xds));
    allHitTimes.addAll(findMaxPointDirectionChangeTime(ys, yds));
    reverseWorld();
    allHitTimes.addAll(findMaxPointDirectionChangeTime(xs, xds));
    allHitTimes.addAll(findMaxPointDirectionChangeTime(ys, yds));
    reverseWorld();
    
    Collections.sort(allHitTimes);
    double areaMin = solveTimeAt(allHitTimes.get(allHitTimes.size() - 1));
    for (int i = 1; i < allHitTimes.size(); i++) {
      areaMin = Math.min(areaMin, solveTimeRange(allHitTimes.get(i-1), allHitTimes.get(i)));
    }
    return areaMin;
  }
  
  private double solveTimeRange(double timeMin, double timeMax) {
    double timeMid = 0.5 * (timeMin + timeMax);
    
    double xMin = Double.MAX_VALUE;
    double xMax = -1.0 * Double.MAX_VALUE;
    double yMin = Double.MAX_VALUE;
    double yMax = -1.0 * Double.MAX_VALUE;
    int xMinIndex = 0;
    int xMaxIndex = 0;
    int yMinIndex = 0;
    int yMaxIndex = 0;
    
    for (int i = 0; i < n; i++) {
      double x = (double)xs[i] + (double)xds[i] * timeMid;
      double y = (double)ys[i] + (double)yds[i] * timeMid;
      if (xMin > x) {
        xMin = x;
        xMinIndex = i;
      }
      if (xMax < x) {
        xMax = x;
        xMaxIndex = i;
      }
      if (yMin > y) {
        yMin = y;
        yMinIndex = i;
      }
      if (yMax < y) {
        yMax = y;
        yMaxIndex = i;
      }
    }
    
    double w = xs[xMaxIndex] - xs[xMinIndex];
    double wd = xds[xMaxIndex] - xds[xMinIndex];
    double h = ys[yMaxIndex] - ys[yMinIndex];
    double hd = yds[yMaxIndex] - yds[yMinIndex];
    
    // Min (w + wd * t) * (h + hd * t)
    double a = wd * hd;
    double b = wd * h + hd * w;
    double c = w * h;
    return calculateMin(a, b, c, timeMin, timeMax);
  }
  
  private double calculate(double a, double b, double c, double x) {
    return a * x * x + b * x + c;
  }
  
  private double calculateMin(double a, double b, double c, double xMin, double xMax) {
    if (a == 0 && b == 0) {
      return c;
    }
    if (a == 0 && b > 0) {
      return calculate(a, b, c, xMin);
    }
    if (a == 0 && b < 0) {
      return calculate(a, b, c, xMax);
    }
    double answer = calculate(a, b, c, xMin);
    answer = Math.min(answer, calculate(a, b, c, xMax));
    
    double xAxis = -0.5 * b / a;
    if (xMin <= xAxis && xAxis <= xMax) {
      answer = Math.min(answer, calculate(a, b, c, xAxis));
    }
    return answer;
  }
  
  private double solveTimeAt(double time) {
    double xMin = Double.MAX_VALUE;
    double xMax = -1.0 * Double.MAX_VALUE;
    double yMin = Double.MAX_VALUE;
    double yMax = -1.0 * Double.MAX_VALUE;
    
    for (int i = 0; i < n; i++) {
      double x = (double)xs[i] + (double)xds[i] * time;
      double y = (double)ys[i] + (double)yds[i] * time;
      xMin = Math.min(xMin, x);
      xMax = Math.max(xMax, x);
      yMin = Math.min(yMin, y);
      yMax = Math.max(yMax, y);
    }
    return (xMax - xMin) * (yMax - yMin);
  }
  
  private void reverseWorld() {
    for (int i = 0; i < n; i++) {
      xs[i] *= -1;
      ys[i] *= -1;
      xds[i] *= -1;
      yds[i] *= -1;
    }
  }
  
  
  private List<Double> findMaxPointDirectionChangeTime(long[] zs, long[] zds) {
    List<Double> hitTimes = new ArrayList<>();
    
    long maxPointZ = zs[0];
    long maxPointZD = zds[0];
    for (int i = 1; i < n; i++) {
      if (maxPointZ < zs[i]) {
        maxPointZ = zs[i];
        maxPointZD = zds[i];
      }
    }
    if (maxPointZD > 0) {
      return hitTimes;
    }
    
    double firstHitTime = Double.MAX_VALUE;
    long firstHitZ = 0;
    long firstHitZD = 0;
    for (int i = 0; i < n; i++) {
      if (zds[i] == maxPointZD || zds[i] < 0) {
        continue;
      }
      // maxPointZ + t * maxPointZD == zs[i] + t * zds[i]
      // maxPointZ + t * maxPointZD == zs[i] + t * zds[i]
      double t = -1.0 * (maxPointZ - zs[i]) / (maxPointZD - zds[i]);
      if (0.0 <= t && t < firstHitTime) {
        firstHitTime = t;
        firstHitZ = zs[i];
        firstHitZD = zds[i];
      }
    }
    
    if (firstHitTime == Double.MAX_VALUE) {
      return hitTimes;
    }
    hitTimes.add(firstHitTime);
    
    if (firstHitZD > 0) {
      return hitTimes;
    }
    
    double secondHitTime = Double.MAX_VALUE;
    for (int i = 0; i < n; i++) {
      if (zds[i] <= 0) {
        continue;
      }
      
      double t = -1.0 * (firstHitZ - zs[i]) / (firstHitZD - zds[i]);
      if (firstHitTime <= t && t < secondHitTime) {
        secondHitTime = t;
      }
    }
    
    if (secondHitTime == Double.MAX_VALUE) {
      return hitTimes;
    }
    
    hitTimes.add(secondHitTime);
    return hitTimes;
  }
}

public class Main {
  private static void execute(ContestReader reader, PrintWriter out) {
    int n = reader.nextInt();
    long[] xs = new long[n];
    long[] ys = new long[n];
    String[] ds = new String[n];
    for (int i = 0; i < n; i++) {
      xs[i] = reader.nextLong();
      ys[i] = reader.nextLong();
      ds[i] = reader.next();
    }
    out.printf("%.20f\n", new Solver(n, xs, ys, ds).solve());
  }
  
  public static void main(String[] args) {
    ContestReader reader = new ContestReader(System.in);
    PrintWriter out = new PrintWriter(System.out);
    execute(reader, out);
    out.flush();
  }
}

class ContestReader {
  private BufferedReader reader;
  private StringTokenizer tokenizer;
  
  ContestReader(InputStream in) {
    reader = new BufferedReader(new InputStreamReader(in));
  }
  
  public String next() {
    while (tokenizer == null || !tokenizer.hasMoreTokens()) {
      try {
        tokenizer = new java.util.StringTokenizer(reader.readLine());
      } catch (Exception e) {
        throw new RuntimeException(e);
      }
    }
    return tokenizer.nextToken();
  }
  
  public int nextInt() {
    return Integer.parseInt(next());
  }
  
  public long nextLong() {
    return Long.parseLong(next());
  }
  
  public double nextDouble() {
    return Double.parseDouble(next());
  }
  
  public int[] nextIntArray(int n) {
    int[] array = new int[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextInt();
    }
    return array;
  }
  
  public long[] nextLongArray(int n) {
    long[] array = new long[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextLong();
    }
    return array;
  }
  
  public int[][] nextIntMatrix(int n, int m) {
    int[][] matrix = new int[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextInt();
      }
    }
    return matrix;
  }
  
  public long[][] nextLongMatrix(int n, int m) {
    long[][] matrix = new long[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextInt();
      }
    }
    return matrix;
  }
}

class Algorithm {
  private static void swap(Object[] list, int a, int b) {
    Object tmp = list[a];
    list[a] = list[b];
    list[b] = tmp;
  }
  
  public static <T extends Comparable<? super T>> boolean nextPermutation(T[] ts) {
    int rightMostAscendingOrderIndex = ts.length - 2;
    while (rightMostAscendingOrderIndex >= 0 &&
        ts[rightMostAscendingOrderIndex].compareTo(ts[rightMostAscendingOrderIndex + 1]) >= 0) {
      rightMostAscendingOrderIndex--;
    }
    if (rightMostAscendingOrderIndex < 0) {
      return false;
    }
    
    int rightMostGreatorIndex = ts.length - 1;
    while (ts[rightMostAscendingOrderIndex].compareTo(ts[rightMostGreatorIndex]) >= 0) {
      rightMostGreatorIndex--;
    }
    
    swap(ts, rightMostAscendingOrderIndex, rightMostGreatorIndex);
    for (int i = 0; i < (ts.length - rightMostAscendingOrderIndex - 1) / 2; i++) {
      swap(ts, rightMostAscendingOrderIndex + 1 + i, ts.length - 1 - i);
    }
    return true;
  }
  
  public static void shuffle(int[] array) {
    Random random = new Random();
    int n = array.length;
    for (int i = 0; i < n; i++) {
      int randomIndex = i + random.nextInt(n - i);
      
      int temp = array[i];
      array[i] = array[randomIndex];
      array[randomIndex] = temp;
    }
  }
  
  public static void shuffle(long[] array) {
    Random random = new Random();
    int n = array.length;
    for (int i = 0; i < n; i++) {
      int randomIndex = i + random.nextInt(n - i);
      
      long temp = array[i];
      array[i] = array[randomIndex];
      array[randomIndex] = temp;
    }
  }
  
  public static void sort(int[] array) {
    shuffle(array);
    Arrays.sort(array);
  }
  
  public static void sort(long[] array) {
    shuffle(array);
    Arrays.sort(array);
  }
}


</source>
<source file="../hum_codes_raw/s988807814.java" startline="1" endline="375" pcid="33254">
import java.io.*;
import java.util.*;

class Solver {
  int n;
  long[] xs;
  long[] ys;
  String[] ds;
  
  
  long[] xds;
  long[] yds;
  
  public Solver(int n, long[] xs, long[] ys, String[] ds) {
    this.n = n;
    this.xs = xs;
    this.ys = ys;
    this.ds = ds;
  }
  
  public double solve() {
    xds = new long[n];
    yds = new long[n];
    
    for (int i = 0; i < n; i++) {
      switch(ds[i].charAt(0)) {
        case 'R':
          xds[i] = 1;
          yds[i] = 0;
          break;
        case 'L':
          xds[i] = -1;
          yds[i] = 0;
          break;
        case 'U':
          xds[i] = 0;
          yds[i] = 1;
          break;
        case 'D':
          xds[i] = 0;
          yds[i] = -1;
          break;
      }
    }
    
    List<Double> allHitTimes = new ArrayList<>();
    allHitTimes.add(0.0);
    allHitTimes.addAll(findMaxPointDirectionChangeTime(xs, xds));
    allHitTimes.addAll(findMaxPointDirectionChangeTime(ys, yds));
    reverseWorld();
    allHitTimes.addAll(findMaxPointDirectionChangeTime(xs, xds));
    allHitTimes.addAll(findMaxPointDirectionChangeTime(ys, yds));
    reverseWorld();
    
    Collections.sort(allHitTimes);
    double areaMin = solveTimeAt(allHitTimes.get(allHitTimes.size() - 1));
    for (int i = 1; i < allHitTimes.size(); i++) {
      areaMin = Math.min(areaMin, solveTimeRange(allHitTimes.get(i-1), allHitTimes.get(i)));
    }
    return areaMin;
  }
  
  private double solveTimeRange(double timeMin, double timeMax) {
    double timeMid = 0.5 * (timeMin + timeMax);
    
    double xMin = Double.MAX_VALUE;
    double xMax = -1.0 * Double.MAX_VALUE;
    double yMin = Double.MAX_VALUE;
    double yMax = -1.0 * Double.MAX_VALUE;
    int xMinIndex = 0;
    int xMaxIndex = 0;
    int yMinIndex = 0;
    int yMaxIndex = 0;
    
    for (int i = 0; i < n; i++) {
      double x = (double)xs[i] + (double)xds[i] * timeMid;
      double y = (double)ys[i] + (double)yds[i] * timeMid;
      if (xMin > x) {
        xMin = x;
        xMinIndex = i;
      }
      if (xMax < x) {
        xMax = x;
        xMaxIndex = i;
      }
      if (yMin > y) {
        yMin = y;
        yMinIndex = i;
      }
      if (yMax < y) {
        yMax = y;
        yMaxIndex = i;
      }
    }
    
    double w = xs[xMaxIndex] - xs[xMinIndex];
    double wd = xds[xMaxIndex] - xds[xMinIndex];
    double h = ys[yMaxIndex] - ys[yMinIndex];
    double hd = yds[yMaxIndex] - yds[yMinIndex];
    
    // Min (w + wd * t) * (h + hd * t)
    double a = wd * hd;
    double b = wd * h + hd * w;
    double c = w * h;
    return calculateMin(a, b, c, timeMin, timeMax);
  }
  
  private double calculate(double a, double b, double c, double x) {
    return a * x * x + b * x + c;
  }
  
  private double calculateMin(double a, double b, double c, double xMin, double xMax) {
    if (a == 0 && b == 0) {
      return c;
    }
    if (a == 0 && b > 0) {
      return calculate(a, b, c, xMin);
    }
    if (a == 0 && b < 0) {
      return calculate(a, b, c, xMax);
    }
    double answer = calculate(a, b, c, xMin);
    answer = Math.min(answer, calculate(a, b, c, xMax));
    
    double xAxis = -0.5 * b / a;
    if (xMin <= xAxis && xAxis <= xMax) {
      answer = Math.min(answer, calculate(a, b, c, xAxis));
    }
    return answer;
  }
  
  private double solveTimeAt(double time) {
    double xMin = Double.MAX_VALUE;
    double xMax = -1.0 * Double.MAX_VALUE;
    double yMin = Double.MAX_VALUE;
    double yMax = -1.0 * Double.MAX_VALUE;
    
    for (int i = 0; i < n; i++) {
      double x = (double)xs[i] + (double)xds[i] * time;
      double y = (double)ys[i] + (double)yds[i] * time;
      xMin = Math.min(xMin, x);
      xMax = Math.max(xMax, x);
      yMin = Math.min(yMin, y);
      yMax = Math.max(yMax, y);
    }
    return (xMax - xMin) * (yMax - yMin);
  }
  
  private void reverseWorld() {
    for (int i = 0; i < n; i++) {
      xs[i] *= -1;
      ys[i] *= -1;
      xds[i] *= -1;
      yds[i] *= -1;
    }
  }
  
  
  private List<Double> findMaxPointDirectionChangeTime(long[] zs, long[] zds) {
    List<Double> hitTimes = new ArrayList<>();
    
    long maxPointZ = zs[0];
    long maxPointZD = zds[0];
    for (int i = 1; i < n; i++) {
      if (maxPointZ < zs[i]) {
        maxPointZ = zs[i];
        maxPointZD = zds[i];
      }
    }
    if (maxPointZD > 0) {
      return hitTimes;
    }
    
    double firstHitTime = Double.MAX_VALUE;
    long firstHitZ = 0;
    long firstHitZD = 0;
    for (int i = 0; i < n; i++) {
      if (zds[i] == maxPointZD || zds[i] < 0) {
        continue;
      }
      // maxPointZ + t * maxPointZD == zs[i] + t * zds[i]
      // maxPointZ + t * maxPointZD == zs[i] + t * zds[i]
      double t = -1.0 * (maxPointZ - zs[i]) / (maxPointZD - zds[i]);
      if (0.0 <= t && t < firstHitTime) {
        firstHitTime = t;
        firstHitZ = zs[i];
        firstHitZD = zds[i];
      }
    }
    
    if (firstHitTime == Double.MAX_VALUE) {
      return hitTimes;
    }
    hitTimes.add(firstHitTime);
    
    if (firstHitZD > 0) {
      return hitTimes;
    }
    
    double secondHitTime = Double.MAX_VALUE;
    for (int i = 0; i < n; i++) {
      if (zds[i] <= 0) {
        continue;
      }
      
      double t = -1.0 * (firstHitZ - zs[i]) / (firstHitZD - zds[i]);
      if (firstHitTime <= t && t < secondHitTime) {
        secondHitTime = t;
      }
    }
    
    if (secondHitTime == Double.MAX_VALUE) {
      return hitTimes;
    }
    
    hitTimes.add(secondHitTime);
    return hitTimes;
  }
}

public class Main {
  private static void execute(ContestReader reader, PrintWriter out) {
    int n = reader.nextInt();
    long[] xs = new long[n];
    long[] ys = new long[n];
    String[] ds = new String[n];
    for (int i = 0; i < n; i++) {
      xs[i] = reader.nextLong();
      ys[i] = reader.nextLong();
      ds[i] = reader.next();
    }
    out.printf("%.20f\n", new Solver(n, xs, ys, ds).solve());
  }
  
  public static void main(String[] args) {
    ContestReader reader = new ContestReader(System.in);
    PrintWriter out = new PrintWriter(System.out);
    execute(reader, out);
    out.flush();
  }
}

class ContestReader {
  private BufferedReader reader;
  private StringTokenizer tokenizer;
  
  ContestReader(InputStream in) {
    reader = new BufferedReader(new InputStreamReader(in));
  }
  
  public String next() {
    while (tokenizer == null || !tokenizer.hasMoreTokens()) {
      try {
        tokenizer = new java.util.StringTokenizer(reader.readLine());
      } catch (Exception e) {
        throw new RuntimeException(e);
      }
    }
    return tokenizer.nextToken();
  }
  
  public int nextInt() {
    return Integer.parseInt(next());
  }
  
  public long nextLong() {
    return Long.parseLong(next());
  }
  
  public double nextDouble() {
    return Double.parseDouble(next());
  }
  
  public int[] nextIntArray(int n) {
    int[] array = new int[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextInt();
    }
    return array;
  }
  
  public long[] nextLongArray(int n) {
    long[] array = new long[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextLong();
    }
    return array;
  }
  
  public int[][] nextIntMatrix(int n, int m) {
    int[][] matrix = new int[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextInt();
      }
    }
    return matrix;
  }
  
  public long[][] nextLongMatrix(int n, int m) {
    long[][] matrix = new long[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextInt();
      }
    }
    return matrix;
  }
}

class Algorithm {
  private static void swap(Object[] list, int a, int b) {
    Object tmp = list[a];
    list[a] = list[b];
    list[b] = tmp;
  }
  
  public static <T extends Comparable<? super T>> boolean nextPermutation(T[] ts) {
    int rightMostAscendingOrderIndex = ts.length - 2;
    while (rightMostAscendingOrderIndex >= 0 &&
        ts[rightMostAscendingOrderIndex].compareTo(ts[rightMostAscendingOrderIndex + 1]) >= 0) {
      rightMostAscendingOrderIndex--;
    }
    if (rightMostAscendingOrderIndex < 0) {
      return false;
    }
    
    int rightMostGreatorIndex = ts.length - 1;
    while (ts[rightMostAscendingOrderIndex].compareTo(ts[rightMostGreatorIndex]) >= 0) {
      rightMostGreatorIndex--;
    }
    
    swap(ts, rightMostAscendingOrderIndex, rightMostGreatorIndex);
    for (int i = 0; i < (ts.length - rightMostAscendingOrderIndex - 1) / 2; i++) {
      swap(ts, rightMostAscendingOrderIndex + 1 + i, ts.length - 1 - i);
    }
    return true;
  }
  
  public static void shuffle(int[] array) {
    Random random = new Random();
    int n = array.length;
    for (int i = 0; i < n; i++) {
      int randomIndex = i + random.nextInt(n - i);
      
      int temp = array[i];
      array[i] = array[randomIndex];
      array[randomIndex] = temp;
    }
  }
  
  public static void shuffle(long[] array) {
    Random random = new Random();
    int n = array.length;
    for (int i = 0; i < n; i++) {
      int randomIndex = i + random.nextInt(n - i);
      
      long temp = array[i];
      array[i] = array[randomIndex];
      array[randomIndex] = temp;
    }
  }
  
  public static void sort(int[] array) {
    shuffle(array);
    Arrays.sort(array);
  }
  
  public static void sort(long[] array) {
    shuffle(array);
    Arrays.sort(array);
  }
}


</source>
</class>

<class classid="257" nclones="2" nlines="196" similarity="100">
<source file="../hum_codes_raw/s570316752.java" startline="1" endline="235" pcid="19178">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            DReversedLCS solver = new DReversedLCS();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class DReversedLCS {
        char[] s;
        int[][][] dp;

        public int dp(int l, int r, int k) {
            if (l > r) {
                return 0;
            }
            if (l == r) {
                return 1;
            }
            if (dp[l][r][k] == -1) {
                dp[l][r][k] = 0;
                //change nothing
                dp[l][r][k] = Math.max(dp(l + 1, r, k), dp(l, r - 1, k));
                if (s[l] == s[r]) {
                    dp[l][r][k] = dp(l + 1, r - 1, k) + 2;
                }
                if (k > 0) {
                    dp[l][r][k] = Math.max(dp[l][r][k], dp(l + 1, r - 1, k - 1) + 2);
                }
            }
            return dp[l][r][k];
        }

        public void solve(int testNumber, FastInput in, FastOutput out) {
            s = in.readString().toCharArray();
            int k = in.readInt();
            dp = new int[s.length][s.length][k + 1];
            SequenceUtils.deepFill(dp, -1);
            int ans = dp(0, s.length - 1, k);
            out.println(ans);
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class SequenceUtils {
        public static void deepFill(Object array, int val) {
            if (!array.getClass().isArray()) {
                throw new IllegalArgumentException();
            }
            if (array instanceof int[]) {
                int[] intArray = (int[]) array;
                Arrays.fill(intArray, val);
            } else {
                Object[] objArray = (Object[]) array;
                for (Object obj : objArray) {
                    deepFill(obj, val);
                }
            }
        }

    }

    static class FastInput {
        private final InputStream is;
        private StringBuilder defaultStringBuf = new StringBuilder(1 << 13);
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

        public String readString(StringBuilder builder) {
            skipBlank();

            while (next > 32) {
                builder.append((char) next);
                next = read();
            }

            return builder.toString();
        }

        public String readString() {
            defaultStringBuf.setLength(0);
            return readString(defaultStringBuf);
        }

    }
}


</source>
<source file="../hum_codes_raw/s976414384.java" startline="1" endline="235" pcid="32855">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            DReversedLCS solver = new DReversedLCS();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class DReversedLCS {
        char[] s;
        int[][][] dp;

        public int dp(int l, int r, int k) {
            if (l > r) {
                return 0;
            }
            if (l == r) {
                return 1;
            }
            if (dp[l][r][k] == -1) {
                dp[l][r][k] = 0;
                //change nothing
                dp[l][r][k] = Math.max(dp(l + 1, r, k), dp(l, r - 1, k));
                if (s[l] == s[r]) {
                    dp[l][r][k] = dp(l + 1, r - 1, k) + 2;
                }
                if (k > 0) {
                    dp[l][r][k] = Math.max(dp[l][r][k], dp(l + 1, r - 1, k - 1) + 2);
                }
            }
            return dp[l][r][k];
        }

        public void solve(int testNumber, FastInput in, FastOutput out) {
            s = in.readString().toCharArray();
            int k = in.readInt();
            dp = new int[s.length][s.length][k + 1];
            SequenceUtils.deepFill(dp, -1);
            int ans = dp(0, s.length - 1, k);
            out.println(ans);
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class SequenceUtils {
        public static void deepFill(Object array, int val) {
            if (!array.getClass().isArray()) {
                throw new IllegalArgumentException();
            }
            if (array instanceof int[]) {
                int[] intArray = (int[]) array;
                Arrays.fill(intArray, val);
            } else {
                Object[] objArray = (Object[]) array;
                for (Object obj : objArray) {
                    deepFill(obj, val);
                }
            }
        }

    }

    static class FastInput {
        private final InputStream is;
        private StringBuilder defaultStringBuf = new StringBuilder(1 << 13);
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

        public String readString(StringBuilder builder) {
            skipBlank();

            while (next > 32) {
                builder.append((char) next);
                next = read();
            }

            return builder.toString();
        }

        public String readString() {
            defaultStringBuf.setLength(0);
            return readString(defaultStringBuf);
        }

    }
}


</source>
</class>

<class classid="258" nclones="2" nlines="38" similarity="100">
<source file="../hum_codes_raw/s575133689.java" startline="1" endline="51" pcid="19332">

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Stack;

public class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String[] tmpArray = br.readLine().split(" ");
		int n = Integer.parseInt(tmpArray[0]);
		int q = Integer.parseInt(tmpArray[1]);

		@SuppressWarnings("unchecked")
		ArrayList<Integer>[] queue = new ArrayList[n];
		for(int i = 0; i < n; i++){
			queue[i] = new ArrayList<Integer>();
		}

		for(int i = 0; i < q; i++){
			tmpArray = br.readLine().split(" ");

	
			if(tmpArray[0].equals("0")){
				int t = Integer.parseInt(tmpArray[1]);
				int x = Integer.parseInt(tmpArray[2]);

				queue[t].add(x);
			}
	
			else if(tmpArray[0].equals("1")){
				int t = Integer.parseInt(tmpArray[1]);

				if(!queue[t].isEmpty()){
					System.out.println(queue[t].get(0));
				}
			}
			
			else {
				int t = Integer.parseInt(tmpArray[1]);

				if(!queue[t].isEmpty()){
					queue[t].remove(0);
				}
			}
		}
	}
}


</source>
<source file="../hum_codes_raw/s863451359.java" startline="1" endline="51" pcid="29036">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Stack;

public class Main {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String[] tmpArray = br.readLine().split(" ");
		int n = Integer.parseInt(tmpArray[0]);
		int q = Integer.parseInt(tmpArray[1]);

		@SuppressWarnings("unchecked")
		ArrayList<Integer>[] queue = new ArrayList[n];
		for(int i = 0; i < n; i++){
			queue[i] = new ArrayList<Integer>();
		}

		for(int i = 0; i < q; i++){
			tmpArray = br.readLine().split(" ");

			//enqueue
			if(tmpArray[0].equals("0")){
				int t = Integer.parseInt(tmpArray[1]);
				int x = Integer.parseInt(tmpArray[2]);

				queue[t].add(x);
			}
			//front
			else if(tmpArray[0].equals("1")){
				int t = Integer.parseInt(tmpArray[1]);

				if(!queue[t].isEmpty()){
					System.out.println(queue[t].get(0));
				}
			}
			//dequeue
			else {
				int t = Integer.parseInt(tmpArray[1]);

				if(!queue[t].isEmpty()){
					queue[t].remove(0);
				}
			}
		}

	}
}

</source>
</class>

<class classid="259" nclones="2" nlines="55" similarity="100">
<source file="../hum_codes_raw/s577181364.java" startline="1" endline="71" pcid="19379">
import java.io.BufferedReader;
import java.io.InputStreamReader;

public class Main {
	private final static byte MASK_RIGHT = 0x0F; //右4bit数値化用マスク
	private final static int STRIP_LENGTH = 10; //短冊1行の長さ
	private static int[] punchTape = new int[100]; //10*10の方眼紙を短冊にしてくっつけた紙テープ

	public static void main(String[] args) throws Exception {
		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in), 256);
		String sLine;
		while ((sLine = reader.readLine()) != null) {
			droppingInk(sLine.charAt(0) & MASK_RIGHT, sLine.charAt(2) & MASK_RIGHT, sLine.charAt(4) & MASK_RIGHT);
		}
		calcResult();
	}

	/**
	 *都合の良い滴下
	 */
	private static void droppingInk(int x, int y, int size) {
		sinking(x, y - 1);
		sinking(x - 1, y);
		sinking(x, y);
		sinking(x + 1, y);
		sinking(x, y + 1);
		if (size == 1) {
			return;
		}

		sinking(x - 1, y - 1);
		sinking(x + 1, y - 1);
		sinking(x - 1, y + 1);
		sinking(x + 1, y + 1);
		if (size == 2) {
			return;
		}

		sinking(x, y - 2);
		sinking(x - 2, y);
		sinking(x + 2, y);
		sinking(x, y + 2);
	}

	/**
	 * 床は汚さないようにする
	 */
	private static void sinking(int x, int y) {
		if (x >= 0 && x < 10 && y >= 0 && y < 10) {
			punchTape[x * STRIP_LENGTH + y]++;
		}
	}

	/**
	 *紙の染みを数え、損害を報告する
	 */
	private static void calcResult() {
		int white = 0;//綺麗な部分
		int max = 0;//一番ひどい汚れ
		for (int cell : punchTape) {
			if (cell == 0) {
				white++;
			} else if (cell > max) {
				max = cell;
			}
		}
		System.out.println(white);
		System.out.println(max);
	}
}

</source>
<source file="../hum_codes_raw/s762004113.java" startline="1" endline="71" pcid="25595">
import java.io.BufferedReader;
import java.io.InputStreamReader;

public class Main {
	private final static byte MASK_RIGHT = 0x0F; //右4bit数値化用マスク
	private final static int STRIP_LENGTH = 10; //短冊1行の長さ
	private static int[] punchTape = new int[100]; //10*10の方眼紙を短冊にしてくっつけた紙テープ

	public static void main(String[] args) throws Exception {
		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in), 256);
		String sLine;
		while ((sLine = reader.readLine()) != null) {
			droppingInk(sLine.charAt(0) & MASK_RIGHT, sLine.charAt(2) & MASK_RIGHT, sLine.charAt(4) & MASK_RIGHT);
		}
		calcResult();
	}

	/**
	 *都合の良い滴下
	 */
	private static void droppingInk(int x, int y, int size) {
		sinking(x, y - 1);
		sinking(x - 1, y);
		sinking(x, y);
		sinking(x + 1, y);
		sinking(x, y + 1);
		if (size == 1) {
			return;
		}

		sinking(x - 1, y - 1);
		sinking(x + 1, y - 1);
		sinking(x - 1, y + 1);
		sinking(x + 1, y + 1);
		if (size == 2) {
			return;
		}

		sinking(x, y - 2);
		sinking(x - 2, y);
		sinking(x + 2, y);
		sinking(x, y + 2);
	}

	/**
	 * 床は汚さないようにする
	 */
	private static void sinking(int x, int y) {
		if (x >= 0 && x < 10 && y >= 0 && y < 10) {
			punchTape[x * STRIP_LENGTH + y]++;
		}
	}

	/**
	 *紙の染みを数え、損害を報告する
	 */
	private static void calcResult() {
		int white = 0;//綺麗な部分
		int max = 0;//一番ひどい汚れ
		for (int cell : punchTape) {
			if (cell == 0) {
				white++;
			} else if (cell > max) {
				max = cell;
			}
		}
		System.out.println(white);
		System.out.println(max);
	}
}

</source>
</class>

<class classid="260" nclones="2" nlines="65" similarity="100">
<source file="../hum_codes_raw/s577710680.java" startline="1" endline="64" pcid="19397">
import java.util.*;
public class Main {
	private static Scanner sc;
	public static void main(String[] args) {
		sc = new Scanner(System.in);
		byte a = sc.nextByte();
		for (int l=0; l<a; l++){
			byte gx=sc.nextByte();
			byte gy=sc.nextByte();
			byte No [][] = new byte [gx+1][gy+1];
			byte b = sc.nextByte();
			for (int k=0; k<b; k++){
				byte x1=sc.nextByte();
				byte y1=sc.nextByte();
				byte x2=sc.nextByte();
				byte y2=sc.nextByte();
				
				if (x1 == x2) {
					No [x1][(Math.max(y1, y2))]+=1;
				}
				else {No[(Math.max(x1,x2))][y1]+=2;}			
			}
			int Total[][] = new int [gx+1][gy+1];
			Total[0][0] = 1;
			for (int i=0; i<=gx; i++){
				for (int j=0; j<=gy; j++){
					if (No[i][j] == 0){
						if (i>0 & j>0){
							Total[i][j]=Total[i-1][j]+Total[i][j-1];
						}
						else if (i>0){
							Total[i][j]=Total[i-1][j];
						}
						else if (j>0){
							Total[i][j]=Total[i][j-1];
						}
						else;
					}
					else if(No[i][j] == 1){
						if (i>0){
							Total[i][j]=Total[i-1][j];
							}
						else Total[i][j]=0;
					}
					else if(No[i][j] == 2){
						if (j>0){
						Total[i][j]=Total[i][j-1];
						}
						else Total[i][j]=0;
					}
					else {
						Total[i][j]=0;
					}
				}
			}
			if (Total[gx][gy]==0){
				System.out.println("Miserable Hokusai!");
			}
			else {System.out.println(Total[gx][gy]);
			}
		}
	}
}

</source>
<source file="../hum_codes_raw/s998246257.java" startline="1" endline="64" pcid="33607">
import java.util.*;
public class Main {
	private static Scanner sc;
	public static void main(String[] args) {
		sc = new Scanner(System.in);
		byte a = sc.nextByte();
		for (int l=0; l<a; l++){
			byte gx=sc.nextByte();
			byte gy=sc.nextByte();
			byte No [][] = new byte [gx+1][gy+1];
			byte b = sc.nextByte();
			for (int k=0; k<b; k++){
				byte x1=sc.nextByte();
				byte y1=sc.nextByte();
				byte x2=sc.nextByte();
				byte y2=sc.nextByte();
				
				if (x1 == x2) {
					No [x1][(Math.max(y1, y2))]+=1;
				}
				else {No[(Math.max(x1,x2))][y1]+=2;}			
			}
			int Total[][] = new int [gx+1][gy+1];
			Total[0][0] = 1;
			for (int i=0; i<=gx; i++){
				for (int j=0; j<=gy; j++){
					if (No[i][j] == 0){
						if (i>0 & j>0){
							Total[i][j]=Total[i-1][j]+Total[i][j-1];
						}
						else if (i>0){
							Total[i][j]=Total[i-1][j];
						}
						else if (j>0){
							Total[i][j]=Total[i][j-1];
						}
						else;
					}
					else if(No[i][j] == 1){
						if (i>0){
							Total[i][j]=Total[i-1][j];
							}
						else Total[i][j]=0;
					}
					else if(No[i][j] == 2){
						if (j>0){
						Total[i][j]=Total[i][j-1];
						}
						else Total[i][j]=0;
					}
					else {
						Total[i][j]=0;
					}
				}
			}
			if (Total[gx][gy]==0){
				System.out.println("Miserable Hokusai!");
			}
			else {System.out.println(Total[gx][gy]);
			}
		}
	}
}

</source>
</class>

<class classid="261" nclones="2" nlines="92" similarity="100">
<source file="../hum_codes_raw/s583890283.java" startline="1" endline="122" pcid="19588">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

  public static void main(String[] args) {
    
    new Main().run();
  }

  public void run() {

    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      int n = Integer.parseInt(br.readLine());
      String op;
      String[] words;
      Tree tree = new Tree();

      for(int i=0,k=0; i<n; i++,k=0){
        words = br.readLine().split(" ");
        op  = words[k++];
        if ( op.equals("insert") ) { 
          tree.insert(Integer.parseInt(words[k++]));
        }
        else {
          tree.dispRoundPath();
        }
      }

    }
    catch(IOException e) {
      System.out.println("IOException!");
    }
  }
}

class Tree {

  static final BTreeNode NIL = new BTreeNode(-1);
  BTreeNode root;
  StringBuilder buf;

  public Tree() {
    root = NIL;
    buf = new StringBuilder();
  }

  public void insert(int val) {
    BTreeNode y = NIL;
    BTreeNode x = root;
    BTreeNode z = new BTreeNode(val);

    while( !x.equals(NIL) ) {
      y = x;
      if( z.key < x.key )
        x = x.left;
      else
        x = x.right;
    }
    z.parent = y;

    if( y.equals(NIL) ){
      root = z;
    }
    else if( z.key < y.key )
      y.left = z;
    else
      y.right = z;
  } 
  void preParse(BTreeNode u) {
    if( !u.equals(NIL) ) {
      buf.append(" ").append(u.key);
      preParse(u.left);
      preParse(u.right);
    }
  }
  void inParse(BTreeNode u) {
    if( !u.equals(NIL) ) {
      inParse(u.left);
      buf.append(" ").append(u.key);
      inParse(u.right);
    }
  }

  void dispRoundPath() {

    inParse(root);
    buf.append("\n");
    preParse(root);
    buf.append("\n");

    System.out.print(buf);
    buf.setLength(0);
  }
}

class BTreeNode {
  int key;
  BTreeNode parent,left,right;

  public BTreeNode(int key) {
    this.key = key;
    this.parent =
    this.left =
    this.right = Tree.NIL;
  }

  @Override
  public boolean equals(Object o) {
    if(o == this) return true;
    if(o == null) return false;
    if(!(o instanceof BTreeNode)) return false;

    BTreeNode node = (BTreeNode)o;
    if(!(this.key == node.key)) return false;

    return true;
  }
}

</source>
<source file="../hum_codes_raw/s635452209.java" startline="1" endline="122" pcid="21315">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

  public static void main(String[] args) {
    
    new Main().run();
  }

  public void run() {

    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      int n = Integer.parseInt(br.readLine());
      String op;
      String[] words;
      Tree tree = new Tree();

      for(int i=0,k=0; i<n; i++,k=0){
        words = br.readLine().split(" ");
        op  = words[k++];
        if ( op.equals("insert") ) { 
          tree.insert(Integer.parseInt(words[k++]));
        }
        else {
          tree.dispRoundPath();
        }
      }

    }
    catch(IOException e) {
      System.out.println("IOException!");
    }
  }
}

class Tree {

  static final BTreeNode NIL = new BTreeNode(-1);
  BTreeNode root;
  StringBuilder buf;

  public Tree() {
    root = NIL;
    buf = new StringBuilder();
  }

  public void insert(int val) {
    BTreeNode y = NIL;
    BTreeNode x = root;
    BTreeNode z = new BTreeNode(val);

    while( !x.equals(NIL) ) {
      y = x;
      if( z.key < x.key )
        x = x.left;
      else
        x = x.right;
    }
    z.parent = y;

    if( y.equals(NIL) ){
      root = z;
    }
    else if( z.key < y.key )
      y.left = z;
    else
      y.right = z;
  } 
  void preParse(BTreeNode u) {
    if( !u.equals(NIL) ) {
      buf.append(" ").append(u.key);
      preParse(u.left);
      preParse(u.right);
    }
  }
  void inParse(BTreeNode u) {
    if( !u.equals(NIL) ) {
      inParse(u.left);
      buf.append(" ").append(u.key);
      inParse(u.right);
    }
  }

  void dispRoundPath() {

    inParse(root);
    buf.append("\n");
    preParse(root);
    buf.append("\n");

    System.out.print(buf);
    buf.setLength(0);
  }
}

class BTreeNode {
  int key;
  BTreeNode parent,left,right;

  public BTreeNode(int key) {
    this.key = key;
    this.parent =
    this.left =
    this.right = Tree.NIL;
  }

  @Override
  public boolean equals(Object o) {
    if(o == this) return true;
    if(o == null) return false;
    if(!(o instanceof BTreeNode)) return false;

    BTreeNode node = (BTreeNode)o;
    if(!(this.key == node.key)) return false;

    return true;
  }
}

</source>
</class>

<class classid="262" nclones="2" nlines="10" similarity="100">
<source file="../hum_codes_raw/s590174077.java" startline="1" endline="12" pcid="19803">
import java.util.Scanner;

public class Main{
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int x = sc.nextInt();
        int y = sc.nextInt();
        int z = sc.nextInt();
        System.out.println(z + " " + x + " " + y);
    }
}

</source>
<source file="../hum_codes_raw/s684353770.java" startline="1" endline="14" pcid="22993">
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int x = sc.nextInt();
        int y = sc.nextInt();
        int z = sc.nextInt();
        System.out.println(z + " " + x + " " + y);
    }

}

</source>
</class>

<class classid="263" nclones="2" nlines="69" similarity="100">
<source file="../hum_codes_raw/s590523901.java" startline="1" endline="76" pcid="19813">
import java.util.Scanner;

public class Main{
    public static void main(String[] args){
        Scanner s = new Scanner(System.in);


        int i,j,t;
        String st;
   
        t = s.nextInt();
        for(i=0;i<t;i++){
            int[] num = new int[10];
            int[] g = new int[10],b =new int[10], r =new int[10];
            boolean ch=true;
            for(j=0;j<9;j++)num[j]=s.nextInt();
            for(j=0;j<9;j++){

                st = s.next();
                if(st.charAt(0)=='G')g[num[j]]++;
                else if(st.charAt(0)=='B')b[num[j]]++;
                else if(st.charAt(0)=='R')r[num[j]]++;
            }
            for(j=1;j<=9;j++){
                if(g[j]>=3)g[j]-=3;
                if(j<8&&g[j]==2&&g[j+1]>1&&g[j+2]>1){
                    g[j]-=2;
                    g[j+1]-=2;
                    g[j+2]-=2;
                }
                if(j<8&&g[j]==1&&g[j+1]>0&&g[j+2]>0){
                    g[j]--;
                    g[j+1]--;
                    g[j+2]--;
                }
                if(b[j]>=3)b[j]-=3;
                if(j<8&&b[j]==2&&b[j+1]>1&&b[j+2]>1){
                    b[j]-=2;
                    b[j+1]-=2;
                    b[j+2]-=2;
                }
                if(j<8&&b[j]==1&&b[j+1]>0&&b[j+2]>0){
                    b[j]--;
                    b[j+1]--;
                    b[j+2]--;
                }
                if(r[j]>=3)r[j]-=3;
                if(j<8&&g[j]==2&&r[j+1]>1&&r[j+2]>1){
                    r[j]-=2;
                    r[j+1]-=2;
                    r[j+2]-=2;
                }
                if(j<8&&r[j]==1&&r[j+1]>0&&r[j+2]>0){
                    r[j]--;
                    r[j+1]--;
                    r[j+2]--;
                }
                if(g[j]>0||b[j]>0||r[j]>0){
                    ch = false;
                    break;
                }   
            }
            if(ch==true)System.out.println(1);
            else System.out.println(0);
            for(j=0;j<=9;j++){
                g[j]=0;
                b[j]=0;
                r[j]=0;
                num[j]=0;
            }
            ch=true;
        }

    }
}

</source>
<source file="../hum_codes_raw/s615785556.java" startline="1" endline="77" pcid="20693">
import java.util.Scanner;
 
public class Main{
    public static void main(String[] args){
        Scanner s = new Scanner(System.in);
 
 
        int i,j,t;
        String st;
    
        t = s.nextInt();
        for(i=0;i<t;i++){
            int[] num = new int[10];
            int[] g = new int[10],b =new int[10], r =new int[10];
            boolean ch=true;
            for(j=0;j<9;j++)num[j]=s.nextInt();
            for(j=0;j<9;j++){
 
                st = s.next();
                if(st.charAt(0)=='G')g[num[j]]++;
                else if(st.charAt(0)=='B')b[num[j]]++;
                else if(st.charAt(0)=='R')r[num[j]]++;
            }
            for(j=1;j<=9;j++){
                if(g[j]>=3)g[j]-=3;
                if(j<8&&g[j]==2&&g[j+1]>1&&g[j+2]>1){
                    g[j]-=2;
                    g[j+1]-=2;
                    g[j+2]-=2;
                }
                if(j<8&&g[j]==1&&g[j+1]>0&&g[j+2]>0){
                    g[j]--;
                    g[j+1]--;
                    g[j+2]--;
                }
                if(b[j]>=3)b[j]-=3;
                if(j<8&&b[j]==2&&b[j+1]>1&&b[j+2]>1){
                    b[j]-=2;
                    b[j+1]-=2;
                    b[j+2]-=2;
                }
                if(j<8&&b[j]==1&&b[j+1]>0&&b[j+2]>0){
                    b[j]--;
                    b[j+1]--;
                    b[j+2]--;
                }
                if(r[j]>=3)r[j]-=3;
                if(j<8&&g[j]==2&&r[j+1]>1&&r[j+2]>1){
                    r[j]-=2;
                    r[j+1]-=2;
                    r[j+2]-=2;
                }
                if(j<8&&r[j]==1&&r[j+1]>0&&r[j+2]>0){
                    r[j]--;
                    r[j+1]--;
                    r[j+2]--;
                }
                if(g[j]>0||b[j]>0||r[j]>0){
                    ch = false;
                    break;
                }   
            }
            if(ch==true)System.out.println(1);
            else System.out.println(0);
            for(j=0;j<=9;j++){
                g[j]=0;
                b[j]=0;
                r[j]=0;
                num[j]=0;
            }
            ch=true;
        }
 
    }
}


</source>
</class>

<class classid="264" nclones="2" nlines="86" similarity="100">
<source file="../hum_codes_raw/s598183861.java" startline="1" endline="103" pcid="20073">

import java.util.*;

import static java.lang.Math.*;
import static java.util.Arrays.*;

public class Main {

	int INF = 1 << 28;
	int MAX = 30;
	double EPS = 1e-5;
	int n, m;
	int s, g;
	int map[][];
	int lim[][];
	
	void run() {
		Scanner sc = new Scanner(System.in);
		for(;;) {
			n = sc.nextInt();
			m = sc.nextInt();
			if( (n|m) == 0 ) break;
			s = sc.nextInt()-1;
			g = sc.nextInt()-1;
			map = new int[n][n];
			lim = new int[n][n];
			for(int i=0;i<m;i++) {
				int a = sc.nextInt()-1;
				int b = sc.nextInt()-1;
				int d = sc.nextInt();
				int l = sc.nextInt();
				map[a][b] = map[b][a] = d;
				lim[a][b] = lim[b][a] = l;
			}
			System.out.println(dijkstra());
		}
	}
	int dv[] = {-1,0,1};
	String dijkstra() {
		double t[][][] = new double[n][n+1][MAX+1];
		for(double[][] a:t ) for(double[] b:  a) fill(b, INF);
		t[s][n][0] = 0;
		PriorityQueue<Pair> que = new PriorityQueue<Pair>(1, new MyComp());
		Pair now = new Pair(s, -1, 1, 0, 0);
		que.add(now);
		for(;!que.isEmpty();) {
			now = que.remove();
//			debug(que);
//			debug(now.p, now.past_p, now.v, now.t);
			if( now.p == g && now.past_v == 1 ) return String.valueOf(now.t);
			if( 0 == now.v ) continue;
			for(int i=0;i<n;i++) {
				if( map[now.p][i] == 0 || now.p == i || now.past_p == i) continue;
				if( now.v > lim[now.p][i] ) continue;
				double time = now.t + (double)map[now.p][i] / now.v;
//				debug(now.p, i, map[now.p][i]*1.0/now.v);
				if(time < t[i][now.p][now.v]) {
					for(int j=0;j<3;j++) {
						if( now.v + dv[j] >= 0 ) {					
							que.add(new Pair(i, now.p, now.v+dv[j], now.v, time));
//							debug(i, now.p, now.v+dv[j], time);
						}
					}
					t[i][now.p][now.v] = time;
				}
			}
		}
		return "unreachable";
	}
	
	class Pair {
		int p, v, past_p, past_v;
		double t;
		Pair(int p, int past_p, int v, int past_v, double t) {
			this.p = p;
			this.v = v;
			this.t = t;
			this.past_p = past_p;
			this.past_v = past_v;
		}
	}
	
	class MyComp implements Comparator<Pair> {

		@Override
		public int compare(Pair o1, Pair o2) {
			// TODO ツ篠ゥツ督ョツ青カツ青ャツつウツづェツつスツδソツッツドツ・ツスツタツブ
			if(o1.t > o2.t ) return 1;
			else if(o1.t < o2.t) return -1;
			return o1.v - o2.v;
		}
		
	}

	public static void main(String[] args) {
		new Main().run();
	}

	void debug(Object... os) {
		System.err.println(Arrays.deepToString(os));
	}
}

</source>
<source file="../hum_codes_raw/s797920347.java" startline="1" endline="103" pcid="26808">

import java.util.*;

import static java.lang.Math.*;
import static java.util.Arrays.*;

public class Main {

	int INF = 1 << 28;
	int MAX = 30;
	double EPS = 1e-5;
	int n, m;
	int s, g;
	int map[][];
	int lim[][];
	
	void run() {
		Scanner sc = new Scanner(System.in);
		for(;;) {
			n = sc.nextInt();
			m = sc.nextInt();
			if( (n|m) == 0 ) break;
			s = sc.nextInt()-1;
			g = sc.nextInt()-1;
			map = new int[n][n];
			lim = new int[n][n];
			for(int i=0;i<m;i++) {
				int a = sc.nextInt()-1;
				int b = sc.nextInt()-1;
				int d = sc.nextInt();
				int l = sc.nextInt();
				map[a][b] = map[b][a] = d;
				lim[a][b] = lim[b][a] = l;
			}
			System.out.println(dijkstra());
		}
	}
	int dv[] = {-1,0,1};
	String dijkstra() {
		double t[][][] = new double[n][n+1][MAX+1];
		for(double[][] a:t ) for(double[] b:  a) fill(b, INF);
		t[s][n][0] = 0;
		PriorityQueue<Pair> que = new PriorityQueue<Pair>(1, new MyComp());
		Pair now = new Pair(s, -1, 1, 0, 0);
		que.add(now);
		for(;!que.isEmpty();) {
			now = que.remove();
//			debug(que);
//			debug(now.p, now.past_p, now.v, now.t);
			if( now.p == g && now.past_v == 1 ) return String.valueOf(now.t);
			if( 0 == now.v ) continue;
			for(int i=0;i<n;i++) {
				if( map[now.p][i] == 0 || now.p == i || now.past_p == i) continue;
				if( now.v > lim[now.p][i] ) continue;
				double time = now.t + (double)map[now.p][i] / now.v;
//				debug(now.p, i, map[now.p][i]*1.0/now.v);
				if(time < t[i][now.p][now.v]) {
					for(int j=0;j<3;j++) {
						if( now.v + dv[j] >= 0 ) {					
							que.add(new Pair(i, now.p, now.v+dv[j], now.v, time));
//							debug(i, now.p, now.v+dv[j], time);
						}
					}
					t[i][now.p][now.v] = time;
				}
			}
		}
		return "unreachable";
	}
	
	class Pair {
		int p, v, past_p, past_v;
		double t;
		Pair(int p, int past_p, int v, int past_v, double t) {
			this.p = p;
			this.v = v;
			this.t = t;
			this.past_p = past_p;
			this.past_v = past_v;
		}
	}
	
	class MyComp implements Comparator<Pair> {

		@Override
		public int compare(Pair o1, Pair o2) {
			// TODO 自動生成されたメソッド・スタブ
			if(o1.t > o2.t ) return 1;
			else if(o1.t < o2.t) return -1;
			return o1.v - o2.v;
		}
		
	}

	public static void main(String[] args) {
		new Main().run();
	}

	void debug(Object... os) {
		System.err.println(Arrays.deepToString(os));
	}
}

</source>
</class>

<class classid="265" nclones="2" nlines="56" similarity="100">
<source file="../hum_codes_raw/s602264455.java" startline="1" endline="69" pcid="20223">
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		try(Scanner sc = new Scanner(System.in)){
			int V=sc.nextInt();//頂点数
			int E=sc.nextInt();//辺の数
			int s;//頂点
			int t;//頂点
			double[][] dist=new double[V+1][V+1];//辺の長さ(st距離)
			double[][] dp=new double[1<<V][V];
			double INF=1e100;
			
			for(int i=0; i<V; i++) {
				for(int j=0; j<V; j++) {
					dist[i][j]=INF;
				}
			}
			
			for(int i=0; i<E; i++) {
				s=sc.nextInt();
				t=sc.nextInt();
				dist[s][t]=sc.nextInt();
			}
			for(int i=0; i<(1<<V); i++) {
				for(int j=0; j<V; j++) {
					dp[i][j]=INF;
				}
			}
			dp[1][0]=0;//頂点0からスタートだから
			
			for(int i=0; i<(1<<V); i++) {
				for(int j=0; j<V; j++) {//現在いる頂点j
					if(dp[i][j]==INF) continue;
					for(int k=0; k<V; k++) {//次の行き先頂点k
						if((1&i>>k)==1) continue;//すでに訪れてるとき
						else if(dist[j][k]==INF) continue;//辺がないとき
						int nexti = i| (1<<k);//bitごとのOR演算(今まで通ってきた頂点に次の頂点を足せる) 
						//System.out.printf("nexti=%d\n", nexti);
						double nextd=dp[i][j]+dist[j][k];
						dp[nexti][k]=Math.min(dp[nexti][k], nextd);
					}
				}
			}
//			for(int i=0; i<(1<<V); i++) {
//				for(int j=0; j<V; j++) {
//					System.out.printf("dp[%d][%d]=%f\n", i, j, dp[i][j]);
//				}
//			}
			int all=(1<<V)-1;//最後の全部bitたっている状態
			double ret=INF;
			for(int i=0; i<V; i++) {//最後頂点0に戻る分の距離を足す
				if(dp[all][i]==INF) {
					continue;
				}
				else if(dist[i][0]==INF) continue;//頂点0にもどれないとき
				double temp = dp[all][i]+dist[i][0];
				ret=Math.min(ret, temp);
			}
			if(ret==INF) {
				ret=-1;
			}//bitが全部たたない
			System.out.println((int)ret);
			

		}
	}
}

</source>
<source file="../hum_codes_raw/s884803887.java" startline="1" endline="69" pcid="29747">
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		try(Scanner sc = new Scanner(System.in)){
			int V=sc.nextInt();//頂点数
			int E=sc.nextInt();//辺の数
			int s;//頂点
			int t;//頂点
			double[][] dist=new double[V+1][V+1];//辺の長さ(st距離)
			double[][] dp=new double[1<<V][V];
			double INF=1e100;
			
			for(int i=0; i<V; i++) {
				for(int j=0; j<V; j++) {
					dist[i][j]=INF;
				}
			}
			
			for(int i=0; i<E; i++) {
				s=sc.nextInt();
				t=sc.nextInt();
				dist[s][t]=sc.nextInt();
			}
			for(int i=0; i<(1<<V); i++) {
				for(int j=0; j<V; j++) {
					dp[i][j]=INF;
				}
			}
			dp[1][0]=0;//頂点0からスタートだから
			
			for(int i=0; i<(1<<V); i++) {
				for(int j=0; j<V; j++) {//現在いる頂点j
					if(dp[i][j]==INF) continue;
					for(int k=0; k<V; k++) {//次の行き先頂点k
						if((1&i>>k)==1) continue;//すでに訪れてるとき
						else if(dist[j][k]==INF) continue;//辺がないとき
						int nexti = i| (1<<k);//bitごとのOR演算(今まで通ってきた頂点に次の頂点を足せる) 
						//System.out.printf("nexti=%d\n", nexti);
						double nextd=dp[i][j]+dist[j][k];
						dp[nexti][k]=Math.min(dp[nexti][k], nextd);
					}
				}
			}
//			for(int i=0; i<(1<<V); i++) {
//				for(int j=0; j<V; j++) {
//					System.out.printf("dp[%d][%d]=%f\n", i, j, dp[i][j]);
//				}
//			}
			int all=(1<<V)-1;//最後の全部bitたっている状態
			double ret=INF;
			for(int i=0; i<V; i++) {//最後頂点0に戻る分の距離を足す
				if(dp[all][i]==INF) {
					continue;
				}
				else if(dist[i][0]==INF) continue;//頂点0にもどれないとき
				double temp = dp[all][i]+dist[i][0];
				ret=Math.min(ret, temp);
			}
			if(ret==INF) {
				ret=-1;
			}//bitが全部たたない
			System.out.println((int)ret);
			

		}
	}
}

</source>
</class>

<class classid="266" nclones="2" nlines="84" similarity="100">
<source file="../hum_codes_raw/s603191053.java" startline="1" endline="52" pcid="20253">
import java.util.*;
import java.io.*;

public class Main{

static BufferedReader s1;
static BufferedWriter out;
static String read() throws IOException{String line="";while(line.length()==0){line=s1.readLine();continue;}return line;}
static int int_v (String s1){return Integer.parseInt(s1);}
static long long_v(String s1){return Long.parseLong(s1);}
static int[] int_arr() throws IOException{String[] a=read().split("\\s+");int[] b=new int[a.length];for(int i=0;i<a.length;i++){b[i]=int_v(a[i]);}return b;}
static long[] long_arr() throws IOException{String[] a=read().split("\\s+");long[] b=new long[a.length];for(int i=0;i<a.length;i++){b[i]=long_v(a[i]);}return b;}
static void assign(){s1=new BufferedReader(new InputStreamReader(System.in));out=new BufferedWriter(new OutputStreamWriter(System.out));}
static long Modpow(long a,long p,long m){long res=1;while(p>0){if((p&1)!=0){res=(res*a)%m;}p >>=1;a=(a*a)%m;}return res;}
//......................................@uthor_Alx..............................................
static long mod=(long)1e9+7;
static long rec(long x, Map<Long,Long> map,long[][] op,long d){
    if(x<=0l){
        map.put(0l,0l); return 0l;
    }
    if(map.get(x)!=null) return map.get(x);
    long n=x;
    map.put(x,(long)4e18);
    if((map.get(x)+d-1)/d>n) map.put(x,d*n);
    for(int i=0;i<3;i++){
        if(x%op[i][0]==0){
            map.put(x,Math.min(map.get(x),rec(x/op[i][0],map,op,d)+op[i][1]));
        }
        else{
            map.put(x,Math.min(map.get(x),d*(x%op[i][0])+rec(x/op[i][0],map,op,d)+op[i][1]));
            map.put(x,Math.min(map.get(x),d*(op[i][0]-x%op[i][0])+rec(x/op[i][0]+1,map,op,d)+op[i][1]));
        }
    }
    
     return map.get(n);
}
public static void main(String[] args) throws  IOException{
                assign();
                int t=int_v(read());
               while(t--!=0){
                     long[] x=long_arr();
                     long n=x[0],a=x[1],b=x[2],c=x[3],d=x[4];
                     Map<Long,Long> map=new HashMap<>();
                     long[][] op=new long[][]{{2l,a},{3l,b},{5l,c}};
                     out.write(rec(n,map,op,d)+"\n");
               }

                out.flush();

    }
}

</source>
<source file="../hum_codes_raw/s814948591.java" startline="1" endline="52" pcid="27373">
import java.util.*;
import java.io.*;

public class Main{

static BufferedReader s1;
static BufferedWriter out;
static String read() throws IOException{String line="";while(line.length()==0){line=s1.readLine();continue;}return line;}
static int int_v (String s1){return Integer.parseInt(s1);}
static long long_v(String s1){return Long.parseLong(s1);}
static int[] int_arr() throws IOException{String[] a=read().split("\\s+");int[] b=new int[a.length];for(int i=0;i<a.length;i++){b[i]=int_v(a[i]);}return b;}
static long[] long_arr() throws IOException{String[] a=read().split("\\s+");long[] b=new long[a.length];for(int i=0;i<a.length;i++){b[i]=long_v(a[i]);}return b;}
static void assign(){s1=new BufferedReader(new InputStreamReader(System.in));out=new BufferedWriter(new OutputStreamWriter(System.out));}
static long Modpow(long a,long p,long m){long res=1;while(p>0){if((p&1)!=0){res=(res*a)%m;}p >>=1;a=(a*a)%m;}return res;}
//......................................@uthor_Alx..............................................
static long mod=(long)1e9+7;
static long rec(long x, Map<Long,Long> map,long[][] op,long d){
    if(x<=0l){
        map.put(0l,0l); return 0l;
    }
    if(map.get(x)!=null) return map.get(x);
    long n=x;
    map.put(x,(long)4e18);
    if((map.get(x)+d-1)/d>n) map.put(x,d*n);
    for(int i=0;i<3;i++){
        if(x%op[i][0]==0){
            map.put(x,Math.min(map.get(x),rec(x/op[i][0],map,op,d)+op[i][1]));
        }
        else{
            map.put(x,Math.min(map.get(x),d*(x%op[i][0])+rec(x/op[i][0],map,op,d)+op[i][1]));
            map.put(x,Math.min(map.get(x),d*(op[i][0]-x%op[i][0])+rec(x/op[i][0]+1,map,op,d)+op[i][1]));
        }
    }
    
     return map.get(n);
}
public static void main(String[] args) throws  IOException{
                assign();
                int t=int_v(read());
               while(t--!=0){
                     long[] x=long_arr();
                     long n=x[0],a=x[1],b=x[2],c=x[3],d=x[4];
                     Map<Long,Long> map=new HashMap<>();
                     long[][] op=new long[][]{{2l,a},{3l,b},{5l,c}};
                     out.write(rec(n,map,op,d)+"\n");
               }

                out.flush();

    }
}

</source>
</class>

<class classid="267" nclones="2" nlines="34" similarity="100">
<source file="../hum_codes_raw/s606960694.java" startline="1" endline="51" pcid="20391">
import java.util.*;
import java.awt.geom.*;

public class Main{
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);

		while(true){
			int n = sc.nextInt();
			if(n == 0) break;
			Point2D[] p = new Point2D[n];

			for(int i=0;i<n;i++){
				String[] s = sc.next().split(",");
				p[i] = new Point2D.Double(Double.parseDouble(s[0]), Double.parseDouble(s[1]));
			}

			System.out.println(p.length - convexHull(p).length);
		}
	}

	public static Point2D[] convexHull(Point2D[] ps) {        
		Arrays.sort(ps , new Comparator< Point2D >() {
				public int compare(Point2D o1, Point2D o2) {
					if(o1.getX() < o2.getX()) return -1;
					else if(o1.getX() > o2.getX()) return 1;
					else if(o1.getY() < o2.getY()) return -1;
					else if(o1.getY() > o2.getY()) return 1;
					else return 0;        
				}
			});
		int n = ps.length, k = 0;
		Point2D[] ch = new Point2D[2 * n];

		for (int i = 0; i < n; ch[k++] = ps[i++])
			while (k >= 2
						 && Line2D.relativeCCW(ch[k - 2].getX(), ch[k - 2].getY(),
																	 ch[k - 1].getX(), ch[k - 1].getY(), ps[i].getX(),
																	 ps[i].getY()) <= 0)
				k--;

		for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])
			while (k >= t
						 && Line2D.relativeCCW(ch[k - 2].getX(), ch[k - 2].getY(),
																	 ch[k - 1].getX(), ch[k - 1].getY(), ps[i].getX(),
																	 ps[i].getY()) <= 0)
				k--;
		return Arrays.copyOf(ch, k - 1);
	}
}

</source>
<source file="../hum_codes_raw/s792253704.java" startline="1" endline="51" pcid="26618">
import java.util.*;
import java.awt.geom.*;

public class Main{
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);

		while(true){
			int n = sc.nextInt();
			if(n == 0) break;
			Point2D[] p = new Point2D[n];

			for(int i=0;i<n;i++){
				String[] s = sc.next().split(",");
				p[i] = new Point2D.Double(Double.parseDouble(s[0]), Double.parseDouble(s[1]));
			}

			System.out.println(p.length - convexHull(p).length);
		}
	}

	public static Point2D[] convexHull(Point2D[] ps) {        
		Arrays.sort(ps , new Comparator< Point2D >() {
				public int compare(Point2D o1, Point2D o2) {
					if(o1.getX() < o2.getX()) return -1;
					else if(o1.getX() > o2.getX()) return 1;
					else if(o1.getY() < o2.getY()) return -1;
					else if(o1.getY() > o2.getY()) return 1;
					else return 0;        
				}
			});
		int n = ps.length, k = 0;
		Point2D[] ch = new Point2D[2 * n];

		for (int i = 0; i < n; ch[k++] = ps[i++])
			while (k >= 2
						 && Line2D.relativeCCW(ch[k - 2].getX(), ch[k - 2].getY(),
																	 ch[k - 1].getX(), ch[k - 1].getY(), ps[i].getX(),
																	 ps[i].getY()) <= 0)
				k--;

		for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])
			while (k >= t
						 && Line2D.relativeCCW(ch[k - 2].getX(), ch[k - 2].getY(),
																	 ch[k - 1].getX(), ch[k - 1].getY(), ps[i].getX(),
																	 ps[i].getY()) <= 0)
				k--;
		return Arrays.copyOf(ch, k - 1);
	}
}

</source>
</class>

<class classid="268" nclones="2" nlines="26" similarity="100">
<source file="../hum_codes_raw/s609863463.java" startline="1" endline="33" pcid="20490">
import java.util.*;
 
public class Main {
     
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
         
        while(sc.hasNext()){
            int n = sc.nextInt();
            for(int k=0;k<n;k++){
                String s = sc.next();
                int[] num = new int[8];
 
                for(int i=0;i<8;i++){
                    num[i] = Integer.valueOf(s.substring(i,i+1));
                }
                Arrays.sort(num);
                int a = 0;
                int b = 0;
                int c = 1;
                for(int i=0;i<8;i++){
                    a += num[i]*c;
                    b += num[7-i]*c;
                    c *= 10;
                }
                System.out.println(a-b);
                 
            }
        }
     
    }   
}

</source>
<source file="../hum_codes_raw/s767590340.java" startline="1" endline="33" pcid="25773">
import java.util.*;

public class Main {
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		while(sc.hasNext()){
			int n = sc.nextInt();
			for(int k=0;k<n;k++){
				String s = sc.next();
				int[] num = new int[8];

				for(int i=0;i<8;i++){
					num[i] = Integer.valueOf(s.substring(i,i+1));
				}
				Arrays.sort(num);
				int a = 0;
				int b = 0;
				int c = 1;
				for(int i=0;i<8;i++){
					a += num[i]*c;
					b += num[7-i]*c;
					c *= 10;
				}
				System.out.println(a-b);
				
			}
		}
	
	}	
}

</source>
</class>

<class classid="269" nclones="3" nlines="10" similarity="100">
<source file="../hum_codes_raw/s624782978.java" startline="1" endline="16" pcid="20976">
import java.util.Scanner;

public class Main {
  public static void main(String[] args) {
    Scanner scanner = new Scanner(System.in);

    // 標準入力から上底a、下底b、高さhを取得
    int a = scanner.nextInt();
    int b = scanner.nextInt();
    int h = scanner.nextInt();

    // 台形の面積を求める：(上底 + 下底) * 高さ / 2
    System.out.println((a + b) * h / 2);
  }
}

</source>
<source file="../hum_codes_raw/s854014023.java" startline="1" endline="13" pcid="28709">
import java.util.Scanner;

public class Main {
  public static void main(String[] args) {
    Scanner scanner = new Scanner(System.in);
    int a = scanner.nextInt();
    int b = scanner.nextInt();
    int h = scanner.nextInt();
    
    System.out.println((a + b) * h / 2);
  }
}

</source>
<source file="../hum_codes_raw/s789025168.java" startline="1" endline="17" pcid="26490">
import java.util.Scanner;

/**
 * archeryue
 * 9/19/16
 */
public class Main {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int a = scanner.nextInt();
        int b = scanner.nextInt();
        int h = scanner.nextInt();
        System.out.println((a + b) * h / 2);
    }
}

</source>
</class>

<class classid="270" nclones="2" nlines="149" similarity="100">
<source file="../hum_codes_raw/s626787143.java" startline="1" endline="181" pcid="21034">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 27);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            DYetAnotherPalindromePartitioning solver = new DYetAnotherPalindromePartitioning();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class DYetAnotherPalindromePartitioning {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            char[] s = new char[(int) 2e5];
            int n = in.readString(s, 0);
            int charset = 'z' - 'a' + 1;
            int[] dp = new int[1 << charset];
            int inf = (int) 1e8;
            Arrays.fill(dp, inf);
            int pre = 0;
            dp[pre] = 0;
            for (int i = 0; i < n; i++) {
                int x = s[i] - 'a';
                int bit = 1 << x;
                pre ^= bit;

                int ans = inf;
                ans = Math.min(ans, dp[pre] + 1);
                for (int j = 0; j < charset; j++) {
                    ans = Math.min(ans, dp[pre ^ (1 << j)] + 1);
                }
                dp[pre] = Math.min(dp[pre], ans);

                if (i == n - 1) {
                    out.println(ans);
                    return;
                }
            }
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readString(char[] data, int offset) {
            skipBlank();

            int originalOffset = offset;
            while (next > 32) {
                data[offset++] = (char) next;
                next = read();
            }

            return offset - originalOffset;
        }

    }
}

</source>
<source file="../hum_codes_raw/s838965784.java" startline="1" endline="182" pcid="28167">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 27);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            DYetAnotherPalindromePartitioning solver = new DYetAnotherPalindromePartitioning();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class DYetAnotherPalindromePartitioning {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            char[] s = new char[(int) 2e5];
            int n = in.readString(s, 0);
            int charset = 'z' - 'a' + 1;
            int[] dp = new int[1 << charset];
            int inf = (int) 1e8;
            Arrays.fill(dp, inf);
            int pre = 0;
            dp[pre] = 0;
            for (int i = 0; i < n; i++) {
                int x = s[i] - 'a';
                int bit = 1 << x;
                pre ^= bit;

                int ans = inf;
                ans = Math.min(ans, dp[pre] + 1);
                for (int j = 0; j < charset; j++) {
                    ans = Math.min(ans, dp[pre ^ (1 << j)] + 1);
                }
                dp[pre] = Math.min(dp[pre], ans);

                if (i == n - 1) {
                    out.println(ans);
                    return;
                }
            }
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readString(char[] data, int offset) {
            skipBlank();

            int originalOffset = offset;
            while (next > 32) {
                data[offset++] = (char) next;
                next = read();
            }

            return offset - originalOffset;
        }

    }
}


</source>
</class>

<class classid="271" nclones="2" nlines="83" similarity="100">
<source file="../hum_codes_raw/s639169281.java" startline="1" endline="123" pcid="21437">
import java.util.*;
import java.io.*;
import java.math.*;

import static java.lang.Math.*;
import static java.util.Arrays.*;
import static java.util.Collections.*;

public class Main{
    static long mod=1000000007;
    // static int dx[]={1,-1,0,0};
    // static int dy[]={0,0,1,-1};
    // static int dx[]={1,-1,0,0,1,1,-1,-1};
    // static int dy[]={0,0,1,-1,1,-1,1,-1};
    // PriorityQueue<Integer> que = new PriorityQueue<Integer>(); 
    //HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();
    //ArrayList<Integer> lis = new ArrayList<Integer>();
    public  static void main(String[] args)   throws Exception, IOException{
        Reader sc = new Reader(System.in);
        PrintWriter out=new PrintWriter(System.out);

        int n=sc.nextInt(),a=0;
        long ans=0,e[]=new long[n];
        for( int i=0; i<n; i++ ){
            e[i] = sc.nextLong();
        }
        while(true){
            sort(e);
            int x=-1;
                if(e[n-1]<n) break;
            long c=e[n-1]/n;
            //db(c,x,e,++a);
            ans+=c;
            for( int i=0; i<n-1; i++ ){
                e[i] += c;
            }
            e[n-1] -= c * n;
        }
        out.println(ans); 
        out.flush();
    }

    static void db(Object... os){
        System.err.println(Arrays.deepToString(os));
    }

    static boolean validpos(int x,int y,int r, int c){
        return x<r && 0<=x && y<c && 0<=y;
    }
     
    static boolean bit(long x,int k){
        // weather k-th bit (from right) be one or zero
        return  ( 0 < ( (x>>k) & 1 )  )  ? true:false;
    }
}

class Pair implements Comparable<Pair>{
    int x,y,id;
    Pair(int x, int y,int id) {
        this.x=x;
        this.y=y;
        this.id=id;
    } 
    public int compareTo(Pair p){
        return p.x -     x;
    } 
}

// class Pair implements Comparable<Pair>{
//     int x,y;
//     Pair(int x, int y) {
//         this.x=x;
//         this.y=y;
//     } 
//     public int compareTo(Pair p){//descend
//         return p.x - x;
//     } 

// }

class P implements Comparable<P>{
    int diff,id1,id2;
    P(int diff, int id1,int id2) {
        this.diff=diff;
        this.id1=id1;
        this.id2=id2;
    } 
      
    public int compareTo(P p){//ascend
        return diff - p.diff;
    } 
}

class Reader
{ 
    private BufferedReader x;
    private StringTokenizer st;
    
    public Reader(InputStream in)
    {
        x = new BufferedReader(new InputStreamReader(in));
        st = null;
    }
    public String nextString() throws IOException
    {
        while( st==null || !st.hasMoreTokens() )
            st = new StringTokenizer(x.readLine());
        return st.nextToken();
    }
    public int nextInt() throws IOException
    {
        return Integer.parseInt(nextString());
    }
    public long nextLong() throws IOException
    {
        return Long.parseLong(nextString());
    }
    public double nextDouble() throws IOException
    {
        return Double.parseDouble(nextString());
    }
}

</source>
<source file="../hum_codes_raw/s957996237.java" startline="1" endline="123" pcid="32198">
import java.util.*;
import java.io.*;
import java.math.*;

import static java.lang.Math.*;
import static java.util.Arrays.*;
import static java.util.Collections.*;

public class Main{
    static long mod=1000000007;
    // static int dx[]={1,-1,0,0};
    // static int dy[]={0,0,1,-1};
    // static int dx[]={1,-1,0,0,1,1,-1,-1};
    // static int dy[]={0,0,1,-1,1,-1,1,-1};
    // PriorityQueue<Integer> que = new PriorityQueue<Integer>(); 
    //HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();
    //ArrayList<Integer> lis = new ArrayList<Integer>();
    public  static void main(String[] args)   throws Exception, IOException{
        Reader sc = new Reader(System.in);
        PrintWriter out=new PrintWriter(System.out);

        int n=sc.nextInt(),a=0;
        long ans=0,e[]=new long[n];
        for( int i=0; i<n; i++ ){
            e[i] = sc.nextLong();
        }
        while(true){
            sort(e);
            int x=-1;
                if(e[n-1]<n) break;
            long c=e[n-1]/n;
            //db(c,x,e,++a);
            ans+=c;
            for( int i=0; i<n-1; i++ ){
                e[i] += c;
            }
            e[n-1] -= c * n;
        }
        out.println(ans); 
        out.flush();
    }

    static void db(Object... os){
        System.err.println(Arrays.deepToString(os));
    }

    static boolean validpos(int x,int y,int r, int c){
        return x<r && 0<=x && y<c && 0<=y;
    }
     
    static boolean bit(long x,int k){
        // weather k-th bit (from right) be one or zero
        return  ( 0 < ( (x>>k) & 1 )  )  ? true:false;
    }
}

class Pair implements Comparable<Pair>{
    int x,y,id;
    Pair(int x, int y,int id) {
        this.x=x;
        this.y=y;
        this.id=id;
    } 
    public int compareTo(Pair p){
        return p.x -     x;
    } 
}

// class Pair implements Comparable<Pair>{
//     int x,y;
//     Pair(int x, int y) {
//         this.x=x;
//         this.y=y;
//     } 
//     public int compareTo(Pair p){//descend
//         return p.x - x;
//     } 

// }

class P implements Comparable<P>{
    int diff,id1,id2;
    P(int diff, int id1,int id2) {
        this.diff=diff;
        this.id1=id1;
        this.id2=id2;
    } 
      
    public int compareTo(P p){//ascend
        return diff - p.diff;
    } 
}

class Reader
{ 
    private BufferedReader x;
    private StringTokenizer st;
    
    public Reader(InputStream in)
    {
        x = new BufferedReader(new InputStreamReader(in));
        st = null;
    }
    public String nextString() throws IOException
    {
        while( st==null || !st.hasMoreTokens() )
            st = new StringTokenizer(x.readLine());
        return st.nextToken();
    }
    public int nextInt() throws IOException
    {
        return Integer.parseInt(nextString());
    }
    public long nextLong() throws IOException
    {
        return Long.parseLong(nextString());
    }
    public double nextDouble() throws IOException
    {
        return Double.parseDouble(nextString());
    }
}

</source>
</class>

<class classid="272" nclones="2" nlines="40" similarity="100">
<source file="../hum_codes_raw/s641161060.java" startline="1" endline="51" pcid="21507">
import java.util.Scanner;
class Main
{
    public static void main(String args[])
    {
	Scanner scan=new Scanner(System.in);
	while(true)
	    {
		int n=scan.nextInt();
		if(n==0)break;
		int s[]=new int[n];
		char x[]=new char[100];
		int f=0;
		String str=scan.next();
		for(int i=0;i<100;i++)
		    {
			x[i]=str.charAt(i);
			if(x[i]=='S')
			    {
				f+=s[i%n]+1;
				s[i%n]=0;
			    }
			else if(x[i]=='M')s[i%n]++;
			else 
			    {
				s[i%n]+=f+1;
				f=0;
			    }
		    }
		for(int i=0;i<n;i++)
		    {
			for(int j=n-1;j>i;j--)
			    {
				if(s[j]<s[j-1])
				    {
				int t=s[j];
				s[j]=s[j-1];
				s[j-1]=t;
				    }
			    }
		    }
		for(int i=0;i<n;i++)
		    {
			System.out.print((i!=n)?s[i]+" ":"");
		    }
		System.out.print(f);
		System.out.println();
	    }
    }
}

</source>
<source file="../hum_codes_raw/s665449186.java" startline="1" endline="51" pcid="22347">
import java.util.Scanner;
class Main
{
    public static void main(String args[])
    {
	Scanner scan=new Scanner(System.in);
	while(true)
	    {
		int n=scan.nextInt();
		if(n==0)break;
		int s[]=new int[n];
		char x[]=new char[100];
		int f=0;
		String str=scan.next();
		for(int i=0;i<100;i++)
		    {
			x[i]=str.charAt(i);
			if(x[i]=='S')
			    {
				f+=s[i%n]+1;
				s[i%n]=0;
			    }
			else if(x[i]=='M')s[i%n]++;
			else 
			    {
				s[i%n]+=f+1;
				f=0;
			    }
		    }
		for(int i=0;i<n;i++)
		    {
			for(int j=n-1;j>i;j--)
			    {
				if(s[j]<s[j-1])
				    {
				int t=s[j];
				s[j]=s[j-1];
				s[j-1]=t;
				    }
			    }
		    }
		for(int i=0;i<n;i++)
		    {
			System.out.print((i!=n)?s[i]+" ":"");
		    }
		System.out.print(f);
		System.out.println();
	    }
    }
}

</source>
</class>

<class classid="273" nclones="2" nlines="91" similarity="100">
<source file="../hum_codes_raw/s647488374.java" startline="1" endline="108" pcid="21738">


import java.util.*;
import java.lang.*;
import java.math.*;
import java.io.*;
 
import static java.lang.Math.*;
import static java.util.Arrays.*;
 
public class Main{
 
    Scanner sc=new Scanner(System.in);;
 
    int INF=1<<28;
    double EPS=1e-9;
 
    int[][] a;
    int w, h;
    boolean[][] visited;
 
    void run(){
        for(;;){
            h=sc.nextInt();
            w=sc.nextInt();
            if((h|w)==0){
                break;
            }
            a=new int[h][w];
            visited=new boolean[h][w];
            for(int j=0; j<h; j++){
                String s=sc.next();
                for(int i=0; i<w; i++){
                    switch(s.charAt(i)){
                    case '@':
                        a[j][i]=0;
                        break;
                    case '#':
                        a[j][i]=1;
                        break;
                    case '*':
                        a[j][i]=2;
                        break;
                    }
                }
            }
            solve();
        }
    }
 
    void solve(){
        int ans=0;
        for(int j=0; j<h; j++){
            for(int i=0; i<w; i++){
                if(!visited[j][i]){
                    ans++;
                    bfs(i, j);
                }
            }
        }
        println(ans+"");
    }
 
    void bfs(int x, int y){
        LinkedList<P> que=new LinkedList<P>();
        que.offer(new P(x, y));
        visited[y][x]=true;
        int[] dx={0, 0, -1, 1};
        int[] dy={-1, 1, 0, 0};
        for(; !que.isEmpty();){
            P p=que.poll();
            for(int i=0; i<4; i++){
                P q=new P(p.x+dx[i], p.y+dy[i]);
                if(q.x>=0&&q.x<w&&q.y>=0&&q.y<h&&!visited[q.y][q.x]
                        &&a[p.y][p.x]==a[q.y][q.x]){
                    que.offer(q);
                    visited[q.y][q.x]=true;
                }
            }
        }
    }
 
    class P{
        int x, y;
 
        P(int x, int y){
            this.x=x;
            this.y=y;
        }
    }
 
    void debug(Object... os){
        System.err.println(Arrays.deepToString(os));
    }
 
    void print(String s){
        System.out.print(s);
    }
 
    void println(String s){
        System.out.println(s);
    }
 
    public static void main(String[] args){
        new Main().run();
    }
}

</source>
<source file="../hum_codes_raw/s686809997.java" startline="1" endline="106" pcid="23074">
import java.util.*;
import java.lang.*;
import java.math.*;
import java.io.*;

import static java.lang.Math.*;
import static java.util.Arrays.*;

public class Main{

	Scanner sc=new Scanner(System.in);;

	int INF=1<<28;
	double EPS=1e-9;

	int[][] a;
	int w, h;
	boolean[][] visited;

	void run(){
		for(;;){
			h=sc.nextInt();
			w=sc.nextInt();
			if((h|w)==0){
				break;
			}
			a=new int[h][w];
			visited=new boolean[h][w];
			for(int j=0; j<h; j++){
				String s=sc.next();
				for(int i=0; i<w; i++){
					switch(s.charAt(i)){
					case '@':
						a[j][i]=0;
						break;
					case '#':
						a[j][i]=1;
						break;
					case '*':
						a[j][i]=2;
						break;
					}
				}
			}
			solve();
		}
	}

	void solve(){
		int ans=0;
		for(int j=0; j<h; j++){
			for(int i=0; i<w; i++){
				if(!visited[j][i]){
					ans++;
					bfs(i, j);
				}
			}
		}
		println(ans+"");
	}

	void bfs(int x, int y){
		LinkedList<P> que=new LinkedList<P>();
		que.offer(new P(x, y));
		visited[y][x]=true;
		int[] dx={0, 0, -1, 1};
		int[] dy={-1, 1, 0, 0};
		for(; !que.isEmpty();){
			P p=que.poll();
			for(int i=0; i<4; i++){
				P q=new P(p.x+dx[i], p.y+dy[i]);
				if(q.x>=0&&q.x<w&&q.y>=0&&q.y<h&&!visited[q.y][q.x]
						&&a[p.y][p.x]==a[q.y][q.x]){
					que.offer(q);
					visited[q.y][q.x]=true;
				}
			}
		}
	}

	class P{
		int x, y;

		P(int x, int y){
			this.x=x;
			this.y=y;
		}
	}

	void debug(Object... os){
		System.err.println(Arrays.deepToString(os));
	}

	void print(String s){
		System.out.print(s);
	}

	void println(String s){
		System.out.println(s);
	}

	public static void main(String[] args){
		new Main().run();
	}
}

</source>
</class>

<class classid="274" nclones="2" nlines="21" similarity="100">
<source file="../hum_codes_raw/s651263458.java" startline="1" endline="23" pcid="21862">
import java.util.Scanner;
 
public class Main {
 
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int a = scanner.nextInt();
        int b = scanner.nextInt();
        int c = scanner.nextInt();
        int d = scanner.nextInt();
        int x = 0;
        int y = 0;
        x = ((n+a-1) / a) * b;
        y = ((n+c-1) / c) * d;
        if (x >= y) {
            System.out.println(y);
        } else {
            System.out.println(x);
        }
    }
}

</source>
<source file="../hum_codes_raw/s916398522.java" startline="1" endline="25" pcid="30816">

import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int a = scanner.nextInt();
        int b = scanner.nextInt();
        int c = scanner.nextInt();
        int d = scanner.nextInt();
        int x = 0;
        int y = 0;
        x = ((n+a-1) / a) * b;
        y = ((n+c-1) / c) * d;
        if (x >= y) {
            System.out.println(y);
        } else {
            System.out.println(x);
        }
    }
}


</source>
</class>

<class classid="275" nclones="2" nlines="28" similarity="100">
<source file="../hum_codes_raw/s655257449.java" startline="1" endline="29" pcid="21998">
import java.util.*;
public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int m = sc.nextInt();
			if(m==0)break;
			int[] a = new int[m+1];
			int[] b = new int[m+1];
			for(int i=1;i<=m;i++){
				a[i] = sc.nextInt();
				b[i] = sc.nextInt();
			}
			int[][] p = new int[m+1][1001];
			p[0][0] = 1;
			for(int i=1;i<=m;i++){
				for(int k=0;k<1001;k++){
					for(int s=0;s<=b[i];s++){
						if(k-a[i]*s<0)break;
						p[i][k] += p[i-1][k-s*a[i]];
					}
				}
			}
			int g = sc.nextInt();
			while(g--!=0)System.out.println(p[m][sc.nextInt()]);
		}
	}
}

</source>
<source file="../hum_codes_raw/s777478378.java" startline="1" endline="29" pcid="26102">
import java.util.*;
public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int m = sc.nextInt();
			if(m==0)break;
			int[] a = new int[m+1];
			int[] b = new int[m+1];
			for(int i=1;i<=m;i++){
				a[i] = sc.nextInt();
				b[i] = sc.nextInt();
			}
			int[][] p = new int[m+1][1001];
			p[0][0] = 1;
			for(int i=1;i<=m;i++){
				for(int k=0;k<1001;k++){
					for(int s=0;s<=b[i];s++){
						if(k-a[i]*s<0)break;
						p[i][k] += p[i-1][k-s*a[i]];
					}
				}
			}
			int g = sc.nextInt();
			while(g--!=0)System.out.println(p[m][sc.nextInt()]);
		}
	}
}

</source>
</class>

<class classid="276" nclones="2" nlines="484" similarity="100">
<source file="../hum_codes_raw/s667004134.java" startline="1" endline="645" pcid="22407">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class Main {
	final int _intMax = Integer.MAX_VALUE; // =2147483647>10^9
	final int _intMin = Integer.MIN_VALUE;
	final long _longMax = Long.MAX_VALUE; // =9223372036854775807L>10^18
	final long _longMin = Long.MIN_VALUE;
	final char[] _azAry = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',
			's', 't', 'u', 'v', 'w', 'x', 'y', 'z' };

	void solve() {
		Prime prime = new Prime();
		int n = readNum();
		StringBuilder sb = new StringBuilder();
		for (int i = 11; n > 0; i += 5) {
			if (prime.isPrime(i)) {
				sb.append(i).append(" ");
				n--;
			}
		}
		pln(sb.toString().trim());
	}

	// -----------------------------------------------------
	// 2018/05/06 r27
	// -----------------------------------------------------
	List<Character> getazList() {
		List<Character> list = new ArrayList<>();
		for (char ch : _azAry)
			list.add(ch);
		return list;
	}

	int getDx(int idx) {
		int[] dx = { 0, 1, 1, 1, 0, -1, -1, -1 };
		return dx[idx];
	}

	int getDy(int idx) {
		int[] dy = { -1, -1, 0, 1, 1, 1, 0, -1 };
		return dy[idx];
	}

	class Bitmap {
		int mx;
		int my;
		boolean[][] map;

		public Bitmap(int mx, int my) {
			this.mx = mx;
			this.my = my;
			map = new boolean[my + 2][mx + 2];
		}

		public boolean is(int x, int y) {
			return map[y][x];
		}

		public void set(int x, int y, boolean b) {
			map[y][x] = b;
		}
	}

	class CharList implements Iterable<Character> {
		class CharComparator implements Comparator<Character> {
			int sign;

			public CharComparator(boolean bAsc) {
				sign = bAsc ? 1 : -1;
			}

			public int compare(Character o1, Character o2) {
				return sign * Character.compare(o1, o2);
			}
		}

		List<Character> list = new ArrayList<>();
		CharComparator asc = new CharComparator(true);
		CharComparator desc = new CharComparator(false);

		public void add(char ch) {
			list.add(ch);
		}

		public char get(int idx) {
			return list.get(idx);
		}

		public char getLast() {
			return list.get(list.size() - 1);
		}

		public Iterator<Character> iterator() {
			return list.iterator();
		}

		public void remove(int idx) {
			list.remove(idx);
		}

		public void removeLast() {
			list.remove(list.size() - 1);
		}

		public int size() {
			return list.size();
		}

		public void sort(boolean bAsc) {
			if (bAsc)
				Collections.sort(list, asc);
			else
				Collections.sort(list, desc);
		}

		public String toString() {
			StringBuilder sb = new StringBuilder();
			for (char ch : list)
				sb.append(ch);
			return sb.toString();
		}
	}

	class Counter<K> {
		Map<K, Integer> map = new HashMap<>();

		public Counter() {
		}

		public Counter(Iterable<K> itr) {
			for (K obj : itr) {
				add(obj);
			}
		}

		public void add(K key) {
			Integer cnt = map.get(key);
			if (cnt == null)
				map.put(key, 1);
			else
				map.put(key, cnt + 1);
		}

		public int get(K key) {
			Integer cnt = map.get(key);
			if (cnt == null)
				return 0;
			else
				return cnt;
		}

		public Set<K> keySet() {
			return map.keySet();
		}
	}

	class IntList implements Iterable<Integer> {
		class Info {
			int idx;
			int val;

			public Info(int idx, int val) {
				this.idx = idx;
				this.val = val;
			}

			public String toString() {
				return "(" + idx + ", " + val + ")";
			}
		}

		class InfoComparator implements Comparator<Info> {
			int sign;

			public InfoComparator(boolean bAsc) {
				sign = bAsc ? 1 : -1;
			}

			public int compare(Info o1, Info o2) {
				return sign * Integer.compare(o1.val, o2.val);
			}
		}

		List<Info> list = new ArrayList<>();
		InfoComparator asc = new InfoComparator(true);
		InfoComparator desc = new InfoComparator(false);

		public IntList() {
		}

		public IntList(int[] ia) {
			for (int i = 0; i < ia.length; i++)
				add(ia[i]);
		}

		public void add(int val) {
			list.add(new Info(list.size(), val));
		}

		public void add(int idx, int val) {
			list.add(new Info(idx, val));
		}

		public int getIdx(int idx) {
			return list.get(idx).idx;
		}

		public int getVal(int idx) {
			return list.get(idx).val;
		}

		public int getLastVal() {
			return list.get(list.size() - 1).val;
		}

		public Iterator<Integer> iterator() {
			List<Integer> vallist = new ArrayList<>();
			for (Info info : list)
				vallist.add(info.val);
			return vallist.iterator();
		}

		public void remove(int idx) {
			list.remove(idx);
		}

		public void removeLast() {
			list.remove(list.size() - 1);
		}

		public int size() {
			return list.size();
		}

		public void sort(boolean bAsc) {
			if (bAsc)
				Collections.sort(list, asc);
			else
				Collections.sort(list, desc);
		}
	}

	class Point {
		int x;
		int y;

		public Point(int x, int y) {
			this.x = x;
			this.y = y;
		}

		public Point(Point pt) {
			this.x = pt.x;
			this.y = pt.y;
		}

		public boolean equals(Object o) {
			if (o instanceof Point) {
				Point that = (Point) o;
				return (x == that.x) && (y == that.y);
			}
			return false;
		}

		public long getManhattanDistance(Point pt) {
			return abs((long) pt.x - this.x) + abs((long) pt.y - this.y);
		}

		public int hashCode() {
			return x + (y * 31);
		}

		public String toString() {
			return "(" + x + ", " + y + ")";
		}
	}

	class PointList implements Iterable<Point> {
		class PointComparator implements Comparator<Point> {
			int mode;

			public PointComparator(int prop, boolean bAsc) {
				switch (prop) {
				case 1:
					if (bAsc)
						this.mode = 11;
					else
						this.mode = 12;
					break;
				case 2:
					if (bAsc)
						this.mode = 21;
					else
						this.mode = 22;
					break;
				default:
					throw new RuntimeException();
				}
			}

			public int compare(Point p1, Point p2) {
				switch (mode) {
				case 11:
					return 1 * Integer.compare(p1.x, p2.x);
				case 12:
					return -1 * Integer.compare(p1.x, p2.x);
				case 21:
					return 1 * Integer.compare(p1.y, p2.y);
				case 22:
					return -1 * Integer.compare(p1.y, p2.y);
				}
				throw new IllegalStateException();
			}
		}

		List<Point> list = new ArrayList<>();

		public void add(int x, int y) {
			list.add(new Point(x, y));
		}

		public Point get(int idx) {
			return list.get(idx);
		}

		public Iterator<Point> iterator() {
			return list.iterator();
		}

		public void remove(int idx) {
			list.remove(idx);
		}

		public int size() {
			return list.size();
		}

		public void sort(int prop, boolean bAsc) {
			PointComparator c = new PointComparator(prop, bAsc);
			Collections.sort(list, c);
		}
	}

	class Prime {
		final int maxPrime = 1000;
		final int[] prime = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,
				89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193,
				197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313,
				317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443,
				449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587,
				593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719,
				727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859,
				863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997 };
		final Set<Integer> primeSet = new HashSet<>();

		Prime() {
			for (int p : prime)
				primeSet.add(p);
		}

		boolean isPrime(int n) {
			if (n <= maxPrime)
				return primeSet.contains(n);
			for (int i : prime) {
				if (n % i == 0)
					return false;
			}
			int sqrtNum = (int) Math.ceil(Math.sqrt(n));
			for (int i = maxPrime + 1; i <= sqrtNum; i += 2) {
				if (n % i == 0)
					return false;
			}
			return true;
		}
	}

	class StrList implements Iterable<String> {
		class StrComparator implements Comparator<String> {
			int sign;

			public StrComparator(boolean bAsc) {
				sign = bAsc ? 1 : -1;
			}

			public int compare(String o1, String o2) {
				return sign * o1.compareTo(o2);
			}
		}

		List<String> list = new ArrayList<>();
		StrComparator asc = new StrComparator(true);
		StrComparator desc = new StrComparator(false);

		public StrList() {
		}

		public StrList(String[] sa) {
			for (int i = 0; i < sa.length; i++)
				list.add(sa[i]);
		}

		public void add(String s) {
			list.add(s);
		}

		public String get(int idx) {
			return list.get(idx);
		}

		public Iterator<String> iterator() {
			return list.iterator();
		}

		public int size() {
			return list.size();
		}

		public void sort(boolean bAsc) {
			if (bAsc)
				Collections.sort(list, asc);
			else
				Collections.sort(list, desc);
		}
	}

	int abs(int a) {
		return (a >= 0) ? a : -a;
	}

	long abs(long a) {
		return (a >= 0) ? a : -a;
	}

	long ceil(long a, long b) {
		if (a < 0) {
			return -1 * floor(-a, b);
		}
		return ((a + b - 1) / b) * b;
	}

	long floor(long a, long b) {
		if (a < 0) {
			return -1 * ceil(-a, b);
		}
		return (a / b) * b;
	}

	int max(int a, int b) {
		return (a > b) ? a : b;
	}

	long max(long a, long b) {
		return (a > b) ? a : b;
	}

	int min(int a, int b) {
		return (a < b) ? a : b;
	}

	long min(long a, long b) {
		return (a < b) ? a : b;
	}

	int reed(long a, int n) {
		while (n-- > 0)
			a /= 10;
		return (int) (a % 10);
	}

	int sqrt(long a) {
		return (int) Math.sqrt(a);
	}

	int pint(String s) {
		return Integer.parseInt(s);
	}

	long plong(String s) {
		return Long.parseLong(s);
	}

	String readLine() {
		try {
			return _in.readLine();
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}

	int readNum() {
		String line = readLine();
		return pint(line);
	}

	long readLong() {
		String line = readLine();
		return plong(line);
	}

	String[] readFlds() {
		String line = readLine();
		return line.split(" ");
	}

	String[] readLines(int n) {
		String[] lines = new String[n];
		for (int i = 0; i < n; i++)
			lines[i] = readLine();
		return lines;
	}

	CharList readChars() {
		CharList list = new CharList();
		String line = readLine();
		for (int i = 0; i < line.length(); i++)
			list.add(line.charAt(i));
		return list;
	}

	int[] readNums() {
		String[] flds = readFlds();
		int[] nums = new int[flds.length];
		for (int i = 0; i < flds.length; i++)
			nums[i] = pint(flds[i]);
		return nums;
	}

	int[] readNums(int n) {
		int[] nums = new int[n];
		for (int i = 0; i < n; i++)
			nums[i] = readNum();
		return nums;
	}

	long[] readLongs() {
		String[] flds = readFlds();
		long[] nums = new long[flds.length];
		for (int i = 0; i < flds.length; i++)
			nums[i] = plong(flds[i]);
		return nums;
	}

	long[] readLongs(int n) {
		long[] nums = new long[n];
		for (int i = 0; i < n; i++)
			nums[i] = readLong();
		return nums;
	}

	Main pln() {
		_out.println();
		return this;
	}

	Main p(char c) {
		_out.print(c);
		return this;
	}

	Main p(char c, int n) {
		for (int i = 0; i < n; i++)
			p(c);
		return this;
	}

	Main pln(char c) {
		_out.println(c);
		return this;
	}

	Main p(double d) {
		_out.print(d);
		return this;
	}

	Main pln(double d) {
		_out.println(d);
		return this;
	}

	Main p(long l) {
		_out.print(l);
		return this;
	}

	Main pln(long l) {
		_out.println(l);
		return this;
	}

	Main p(String s) {
		_out.print(s);
		return this;
	}

	Main p(String s, int idx) {
		_out.print(s.charAt(idx));
		return this;
	}

	Main pln(String s) {
		_out.println(s);
		return this;
	}

	Main pln(int[] ia) {
		for (int i = 0; i < ia.length; i++)
			_out.println(ia[i]);
		return this;
	}

	Main pln(long[] la) {
		for (int i = 0; i < la.length; i++)
			_out.println(la[i]);
		return this;
	}

	static BufferedReader _in;
	static PrintWriter _out;
	static boolean _bElapsed = false;

	public static void main(String[] args) {
		long start = System.currentTimeMillis();
		_in = new BufferedReader(new InputStreamReader(System.in));
		_out = new PrintWriter(System.out);
		new Main().solve();
		_out.flush();
		long end = System.currentTimeMillis();
		if (_bElapsed)
			System.err.println((end - start) + "ms");
	}
}

</source>
<source file="../hum_codes_raw/s743962494.java" startline="1" endline="645" pcid="24990">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class Main {
	final int _intMax = Integer.MAX_VALUE; // =2147483647>10^9
	final int _intMin = Integer.MIN_VALUE;
	final long _longMax = Long.MAX_VALUE; // =9223372036854775807L>10^18
	final long _longMin = Long.MIN_VALUE;
	final char[] _azAry = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',
			's', 't', 'u', 'v', 'w', 'x', 'y', 'z' };

	void solve() {
		Prime prime = new Prime();
		int n = readNum();
		StringBuilder sb = new StringBuilder();
		for (int i = 11; n > 0; i += 5) {
			if (prime.isPrime(i)) {
				sb.append(i).append(" ");
				n--;
			}
		}
		pln(sb.toString().trim());
	}

	// -----------------------------------------------------
	// 2018/05/06 r27
	// -----------------------------------------------------
	List<Character> getazList() {
		List<Character> list = new ArrayList<>();
		for (char ch : _azAry)
			list.add(ch);
		return list;
	}

	int getDx(int idx) {
		int[] dx = { 0, 1, 1, 1, 0, -1, -1, -1 };
		return dx[idx];
	}

	int getDy(int idx) {
		int[] dy = { -1, -1, 0, 1, 1, 1, 0, -1 };
		return dy[idx];
	}

	class Bitmap {
		int mx;
		int my;
		boolean[][] map;

		public Bitmap(int mx, int my) {
			this.mx = mx;
			this.my = my;
			map = new boolean[my + 2][mx + 2];
		}

		public boolean is(int x, int y) {
			return map[y][x];
		}

		public void set(int x, int y, boolean b) {
			map[y][x] = b;
		}
	}

	class CharList implements Iterable<Character> {
		class CharComparator implements Comparator<Character> {
			int sign;

			public CharComparator(boolean bAsc) {
				sign = bAsc ? 1 : -1;
			}

			public int compare(Character o1, Character o2) {
				return sign * Character.compare(o1, o2);
			}
		}

		List<Character> list = new ArrayList<>();
		CharComparator asc = new CharComparator(true);
		CharComparator desc = new CharComparator(false);

		public void add(char ch) {
			list.add(ch);
		}

		public char get(int idx) {
			return list.get(idx);
		}

		public char getLast() {
			return list.get(list.size() - 1);
		}

		public Iterator<Character> iterator() {
			return list.iterator();
		}

		public void remove(int idx) {
			list.remove(idx);
		}

		public void removeLast() {
			list.remove(list.size() - 1);
		}

		public int size() {
			return list.size();
		}

		public void sort(boolean bAsc) {
			if (bAsc)
				Collections.sort(list, asc);
			else
				Collections.sort(list, desc);
		}

		public String toString() {
			StringBuilder sb = new StringBuilder();
			for (char ch : list)
				sb.append(ch);
			return sb.toString();
		}
	}

	class Counter<K> {
		Map<K, Integer> map = new HashMap<>();

		public Counter() {
		}

		public Counter(Iterable<K> itr) {
			for (K obj : itr) {
				add(obj);
			}
		}

		public void add(K key) {
			Integer cnt = map.get(key);
			if (cnt == null)
				map.put(key, 1);
			else
				map.put(key, cnt + 1);
		}

		public int get(K key) {
			Integer cnt = map.get(key);
			if (cnt == null)
				return 0;
			else
				return cnt;
		}

		public Set<K> keySet() {
			return map.keySet();
		}
	}

	class IntList implements Iterable<Integer> {
		class Info {
			int idx;
			int val;

			public Info(int idx, int val) {
				this.idx = idx;
				this.val = val;
			}

			public String toString() {
				return "(" + idx + ", " + val + ")";
			}
		}

		class InfoComparator implements Comparator<Info> {
			int sign;

			public InfoComparator(boolean bAsc) {
				sign = bAsc ? 1 : -1;
			}

			public int compare(Info o1, Info o2) {
				return sign * Integer.compare(o1.val, o2.val);
			}
		}

		List<Info> list = new ArrayList<>();
		InfoComparator asc = new InfoComparator(true);
		InfoComparator desc = new InfoComparator(false);

		public IntList() {
		}

		public IntList(int[] ia) {
			for (int i = 0; i < ia.length; i++)
				add(ia[i]);
		}

		public void add(int val) {
			list.add(new Info(list.size(), val));
		}

		public void add(int idx, int val) {
			list.add(new Info(idx, val));
		}

		public int getIdx(int idx) {
			return list.get(idx).idx;
		}

		public int getVal(int idx) {
			return list.get(idx).val;
		}

		public int getLastVal() {
			return list.get(list.size() - 1).val;
		}

		public Iterator<Integer> iterator() {
			List<Integer> vallist = new ArrayList<>();
			for (Info info : list)
				vallist.add(info.val);
			return vallist.iterator();
		}

		public void remove(int idx) {
			list.remove(idx);
		}

		public void removeLast() {
			list.remove(list.size() - 1);
		}

		public int size() {
			return list.size();
		}

		public void sort(boolean bAsc) {
			if (bAsc)
				Collections.sort(list, asc);
			else
				Collections.sort(list, desc);
		}
	}

	class Point {
		int x;
		int y;

		public Point(int x, int y) {
			this.x = x;
			this.y = y;
		}

		public Point(Point pt) {
			this.x = pt.x;
			this.y = pt.y;
		}

		public boolean equals(Object o) {
			if (o instanceof Point) {
				Point that = (Point) o;
				return (x == that.x) && (y == that.y);
			}
			return false;
		}

		public long getManhattanDistance(Point pt) {
			return abs((long) pt.x - this.x) + abs((long) pt.y - this.y);
		}

		public int hashCode() {
			return x + (y * 31);
		}

		public String toString() {
			return "(" + x + ", " + y + ")";
		}
	}

	class PointList implements Iterable<Point> {
		class PointComparator implements Comparator<Point> {
			int mode;

			public PointComparator(int prop, boolean bAsc) {
				switch (prop) {
				case 1:
					if (bAsc)
						this.mode = 11;
					else
						this.mode = 12;
					break;
				case 2:
					if (bAsc)
						this.mode = 21;
					else
						this.mode = 22;
					break;
				default:
					throw new RuntimeException();
				}
			}

			public int compare(Point p1, Point p2) {
				switch (mode) {
				case 11:
					return 1 * Integer.compare(p1.x, p2.x);
				case 12:
					return -1 * Integer.compare(p1.x, p2.x);
				case 21:
					return 1 * Integer.compare(p1.y, p2.y);
				case 22:
					return -1 * Integer.compare(p1.y, p2.y);
				}
				throw new IllegalStateException();
			}
		}

		List<Point> list = new ArrayList<>();

		public void add(int x, int y) {
			list.add(new Point(x, y));
		}

		public Point get(int idx) {
			return list.get(idx);
		}

		public Iterator<Point> iterator() {
			return list.iterator();
		}

		public void remove(int idx) {
			list.remove(idx);
		}

		public int size() {
			return list.size();
		}

		public void sort(int prop, boolean bAsc) {
			PointComparator c = new PointComparator(prop, bAsc);
			Collections.sort(list, c);
		}
	}

	class Prime {
		final int maxPrime = 1000;
		final int[] prime = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,
				89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193,
				197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313,
				317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443,
				449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587,
				593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719,
				727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859,
				863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997 };
		final Set<Integer> primeSet = new HashSet<>();

		Prime() {
			for (int p : prime)
				primeSet.add(p);
		}

		boolean isPrime(int n) {
			if (n <= maxPrime)
				return primeSet.contains(n);
			for (int i : prime) {
				if (n % i == 0)
					return false;
			}
			int sqrtNum = (int) Math.ceil(Math.sqrt(n));
			for (int i = maxPrime + 1; i <= sqrtNum; i += 2) {
				if (n % i == 0)
					return false;
			}
			return true;
		}
	}

	class StrList implements Iterable<String> {
		class StrComparator implements Comparator<String> {
			int sign;

			public StrComparator(boolean bAsc) {
				sign = bAsc ? 1 : -1;
			}

			public int compare(String o1, String o2) {
				return sign * o1.compareTo(o2);
			}
		}

		List<String> list = new ArrayList<>();
		StrComparator asc = new StrComparator(true);
		StrComparator desc = new StrComparator(false);

		public StrList() {
		}

		public StrList(String[] sa) {
			for (int i = 0; i < sa.length; i++)
				list.add(sa[i]);
		}

		public void add(String s) {
			list.add(s);
		}

		public String get(int idx) {
			return list.get(idx);
		}

		public Iterator<String> iterator() {
			return list.iterator();
		}

		public int size() {
			return list.size();
		}

		public void sort(boolean bAsc) {
			if (bAsc)
				Collections.sort(list, asc);
			else
				Collections.sort(list, desc);
		}
	}

	int abs(int a) {
		return (a >= 0) ? a : -a;
	}

	long abs(long a) {
		return (a >= 0) ? a : -a;
	}

	long ceil(long a, long b) {
		if (a < 0) {
			return -1 * floor(-a, b);
		}
		return ((a + b - 1) / b) * b;
	}

	long floor(long a, long b) {
		if (a < 0) {
			return -1 * ceil(-a, b);
		}
		return (a / b) * b;
	}

	int max(int a, int b) {
		return (a > b) ? a : b;
	}

	long max(long a, long b) {
		return (a > b) ? a : b;
	}

	int min(int a, int b) {
		return (a < b) ? a : b;
	}

	long min(long a, long b) {
		return (a < b) ? a : b;
	}

	int reed(long a, int n) {
		while (n-- > 0)
			a /= 10;
		return (int) (a % 10);
	}

	int sqrt(long a) {
		return (int) Math.sqrt(a);
	}

	int pint(String s) {
		return Integer.parseInt(s);
	}

	long plong(String s) {
		return Long.parseLong(s);
	}

	String readLine() {
		try {
			return _in.readLine();
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}

	int readNum() {
		String line = readLine();
		return pint(line);
	}

	long readLong() {
		String line = readLine();
		return plong(line);
	}

	String[] readFlds() {
		String line = readLine();
		return line.split(" ");
	}

	String[] readLines(int n) {
		String[] lines = new String[n];
		for (int i = 0; i < n; i++)
			lines[i] = readLine();
		return lines;
	}

	CharList readChars() {
		CharList list = new CharList();
		String line = readLine();
		for (int i = 0; i < line.length(); i++)
			list.add(line.charAt(i));
		return list;
	}

	int[] readNums() {
		String[] flds = readFlds();
		int[] nums = new int[flds.length];
		for (int i = 0; i < flds.length; i++)
			nums[i] = pint(flds[i]);
		return nums;
	}

	int[] readNums(int n) {
		int[] nums = new int[n];
		for (int i = 0; i < n; i++)
			nums[i] = readNum();
		return nums;
	}

	long[] readLongs() {
		String[] flds = readFlds();
		long[] nums = new long[flds.length];
		for (int i = 0; i < flds.length; i++)
			nums[i] = plong(flds[i]);
		return nums;
	}

	long[] readLongs(int n) {
		long[] nums = new long[n];
		for (int i = 0; i < n; i++)
			nums[i] = readLong();
		return nums;
	}

	Main pln() {
		_out.println();
		return this;
	}

	Main p(char c) {
		_out.print(c);
		return this;
	}

	Main p(char c, int n) {
		for (int i = 0; i < n; i++)
			p(c);
		return this;
	}

	Main pln(char c) {
		_out.println(c);
		return this;
	}

	Main p(double d) {
		_out.print(d);
		return this;
	}

	Main pln(double d) {
		_out.println(d);
		return this;
	}

	Main p(long l) {
		_out.print(l);
		return this;
	}

	Main pln(long l) {
		_out.println(l);
		return this;
	}

	Main p(String s) {
		_out.print(s);
		return this;
	}

	Main p(String s, int idx) {
		_out.print(s.charAt(idx));
		return this;
	}

	Main pln(String s) {
		_out.println(s);
		return this;
	}

	Main pln(int[] ia) {
		for (int i = 0; i < ia.length; i++)
			_out.println(ia[i]);
		return this;
	}

	Main pln(long[] la) {
		for (int i = 0; i < la.length; i++)
			_out.println(la[i]);
		return this;
	}

	static BufferedReader _in;
	static PrintWriter _out;
	static boolean _bElapsed = false;

	public static void main(String[] args) {
		long start = System.currentTimeMillis();
		_in = new BufferedReader(new InputStreamReader(System.in));
		_out = new PrintWriter(System.out);
		new Main().solve();
		_out.flush();
		long end = System.currentTimeMillis();
		if (_bElapsed)
			System.err.println((end - start) + "ms");
	}
}

</source>
</class>

<class classid="277" nclones="2" nlines="99" similarity="100">
<source file="../hum_codes_raw/s667272876.java" startline="1" endline="136" pcid="22414">
import java.io.*;
import java.util.*;

class Main{
	public static void main(String[] args){
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		try{
			String input_str;
			while((input_str = br.readLine()) != null){
				String[] input_strs = input_str.split(" ");

				// まずノードを生成
				Node node1 = new Node(input_strs[1]);
				Node node2 = new Node(input_strs[2]);
				Node result_node = new Node();

				// intersection
				if(input_strs[0].equals("i")){
					result_node.intersection(node1, node2);
				}

				// union
				if(input_strs[0].equals("u")){
					result_node.union(node1, node2);
				}

				System.out.println(result_node.toString());
			}
		}catch(Exception e){
			System.out.println("Error");
		}

		/*
		Node node1 = new Node("((,),(,))");
		System.out.println("node1: " + node1.toString());

		Node node2 = new Node("((,(,)),)");
		System.out.println("node2: " + node2.toString());

		Node inode = new Node();
		inode.intersection(node1, node2);
		System.out.println("inode: " + inode.toString());

		Node unode = new Node();
		unode.union(node1, node2);
		System.out.println("unode: " + unode.toString());
		*/
	}
}

class Node{
	Node left;
	Node right;

	Node(){
		left = null;
		right = null;
	}

	Node(String str){
		//System.out.println(str);

		int lvl = 0;
		for(int i = 0; i < str.length(); i++){
			char ch = str.charAt(i);
			if(ch == '(') lvl++;
			if(ch == ')') lvl--;
			if(ch == ',' && lvl == 1){
				// 左辺
				String left_str = str.substring(1, i);
				if(left_str.length() == 0){
					left = null;
				}else{
					left = new Node(left_str);
				}

				// 右辺
				String right_str = str.substring(i+1, str.length()-1);
				if(right_str.length() == 0){
					right = null;
				}else{
					right = new Node(right_str);
				}
			}
		}
	}

	public String toString(){
		String result = "(";
		if(left != null) result += left.toString();
		result += ",";
		if(right != null) result += right.toString();
		result += ")";
		return result;
	}

	public Node intersection(Node node1, Node node2){
		// intersection は，どちらか片方が null なら null
		// 両方 null でないなら，子の intersection
		// left
		if(node1.left != null && node2.left != null){
			left = new Node();
			left.intersection(node1.left, node2.left);
		}
		// right
		if(node1.right != null && node2.right != null){
			// どちらも null でない
			right = new Node();
			right.intersection(node1.right, node2.right);
		}
		return this;
	}

	public Node union(Node node1, Node node2){
		// left
		if(node1.left == null){
			left = node2.left;
		}else if(node2.left == null){
			left = node1.left;
		}else{
			left = new Node();
			left.union(node1.left, node2.left);
		}
		// right
		if(node1.right == null){
			right = node2.right;
		}else if(node2.right == null){
			right = node1.right;
		}else{
			right = new Node();
			right.union(node1.right, node2.right);
		}
		return this;
	}
}

</source>
<source file="../hum_codes_raw/s881270089.java" startline="1" endline="116" pcid="29617">
import java.io.*;
import java.util.*;
 
class Main{
    public static void main(String[] args){
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        try{
            String input_str;
            while((input_str = br.readLine()) != null){
                String[] input_strs = input_str.split(" ");
 
                // まずノードを生成
                Node node1 = new Node(input_strs[1]);
                Node node2 = new Node(input_strs[2]);
                Node result_node = new Node();
 
                // intersection
                if(input_strs[0].equals("i")){
                    result_node.intersection(node1, node2);
                }
 
                // union
                if(input_strs[0].equals("u")){
                    result_node.union(node1, node2);
                }
 
                System.out.println(result_node.toString());
            }
        }catch(Exception e){
            System.out.println("Error");
        }
    }
}
 
class Node{
    Node left;
    Node right;
 
    Node(){
        left = null;
        right = null;
    }
 
    Node(String str){
        int lvl = 0;
        for(int i = 0; i < str.length(); i++){
            char ch = str.charAt(i);
            if(ch == '(') lvl++;
            if(ch == ')') lvl--;
            if(ch == ',' && lvl == 1){
                // 左辺
                String left_str = str.substring(1, i);
                if(left_str.length() == 0){
                    left = null;
                }else{
                    left = new Node(left_str);
                }
 
                // 右辺
                String right_str = str.substring(i+1, str.length()-1);
                if(right_str.length() == 0){
                    right = null;
                }else{
                    right = new Node(right_str);
                }
            }
        }
    }
 
    public String toString(){
        String result = "(";
        if(left != null) result += left.toString();
        result += ",";
        if(right != null) result += right.toString();
        result += ")";
        return result;
    }
 
    public Node intersection(Node node1, Node node2){
        // left
        if(node1.left != null && node2.left != null){
            left = new Node();
            left.intersection(node1.left, node2.left);
        }
        // right
        if(node1.right != null && node2.right != null){
            // どちらも null でない
            right = new Node();
            right.intersection(node1.right, node2.right);
        }
        return this;
    }
 
    public Node union(Node node1, Node node2){
        // left
        if(node1.left == null){
            left = node2.left;
        }else if(node2.left == null){
            left = node1.left;
        }else{
            left = new Node();
            left.union(node1.left, node2.left);
        }
        // right
        if(node1.right == null){
            right = node2.right;
        }else if(node2.right == null){
            right = node1.right;
        }else{
            right = new Node();
            right.union(node1.right, node2.right);
        }
        return this;
    }
}

</source>
</class>

<class classid="278" nclones="2" nlines="56" similarity="100">
<source file="../hum_codes_raw/s667781206.java" startline="1" endline="72" pcid="22431">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;

public class Main {

  int H,W;
  int sy,sx;
  int cnt;
  boolean[][] map;
  int[] dy = {-1,0,1,0}, dx = {0,1,0,-1}; 
  public static void main(String[] args) {
    new Main().run();
  }
  public void run() {

    try(BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(System.out) ) {

      String[] lines;
      // StringBuilder buf = new StringBuilder();
      while(true) {
        lines = in.readLine().split(" ");
        W = Integer.parseInt(lines[0]);
        H = Integer.parseInt(lines[1]);

        if( W==0 && H==0) break;

        map = new boolean[H][W];

        String line;
        for(int y=0; y<H; y++) {
          char ch;
          line = in.readLine();
          for(int x=0; x<W; x++) {
            ch = line.charAt(x);
            map[y][x] = ch == '#' ? false : true;
            if(ch == '@') {
              sy = y; sx = x;
            }
          }
        }

        cnt = 0;
        dfs(sy,sx);
        // buf.append(cnt).append("\n");
        out.println(cnt);
      }

      // System.out.print(buf);
      out.flush();
    }
    catch(IOException e) {
      System.err.println(e);
    }
  }

  private void dfs(int y, int x) {
    map[y][x] = false;
    cnt++;

    for(int i=0; i<4; i++) {
      int ny = y + dy[i], nx = x + dx[i];
      if(0 <= ny && ny < H && 0 <= nx && nx < W && map[ny][nx]) {
        dfs(ny,nx);
      }
    }
    return;
  }
}

</source>
<source file="../hum_codes_raw/s788167550.java" startline="1" endline="72" pcid="26460">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;

public class Main {

  int H,W;
  int sy,sx;
  int cnt;
  boolean[][] map;
  int[] dy = {-1,0,1,0}, dx = {0,1,0,-1}; 
  public static void main(String[] args) {
    new Main().run();
  }
  public void run() {

    try(BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(System.out) ) {

      String[] lines;
      // StringBuilder buf = new StringBuilder();
      while(true) {
        lines = in.readLine().split(" ");
        W = Integer.parseInt(lines[0]);
        H = Integer.parseInt(lines[1]);

        if( W==0 && H==0) break;

        map = new boolean[H][W];

        String line;
        for(int y=0; y<H; y++) {
          char ch;
          line = in.readLine();
          for(int x=0; x<W; x++) {
            ch = line.charAt(x);
            map[y][x] = ch == '#' ? false : true;
            if(ch == '@') {
              sy = y; sx = x;
            }
          }
        }

        cnt = 0;
        dfs(sy,sx);
        // buf.append(cnt).append("\n");
        out.println(cnt);
      }

      // System.out.print(buf);
      out.flush();
    }
    catch(IOException e) {
      System.err.println(e);
    }
  }

  private void dfs(int y, int x) {
    map[y][x] = false;
    cnt++;

    for(int i=0; i<4; i++) {
      int ny = y + dy[i], nx = x + dx[i];
      if(0 <= ny && ny < H && 0 <= nx && nx < W && map[ny][nx]) {
        dfs(ny,nx);
      }
    }
    return;
  }
}

</source>
</class>

<class classid="279" nclones="3" nlines="51" similarity="100">
<source file="../hum_codes_raw/s672841375.java" startline="1" endline="78" pcid="22607">
import java.util.*;



class Main{

    public static void main(String[] args){

	int gyo,retu,n;
	String sc;
	Scanner in = new Scanner(System.in);


	gyo = in.nextInt();
	retu = in.nextInt();
	n = in.nextInt();
	int[][] jm = new int[gyo+1][retu+1];
	int[][] om = new int[gyo+1][retu+1];
	int[][] im = new int[gyo+1][retu+1];
	for(int i=0;i<=gyo;i++){
	    for(int j=0;j<=retu;j++){
		jm[i][j]=0;
		om[i][j]=0;
		im[i][j]=0;
	    }
	}

	//Arrays.fill(jm,0); //memsetÂIÂÃÂÂ¨ÂÂ©memÂÃÂÃÂÃ¡ÂÃÂÃ2ÂÂÂÂ¾ÂÃÂGÂÂÂ[ÂÂ©ÂÃÂÃ§ÂÂ½ÂgÂÂ¦ÂÃÂÂ¢ÂÂ¢ÂÃÂHÂÂ©ÂmÂÃ§ÂÃÂÂ¢ÂÂ©ÂÃ§ÂÂÂÃÂÃÂÂÂ[ÂvÂÃ±ÂÂ·
	//Arrays.fill(om,0);
	//Arrays.fill(im,0);

	for(int i=1;i<=gyo;i++){
	    sc = in.next();
	    for(int j=0;j<retu;j++){
		char cc[] = sc.toCharArray();
		jm[i][j+1]=jm[i-1][j+1]+jm[i][j]-jm[i-1][j];
		om[i][j+1] = om[i-1][j+1]+om[i][j]-om[i-1][j];
		im[i][j+1]=im[i-1][j+1]+im[i][j]-im[i-1][j];
		if(cc[j] == 'J'){
		    jm[i][j+1]++;
		}else if(cc[j] == 'O'){
		    om[i][j+1]++;
		}else if(cc[j] == 'I'){
		    im[i][j+1]++;
		}


	    }
	}

	/*	
		for(int i=0;i<=gyo;i++){
		for(int j=0;j<=retu;j++)System.out.print(jm[i][j] + " ");
		System.out.printf("\n");
		}
	*/
	
	int a,b,c,d;
	for(int i=0;i<n;i++){
	    a = in.nextInt();
	    b = in.nextInt();
	    c = in.nextInt();
	    d = in.nextInt();
	    System.out.print(jm[c][d]-jm[a-1][d]-jm[c][b-1]+jm[a-1][b-1]);
	    System.out.print(" ");
	    System.out.print(om[c][d]-om[a-1][d]-om[c][b-1]+om[a-1][b-1]);
	    System.out.print(" ");
	    System.out.println(im[c][d]-im[a-1][d]-im[c][b-1]+im[a-1][b-1]);

	}
	


    }


}

</source>
<source file="../hum_codes_raw/s966835667.java" startline="1" endline="84" pcid="32511">
import java.util.*;


//ÂÃ£ÂÃÂÂ©ÂÃÂÂÂÃ°ÂÃÂÂ«ÂÃÂÂ©ÂÃÂÂ½ÂÂÂÃÂÂ´ÂpÂÃ°ÂÃ 
//
//ÂÂ¢ÂÃ«ÂÂ¢ÂÃ«ÂÃ ÂÂ¾ÂÂÂÂ¢ÂÃÂÃÂÂ½ÂÂ¯ÂÃÂÃÂÃªÂÃ ÂÃ­ÂÂ©ÂÃ¨ÂÃÂÂ­ÂÂ©ÂÃÂÂ½ÂÃÂÃÂÃ¢ÂÃÂÃ©
//ÂmÂ[ÂgÂÂ©ÂÃÂÃ±ÂÂ©ÂÃÂÂÂÂ¢ÂÃÂÃ
//ÂÂ¢ÂÃ§ÂÃ±ÂÃÂÂ±ÂÃ¸ÂÂ¢ÂÃ2ÂÃ±ÂÃ¸ÂÂ¢ÂÃÂÂµÂÃÂÃÂÂ½ÂÃÂÂ±ÂÃ°ÂÃÂÂ¦ÂÂ½ÂÂ¾ÂÂ¯


class Main{

    public static void main(String[] args){

	int gyo,retu,n;
	String sc;
	Scanner in = new Scanner(System.in);


	gyo = in.nextInt();
	retu = in.nextInt();
	n = in.nextInt();
	int[][] jm = new int[gyo+1][retu+1];
	int[][] om = new int[gyo+1][retu+1];
	int[][] im = new int[gyo+1][retu+1];
	for(int i=0;i<=gyo;i++){
	    for(int j=0;j<=retu;j++){
		jm[i][j]=0;
		om[i][j]=0;
		im[i][j]=0;
	    }
	}

	//Arrays.fill(jm,0); //memsetÂIÂÃÂÂ¨ÂÂ©memÂÃÂÃÂÃ¡ÂÃÂÃ2ÂÂÂÂ¾ÂÃÂGÂÂÂ[ÂÂ©ÂÃÂÃ§ÂÂ½ÂgÂÂ¦ÂÃÂÂ¢ÂÂ¢ÂÃÂHÂÂ©ÂmÂÃ§ÂÃÂÂ¢ÂÂ©ÂÃ§ÂÂÂÃÂÃÂÂÂ[ÂvÂÃ±ÂÂ·
	//Arrays.fill(om,0);
	//Arrays.fill(im,0);

	for(int i=1;i<=gyo;i++){
	    sc = in.next();
	    for(int j=0;j<retu;j++){
		char cc[] = sc.toCharArray();
		jm[i][j+1]=jm[i-1][j+1]+jm[i][j]-jm[i-1][j];
		om[i][j+1] = om[i-1][j+1]+om[i][j]-om[i-1][j];
		im[i][j+1]=im[i-1][j+1]+im[i][j]-im[i-1][j];
		if(cc[j] == 'J'){
		    jm[i][j+1]++;
		}else if(cc[j] == 'O'){
		    om[i][j+1]++;
		}else if(cc[j] == 'I'){
		    im[i][j+1]++;
		}


	    }
	}

	/*	
		for(int i=0;i<=gyo;i++){
		for(int j=0;j<=retu;j++)System.out.print(jm[i][j] + " ");
		System.out.printf("\n");
		}
	*/
	
	int a,b,c,d;
	for(int i=0;i<n;i++){
	    a = in.nextInt();
	    b = in.nextInt();
	    c = in.nextInt();
	    d = in.nextInt();
	    System.out.print(jm[c][d]-jm[a-1][d]-jm[c][b-1]+jm[a-1][b-1]);
	    System.out.print(" ");
	    System.out.print(om[c][d]-om[a-1][d]-om[c][b-1]+om[a-1][b-1]);
	    System.out.print(" ");
	    System.out.println(im[c][d]-im[a-1][d]-im[c][b-1]+im[a-1][b-1]);

	}
	


    }


}

</source>
<source file="../hum_codes_raw/s764844827.java" startline="1" endline="78" pcid="25684">
import java.util.*;



class Main{

    public static void main(String[] args){

	int gyo,retu,n;
	String sc;
	Scanner in = new Scanner(System.in);


	gyo = in.nextInt();
	retu = in.nextInt();
	n = in.nextInt();
	int[][] jm = new int[gyo+1][retu+1];
	int[][] om = new int[gyo+1][retu+1];
	int[][] im = new int[gyo+1][retu+1];
	for(int i=0;i<=gyo;i++){
	    for(int j=0;j<=retu;j++){
		jm[i][j]=0;
		om[i][j]=0;
		im[i][j]=0;
	    }
	}

	//Arrays.fill(jm,0); //memsetツ的ツづ按閉ィ
	//Arrays.fill(om,0);
	//Arrays.fill(im,0);

	for(int i=1;i<=gyo;i++){
	    sc = in.next();
	    for(int j=0;j<retu;j++){
		char cc[] = sc.toCharArray();
		jm[i][j+1]=jm[i-1][j+1]+jm[i][j]-jm[i-1][j];
		om[i][j+1] = om[i-1][j+1]+om[i][j]-om[i-1][j];
		im[i][j+1]=im[i-1][j+1]+im[i][j]-im[i-1][j];
		if(cc[j] == 'J'){
		    jm[i][j+1]++;
		}else if(cc[j] == 'O'){
		    om[i][j+1]++;
		}else if(cc[j] == 'I'){
		    im[i][j+1]++;
		}


	    }
	}

	/*	
		for(int i=0;i<=gyo;i++){
		for(int j=0;j<=retu;j++)System.out.print(jm[i][j] + " ");
		System.out.printf("\n");
		}
	*/
	
	int a,b,c,d;
	for(int i=0;i<n;i++){
	    a = in.nextInt();
	    b = in.nextInt();
	    c = in.nextInt();
	    d = in.nextInt();
	    System.out.print(jm[c][d]-jm[a-1][d]-jm[c][b-1]+jm[a-1][b-1]);
	    System.out.print(" ");
	    System.out.print(om[c][d]-om[a-1][d]-om[c][b-1]+om[a-1][b-1]);
	    System.out.print(" ");
	    System.out.println(im[c][d]-im[a-1][d]-im[c][b-1]+im[a-1][b-1]);

	}
	


    }


}

</source>
</class>

<class classid="280" nclones="2" nlines="194" similarity="100">
<source file="../hum_codes_raw/s676825637.java" startline="1" endline="192" pcid="22742">
import java.io.*;
        
class Main{
static int[] sx={0,0,1,0,-1};
static int[] sy={0,1,0,-1,0};
static int[] mx={0,0,1,0,-1,-1,-1,1,1};
static int[] my={0,1,0,-1,0,-1,1,-1,1};
static int[] lx={0,0,1,0,-1,-1,-1,1,1,0,2,0,-2};
static int[] ly={0,1,0,-1,0,-1,1,-1,1,2,0,-2,0};
static int total;
static int res;
static int[][] map=new int[10][10];
static int[][][] drop=new int[10][10][3];
static void sd(int x,int y){
for(int i=0;i<sx.length;i++){
map[x+sx[i]][y+sy[i]]--;
}
total-=5;
res--;
}
static void sr(int x,int y){
for(int i=0;i<sx.length;i++){
map[x+sx[i]][y+sy[i]]++;
}
total+=5;
res++;
}
static boolean scd(int x,int y){
for(int i=0;i<sx.length;i++){
int nx=x+sx[i];
int ny=y+sy[i];
if(nx<0||ny<0||nx>=10||ny>=10||map[nx][ny]==0){
return false;
}
}
return true;
}
static void md(int x,int y){
for(int i=0;i<mx.length;i++){
map[x+mx[i]][y+my[i]]--;
}
total-=9;
res--;
}
static void mr(int x,int y){
for(int i=0;i<mx.length;i++){
map[x+mx[i]][y+my[i]]++;
}
total+=9;
res++;
}
static boolean mcd(int x,int y){
for(int i=0;i<mx.length;i++){
int nx=x+mx[i];
int ny=y+my[i];
if(nx<0||ny<0||nx>=10||ny>=10||map[nx][ny]==0){
return false;
}
}
return true;
}
static void ld(int x,int y){
for(int i=0;i<lx.length;i++){
map[x+lx[i]][y+ly[i]]--;
}
total-=13;
res--;
}
static void lr(int x,int y){
for(int i=0;i<lx.length;i++){
map[x+lx[i]][y+ly[i]]++;
}
total+=13;
res++;
}
static boolean lcd(int x,int y){
for(int i=0;i<lx.length;i++){
int nx=x+lx[i];
int ny=y+ly[i];
if(nx<0||ny<0||nx>=10||ny>=10||map[nx][ny]==0){
return false;
}
}
return true;
}
public static void main(String[] args) throws IOException{
BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
res=Integer.parseInt(br.readLine());
total=0;
int m;
for(int i=0;i<10;i++){
String[] value=br.readLine().split(" ");
for(int j=0;j<10;j++){
int num=Integer.parseInt(value[j]);
map[i][j]=num;
total+=num;
}
}
if(search(1,1,3)){
for(int i=1;i<9;i++){
for(int j=1;j<9;j++){
for(int k=1;k<=3;k++){
m=drop[i][j][k-1];
if(m!=0){
for(int l=0;l<m;l++){
System.out.println(j+" "+i+" "+k);
}
}
}
}
}
}
}
static boolean searchnext(int x,int y){
if(x==8){
return search(1,y+1,3);
}
return search(x+1,y,3);
}
static boolean search(int x,int y,int size){
if(res==0&&total==0){
return true;
}
else if(total<res*5||total>res*13){
return false;
}
else if(res==0){
return false;
}
if(y==9){
return false;
}
if(y>2&&x==1){
for(int i=0;i<10;i++){
if(map[i][y-3]!=0){
return false;
}
}
}
while(true){
switch(size){
case 3:if(lcd(x,y)){
       ld(x,y);
       drop[x][y][2]++;
       if(searchnext(x,y)){
       return true;
       }
       else{
       if(scd(x,y)&&search(x,y,3)){
       return true;
       }
       lr(x,y);
       drop[x][y][2]--;
       }
       }
       size--;
case 2:if(mcd(x,y)){
       md(x,y);
       drop[x][y][1]++;
       if(searchnext(x,y)){
       return true;
       }
       else{
       if(scd(x,y)&&search(x,y,2)){
       return true;
       }
       mr(x,y);
       drop[x][y][1]--;
       }
       }
       size--;
case 1:if(scd(x,y)){
       sd(x,y);
       drop[x][y][0]++;
       if(searchnext(x,y)){
       return true;
       }
       else{
       if(scd(x,y)&&search(x,y,1)){
       return true;
       }
       sr(x,y);
       drop[x][y][0]--;
       }
       }
       size--;
case 0:return searchnext(x,y);
}
}
}
}

</source>
<source file="../hum_codes_raw/s953973035.java" startline="1" endline="192" pcid="32059">
import java.io.*;
         
class Main{
static int[] sx={0,0,1,0,-1};
static int[] sy={0,1,0,-1,0};
static int[] mx={0,0,1,0,-1,-1,-1,1,1};
static int[] my={0,1,0,-1,0,-1,1,-1,1};
static int[] lx={0,0,1,0,-1,-1,-1,1,1,0,2,0,-2};
static int[] ly={0,1,0,-1,0,-1,1,-1,1,2,0,-2,0};
static int total;
static int res;
static int[][] map=new int[10][10];
static int[][][] drop=new int[10][10][3];
static void sd(int x,int y){
for(int i=0;i<sx.length;i++){
map[x+sx[i]][y+sy[i]]--;
}
total-=5;
res--;
}
static void sr(int x,int y){
for(int i=0;i<sx.length;i++){
map[x+sx[i]][y+sy[i]]++;
}
total+=5;
res++;
}
static boolean scd(int x,int y){
for(int i=0;i<sx.length;i++){
int nx=x+sx[i];
int ny=y+sy[i];
if(nx<0||ny<0||nx>=10||ny>=10||map[nx][ny]==0){
return false;
}
}
return true;
}
static void md(int x,int y){
for(int i=0;i<mx.length;i++){
map[x+mx[i]][y+my[i]]--;
}
total-=9;
res--;
}
static void mr(int x,int y){
for(int i=0;i<mx.length;i++){
map[x+mx[i]][y+my[i]]++;
}
total+=9;
res++;
}
static boolean mcd(int x,int y){
for(int i=0;i<mx.length;i++){
int nx=x+mx[i];
int ny=y+my[i];
if(nx<0||ny<0||nx>=10||ny>=10||map[nx][ny]==0){
return false;
}
}
return true;
}
static void ld(int x,int y){
for(int i=0;i<lx.length;i++){
map[x+lx[i]][y+ly[i]]--;
}
total-=13;
res--;
}
static void lr(int x,int y){
for(int i=0;i<lx.length;i++){
map[x+lx[i]][y+ly[i]]++;
}
total+=13;
res++;
}
static boolean lcd(int x,int y){
for(int i=0;i<lx.length;i++){
int nx=x+lx[i];
int ny=y+ly[i];
if(nx<0||ny<0||nx>=10||ny>=10||map[nx][ny]==0){
return false;
}
}
return true;
}
public static void main(String[] args) throws IOException{
BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
res=Integer.parseInt(br.readLine());
total=0;
int m;
for(int i=0;i<10;i++){
String[] value=br.readLine().split(" ");
for(int j=0;j<10;j++){
int num=Integer.parseInt(value[j]);
map[i][j]=num;
total+=num;
}
}
if(search(1,1,3)){
for(int i=1;i<9;i++){
for(int j=1;j<9;j++){
for(int k=1;k<=3;k++){
m=drop[i][j][k-1];
if(m!=0){
for(int l=0;l<m;l++){
System.out.println(j+" "+i+" "+k);
}
}
}
}
}
}
}
static boolean searchnext(int x,int y){
if(x==8){
return search(1,y+1,3);
}
return search(x+1,y,3);
}
static boolean search(int x,int y,int size){
if(res==0&&total==0){
return true;
}
else if(total<res*5||total>res*13){
return false;
}
else if(res==0){
return false;
}
if(y==9){
return false;
}
if(y>2&&x==1){
for(int i=0;i<10;i++){
if(map[i][y-3]!=0){
return false;
}
}
}
while(true){
switch(size){
case 3:if(lcd(x,y)){
       ld(x,y);
       drop[x][y][2]++;
       if(searchnext(x,y)){
       return true;
       }
       else{
       if(scd(x,y)&&search(x,y,3)){
       return true;
       }
       lr(x,y);
       drop[x][y][2]--;
       }
       }
       size--;
case 2:if(mcd(x,y)){
       md(x,y);
       drop[x][y][1]++;
       if(searchnext(x,y)){
       return true;
       }
       else{
       if(scd(x,y)&&search(x,y,2)){
       return true;
       }
       mr(x,y);
       drop[x][y][1]--;
       }
       }
       size--;
case 1:if(scd(x,y)){
       sd(x,y);
       drop[x][y][0]++;
       if(searchnext(x,y)){
       return true;
       }
       else{
       if(scd(x,y)&&search(x,y,1)){
       return true;
       }
       sr(x,y);
       drop[x][y][0]--;
       }
       }
       size--;
case 0:return searchnext(x,y);
}
}
}
}

</source>
</class>

<class classid="281" nclones="2" nlines="15" similarity="100">
<source file="../hum_codes_raw/s681438131.java" startline="1" endline="19" pcid="22901">

import java.util.Scanner;

public class Main {
   public static void main(String[] args) {
      Scanner sc = new Scanner(System.in);
      int a = sc.nextInt();
      int b = sc.nextInt();
      int c = sc.nextInt();
     
       if(a < b && b < c){
           System.out.printf("Yes\n");
       }
       else {
    	   System.out.printf("No\n");
       }
   }
}

</source>
<source file="../hum_codes_raw/s991534137.java" startline="1" endline="24" pcid="33362">
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {


		Scanner sc = new Scanner(System.in);

		int a = sc.nextInt();
		int b = sc.nextInt();
		int c = sc.nextInt();

		if(a < b && b < c){
			System.out.printf("Yes\n");
		}else{
			System.out.printf("No\n");
		}
	}
}




</source>
</class>

<class classid="282" nclones="2" nlines="33" similarity="100">
<source file="../hum_codes_raw/s683051354.java" startline="1" endline="37" pcid="22951">
//Volume1-0102
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {

		//initialization
		int    out,
		       runner,
		       score;
		String s;

        //input
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        while(n-- > 0){
        	out    = 0;
        	runner = 0;
        	score  = 0;
        	while(out != 3){
            	s = sc.next();
            	if(s.equals("HIT")){
            		if   (runner == 3){score++; }
            		else              {runner++;}
           		}
            	if(s.equals("OUT")){out++;}
            	if(s.equals("HOMERUN")){
            		score += runner + 1;
            		runner = 0;
            	}
        	}
        	System.out.println(score);
        }
	}
}

</source>
<source file="../hum_codes_raw/s730872863.java" startline="1" endline="41" pcid="24566">
//Volume1-0103
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {

		//initialization
		int    out,
		       runner,
		       score;
		String s;

        //input
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        while(n-- > 0){
        	out    = 0;
        	runner = 0;
        	score  = 0;
        	while(out != 3){
            	s = sc.next();

            	//calculation
            	if(s.equals("HIT")){
            		if   (runner == 3){score++; }
            		else              {runner++;}
           		}
            	if(s.equals("OUT")){out++;}
            	if(s.equals("HOMERUN")){
            		score += runner + 1;
            		runner = 0;
            	}
        	}

        	//output
        	System.out.println(score);
        }
	}
}

</source>
</class>

<class classid="283" nclones="2" nlines="77" similarity="100">
<source file="../hum_codes_raw/s690494390.java" startline="1" endline="96" pcid="23222">
import java.util.Scanner;
import java.util.LinkedList;
import java.util.Queue;
 
 
public class Main{
    public static int[] dp=new int[77777777];
    public static void main(String[] args){
        Scanner s = new Scanner(System.in);
       int[][] a = new int[2][4];
       int i,j,m;
       long k=1,n=0;
       m = solve(76543210);
       while(s.hasNext()){
       for(i=0;i<2;i++){
           for(j=0;j<4;j++){
        m=s.nextInt();
        n+=k*(long)m;
        k*=10;
       }
    }
 
 
            
       // m = solve(n);
        System.out.println(Main.dp[(int)n]);
        n=0;
        k=1;
}
    }
    public static int solve(long n){
        Queue<Long> qu=new LinkedList<Long>();
        int[] x = {1,-1,0,0},y= {0,0,1,-1};
        long[] zc =new long[50000];
        int[][] arr = new int[2][4];
        int i,j,zh=-5,zw=-5,e,ppp=0,col=0,kri=0;
        long k=n,temp,no;
        boolean ch=false,chk=false;
        qu.add(n);
        while(true){
            if(qu.size()==0)return 0;
        k = qu.remove();
  //      if(k%100000000==76543210)return (int)k/100000000+kri;
        for(i=0;i<2;i++){
            for(j=0;j<4;j++){
                arr[i][j]=(int)k%10;
                k/=10;
                if(arr[i][j]==0){
                    zh=i;
                    zw=j;
                }
            }
        }
   //     System.out.println(k+" " +col);
        if(k==19){
            kri=20;
            k=0;
        }
        else k++;
 
        k*=100000000;
        no = k;
        for(e=0;e<4;e++){
            if(zh+x[e]>=0&&zh+x[e]<2&&zw+y[e]>=0&&zw+y[e]<4){
            arr[zh][zw] = arr[zh+x[e]][zw+y[e]];
            arr[zh+x[e]][zw+y[e]]=0;
        temp =1;
        for(i=0;i<2;i++){
            for(j=0;j<4;j++){
                k+=temp*(long)arr[i][j];
                temp*=10;
            }
        }
       /* for(ppp=0;ppp<col;ppp++)if(zc[ppp]==k%100000000)ch=true;
        if(ch==false){
            zc[col]=k%100000000;
            qu.add(k);
            col++;
        }*/
        if(Main.dp[(int)k%100000000]==0){
            Main.dp[(int)k%100000000]=(int)k/100000000+kri;
            //System.out.println(sep3.dp[(int)k%100000000]+" "+k%100000000);
            qu.add(k);
        }
        else ch = false;
        k = no;
        arr[zh+x[e]][zw+y[e]] = arr[zh][zw];
        arr[zh][zw]=0;
    }
}
    }
}
 
    }


</source>
<source file="../hum_codes_raw/s906574798.java" startline="1" endline="97" pcid="30501">
import java.util.Scanner;
import java.util.LinkedList;
import java.util.Queue;


public class Main{
    public static int[] dp=new int[77777777];
    public static void main(String[] args){
        Scanner s = new Scanner(System.in);
       int[][] a = new int[2][4];
       int i,j,m;
       long k=1,n=0;
       m = solve(76543210);
       while(s.hasNext()){
       for(i=0;i<2;i++){
           for(j=0;j<4;j++){
        m=s.nextInt();
        n+=k*(long)m;
        k*=10;
       }
    }


           
       // m = solve(n);
        System.out.println(Main.dp[(int)n]);
        n=0;
        k=1;
}
    }
    public static int solve(long n){
        Queue<Long> qu=new LinkedList<Long>();
        int[] x = {1,-1,0,0},y= {0,0,1,-1};
        long[] zc =new long[50000];
        int[][] arr = new int[2][4];
        int i,j,zh=-5,zw=-5,e,ppp=0,col=0,kri=0;
        long k=n,temp,no;
        boolean ch=false,chk=false;
        qu.add(n);
        while(true){
            if(qu.size()==0)return 0;
        k = qu.remove();
  //      if(k%100000000==76543210)return (int)k/100000000+kri;
        for(i=0;i<2;i++){
            for(j=0;j<4;j++){
                arr[i][j]=(int)k%10;
                k/=10;
                if(arr[i][j]==0){
                    zh=i;
                    zw=j;
                }
            }
        }
   //     System.out.println(k+" " +col);
        if(k==19){
            kri=20;
            k=0;
        }
        else k++;

        k*=100000000;
        no = k;
        for(e=0;e<4;e++){
            if(zh+x[e]>=0&&zh+x[e]<2&&zw+y[e]>=0&&zw+y[e]<4){
            arr[zh][zw] = arr[zh+x[e]][zw+y[e]];
            arr[zh+x[e]][zw+y[e]]=0;
        temp =1;
        for(i=0;i<2;i++){
            for(j=0;j<4;j++){
                k+=temp*(long)arr[i][j];
                temp*=10;
            }
        }
       /* for(ppp=0;ppp<col;ppp++)if(zc[ppp]==k%100000000)ch=true;
        if(ch==false){
            zc[col]=k%100000000;
            qu.add(k);
            col++;
        }*/
        if(Main.dp[(int)k%100000000]==0){
            Main.dp[(int)k%100000000]=(int)k/100000000+kri;
            //System.out.println(sep3.dp[(int)k%100000000]+" "+k%100000000);
            qu.add(k);
        }
        else ch = false;
        k = no;
        arr[zh+x[e]][zw+y[e]] = arr[zh][zw];
        arr[zh][zw]=0;
    }
}
    }
}

    }



</source>
</class>

<class classid="284" nclones="2" nlines="45" similarity="100">
<source file="../hum_codes_raw/s699035761.java" startline="1" endline="55" pcid="23511">

import java.util.*;
import static java.lang.Math.*;
import static java.util.Arrays.*;

public class Main {

	int INF = 1 << 28;

	void run() {
		Scanner sc = new Scanner(System.in);
		for(;;) {
			int n = sc.nextInt();
			if(n==0) break;
			int maxn = 0;
			int map[][] = new int[10][10];
			for(int[] a: map) fill(a, INF);
			for(int i=0;i<n;i++) {
				int a = sc.nextInt();
				int b = sc.nextInt();
				int c = sc.nextInt();
				maxn = max(maxn, max(a,b));
				map[a][b] = map[b][a] = c;
			}
			maxn++;
			for(int i=0;i<maxn;i++) map[i][i] = 0;
			for(int k=0;k<maxn;k++) for(int i=0;i<maxn;i++) for(int j=0;j<maxn;j++) {
				map[i][j] = min(map[i][j], map[i][k] + map[k][j]);
			}
//			for(int[] a: map) debug(a);
			
			int node = -1;
			int min = INF;
			for(int i=0;i<maxn;i++) {
				int sum = 0;
				for(int j=0;j<maxn;j++) sum += map[i][j];
				if(min > sum) {
					node = i;
					min = sum;
				}
			}
			System.out.println(node + " " + min);
			
		}
	}

	public static void main(String[] args) {
		new Main().run();
	}

	void debug(Object... os) {
		System.err.println(Arrays.deepToString(os));
	}
}

</source>
<source file="../hum_codes_raw/s821492058.java" startline="1" endline="55" pcid="27576">

import java.util.*;
import static java.lang.Math.*;
import static java.util.Arrays.*;

public class Main {

	int INF = 1 << 28;

	void run() {
		Scanner sc = new Scanner(System.in);
		for(;;) {
			int n = sc.nextInt();
			if(n==0) break;
			int maxn = 0;
			int map[][] = new int[10][10];
			for(int[] a: map) fill(a, INF);
			for(int i=0;i<n;i++) {
				int a = sc.nextInt();
				int b = sc.nextInt();
				int c = sc.nextInt();
				maxn = max(maxn, max(a,b));
				map[a][b] = map[b][a] = c;
			}
			maxn++;
			for(int i=0;i<maxn;i++) map[i][i] = 0;
			for(int k=0;k<maxn;k++) for(int i=0;i<maxn;i++) for(int j=0;j<maxn;j++) {
				map[i][j] = min(map[i][j], map[i][k] + map[k][j]);
			}
//			for(int[] a: map) debug(a);
			
			int node = -1;
			int min = INF;
			for(int i=0;i<maxn;i++) {
				int sum = 0;
				for(int j=0;j<maxn;j++) sum += map[i][j];
				if(min > sum) {
					node = i;
					min = sum;
				}
			}
			System.out.println(node + " " + min);
			
		}
	}

	public static void main(String[] args) {
		new Main().run();
	}

	void debug(Object... os) {
		System.err.println(Arrays.deepToString(os));
	}
}

</source>
</class>

<class classid="285" nclones="2" nlines="20" similarity="100">
<source file="../hum_codes_raw/s701832384.java" startline="1" endline="26" pcid="23609">
import java.util.Scanner;

public class Main{

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int A = sc.nextInt();// 几个500
		int B = sc.nextInt();// 几个100
		int C = sc.nextInt();// 几个50
		int X = sc.nextInt();
		int ans = 0;
		int i,j,k;
		for (i = 0; i <= A; i++) {
			for (j = 0; j <= B; j++) {
				for (k = 0; k <= C; k++) {
					if (500 * i + 100 * j + 50 * k == X)
						ans+=1;
				}
			}
		}
		System.out.println(ans);

		
	}
}

</source>
<source file="../hum_codes_raw/s906415007.java" startline="1" endline="26" pcid="30498">
import java.util.Scanner;

public class Main{

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int A = sc.nextInt();// 几个500
		int B = sc.nextInt();// 几个100
		int C = sc.nextInt();// 几个50
		int X = sc.nextInt();
		int ans = 0;
		int i,j,k;
		for (i = 0; i <= A; i++) {
			for (j = 0; j <= B; j++) {
				for (k = 0; k <= C; k++) {
					if (500 * i + 100 * j + 50 * k == X)
						ans+=1;
				}
			}
		}
		System.out.println(ans);

		
	}
}

</source>
</class>

<class classid="286" nclones="2" nlines="88" similarity="100">
<source file="../hum_codes_raw/s715389482.java" startline="1" endline="100" pcid="24044">
import java.util.*;
import java.lang.*;
import java.math.*;
import java.io.*;

import static java.lang.Math.*;
import static java.util.Arrays.*;

public class Main{

	Scanner sc=new Scanner(System.in);

	static final int INF=1<<28;
	static final double EPS=1e-9;

	int n, s;
	int[][] sum;

	void run(){
		n=10;
		s=330;
		init();
		for(; sc.hasNext();){
			n=sc.nextInt();
			s=sc.nextInt();
			if(n<=10&&s<=330){
				println(sum[n-1][s]+"");
			}else{
				println("0");
			}
		}
		sc.close();
	}

	void init(){
		int[][] dp=new int[s+1][1<<10];
		int[][] dp2=new int[s+1][1<<10];
		sum=new int[n][s+1];
		dp[0][0]=1;

		for(int j=0; j<n; j++){
			for(int i=0; i<=s; i++){
				System.arraycopy(dp[i], 0, dp2[i], 0, 1<<10);
				Arrays.fill(dp[i], 0);
			}
			for(int i=0; i<10; i++){
				int d=(j+1)*i;
				for(int b=0; b<1<<10; b++){
					if(((1<<i)&b)==0){
						for(int k=0; k+d<=s; k++){
							dp[k+d][(1<<i)|b]+=dp2[k][b];
						}
					}
				}
			}
			for(int i=0; i<=s; i++){
				for(int b=0; b<1<<10; b++){
					sum[j][i]+=dp[i][b];
				}
			}
		}
	}

	int rec(int sum, int flag, int k){
		if(sum>s){
			return 0;
		}
		if(k==n){
			if(sum==s){
				return 1;
			}else{
				return 0;
			}
		}
		int ret=0;
		for(int i=0; i<10; i++){
			if(((1<<i)&flag)==0){
				ret+=rec(sum+(k+1)*i, (1<<i)|flag, k+1);
			}
		}
		return ret;
	}

	void debug(Object... os){
		System.err.println(Arrays.deepToString(os));
	}

	void print(String s){
		System.out.print(s);
	}

	void println(String s){
		System.out.println(s);
	}

	public static void main(String[] args){
		new Main().run();
	}
}

</source>
<source file="../hum_codes_raw/s727772113.java" startline="1" endline="108" pcid="24469">
import java.util.*;
import java.lang.*;
import java.math.*;
import java.io.*;

import static java.lang.Math.*;
import static java.util.Arrays.*;

public class Main{

	Scanner sc=new Scanner(System.in);

	static final int INF=1<<28;
	static final double EPS=1e-9;

	int n, s;
	int[][] sum;

	void run(){
		n=10;
		s=330;
		init();
		for(; sc.hasNext();){
			n=sc.nextInt();
			s=sc.nextInt();
			if(n<=10&&s<=330){
				println(sum[n-1][s]+"");
			}else{
				println("0");
			}
		}
		sc.close();
	}

	void init(){
		int[][] dp=new int[s+1][1<<10];
		int[][] dp2=new int[s+1][1<<10];
		sum=new int[n][s+1];
		dp[0][0]=1;

		for(int j=0; j<n; j++){
			for(int i=0; i<=s; i++){
				System.arraycopy(dp[i], 0, dp2[i], 0, 1<<10);
				Arrays.fill(dp[i], 0);
			}
			for(int i=0; i<10; i++){
				int d=(j+1)*i;
				for(int b=0; b<1<<10; b++){
					if(((1<<i)&b)==0){
						for(int k=0; k+d<=s; k++){
							dp[k+d][(1<<i)|b]+=dp2[k][b];
						}
					}
				}
			}
			for(int i=0; i<=s; i++){
				for(int b=0; b<1<<10; b++){
					sum[j][i]+=dp[i][b];
				}
			}
		}

		/*
		 * int ans=0;
		 * for(int i=0; i<1<<10; i++){
		 * ans+=dp[s][i];
		 * }
		 * println(ans+"");
		 */
	}

	int rec(int sum, int flag, int k){
		if(sum>s){
			return 0;
		}
		if(k==n){
			if(sum==s){
				return 1;
			}else{
				return 0;
			}
		}
		int ret=0;
		for(int i=0; i<10; i++){
			if(((1<<i)&flag)==0){
				ret+=rec(sum+(k+1)*i, (1<<i)|flag, k+1);
			}
		}
		return ret;
	}

	void debug(Object... os){
		System.err.println(Arrays.deepToString(os));
	}

	void print(String s){
		System.out.print(s);
	}

	void println(String s){
		System.out.println(s);
	}

	public static void main(String[] args){
		new Main().run();
	}
}

</source>
</class>

<class classid="287" nclones="2" nlines="149" similarity="100">
<source file="../hum_codes_raw/s715753651.java" startline="1" endline="192" pcid="24056">
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;
import java.util.Arrays;
import java.util.NoSuchElementException;
public class Main {
    private static final PrintStream ps     = System.out;
    private static final InputStream IS     = System.in;
    private static final byte[]      BUFFER = new byte[1024];
    private static int               ptr    = 0;
    private static int               buflen = 0;

    public static void main(String[] args) {
        final int max = Integer.MAX_VALUE;
        int n = ni();
        int[][] g = new int[n][n];
        for (int i = 0; i < n; i++) {
            Arrays.fill(g[i], max);
        }
        
        for (int i = 0; i < n; i++) {
            int u = ni();
            int m = ni();
            for (int j = 0; j < m; j++) {
                g[u][ni()] = ni();
            }
        }
        
//        UArr.printArr2D(g);
        int[] d = dijkstra(g, 0);
        for (int i = 0; i < n; i++) {
            ps.println(i + " " + d[i]);
        }
    }
    
    
    static int[] dijkstra(int[][] g, int from) {
        final int MAX = Integer.MAX_VALUE;
        int n = g.length;
        
        int[] d = new int[n];
        Arrays.fill(d, MAX);
        d[from] = 0;
        
        boolean[] visited = new boolean[n];
        
        while (true) {
            int u = -1;
            int min = MAX;
            for (int i = 0; i < n; i++) {
                if (!visited[i] && d[i] < min) {
                    u = i;
                    min = d[i];
                }
            }
            if (min == MAX) break;
            
            visited[u] = true;
            for (int i = 0; i < n; i++) {
                if (g[u][i] != MAX) {
                    d[i] = Math.min(d[i], d[u] + g[u][i]);
                }
            }
        }
        return d;
    }

    private static boolean hasNextByte() {
        if (ptr < buflen)
            return true;
        else {
            ptr = 0;
            try {
                buflen = IS.read(BUFFER);
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0)
                return false;
        }
        return true;
    }

    private static int readByte() {
        if (hasNextByte())
            return BUFFER[ptr++];
        else
            return -1;
    }

    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }

    public static boolean hasNext() {
        while (hasNextByte() && !isPrintableChar(BUFFER[ptr]))
            ptr++;
        return hasNextByte();
    }

    public static String n() {
        if (!hasNext())
            throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while (isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }

    public static long nl() {
        if (!hasNext())
            throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b)
            throw new NumberFormatException();
        while (true) {
            if ('0' <= b && b <= '9') {
                n *= 10;
                n += b - '0';
            } else if (b == -1 || !isPrintableChar(b))
                return minus ? -n : n;
            else
                throw new NumberFormatException();
            b = readByte();
        }
    }

    public static int ni() {
        long nl = nl();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)
            throw new NumberFormatException();
        return (int) nl;
    }

    public static double nextDouble() {
        return Double.parseDouble(n());
    }

    private static int[] nia(int n) {
        int[] a = new int[n];
        for (int i = 0; i < n; i++)
            a[i] = ni();
        return a;
    }

    private static long[] nla(int n) {
        long[] a = new long[n];
        for (int i = 0; i < n; i++)
            a[i] = nl();
        return a;
    }

    private static String[] na(int n) {
        String[] a = new String[n];
        for (int i = 0; i < n; i++)
            a[i] = n();
        return a;
    }

    private static int[][] nia2(int n, int m) {
        int[][] a = new int[n][m];
        for (int i = 0; i < n; i++)
            a[i] = nia(m);
        return a;
    }

    private static long[][] nla2(int n, int m) {
        long[][] a = new long[n][m];
        for (int i = 0; i < n; i++)
            a[i] = nla(m);
        return a;
    }

    private static char[][] nca2(int n) {
        char[][] a = new char[n][];
        for (int i = 0; i < n; i++)
            a[i] = n().toCharArray();
        return a;

    }
}


</source>
<source file="../hum_codes_raw/s846270822.java" startline="1" endline="194" pcid="28423">

import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;
import java.util.Arrays;
import java.util.NoSuchElementException;

public class Main {
    private static final PrintStream ps     = System.out;
    private static final InputStream IS     = System.in;
    private static final byte[]      BUFFER = new byte[1024];
    private static int               ptr    = 0;
    private static int               buflen = 0;

    public static void main(String[] args) {
        final int max = Integer.MAX_VALUE;
        int n = ni();
        int[][] g = new int[n][n];
        for (int i = 0; i < n; i++) {
            Arrays.fill(g[i], max);
        }
        
        for (int i = 0; i < n; i++) {
            int u = ni();
            int m = ni();
            for (int j = 0; j < m; j++) {
                g[u][ni()] = ni();
            }
        }
        
//        UArr.printArr2D(g);
        int[] d = dijkstra(g, 0);
        for (int i = 0; i < n; i++) {
            ps.println(i + " " + d[i]);
        }
    }
    
    
    static int[] dijkstra(int[][] g, int from) {
        final int MAX = Integer.MAX_VALUE;
        int n = g.length;
        
        int[] d = new int[n];
        Arrays.fill(d, MAX);
        d[from] = 0;
        
        boolean[] visited = new boolean[n];
        
        while (true) {
            int u = -1;
            int min = MAX;
            for (int i = 0; i < n; i++) {
                if (!visited[i] && d[i] < min) {
                    u = i;
                    min = d[i];
                }
            }
            if (min == MAX) break;
            
            visited[u] = true;
            for (int i = 0; i < n; i++) {
                if (g[u][i] != MAX) {
                    d[i] = Math.min(d[i], d[u] + g[u][i]);
                }
            }
        }
        return d;
    }

    private static boolean hasNextByte() {
        if (ptr < buflen)
            return true;
        else {
            ptr = 0;
            try {
                buflen = IS.read(BUFFER);
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0)
                return false;
        }
        return true;
    }

    private static int readByte() {
        if (hasNextByte())
            return BUFFER[ptr++];
        else
            return -1;
    }

    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }

    public static boolean hasNext() {
        while (hasNextByte() && !isPrintableChar(BUFFER[ptr]))
            ptr++;
        return hasNextByte();
    }

    public static String n() {
        if (!hasNext())
            throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while (isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }

    public static long nl() {
        if (!hasNext())
            throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b)
            throw new NumberFormatException();
        while (true) {
            if ('0' <= b && b <= '9') {
                n *= 10;
                n += b - '0';
            } else if (b == -1 || !isPrintableChar(b))
                return minus ? -n : n;
            else
                throw new NumberFormatException();
            b = readByte();
        }
    }

    public static int ni() {
        long nl = nl();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)
            throw new NumberFormatException();
        return (int) nl;
    }

    public static double nextDouble() {
        return Double.parseDouble(n());
    }

    private static int[] nia(int n) {
        int[] a = new int[n];
        for (int i = 0; i < n; i++)
            a[i] = ni();
        return a;
    }

    private static long[] nla(int n) {
        long[] a = new long[n];
        for (int i = 0; i < n; i++)
            a[i] = nl();
        return a;
    }

    private static String[] na(int n) {
        String[] a = new String[n];
        for (int i = 0; i < n; i++)
            a[i] = n();
        return a;
    }

    private static int[][] nia2(int n, int m) {
        int[][] a = new int[n][m];
        for (int i = 0; i < n; i++)
            a[i] = nia(m);
        return a;
    }

    private static long[][] nla2(int n, int m) {
        long[][] a = new long[n][m];
        for (int i = 0; i < n; i++)
            a[i] = nla(m);
        return a;
    }

    private static char[][] nca2(int n) {
        char[][] a = new char[n][];
        for (int i = 0; i < n; i++)
            a[i] = n().toCharArray();
        return a;

    }
}


</source>
</class>

<class classid="288" nclones="2" nlines="10" similarity="100">
<source file="../hum_codes_raw/s716387324.java" startline="1" endline="14" pcid="24081">
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;

class Main{
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        String[] input = br.readLine().split(" ");

        System.out.println((Integer.parseInt(input[0]) + Integer.parseInt(input[1])) / 2);
    }
} 

</source>
<source file="../hum_codes_raw/s783566823.java" startline="1" endline="15" pcid="26313">
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;

class Main{
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        String[] input = br.readLine().split(" ");

        System.out.println((Integer.parseInt(input[0]) + Integer.parseInt(input[1])) / 2);
    }
} 


</source>
</class>

<class classid="289" nclones="2" nlines="140" similarity="100">
<source file="../hum_codes_raw/s724609023.java" startline="1" endline="157" pcid="24370">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.Arrays;
import java.util.Scanner;
import java.util.StringTokenizer;
 
public class Main {
 
    public static class WeightedUnionFind{
        int[] par; // ????????????
        int[] ws;  // ?????¨???????????????
         
        public WeightedUnionFind(int n){
            par = new int[n];
            ws  = new int[n];
            for(int i = 0; i < n; i++){ 
                par[i] = -1;
            }
        }
         
        public int find(int x){
            if(par[x] < 0){
                return x;
            }else{
                final int parent = find(par[x]);
                ws[x] += ws[par[x]];
                par[x] = parent;
                return parent;
            }
        }
         
        public int weight(int x){
            find(x);
            return ws[x];
        }
         
        public boolean union(int x, int y, int w){ // x <-(w)- y (x + w = y)
            w += weight(x);
            w -= weight(y);
            x = find(x);
            y = find(y);
             
            if(x != y){
                if(par[y] < par[x]) {  // ???????????????????????????????????????????????????.
                    int tmp = x; x = y; y = tmp;
                    w = -w;
                }
                par[x] += par[y];
                par[y] = x;
                ws[y] = w;
                 
                return true;
            }else{
                return false;
            }
        }
         
        public boolean same(int x, int y){
            return find(x) == find(y);
        }
         
        public Integer diff(int x, int y){ // x - y ????±???????. ??????????????????null.
            if(!same(x, y)){
                return null;
            }else{
                return this.weight(x) - this.weight(y);
            }
        }
         
        public int size(int x){
            return -par[find(x)];
        }
    }
     
    public static void main(String[] args) throws IOException {
        Scanner sc = new Scanner(System.in);
 
        while(true){
            final int n = sc.nextInt();
            final int m = sc.nextInt();
             
            if(n == 0 && m == 0){
                break;
            }
             
            WeightedUnionFind uf = new WeightedUnionFind(n);
             
            for(int i = 0; i < m; i++){
                final char ops = sc.nextChar();
                 
                if('?' == ops){
                    final int r = sc.nextInt() - 1;
                    final int l = sc.nextInt() - 1;
                    final Integer ret = uf.diff(r, l);
                    System.out.println(ret == null ? "UNKNOWN" : -ret);
                }else{
                    final int r = sc.nextInt() - 1;
                    final int l = sc.nextInt() - 1;
                    final int w = sc.nextInt();
                     
                    uf.union(r, l, w);
                }
            }
        }
         
        sc.close();
    }
     
    public static class Scanner {
        private Reader br;
 
        public Scanner(InputStream is) throws IOException {
            br = new BufferedReader(new InputStreamReader(is));
        }
         
        public int nextInt() throws IOException {
            int sign = 1;
            int b = br.read();
             
            while(((b < '0') || ('9' < b)) && b != '-' && b != '+'){
                if(b == -1){ return 0; }
                b = br.read();
            }
             
            if(b == '-'){
                sign = -1;
                b = br.read();
            }else if(b == '+'){
                b = br.read();
            }
             
            int ret = b - '0';
            while(true){
                b = br.read();
                if(b < '0' || b > '9'){ return sign * ret; }
                ret *= 10;
                ret += b - '0';
            }
        }
         
        public char nextChar() throws IOException{
            int b = br.read();
            while(Character.isWhitespace(b)){
                b = br.read();
            }
            return (char)(b);
        }
         
        public void close() throws IOException {
            br.close();
        }
    }
}

</source>
<source file="../hum_codes_raw/s964356831.java" startline="1" endline="157" pcid="32408">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.Arrays;
import java.util.Scanner;
import java.util.StringTokenizer;

public class Main {

	public static class WeightedUnionFind{
	    int[] par; // 親の番号
	    int[] ws;  // 親との重みの差
	    
	    public WeightedUnionFind(int n){
	        par = new int[n];
	        ws  = new int[n];
	        for(int i = 0; i < n; i++){ 
	        	par[i] = -1;
	        }
	    }
	    
	    public int find(int x){
	    	if(par[x] < 0){
	    		return x;
	    	}else{
	    		final int parent = find(par[x]);
	    		ws[x] += ws[par[x]];
	    		par[x] = parent;
	    		return parent;
	    	}
	    }
	    
	    public int weight(int x){
	    	find(x);
	    	return ws[x];
	    }
	    
	    public boolean union(int x, int y, int w){ // x <-(w)- y (x + w = y)
	    	w += weight(x);
	    	w -= weight(y);
	        x = find(x);
	        y = find(y);
	        
	        if(x != y){
	            if(par[y] < par[x]) {  // 多い方が根になるようにスワップする.
	                int tmp = x; x = y; y = tmp;
	                w = -w;
	            }
	            par[x] += par[y];
	            par[y] = x;
	            ws[y] = w;
	            
	            return true;
	        }else{
	            return false;
	        }
	    }
	    
	    public boolean same(int x, int y){
	        return find(x) == find(y);
	    }
	    
	    public Integer diff(int x, int y){ // x - y を求める. 比較不能ならnull.
	    	if(!same(x, y)){
	    		return null;
	    	}else{
	    		return this.weight(x) - this.weight(y);
	    	}
	    }
	    
	    public int size(int x){
	        return -par[find(x)];
	    }
	}
	
	public static void main(String[] args) throws IOException {
		Scanner sc = new Scanner(System.in);

		while(true){
			final int n = sc.nextInt();
			final int m = sc.nextInt();
			
			if(n == 0 && m == 0){
				break;
			}
			
			WeightedUnionFind uf = new WeightedUnionFind(n);
			
			for(int i = 0; i < m; i++){
				final char ops = sc.nextChar();
				
				if('?' == ops){
					final int r = sc.nextInt() - 1;
					final int l = sc.nextInt() - 1;
					final Integer ret = uf.diff(r, l);
					System.out.println(ret == null ? "UNKNOWN" : -ret);
				}else{
					final int r = sc.nextInt() - 1;
					final int l = sc.nextInt() - 1;
					final int w = sc.nextInt();
					
					uf.union(r, l, w);
				}
			}
		}
		
		sc.close();
	}
	
	public static class Scanner {
	    private Reader br;

	    public Scanner(InputStream is) throws IOException {
	        br = new BufferedReader(new InputStreamReader(is));
	    }
	    
	    public int nextInt() throws IOException {
	    	int sign = 1;
	    	int b = br.read();
	    	
	    	while(((b < '0') || ('9' < b)) && b != '-' && b != '+'){
	    		if(b == -1){ return 0; }
	    		b = br.read();
	    	}
	    	
	    	if(b == '-'){
	    		sign = -1;
	    		b = br.read();
	    	}else if(b == '+'){
	    		b = br.read();
	    	}
	    	
	    	int ret = b - '0';
	    	while(true){
	    		b = br.read();
	    		if(b < '0' || b > '9'){ return sign * ret; }
	    		ret *= 10;
	    		ret += b - '0';
	    	}
	    }
	    
	    public char nextChar() throws IOException{
	    	int b = br.read();
	    	while(Character.isWhitespace(b)){
	    		b = br.read();
	    	}
	    	return (char)(b);
	    }
	    
	    public void close() throws IOException {
	        br.close();
	    }
	}
}

</source>
</class>

<class classid="290" nclones="2" nlines="97" similarity="100">
<source file="../hum_codes_raw/s737451188.java" startline="1" endline="111" pcid="24791">
import java.util.*;
 
public class Main {
	static int N;
	static long A, B;
	static long[] S;
	static long[][] dpA;
	static long[][] dpB;
	static BinaryIndexedTree bitA;
	static BinaryIndexedTree bitB;
	static final long MOD = 1_000_000_000 + 7;
 
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		N = sc.nextInt();
		A = sc.nextLong();
		B = sc.nextLong();
		S = new long[N];
		dpA = new long[2][N];
		dpB = new long[2][N];
		bitA = new BinaryIndexedTree(N);
		bitB = new BinaryIndexedTree(N);
		Stack<Query> stackA = new Stack<>();
		Stack<Query> stackB = new Stack<>();
		for (int i = 0; i < N; ++i) {
			S[i] = sc.nextLong();
		}
		Arrays.sort(S);
 
		bitA.addVal(0 + 1, 1);
		bitB.addVal(0 + 1, 1);
		stackA.push(new Query(0 + 1, 1));
		stackB.push(new Query(0 + 1, 1));
		int leftA = -1;
		int leftB = -1;
		for (int i = 0; i + 1 < N; ++i) {
			long sA = 0;
			long sB = 0;
			while (S[i + 1] - S[leftA + 1] >= A)
				++leftA;
			while (S[i + 1] - S[leftB + 1] >= B)
				++leftB;
			sB = bitA.getVal((leftB + 1) + 1);
			sA = bitB.getVal((leftA + 1) + 1);
			if (S[i + 1] - S[i] < A) {
				while (!stackA.isEmpty()) {
					Query q = stackA.pop();
					bitA.addVal(q.pos, -q.val);
				}
			}
			if (S[i + 1] - S[i] < B) {
				while (!stackB.isEmpty()) {
					Query q = stackB.pop();
					bitB.addVal(q.pos, -q.val);
				}
			}
			bitA.addVal((i + 1) + 1, sA);
			bitB.addVal((i + 1) + 1, sB);
			stackA.add(new Query((i + 1) + 1, sA));
			stackB.add(new Query((i + 1) + 1, sB));
		}
		System.out.println((bitA.getVal(N) + bitB.getVal(N)) % MOD);
	}
 
	static class BinaryIndexedTree {
		int n;
		long[] val;
 
		public BinaryIndexedTree(int n) {
			this.n = n;
			val = new long[n + 1];
		}
 
		void addVal(int k, long v) {
			while (k <= n) {
				val[k] += v;
				val[k] = (val[k] + MOD) % MOD;
				k += k & -k;
			}
		}
 
		long getVal(int k) {
			long s = 0;
			while (k > 0) {
				s += val[k];
				s = (s + MOD) % MOD;
				k -= k & -k;
			}
			return s;
		}
 
		void clear() {
			val = new long[n + 1];
		}
	}
 
	static class Query {
		int pos;
		long val;
 
		public Query(int pos, long val) {
			this.pos = pos;
			this.val = val;
		}
	}
 
	static void tr(Object... objects) {
		System.out.println(Arrays.deepToString(objects));
	}
}

</source>
<source file="../hum_codes_raw/s747884507.java" startline="1" endline="111" pcid="25126">
import java.util.*;

public class Main {
	static int N;
	static long A, B;
	static long[] S;
	static long[][] dpA;
	static long[][] dpB;
	static BinaryIndexedTree bitA;
	static BinaryIndexedTree bitB;
	static final long MOD = 1_000_000_000 + 7;

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		N = sc.nextInt();
		A = sc.nextLong();
		B = sc.nextLong();
		S = new long[N];
		dpA = new long[2][N];
		dpB = new long[2][N];
		bitA = new BinaryIndexedTree(N);
		bitB = new BinaryIndexedTree(N);
		Stack<Query> stackA = new Stack<>();
		Stack<Query> stackB = new Stack<>();
		for (int i = 0; i < N; ++i) {
			S[i] = sc.nextLong();
		}
		Arrays.sort(S);

		bitA.addVal(0 + 1, 1);
		bitB.addVal(0 + 1, 1);
		stackA.push(new Query(0 + 1, 1));
		stackB.push(new Query(0 + 1, 1));
		int leftA = -1;
		int leftB = -1;
		for (int i = 0; i + 1 < N; ++i) {
			long sA = 0;
			long sB = 0;
			while (S[i + 1] - S[leftA + 1] >= A)
				++leftA;
			while (S[i + 1] - S[leftB + 1] >= B)
				++leftB;
			sB = bitA.getVal((leftB + 1) + 1);
			sA = bitB.getVal((leftA + 1) + 1);
			if (S[i + 1] - S[i] < A) {
				while (!stackA.isEmpty()) {
					Query q = stackA.pop();
					bitA.addVal(q.pos, -q.val);
				}
			}
			if (S[i + 1] - S[i] < B) {
				while (!stackB.isEmpty()) {
					Query q = stackB.pop();
					bitB.addVal(q.pos, -q.val);
				}
			}
			bitA.addVal((i + 1) + 1, sA);
			bitB.addVal((i + 1) + 1, sB);
			stackA.add(new Query((i + 1) + 1, sA));
			stackB.add(new Query((i + 1) + 1, sB));
		}
		System.out.println((bitA.getVal(N) + bitB.getVal(N)) % MOD);
	}

	static class BinaryIndexedTree {
		int n;
		long[] val;

		public BinaryIndexedTree(int n) {
			this.n = n;
			val = new long[n + 1];
		}

		void addVal(int k, long v) {
			while (k <= n) {
				val[k] += v;
				val[k] = (val[k] + MOD) % MOD;
				k += k & -k;
			}
		}

		long getVal(int k) {
			long s = 0;
			while (k > 0) {
				s += val[k];
				s = (s + MOD) % MOD;
				k -= k & -k;
			}
			return s;
		}

		void clear() {
			val = new long[n + 1];
		}
	}

	static class Query {
		int pos;
		long val;

		public Query(int pos, long val) {
			this.pos = pos;
			this.val = val;
		}
	}

	static void tr(Object... objects) {
		System.out.println(Arrays.deepToString(objects));
	}
}

</source>
</class>

<class classid="291" nclones="2" nlines="11" similarity="100">
<source file="../hum_codes_raw/s739842892.java" startline="1" endline="10" pcid="24853">
import java.util.Scanner;
public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int sum = 0;
		for(int i = 0; i < 5; i++){sum += Math.max(40, sc.nextInt());}
		System.out.println(sum/5);
	}
}

</source>
<source file="../hum_codes_raw/s953989737.java" startline="1" endline="20" pcid="32060">
import java.util.Scanner;
 
 
public class Main {
     
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
         
         
        int sum = 0;
        for(int i = 0; i < 5; i++){
            sum += Math.max(40, sc.nextInt());
        }
         
        System.out.println(sum / 5);
         
    }
 
}

</source>
</class>

<class classid="292" nclones="2" nlines="56" similarity="100">
<source file="../hum_codes_raw/s740463383.java" startline="1" endline="68" pcid="24881">
// This file is a "Hello, world!" in Java language by OpenJDK for wandbox.
import java.util.*;
import java.io.*;

class Main
{
	public static void main(String[] args)
	{
		new Main().run();
	}
	
	void run(){
		Scanner sc=new Scanner(System.in);
		int N=sc.nextInt();
		int[] A=new int[N];
		int[] A_diff=new int[2*N-1];
		int[] B=new int[N];
		int[] B_diff=new int[N];
		for(int i=0;i<N;++i)A[i]=sc.nextInt();
		for(int i=0;i<N;++i)B[i]=sc.nextInt();
		for(int i=0;i<N;++i)A_diff[i]=A[i]^A[(i+1)%N];
		for(int i=0;i<N;++i)B_diff[i]=B[i]^B[(i+1)%N];
		for(int i=0;i<N-1;++i)A_diff[i+N]=A_diff[i];
		boolean[] search=search(A_diff,B_diff);
		int ans=0;
		PrintWriter pw=new PrintWriter(System.out);
		for(int i=0;i<N;++i){
			if(search[i]){
				pw.println(i+" " +(B[0]^A[i]));
			}
		}
		pw.close();
	}
	
	boolean[] search(int[] a,int[] b){
		int[] border=border(b);
		boolean[] ret=new boolean[a.length];
		int s=0,t=0,match=0;
		for(int i=0;i<a.length;++i){
			while(match>=0&&(match>=b.length||b[match]!=a[i]))match=(match==0?-1:border[match-1]);
			++match;
			if(match==b.length){ret[i-match+1]=true;}
		}
		return ret;
	}
	
	int[] border(int[] b){
		int n=b.length;
		int[] pat=new int[n];
		int match=0;
		for(int i=1;i<n;++i){
			while(match>=0&&b[i]!=b[match])
				match=(match==0?-1:pat[match-1]);
			++match;
			pat[i]=match;
		}
		return pat;
	}
	
	void tr(Object...o){System.out.println(Arrays.deepToString(o));}
}

// OpenJDK reference:
//   http://openjdk.java.net/

// Java language references:
//   http://docs.oracle.com/javase

</source>
<source file="../hum_codes_raw/s836157593.java" startline="1" endline="68" pcid="28070">
// This file is a "Hello, world!" in Java language by OpenJDK for wandbox.
import java.util.*;
import java.io.*;

class Main
{
    public static void main(String[] args)
    {
		new Main().run();
    }
	
	void run(){
		Scanner sc=new Scanner(System.in);
		int N=sc.nextInt();
		int[] A=new int[N];
		int[] A_diff=new int[2*N-1];
		int[] B=new int[N];
		int[] B_diff=new int[N];
		for(int i=0;i<N;++i)A[i]=sc.nextInt();
		for(int i=0;i<N;++i)B[i]=sc.nextInt();
		for(int i=0;i<N;++i)A_diff[i]=A[i]^A[(i+1)%N];
		for(int i=0;i<N;++i)B_diff[i]=B[i]^B[(i+1)%N];
		for(int i=0;i<N-1;++i)A_diff[i+N]=A_diff[i];
		boolean[] search=search(A_diff,B_diff);
		int ans=0;
		PrintWriter pw=new PrintWriter(System.out);
		for(int i=0;i<N;++i){
			if(search[i]){
				pw.println(i+" " +(B[0]^A[i]));
			}
		}
		pw.close();
	}
	
	boolean[] search(int[] a,int[] b){
		int[] border=border(b);
		boolean[] ret=new boolean[a.length];
		int s=0,t=0,match=0;
		for(int i=0;i<a.length;++i){
			while(match>=0&&(match>=b.length||b[match]!=a[i]))match=(match==0?-1:border[match-1]);
			++match;
			if(match==b.length){ret[i-match+1]=true;}
		}
		return ret;
	}
	
	int[] border(int[] b){
		int n=b.length;
		int[] pat=new int[n];
		int match=0;
		for(int i=1;i<n;++i){
			while(match>=0&&b[i]!=b[match])
				match=(match==0?-1:pat[match-1]);
			++match;
			pat[i]=match;
		}
		return pat;
	}
	
	void tr(Object...o){System.out.println(Arrays.deepToString(o));}
}

// OpenJDK reference:
//   http://openjdk.java.net/

// Java language references:
//   http://docs.oracle.com/javase

</source>
</class>

<class classid="293" nclones="2" nlines="49" similarity="100">
<source file="../hum_codes_raw/s742846647.java" startline="1" endline="66" pcid="24959">

import java.util.Scanner;


public class Main {
	
	public static class BIT {
		int[] dat;
		
		public BIT(int n){
			dat = new int[n + 1];
		}
		
		public void add(int k, int a){ // k : 0-indexed
			for(int i = k + 1; i < dat.length; i += i & -i){
				dat[i] += a;	
			}
		}
		
		public int sum(int s, int t){ // [s, t)
			if(s > 0) return sum(0, t) - sum(0, s);
			
			int ret = 0;
			for(int i = t; i > 0; i -= i & -i) {
				ret += dat[i];
			}
			return ret;
		}
		
		public int get(int k){ // k : 0-indexed
			int p = Integer.highestOneBit(dat.length - 1);
			for(int q = p; q > 0; q >>= 1, p |= q){
				if( p >= dat.length || k < dat[p]) p ^= q;
				else k -= dat[p];
			}
			return p;
		}
	}
	
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		
		while(true){
			final int n = sc.nextInt();
			final int k = sc.nextInt();
			
			if(n == 0 && k == 0){
				break;
			}
			
			BIT bit = new BIT(n);
			for(int i = 0; i < n; i++){
				bit.add(i, sc.nextInt());
			}
			
			int max = Integer.MIN_VALUE;
			for(int start = 0; start < n - k + 1; start++){
				max = Math.max(max, bit.sum(start, start + k));
				//System.out.println("[" + start + " " + (start + k) + ") = " + bit.sum(start, start + k));
			}
		
		System.out.println(max);
		}
	}
}

</source>
<source file="../hum_codes_raw/s856221251.java" startline="1" endline="65" pcid="28780">
import java.util.Scanner;


public class Main {

		public static class BIT{
				int[] dat;
				
				public BIT(int n){
						dat = new int[n + 1];
				}
				
				public void add(int k, int a){
						for(int i = k + 1; i < dat.length; i += i & -i){
								dat[i] += a;	
						}
				}
				
				public int sum(int s, int t){
						if(s > 0) return sum(0, t) - sum(0, s);
						
						int ret = 0;
						for(int i = t; i > 0; i -= i & -i) {
								ret += dat[i];
						}
						return ret;
				}
				
				public int get(int k){
						int p = Integer.highestOneBit(dat.length - 1);
						for(int q = p; q > 0; q >>= 1, p |= q){
								if( p >= dat.length || k < dat[p]) p ^= q;
								else k -= dat[p];
						}
						return p;
				}
		}
		
		public static void main(String[] args){
				Scanner sc = new Scanner(System.in);
				
				while(true){
						final int n = sc.nextInt();
						final int k = sc.nextInt();

						if(n == 0 && k == 0){
								break;
						}

						BIT bit = new BIT(n);
						for(int i = 0; i < n; i++){
								bit.add(i, sc.nextInt());
						}

						int max = Integer.MIN_VALUE;
						for(int start = 0; start < n - k + 1; start++){
								max = Math.max(max, bit.sum(start, start + k));
								//System.out.println("[" + start + " " + (start + k) + ") = " + bit.sum(start, start + k));
						}
						
						System.out.println(max);
				}
		}
}

</source>
</class>

<class classid="294" nclones="2" nlines="54" similarity="100">
<source file="../hum_codes_raw/s747076084.java" startline="1" endline="59" pcid="25089">


import java.util.Scanner;

public class Main {
	int width;//?????????????????????
	int height;//????????????????????????
	//????????????????????¨???????????¢??°
	void printData(int crowd[][]){
		for(int i = 0;i <height;i++){
			for(int j = 0;j < width;j++){
				if(j < width-1){
					System.out.print(crowd[j][i]+" ");					
				}else{
					System.out.print(crowd[j][i]);						
				}
			}
			System.out.println();
		}	
	}
	//?????¨??????????????????????¬?????????????????????????????????????
	void calcCrowd(int crowd[][]){
		for(int i = 0;i <height;i++){
			for(int j = 0;j < width;j++){
				for(int k = width-1;k >= 0;k--){
					if(crowd[k][i] == 0 && crowd[j][i] == -1 && k < j){
						crowd[j][i] = j-k;
					}
				}
			}
		}		
	}
	void doIt(){
		Scanner sc = new Scanner(System.in);
		this.height = sc.nextInt();
		this.width = sc.nextInt();
		String c[] = new String[height];
		int crowd[][] = new int[width][height];
		for(int i = 0; i < height;i++){
			c[i] = sc.next();
		}
		for(int i = 0;i <height;i++){
			for(int j = 0;j < width;j++){
				if(c[i].charAt(j) == 'c'){
					crowd[j][i] = 0;
				}else{
					crowd[j][i] = -1;	
				}
			}
		}
		calcCrowd(crowd);
		printData(crowd);
	}
	public static void main(String[] args) {
		new Main().doIt();
	}

}

</source>
<source file="../hum_codes_raw/s984250523.java" startline="1" endline="58" pcid="33097">

import java.util.Scanner;

public class Main {
	int width;//?????????????????????
	int height;//????????????????????????
	//????????????????????¨???????????¢??°
	void printData(int crowd[][]){
		for(int i = 0;i <height;i++){
			for(int j = 0;j < width;j++){
				if(j < width-1){
					System.out.print(crowd[j][i]+" ");					
				}else{
					System.out.print(crowd[j][i]);						
				}
			}
			System.out.println();
		}	
	}
	//?????¨??????????????????????¬?????????????????????????????????????
	void calcCrowd(int crowd[][]){
		for(int i = 0;i <height;i++){
			for(int j = 0;j < width;j++){
				for(int k = width-1;k >= 0;k--){
					if(crowd[k][i] == 0 && crowd[j][i] == -1 && k < j){
						crowd[j][i] = j-k;
					}
				}
			}
		}		
	}
	void doIt(){
		Scanner sc = new Scanner(System.in);
		this.height = sc.nextInt();
		this.width = sc.nextInt();
		String c[] = new String[height];
		int crowd[][] = new int[width][height];
		for(int i = 0; i < height;i++){
			c[i] = sc.next();
		}
		for(int i = 0;i <height;i++){
			for(int j = 0;j < width;j++){
				if(c[i].charAt(j) == 'c'){
					crowd[j][i] = 0;
				}else{
					crowd[j][i] = -1;	
				}
			}
		}
		calcCrowd(crowd);
		printData(crowd);
	}
	public static void main(String[] args) {
		new Main().doIt();
	}

}

</source>
</class>

<class classid="295" nclones="2" nlines="38" similarity="100">
<source file="../hum_codes_raw/s751521433.java" startline="1" endline="54" pcid="25254">
import java.util.Scanner;
public class Main
{
	public static void main(String arg[])
	{
		Scanner in = new Scanner(System.in);
		while(in.hasNext())
		{
			int n=in.nextInt();
			if(n==0)
				return;
			int a[]=new int[n];
			int b[]=new int[n];

			for(int i=0; i<n;i++)
			{
				a[i]=in.nextInt();
				b[i]=in.nextInt();
			}
			for(int i=0;i<n;i++)
			{
				int m=i;
				for(int j=i;j<n; j++)
				{
					if(b[j]<b[m])
						m=j;
				}
				int tmp =b[i];
				b[i] = b[m];
				b[m] = tmp;
				tmp =a[i];
				a[i]=a[m];
				a[m]=tmp;
			}
			//for(int i=0;i<n; i++)
			//System.out.println(a[i]+" "+b[i]);
			boolean flag=true;
			int T=0;
			int W=0;
			for(int i=0;i <n;i++)
			{
				T+=a[i];
				W=b[i];
				if(T>W)
					flag=false;
			}
			if(flag)
				System.out.println("Yes");
			else
				System.out.println("No");
		}
	}
}

</source>
<source file="../hum_codes_raw/s934430464.java" startline="1" endline="52" pcid="31422">
import java.util.Scanner;
public class Main
{
	public static void main(String arg[])
	{
		Scanner in = new Scanner(System.in);
		while(in.hasNext())
		{
			int n=in.nextInt();
			if(n==0)
				return;
			int a[]=new int[n];
			int b[]=new int[n];

			for(int i=0; i<n;i++)
			{
				a[i]=in.nextInt();
				b[i]=in.nextInt();
			}
			for(int i=0;i<n;i++)
			{
				int m=i;
				for(int j=i;j<n; j++)
				{
					if(b[j]<b[m])
						m=j;
				}
				int tmp =b[i];
				b[i] = b[m];
				b[m] = tmp;
				tmp =a[i];
				a[i]=a[m];
				a[m]=tmp;
			}
			boolean flag=true;
			int T=0;
			int W=0;
			for(int i=0;i <n;i++)
			{
				T+=a[i];
				W=b[i];
				if(T>W)
					flag=false;
			}
			if(flag)
				System.out.println("Yes");
			else
				System.out.println("No");
		}
	}
}

</source>
</class>

<class classid="296" nclones="2" nlines="40" similarity="100">
<source file="../hum_codes_raw/s762799528.java" startline="1" endline="41" pcid="25622">
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		List<Integer> list = new ArrayList<>();
		for (int i = 0; i < n; i++) {
			list.add(sc.nextInt());
		}
		int m = sc.nextInt();
		List<Integer> list2 = new ArrayList<>();
		for (int i = 0; i < m; i++) {
			list2.add(sc.nextInt());
		}
		int size = Math.min(list.size(), list2.size());
		int res = -1;
		for (int i = 0; i < size; i++) {
			if (list2.get(i) > list.get(i)) {
				res = 1;
				break;
			} else if (list2.get(i) < list.get(i)) {
				res = 0;
				break;
			}
		}
		if (res < 0) {
			if (m > n) {
				res = 1;
			} else {
				res = 0;
			}
		}
		System.out.println(res);
	}
}


</source>
<source file="../hum_codes_raw/s923869292.java" startline="1" endline="42" pcid="31067">
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		List<Integer> list = new ArrayList<>();
		for (int i = 0; i < n; i++) {
			list.add(sc.nextInt());
		}
		int m = sc.nextInt();
		List<Integer> list2 = new ArrayList<>();
		for (int i = 0; i < m; i++) {
			list2.add(sc.nextInt());
		}
		int size = Math.min(list.size(), list2.size());
		int res = -1;
		for (int i = 0; i < size; i++) {
			if (list2.get(i) > list.get(i)) {
				res = 1;
				break;
			} else if (list2.get(i) < list.get(i)) {
				res = 0;
				break;
			}
		}
		if (res < 0) {
			if (m > n) {
				res = 1;
			} else {
				res = 0;
			}
		}
		System.out.println(res);
	}
}



</source>
</class>

<class classid="297" nclones="2" nlines="30" similarity="100">
<source file="../hum_codes_raw/s772727847.java" startline="1" endline="34" pcid="25942">
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main{

	void run(){
		Scanner sc = new Scanner(System.in);
		for(;;){
			int n = sc.nextInt();
			if(n==0)break;
			boolean[][] e = new boolean[n][n+1];
			for(int i=0;i<n;i++){
				int m = sc.nextInt();
				while(m--!=0)e[i][sc.nextInt()]=true;
			}
			boolean[] f = new boolean[n+1];
			int K = sc.nextInt();
			while(K--!=0)f[sc.nextInt()]=true;
			List<Integer> l = new ArrayList<Integer>();
			for(int i=0;i<n;i++){
				boolean ok = true;
				for(int j=1;j<=n;j++)if(f[j]&&!e[i][j])ok=false;
				if(ok)l.add(i+1);
			}
			System.out.println(l.isEmpty()||l.size()>1?-1:l.get(0));
		}
	}
	
	public static void main(String[] args) {
		new Main().run();
	}
}

</source>
<source file="../hum_codes_raw/s820968583.java" startline="1" endline="35" pcid="27552">
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

//Save Your Privacy!
public class Main{

	void run(){
		Scanner sc = new Scanner(System.in);
		for(;;){
			int n = sc.nextInt();
			if(n==0)break;
			boolean[][] e = new boolean[n][n+1];
			for(int i=0;i<n;i++){
				int m = sc.nextInt();
				while(m--!=0)e[i][sc.nextInt()]=true;
			}
			boolean[] f = new boolean[n+1];
			int K = sc.nextInt();
			while(K--!=0)f[sc.nextInt()]=true;
			List<Integer> l = new ArrayList<Integer>();
			for(int i=0;i<n;i++){
				boolean ok = true;
				for(int j=1;j<=n;j++)if(f[j]&&!e[i][j])ok=false;
				if(ok)l.add(i+1);
			}
			System.out.println(l.isEmpty()||l.size()>1?-1:l.get(0));
		}
	}
	
	public static void main(String[] args) {
		new Main().run();
	}
}

</source>
</class>

<class classid="298" nclones="2" nlines="40" similarity="100">
<source file="../hum_codes_raw/s773259980.java" startline="1" endline="50" pcid="25964">
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        try (Scanner sc = new Scanner(System.in)) {
            while(true){
                int n = sc.nextInt();
                int r = sc.nextInt();

                if(n==0){
                    break;
                }
                int[] card = new int[n];
                for(int i=0;i<n;i++){
                    card[i] = n-i;
                }

                for(int i=0;i<r;i++){
                    int p = sc.nextInt();
                    int c = sc.nextInt();

                    int[] shuffleC = new int[c];
                    int[] shuffleP = new int[p];

                    for(int j=0;j<p-1;j++){
                        shuffleP[j] = card[j];
                    }
                    for(int j=0;j<c;j++){
                        shuffleC[j] = card[p-1+j];
                    }

                    for(int j=0;j<c;j++){
                        card[j] = shuffleC[j];
                    }
                    for(int j=0;j<p-1;j++){
                        card[j+c] = shuffleP[j];
                    }

                    shuffleC = null;
                    shuffleP = null;

                }
                
                System.out.println(card[0]);
                
                card =null;
            }
        }  
    }
}

</source>
<source file="../hum_codes_raw/s985822988.java" startline="1" endline="50" pcid="33163">
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        try (Scanner sc = new Scanner(System.in)) {
            while(true){
                int n = sc.nextInt();
                int r = sc.nextInt();

                if(n==0){
                    break;
                }
                int[] card = new int[n];
                for(int i=0;i<n;i++){
                    card[i] = n-i;
                }

                for(int i=0;i<r;i++){
                    int p = sc.nextInt();
                    int c = sc.nextInt();

                    int[] shuffleC = new int[c];
                    int[] shuffleP = new int[p];

                    for(int j=0;j<p-1;j++){
                        shuffleP[j] = card[j];
                    }
                    for(int j=0;j<c;j++){
                        shuffleC[j] = card[p-1+j];
                    }

                    for(int j=0;j<c;j++){
                        card[j] = shuffleC[j];
                    }
                    for(int j=0;j<p-1;j++){
                        card[j+c] = shuffleP[j];
                    }

                    shuffleC = null;
                    shuffleP = null;

                }
                
                System.out.println(card[0]);
                
                card =null;
            }
        }  
    }
}

</source>
</class>

<class classid="299" nclones="2" nlines="179" similarity="100">
<source file="../hum_codes_raw/s790111644.java" startline="1" endline="228" pcid="26530">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.PrintStream;
import java.io.BufferedWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        D solver = new D();
        solver.solve(1, in, out);
        out.close();
    }

    static class D {
        public void solve(int testNumber, InputReader in, OutputWriter out) {
//        for (int LL = 2; LL <= 16; LL++) {
//            List<Edge> edges = solve(LL);
//            System.err.println("");
//            System.err.println("solving L = " + LL);
//            for (Edge e : edges) {
//                System.err.println(e.x + " " + e.y + " " + e.w);
//            }
//        }
//        for (int LL = 1<<19; LL >= (1<<19) - 20; LL--) {
//            List<Edge> edges = solve(LL);
//            System.err.println("");
//            System.err.println("solving L = " + LL);
//            for (Edge e : edges) {
//                System.err.println(e.x + " " + e.y + " " + e.w);
//            }
//        }

            int L = in.readInt();
            List<D.Edge> edges = solve(L);
            int n = 0;
            for (D.Edge e : edges) {
                n = Math.max(n, e.x);
                n = Math.max(n, e.y);
            }
            n++;
            for (D.Edge e : edges) {
                e.normalize(n);
            }
            out.printLine(n + " " + edges.size());
            for (D.Edge e : edges) {
                out.printLine(e.x + " " + e.y + " " + e.w);
            }
        }

        private List<D.Edge> solve(int L) {
            int n = getVertCount(L);
            List<D.Edge> edges = new ArrayList<>();
            for (int i = 0; i < n - 1; i++) {
                edges.add(new D.Edge(i + 1, i, 0));
                edges.add(new D.Edge(i + 1, i, 1 << i));
            }
//        System.err.println("L = " + L);
            if ((L & (L - 1)) == 0) {
                return edges;
            }
            if (L == 6) {
                System.err.print("");
            }
            int have = Integer.highestOneBit(L);
            while (have < L) { // L is not 2^n-1
                int bit = Integer.numberOfTrailingZeros(Integer.highestOneBit(L - have));
                int first = have;
                int last = have + (1 << bit) - 1;
                int pw = 19;
                while (have + (1 << pw) - 1 >= L) {
                    pw--;
                }
//            System.err.println("have = " + have + ", first = " + first + ", last = " + last);
                edges.add(new D.Edge(n - 1, pw, have));
                have += 1 << bit;
            }
            if (n < 1 || n > 20) {
                throw new AssertionError();
            }
            if (edges.size() > 60) {
                throw new AssertionError();
            }
            return edges;
        }

        private int getVertCount(int L) {
            return Integer.numberOfTrailingZeros(Integer.highestOneBit(L)) + 1;
        }

        static class Edge {
            int x;
            int y;
            int w;

            public Edge(int x, int y, int w) {
                this.x = x;
                this.y = y;
                this.w = w;
            }

            public void normalize(int n) {
                x = n - x;
                y = n - y;
            }

        }

    }

    static class OutputWriter {
        private final PrintWriter writer;

        public OutputWriter(OutputStream outputStream) {
            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
        }

        public OutputWriter(Writer writer) {
            this.writer = new PrintWriter(writer);
        }

        public void print(Object... objects) {
            for (int i = 0; i < objects.length; i++) {
                if (i != 0) {
                    writer.print(' ');
                }
                writer.print(objects[i]);
            }
        }

        public void printLine(Object... objects) {
            print(objects);
            writer.println();
        }

        public void close() {
            writer.close();
        }

    }

    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private InputReader.SpaceCharFilter filter;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int readInt() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public boolean isSpaceChar(int c) {
            if (filter != null) {
                return filter.isSpaceChar(c);
            }
            return isWhitespace(c);
        }

        public static boolean isWhitespace(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);

        }

    }
}


</source>
<source file="../hum_codes_raw/s830003646.java" startline="1" endline="228" pcid="27841">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.PrintStream;
import java.io.BufferedWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        D solver = new D();
        solver.solve(1, in, out);
        out.close();
    }

    static class D {
        public void solve(int testNumber, InputReader in, OutputWriter out) {
//        for (int LL = 2; LL <= 16; LL++) {
//            List<Edge> edges = solve(LL);
//            System.err.println("");
//            System.err.println("solving L = " + LL);
//            for (Edge e : edges) {
//                System.err.println(e.x + " " + e.y + " " + e.w);
//            }
//        }
//        for (int LL = 1<<19; LL >= (1<<19) - 20; LL--) {
//            List<Edge> edges = solve(LL);
//            System.err.println("");
//            System.err.println("solving L = " + LL);
//            for (Edge e : edges) {
//                System.err.println(e.x + " " + e.y + " " + e.w);
//            }
//        }

            int L = in.readInt();
            List<D.Edge> edges = solve(L);
            int n = 0;
            for (D.Edge e : edges) {
                n = Math.max(n, e.x);
                n = Math.max(n, e.y);
            }
            n++;
            for (D.Edge e : edges) {
                e.normalize(n);
            }
            out.printLine(n + " " + edges.size());
            for (D.Edge e : edges) {
                out.printLine(e.x + " " + e.y + " " + e.w);
            }
        }

        private List<D.Edge> solve(int L) {
            int n = getVertCount(L);
            List<D.Edge> edges = new ArrayList<>();
            for (int i = 0; i < n - 1; i++) {
                edges.add(new D.Edge(i + 1, i, 0));
                edges.add(new D.Edge(i + 1, i, 1 << i));
            }
//        System.err.println("L = " + L);
            if ((L & (L - 1)) == 0) {
                return edges;
            }
            if (L == 6) {
                System.err.print("");
            }
            int have = Integer.highestOneBit(L);
            while (have < L) { // L is not 2^n-1
                int bit = Integer.numberOfTrailingZeros(Integer.highestOneBit(L - have));
                int first = have;
                int last = have + (1 << bit) - 1;
                int pw = 19;
                while (have + (1 << pw) - 1 >= L) {
                    pw--;
                }
//            System.err.println("have = " + have + ", first = " + first + ", last = " + last);
                edges.add(new D.Edge(n - 1, pw, have));
                have += 1 << bit;
            }
            if (n < 1 || n > 20) {
                throw new AssertionError();
            }
            if (edges.size() > 60) {
                throw new AssertionError();
            }
            return edges;
        }

        private int getVertCount(int L) {
            return Integer.numberOfTrailingZeros(Integer.highestOneBit(L)) + 1;
        }

        static class Edge {
            int x;
            int y;
            int w;

            public Edge(int x, int y, int w) {
                this.x = x;
                this.y = y;
                this.w = w;
            }

            public void normalize(int n) {
                x = n - x;
                y = n - y;
            }

        }

    }

    static class OutputWriter {
        private final PrintWriter writer;

        public OutputWriter(OutputStream outputStream) {
            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
        }

        public OutputWriter(Writer writer) {
            this.writer = new PrintWriter(writer);
        }

        public void print(Object... objects) {
            for (int i = 0; i < objects.length; i++) {
                if (i != 0) {
                    writer.print(' ');
                }
                writer.print(objects[i]);
            }
        }

        public void printLine(Object... objects) {
            print(objects);
            writer.println();
        }

        public void close() {
            writer.close();
        }

    }

    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private InputReader.SpaceCharFilter filter;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int readInt() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public boolean isSpaceChar(int c) {
            if (filter != null) {
                return filter.isSpaceChar(c);
            }
            return isWhitespace(c);
        }

        public static boolean isWhitespace(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);

        }

    }
}


</source>
</class>

<class classid="300" nclones="2" nlines="20" similarity="100">
<source file="../hum_codes_raw/s803034229.java" startline="1" endline="25" pcid="26971">
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class Main {
	public static void main(String[] args){
		Map<String,Integer> sales = new HashMap<>();
		Scanner sc = new Scanner(System.in);

		int a = sc.nextInt();

		for(int i = 0; i < a;i++){
			int x= sc.nextInt();
			String key = sc.next();
			if(x ==0){
				sales.put(key,sc.nextInt());
			}else{
				System.out.println(sales.get(key));

			}
		}
	}
}


</source>
<source file="../hum_codes_raw/s888664655.java" startline="1" endline="25" pcid="29883">
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class Main {
	public static void main(String[] args){
		Map<String,Integer> sales = new HashMap<>();
		Scanner sc = new Scanner(System.in);

		int a = sc.nextInt();

		for(int i = 0; i < a;i++){
			int x= sc.nextInt();
			String key = sc.next();
			if(x ==0){
				sales.put(key,sc.nextInt());
			}else{
				System.out.println(sales.get(key));

			}
		}
	}
}


</source>
</class>

<class classid="301" nclones="2" nlines="15" similarity="100">
<source file="../hum_codes_raw/s817243344.java" startline="1" endline="18" pcid="27444">
import java.util.Scanner;

public class Main {

	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		int a = sc.nextInt();
		int b = sc.nextInt();
		int c = sc.nextInt();

		if(a+b+c >=22){
			System.out.println("bust");
		}else{
			System.out.println("win");
		}
	}
}

</source>
<source file="../hum_codes_raw/s862774890.java" startline="1" endline="20" pcid="29015">
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);

		int a = sc.nextInt();
		int b = sc.nextInt();
		int c = sc.nextInt();

		if(a+b+c >= 22) {
			System.out.println("bust");
		}else {
			System.out.println("win");
		}
	}

}

</source>
</class>

<class classid="302" nclones="2" nlines="25" similarity="100">
<source file="../hum_codes_raw/s842681883.java" startline="1" endline="2" pcid="28297">
import java.util.*;class Main{public static void main(String[]args){Scanner sc = new Scanner(System.in);int c=0;for(;;){  int s=sc.nextInt();if(s==0)break;if(c!=0)System.out.println();String tn[] =new String[s];int tp[]=new int[s];  int tpc[]=new int[s];for(int i=0;i<s;i++){ tn[i]=sc.next();tp[i]=(sc.nextInt()*3+sc.nextInt()*0+sc.nextInt());tpc[i]=tp[i];}Arrays.sort(tpc);for(int i=tpc[s-1];i>-1;i--){ for(int j=0;j<s;j++) if(i==tp[j])System.out.println(tn[j]+","+tp[j]);}c++;}}}

</source>
<source file="../hum_codes_raw/s863726903.java" startline="1" endline="29" pcid="29043">
import java.util.*;

 class Main{
    public static void main(String[]args){
        Scanner sc = new Scanner(System.in);
 int c=0;
      for(;;){  
        int s=sc.nextInt();
        if(s==0)break;
        if(c!=0)System.out.println();
   
   String tn[] =new String[s];
    int tp[]=new int[s]; 
    int tpc[]=new int[s];
    for(int i=0;i<s;i++){ 
    	tn[i]=sc.next();
    	tp[i]=(sc.nextInt()*3+sc.nextInt()*0+sc.nextInt());
        tpc[i]=tp[i];
    }
    Arrays.sort(tpc);
    for(int i=tpc[s-1];i>-1;i--){ 
    	for(int j=0;j<s;j++) if(i==tp[j])
    	System.out.println(tn[j]+","+tp[j]);
    }
    c++;
      }
    }
}

</source>
</class>

<class classid="303" nclones="2" nlines="40" similarity="100">
<source file="../hum_codes_raw/s843749289.java" startline="1" endline="53" pcid="28334">
import java.util.Scanner;

public class Main {

	static boolean[] primes;

	static void primeSet(final int MAX){
		primes = new boolean[MAX+1];

		primes[2] = true;
		for(int i=3;i<=MAX;i+=2){
			primes[i] = true;
		}
		int rt = (int) Math.sqrt(MAX);
		for(int i=3;i<=rt;i+=2){
			if(primes[i]){
				for(int j=i*2;j<=MAX;j+=i){
					primes[j] = false;
				}
			}
		}
	}

	public static void main(String[] args) {
		Scanner stdIn = new Scanner(System.in);

		while(true){
			int max = 0;
			int n = stdIn.nextInt();

			if(max<n){
				primeSet(n);
				max=n;
			}
			
			if(n==0){
				break;
			}

			// if(ï) then "0" ÈóÅÍÈ¢Bn=7 ... [2,5]

			int cnt = 0;
			for(int i=2;i<=n/2;i++){
				if(primes[i]&&primes[n-i]){
//					System.out.println("["+i+","+(n-i)+"]");
					cnt++;
				}
			}
			System.out.println(cnt);
		}
	}
}

</source>
<source file="../hum_codes_raw/s951909513.java" startline="1" endline="55" pcid="31975">
import java.util.Scanner;

public class Main {

	// AOJ 0056 , 0185 とソースコードは同じ

	static boolean[] primes;

	static void primeSet(final int MAX){
		primes = new boolean[MAX+1];

		primes[2] = true;
		for(int i=3;i<=MAX;i+=2){
			primes[i] = true;
		}
		int rt = (int) Math.sqrt(MAX);
		for(int i=3;i<=rt;i+=2){
			if(primes[i]){
				for(int j=i*2;j<=MAX;j+=i){
					primes[j] = false;
				}
			}
		}
	}

	public static void main(String[] args) {
		Scanner stdIn = new Scanner(System.in);

		while(true){
			int max = 0;
			int n = stdIn.nextInt();

			if(max<n){
				primeSet(n);
				max=n;
			}

			if(n==0){
				break;
			}

			// if(奇数) then "0" な訳ではない。n=7 ... [2,5]

			int cnt = 0;
			for(int i=2;i<=n/2;i++){
				if(primes[i]&&primes[n-i]){
					// System.out.println("["+i+","+(n-i)+"]");
					cnt++;
				}
			}
			System.out.println(cnt);
		}
	}
}

</source>
</class>

<class classid="304" nclones="2" nlines="76" similarity="100">
<source file="../hum_codes_raw/s844951879.java" startline="1" endline="95" pcid="28370">
import java.io.IOException;

public class Main {

	public static void main(String[] args) {
		while (true) {
			int n = nextInt();
			if (n == 0) {
				break;
			}

			int[][] cir = new int[n][4];
			int[] above = new int[n];// 上に重なってる円盤

			int[] bitDP = new int[1 << n];

			for (int i = 0; i < n; i++) {
				int x = nextInt();
				int y = nextInt();
				int r = nextInt();
				int c = nextInt();
				cir[i][0] = x;
				cir[i][1] = y;
				cir[i][2] = r;
				cir[i][3] = c;

				for (int j = 0; j < i; j++) {
					// 重なっている円盤があるかの判定
					int jx = cir[j][0] - x;
					int jy = cir[j][1] - y;
					int jr = cir[j][2];
					double dist = Math.sqrt(jx * jx + jy * jy);
					if (dist < r + jr) {
						above[i] += (1 << j);
					}
				}
			}

			int max = 0;
			for (int bit = 0; bit < bitDP.length; bit++) {
				// 到達しうる遷移か
				if (bit != 0 && bitDP[bit] == 0) {
					continue;
				}
				for (int i = 0; i < n; i++) {
					// 円iとjが取り除かれていないかチェック
					if ((bit & (1 << i)) != 0) {
						continue;
					}
					for (int j = i + 1; j < n; j++) {
						// 円iとjが取り除かれていないかチェック
						if ((bit & ((1 << i) + (1 << j))) != 0) {
							continue;
						}
						// iとjの上に載っている円が全部取り除かれている
						if ((above[i] & bit) != above[i] || (above[j] & bit) != above[j]) {
							continue;
						}
						// 色が一緒かどうか
						if (cir[i][3] == cir[j][3]) {
							int newbit = bit + (1 << i) + (1 << j);
							bitDP[newbit] = Math.max(bitDP[newbit], bitDP[bit] + 2);
							max = Math.max(max, bitDP[newbit]);
						}
					}
				}
			}

			System.out.println(max);
			System.gc();
		}
	}

	static int nextInt() {
		int c;
		try {
			c = System.in.read();
			while (c != '-' && (c < '0' || c > '9'))
				c = System.in.read();
			if (c == '-')
				return -nextInt();
			int res = 0;
			while (c >= '0' && c <= '9') {
				res = res * 10 + c - '0';
				c = System.in.read();
			}
			return res;
		} catch (IOException e) {
			e.printStackTrace();
		}
		return -1;
	}

}

</source>
<source file="../hum_codes_raw/s928209330.java" startline="1" endline="95" pcid="31231">
import java.io.IOException;

public class Main {

	public static void main(String[] args) {
		while (true) {
			int n = nextInt();
			if (n == 0) {
				break;
			}

			int[][] cir = new int[n][4];
			int[] above = new int[n];// テ、ツクツ甘」ツ?ォテゥツ?催」ツ?ェテ」ツ?」テ」ツ?ヲテ」ツつ凝・ツ??ァツ崢、

			int[] bitDP = new int[1 << n];

			for (int i = 0; i < n; i++) {
				int x = nextInt();
				int y = nextInt();
				int r = nextInt();
				int c = nextInt();
				cir[i][0] = x;
				cir[i][1] = y;
				cir[i][2] = r;
				cir[i][3] = c;

				for (int j = 0; j < i; j++) {
					// テゥツ?催」ツ?ェテ」ツ?」テ」ツ?ヲテ」ツ??」ツつ凝・ツ??ァツ崢、テ」ツ?古」ツ?づ」ツつ凝」ツ?凝」ツ?ョテ・ツ按、テ・ツョツ?
					int jx = cir[j][0] - x;
					int jy = cir[j][1] - y;
					int jr = cir[j][2];
					double dist = Math.sqrt(jx * jx + jy * jy);
					if (dist < r + jr) {
						above[i] += (1 << j);
					}
				}
			}

			int max = 0;
			for (int bit = 0; bit < bitDP.length; bit++) {
				// テ・ツ按ーテゥツ?氾」ツ?療」ツ??」ツつ凝ゥツ?キテァツァツサテ」ツ??
				if (bit != 0 && bitDP[bit] == 0) {
					continue;
				}
				for (int i = 0; i < n; i++) {
					// テ・ツ??テ」ツ?ィjテ」ツ?古・ツ渉姪」ツつ甘ゥツ卍、テ」ツ?凝」ツつ古」ツ?ヲテ」ツ??」ツ?ェテ」ツ??」ツ?凝」ツδ?」ツつァテ」ツδε」ツつッ
					if ((bit & (1 << i)) != 0) {
						continue;
					}
					for (int j = i + 1; j < n; j++) {
						// テ・ツ??テ」ツ?ィjテ」ツ?古・ツ渉姪」ツつ甘ゥツ卍、テ」ツ?凝」ツつ古」ツ?ヲテ」ツ??」ツ?ェテ」ツ??」ツ?凝」ツδ?」ツつァテ」ツδε」ツつッ
						if ((bit & ((1 << i) + (1 << j))) != 0) {
							continue;
						}
						// iテ」ツ?ィjテ」ツ?ョテ、ツクツ甘」ツ?ォティツシツ嘉」ツ?」テ」ツ?ヲテ」ツ??」ツつ凝・ツ??」ツ?古・ツ?ィテゥツδィテ・ツ渉姪」ツつ甘ゥツ卍、テ」ツ?凝」ツつ古」ツ?ヲテ」ツ??」ツつ?
						if ((above[i] & bit) != above[i] || (above[j] & bit) != above[j]) {
							continue;
						}
						// ティツ可イテ」ツ?古、ツクツ?ァツキツ津」ツ?凝」ツ?ゥテ」ツ??」ツ??
						if (cir[i][3] == cir[j][3]) {
							int newbit = bit + (1 << i) + (1 << j);
							bitDP[newbit] = Math.max(bitDP[newbit], bitDP[bit] + 2);
							max = Math.max(max, bitDP[newbit]);
						}
					}
				}
			}

			System.out.println(max);
			System.gc();
		}
	}

	static int nextInt() {
		int c;
		try {
			c = System.in.read();
			while (c != '-' && (c < '0' || c > '9'))
				c = System.in.read();
			if (c == '-')
				return -nextInt();
			int res = 0;
			while (c >= '0' && c <= '9') {
				res = res * 10 + c - '0';
				c = System.in.read();
			}
			return res;
		} catch (IOException e) {
			e.printStackTrace();
		}
		return -1;
	}

}

</source>
</class>

<class classid="305" nclones="2" nlines="29" similarity="100">
<source file="../hum_codes_raw/s845515756.java" startline="1" endline="33" pcid="28394">
import java.util.Scanner;
 
//Flying Jenny
public class Main{
 
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int[] c = {4,1,4,1,2,1,2,1};
        while(sc.hasNext()){
            int[] a = new int[8];
            for(int i=0;i<8;i++)a[i]=sc.nextInt();
            int min = Integer.MAX_VALUE;
            String v = "";
            for(int top=0;top<8;top++){
                int r = 0;
                String m = "";
                for(int j=0;j<8;j++){
                    r += Math.max(0, a[j]-c[(top+j)%8]);
                    m += c[(top+j)%8];
                }
                if(r<min){
                    min = r;
                    v = m;
                }
                else if(r==min&&m.compareTo(v)<0)v = m;
            }
            System.out.print(v.charAt(0));
            for(int i=1;i<8;i++)System.out.print(" "+v.charAt(i));
            System.out.println();
        }
    }
}

</source>
<source file="../hum_codes_raw/s864941032.java" startline="1" endline="33" pcid="29074">
import java.util.Scanner;

//Flying Jenny
public class Main{

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int[] c = {4,1,4,1,2,1,2,1};
		while(sc.hasNext()){
			int[] a = new int[8];
			for(int i=0;i<8;i++)a[i]=sc.nextInt();
			int min = Integer.MAX_VALUE;
			String v = "";
			for(int top=0;top<8;top++){
				int r = 0;
				String m = "";
				for(int j=0;j<8;j++){
					r += Math.max(0, a[j]-c[(top+j)%8]);
					m += c[(top+j)%8];
				}
				if(r<min){
					min = r;
					v = m;
				}
				else if(r==min&&m.compareTo(v)<0)v = m;
			}
			System.out.print(v.charAt(0));
			for(int i=1;i<8;i++)System.out.print(" "+v.charAt(i));
			System.out.println();
		}
	}
}

</source>
</class>

<class classid="306" nclones="2" nlines="31" similarity="100">
<source file="../hum_codes_raw/s863917875.java" startline="1" endline="26" pcid="29046">
import java.util.Scanner;
	import java.util.*;
	
	public class Main{
		
		public static void main(String[] args) {
			
			Scanner sc=new Scanner(System.in);
			
		while(true){int n=sc.nextInt();if(n==0){break;}
		int N[]=new int[n+1];
		
		for(int i=0;i<n+1;i++){N[i]=sc.nextInt();}
		
		bi:for(int i=0;i<n+1;i++){
			List<Integer>tousa=new ArrayList<Integer>();
		for(int p=0;p<n+1;p++){
			tousa.add(N[p]);}
		tousa.remove(i);
			for(int p=0;p<n-2;p++){
				if(tousa.get(p)-tousa.get(p+1)!=tousa.get(p+1)-tousa.get(p+2)){continue bi;}
			}System.out.println(N[i]);break;
		
		}}}}
		

</source>
<source file="../hum_codes_raw/s959716567.java" startline="1" endline="33" pcid="32257">
import java.util.Scanner;
	import java.util.*;
	
	public class Main{
		
		public static void main(String[] args) {
			
			Scanner sc=new Scanner(System.in);
			
		while(true){int n=sc.nextInt();if(n==0){break;}
		int N[]=new int[n+1];
		
		for(int i=0;i<n+1;i++){N[i]=sc.nextInt();}
		
		bi:for(int i=0;i<n+1;i++){
			List<Integer>tousa=new ArrayList<Integer>();
		for(int p=0;p<n+1;p++){
			tousa.add(N[p]);}
		tousa.remove(i);
			for(int p=0;p<n-2;p++){
				if(tousa.get(p)-tousa.get(p+1)!=tousa.get(p+1)-tousa.get(p+2)){continue bi;}
			}System.out.println(N[i]);break;
		
		}}}}
		
		
		
		
		
		
		
		

</source>
</class>

<class classid="307" nclones="2" nlines="82" similarity="100">
<source file="../hum_codes_raw/s870448175.java" startline="1" endline="100" pcid="29277">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

  public static void main(String[] args) {
  
    new Main().run();
  }

  public void run() {

    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      int n = Integer.parseInt(br.readLine());
      Card[] cards = new Card[n];
      char suit;
      int  value;

      for ( int i=0; i<n; i++ ) {
        suit = (char)br.read(); br.skip(1);
        value = Integer.parseInt(br.readLine());
        cards[i] = new Card(suit, value, i);
      }

      quickSortOfCards(cards, 0, n-1);
      dispCardArray(cards);
    }
    catch(IOException e) {
      System.out.println("IOException!");
    }
  }

  public void quickSortOfCards(Card[] card, int p, int r) {

    if( p < r) {
      int q = partitionOfCards(card, p, r);
      quickSortOfCards(card, p, q-1);
      quickSortOfCards(card, q+1, r);
    }
  }

  public int partitionOfCards(Card[] card, int p, int r) {

    int x = card[r].value;
    int i = p-1;
    Card t;

    for(int j=p; j<r; j++) {
      if(card[j].value <= x) {
        t = card[++i]; card[i] = card[j]; card[j] = t;
      }
    }
    t = card[i+1]; card[i+1] = card[r]; card[r] = t;

    return i+1;
  }

public void dispCardArray(Card[] target) {
  StringBuilder s = new StringBuilder();
  int l=target.length;
  boolean isStable = true;
  String sortState = "Stable";

  s.append(target[0]).append("\n");
  for (int i=1; i<l; i++) {
    s.append(target[i]).append("\n");
    if(isStable && target[i-1].value == target[i].value 
      && target[i-1].storedNo > target[i].storedNo) {
      sortState = "Not stable";
      isStable = false;
    }
  }

  System.out.println(sortState);
  System.out.print(s);
  }
}

class Card {
  char suit;
  int value;
  int storedNo;

  public Card( char suit, int value, int storedNo ) {
    this.suit  = suit;
    this.value = value;
    this.storedNo = storedNo;
  }
  public Card( Card card ) {
    this(card.suit, card.value, card.storedNo);
  }

  @Override
  public String toString() {
    return suit + " " + String.valueOf(value);
  }
}

</source>
<source file="../hum_codes_raw/s972659004.java" startline="1" endline="100" pcid="32725">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

  public static void main(String[] args) {
  
    new Main().run();
  }

  public void run() {

    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      int n = Integer.parseInt(br.readLine());
      Card[] cards = new Card[n];
      char suit;
      int  value;

      for ( int i=0; i<n; i++ ) {
        suit = (char)br.read(); br.skip(1);
        value = Integer.parseInt(br.readLine());
        cards[i] = new Card(suit, value, i);
      }

      quickSortOfCards(cards, 0, n-1);
      dispCardArray(cards);
    }
    catch(IOException e) {
      System.out.println("IOException!");
    }
  }

  public void quickSortOfCards(Card[] card, int p, int r) {

    if( p < r) {
      int q = partitionOfCards(card, p, r);
      quickSortOfCards(card, p, q-1);
      quickSortOfCards(card, q+1, r);
    }
  }

  public int partitionOfCards(Card[] card, int p, int r) {

    int x = card[r].value;
    int i = p-1;
    Card t;

    for(int j=p; j<r; j++) {
      if(card[j].value <= x) {
        t = card[++i]; card[i] = card[j]; card[j] = t;
      }
    }
    t = card[i+1]; card[i+1] = card[r]; card[r] = t;

    return i+1;
  }

public void dispCardArray(Card[] target) {
  StringBuilder s = new StringBuilder();
  int l=target.length;
  boolean isStable = true;
  String sortState = "Stable";

  s.append(target[0]).append("\n");
  for (int i=1; i<l; i++) {
    s.append(target[i]).append("\n");
    if(isStable && target[i-1].value == target[i].value 
      && target[i-1].storedNo > target[i].storedNo) {
      sortState = "Not stable";
      isStable = false;
    }
  }

  System.out.println(sortState);
  System.out.print(s);
  }
}

class Card {
  char suit;
  int value;
  int storedNo;

  public Card( char suit, int value, int storedNo ) {
    this.suit  = suit;
    this.value = value;
    this.storedNo = storedNo;
  }
  public Card( Card card ) {
    this(card.suit, card.value, card.storedNo);
  }

  @Override
  public String toString() {
    return suit + " " + String.valueOf(value);
  }
}

</source>
</class>

<class classid="308" nclones="2" nlines="13" similarity="100">
<source file="../hum_codes_raw/s881248582.java" startline="1" endline="15" pcid="29614">
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int [] a = new int [N];
        for(int i=0; i<N; i++){
            a[i] = sc.nextInt();
        }
        Arrays.sort(a);
        System.out.println(a[N-1]-a[0]);
    }
}

</source>
<source file="../hum_codes_raw/s925507872.java" startline="1" endline="14" pcid="31131">
import java.util.*;
public class Main{
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int N = sc.nextInt();
    int[] a = new int[N];
    for (int i=0; i<N; i++){
      a[i] = sc.nextInt();
    }
    Arrays.sort(a);
    System.out.println(a[N-1]-a[0]);
  }
}

</source>
</class>

<class classid="309" nclones="2" nlines="22" similarity="100">
<source file="../hum_codes_raw/s881835494.java" startline="1" endline="31" pcid="29635">
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(sc.hasNext()) {
		char[] a = sc.next().toCharArray();
		char[] b = sc.next().toCharArray();
		int[][] dp = new int[a.length][b.length];
		int max = 0;
		for(int i = 0; i < a.length; i++) {
			for(int j = 0; j < b.length; j++) {
				if(a[i] == b[j]) {
					if(i != 0 && j != 0)
					dp[i][j] = Math.max(dp[i-1][j-1]+1, 1);
					else dp[i][j] = 1;
				}
				max = Math.max(dp[i][j], max);
				
				
			}
		}
		System.out.println(max);
		}
		
	}

	
}

</source>
<source file="../hum_codes_raw/s895881206.java" startline="1" endline="32" pcid="30147">
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(sc.hasNext()) {
		char[] a = sc.next().toCharArray();
		char[] b = sc.next().toCharArray();
		int[][] dp = new int[a.length][b.length];
		int max = 0;
		for(int i = 0; i < a.length; i++) {
			for(int j = 0; j < b.length; j++) {
				if(a[i] == b[j]) {
					if(i != 0 && j != 0)
					dp[i][j] = Math.max(dp[i-1][j-1]+1, 1);
					else dp[i][j] = 1;
					max = Math.max(dp[i][j], max);
				}
				
				
				
			}
		}
		System.out.println(max);
		}
		
	}

	
}

</source>
</class>

<class classid="310" nclones="2" nlines="29" similarity="100">
<source file="../hum_codes_raw/s921794084.java" startline="1" endline="51" pcid="31005">
import java.util.*;
public class Main
{
	public static void main(String[] args) 
	{
		Scanner in=new Scanner(System.in);
		int m[][]={
				{1,2,1,2,1,4,1,4},
				{1,2,1,4,1,4,1,2},
				{1,4,1,2,1,2,1,4},
				{1,4,1,4,1,2,1,2},
				{2,1,2,1,4,1,4,1},
				{2,1,4,1,4,1,2,1},
				{4,1,2,1,2,1,4,1},
				{4,1,4,1,2,1,2,1},
		};
		while(in.hasNext())
		{
			int a[]=new int[8];
			for(int i=0;i<8;i++)
				a[i]=in.nextInt();
			
			int id=-1;
			int min=Integer.MAX_VALUE;
			for(int i=0;i<8;i++)
			{
				int sam=0;
				for(int j=0;j<8;j++)
				{
					int cnt=m[i][j]-a[j];
					if(cnt>0)
						sam+=cnt;
				}
				if(sam<min)
				{
					min=sam;
					id=i;
				}
			}
			for(int i=0;i<7;i++)
				System.out.print(m[id][i]+" ");
			System.out.println(m[id][7]);
		}
	}

	static public void debug(Object... o)
	{
		System.out.println(Arrays.deepToString(o));
	}
}

</source>
<source file="../hum_codes_raw/s972797820.java" startline="1" endline="51" pcid="32733">
import java.util.*;
public class Main
{
    public static void main(String[] args) 
    {
        Scanner in=new Scanner(System.in);
        int m[][]={
                {1,2,1,2,1,4,1,4},
                {1,2,1,4,1,4,1,2},
                {1,4,1,2,1,2,1,4},
                {1,4,1,4,1,2,1,2},
                {2,1,2,1,4,1,4,1},
                {2,1,4,1,4,1,2,1},
                {4,1,2,1,2,1,4,1},
                {4,1,4,1,2,1,2,1},
        };
        while(in.hasNext())
        {
            int a[]=new int[8];
            for(int i=0;i<8;i++)
                a[i]=in.nextInt();
             
            int id=-1;
            int min=Integer.MAX_VALUE;
            for(int i=0;i<8;i++)
            {
                int sam=0;
                for(int j=0;j<8;j++)
                {
                    int cnt=m[i][j]-a[j];
                    if(cnt>0)
                        sam+=cnt;
                }
                if(sam<min)
                {
                    min=sam;
                    id=i;
                }
            }
            for(int i=0;i<7;i++)
                System.out.print(m[id][i]+" ");
            System.out.println(m[id][7]);
        }
    }
 
    static public void debug(Object... o)
    {
        System.out.println(Arrays.deepToString(o));
    }
}

</source>
</class>

<class classid="311" nclones="2" nlines="16" similarity="100">
<source file="../hum_codes_raw/s934462189.java" startline="1" endline="18" pcid="31424">
import java.util.*;

class Main {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
	String s = sc.next();

    if (s.equals("Sunny")) {
	  System.out.println("Cloudy");
    } else if (s.equals("Cloudy")) {
      System.out.println("Rainy");
    } else {
      System.out.println("Sunny");
    }
    
  }
}

</source>
<source file="../hum_codes_raw/s956305632.java" startline="1" endline="16" pcid="32145">
import java.util.*;

class Main{
  public static void main(String[] args){
    Scanner sc = new Scanner(System.in);
    String s = sc.next();
    if(s.equals("Sunny")){
      System.out.println("Cloudy");
    }else if(s.equals("Cloudy")){
      System.out.println("Rainy");
    }else{
      System.out.println("Sunny");
    }
  }
}

</source>
</class>

<class classid="312" nclones="2" nlines="10" similarity="100">
<source file="../hum_codes_raw/s945990009.java" startline="1" endline="15" pcid="31792">
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int X = sc.nextInt();
		int A = sc.nextInt();
		int B = sc.nextInt();

		System.out.println((X-A) % B);

	}
}


</source>
<source file="../hum_codes_raw/s957275050.java" startline="1" endline="20" pcid="32171">
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		// TODO 自動生成されたメソッド・スタブ

		Scanner sc = new Scanner(System.in);

		int X = sc.nextInt();
		int A = sc.nextInt();
		int B = sc.nextInt();

			System.out.println((X-A)%B);


		}
	}


</source>
</class>

<class classid="313" nclones="3" nlines="116" similarity="100">
<source file="../hum_codes_raw/s965431320.java" startline="1" endline="143" pcid="32455">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class Main {

  public static void main(String[] args) {
    
    new Main().run();
  }

  public void run() {

    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      String[] nm = br.readLine().split(" ");
      int n = Integer.parseInt(nm[0]);
      int m = Integer.parseInt(nm[1]);
      Graph graph = new Graph(n);
      String[] vInfo;
      int idS,idT;

      for(int i=0; i<m; i++) {
        vInfo = br.readLine().split(" ");
        idS   = Integer.parseInt(vInfo[0]);
        idT   = Integer.parseInt(vInfo[1]);
        graph.setAjacentList(idS, idT);
        graph.setAjacentList(idT, idS);
      }
      graph.vertexSearch();

      int q = Integer.parseInt(br.readLine());
      StringBuilder buf = new StringBuilder();
      for(int i=0; i<q; i++) {
        vInfo = br.readLine().split(" ");
        idS   = Integer.parseInt(vInfo[0]);
        idT   = Integer.parseInt(vInfo[1]);
        buf.append(graph.isConnected(idS, idT) ? "yes" : "no")
           .append("\n");
      }

      System.out.print(buf);
    }
    catch (IOException e) {
      System.err.println(e);
    }
  }

  class Graph {

    Vertex[] vertices;
    Queue<Vertex> queue;
    int time;

    public Graph(int size ) {
      vertices  = new Vertex[size];
      queue = new ArrayDeque<>(size);
      time = 0;
      for (int i=0; i<size; i++) {
        vertices[i] = new Vertex(i);
      }
    }

    public void setVertex(int id) {
      vertices[convIdToIndex(id)] = new Vertex(id);
    }
    public void setAjacentList(int id, int ajacent) {
      vertices[convIdToIndex(id)].ajacent
      .add(convIdToIndex(ajacent));
    }
    public void vertexSearch() {
      int color = 10;

      for (Vertex v : vertices) {
        if(v.state == Vertex.WHITE)
        GroupingByBFS(v.index,color++);
      }
    }
    public void dispReport() {
      StringBuilder buf = new StringBuilder();

      for (Vertex v : vertices) {
          buf.append(v.id).append(" ")
             .append(v.distance).append("\n");
      }

      System.out.print(buf);
    }
    public int convIdToIndex(int id) {
      return id - Vertex. DIFF_ID_INDEX;
    }
    public boolean isConnected(int idS, int idT) {
      return vertices[idS].state == vertices[idT].state;
    }

    private void GroupingByBFS(int index, int color) {
      vertices[index].state = Vertex.GRAY;
      vertices[index].distance = 0;
      queue.offer(vertices[index]);

      Vertex v;
      while(queue.peek() != null) {
        v = queue.poll();
        for (int ajcIndex : v.ajacent) {
          if(vertices[ajcIndex].state == Vertex.WHITE) {
            vertices[ajcIndex].state = Vertex.GRAY;
            vertices[ajcIndex].distance = v.distance + 1;
            queue.offer(vertices[ajcIndex]);
          }
        }
        v.state =color;
      }
    }

    class Vertex {

      static final int WHITE = 0;
      static final int GRAY  = 1;
      static final int BLACK = 2;
      static final int DIFF_ID_INDEX = 0;
      int id;
      int index;
      int state;
      List<Integer> ajacent;
      int findTime;
      int doneTime;
      int distance;

      public Vertex(int id) {
        this.id = id;
        index = id-DIFF_ID_INDEX;
        state = WHITE;
        distance = -1;
        ajacent = new LinkedList<>();
      }
    }
  }
}

</source>
<source file="../hum_codes_raw/s992552471.java" startline="1" endline="143" pcid="33393">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class Main {

  public static void main(String[] args) {
    
    new Main().run();
  }

  public void run() {

    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      String[] nm = br.readLine().split(" ");
      int n = Integer.parseInt(nm[0]);
      int m = Integer.parseInt(nm[1]);
      Graph graph = new Graph(n);
      String[] vInfo;
      int idS,idT;

      for(int i=0; i<m; i++) {
        vInfo = br.readLine().split(" ");
        idS   = Integer.parseInt(vInfo[0]);
        idT   = Integer.parseInt(vInfo[1]);
        graph.setAjacentList(idS, idT);
        graph.setAjacentList(idT, idS);
      }
      graph.vertexSearch();

      int q = Integer.parseInt(br.readLine());
      StringBuilder buf = new StringBuilder();
      for(int i=0; i<q; i++) {
        vInfo = br.readLine().split(" ");
        idS   = Integer.parseInt(vInfo[0]);
        idT   = Integer.parseInt(vInfo[1]);
        buf.append(graph.isConnected(idS, idT) ? "yes" : "no")
           .append("\n");
      }

      System.out.print(buf);
    }
    catch (IOException e) {
      System.err.println(e);
    }
  }

  class Graph {

    Vertex[] vertices;
    Queue<Vertex> queue;
    int time;

    public Graph(int size ) {
      vertices  = new Vertex[size];
      queue = new ArrayDeque<>(size);
      time = 0;
      for (int i=0; i<size; i++) {
        vertices[i] = new Vertex(i);
      }
    }

    public void setVertex(int id) {
      vertices[convIdToIndex(id)] = new Vertex(id);
    }
    public void setAjacentList(int id, int ajacent) {
      vertices[convIdToIndex(id)].ajacent
      .add(convIdToIndex(ajacent));
    }
    public void vertexSearch() {
      int color = 10;

      for (Vertex v : vertices) {
        if(v.state == Vertex.WHITE)
        GroupingByBFS(v.index,color++);
      }
    }
    public void dispReport() {
      StringBuilder buf = new StringBuilder();

      for (Vertex v : vertices) {
          buf.append(v.id).append(" ")
             .append(v.distance).append("\n");
      }

      System.out.print(buf);
    }
    public int convIdToIndex(int id) {
      return id - Vertex. DIFF_ID_INDEX;
    }
    public boolean isConnected(int idS, int idT) {
      return vertices[idS].state == vertices[idT].state;
    }

    private void GroupingByBFS(int index, int color) {
      vertices[index].state = Vertex.GRAY;
      vertices[index].distance = 0;
      queue.offer(vertices[index]);

      Vertex v;
      while(queue.peek() != null) {
        v = queue.poll();
        for (int ajcIndex : v.ajacent) {
          if(vertices[ajcIndex].state == Vertex.WHITE) {
            vertices[ajcIndex].state = Vertex.GRAY;
            vertices[ajcIndex].distance = v.distance + 1;
            queue.offer(vertices[ajcIndex]);
          }
        }
        v.state =color;
      }
    }

    class Vertex {

      static final int WHITE = 0;
      static final int GRAY  = 1;
      static final int BLACK = 2;
      static final int DIFF_ID_INDEX = 0;
      int id;
      int index;
      int state;
      List<Integer> ajacent;
      int findTime;
      int doneTime;
      int distance;

      public Vertex(int id) {
        this.id = id;
        index = id-DIFF_ID_INDEX;
        state = WHITE;
        distance = -1;
        ajacent = new LinkedList<>();
      }
    }
  }
}

</source>
<source file="../hum_codes_raw/s982466613.java" startline="1" endline="143" pcid="33041">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class Main {

  public static void main(String[] args) {
    
    new Main().run();
  }

  public void run() {

    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      String[] nm = br.readLine().split(" ");
      int n = Integer.parseInt(nm[0]);
      int m = Integer.parseInt(nm[1]);
      Graph graph = new Graph(n);
      String[] vInfo;
      int idS,idT;

      for(int i=0; i<m; i++) {
        vInfo = br.readLine().split(" ");
        idS   = Integer.parseInt(vInfo[0]);
        idT   = Integer.parseInt(vInfo[1]);
        graph.setAjacentList(idS, idT);
        graph.setAjacentList(idT, idS);
      }
      graph.vertexSearch();

      int q = Integer.parseInt(br.readLine());
      StringBuilder buf = new StringBuilder();
      for(int i=0; i<q; i++) {
        vInfo = br.readLine().split(" ");
        idS   = Integer.parseInt(vInfo[0]);
        idT   = Integer.parseInt(vInfo[1]);
        buf.append(graph.isConnected(idS, idT) ? "yes" : "no")
           .append("\n");
      }

      System.out.print(buf);
    }
    catch (IOException e) {
      System.err.println(e);
    }
  }

  class Graph {

    Vertex[] vertices;
    Queue<Vertex> queue;
    int time;

    public Graph(int size ) {
      vertices  = new Vertex[size];
      queue = new ArrayDeque<>(size);
      time = 0;
      for (int i=0; i<size; i++) {
        vertices[i] = new Vertex(i);
      }
    }

    public void setVertex(int id) {
      vertices[convIdToIndex(id)] = new Vertex(id);
    }
    public void setAjacentList(int id, int ajacent) {
      vertices[convIdToIndex(id)].ajacent
      .add(convIdToIndex(ajacent));
    }
    public void vertexSearch() {
      int color = 10;

      for (Vertex v : vertices) {
        if(v.state == Vertex.WHITE)
        GroupingByBFS(v.index,color++);
      }
    }
    public void dispReport() {
      StringBuilder buf = new StringBuilder();

      for (Vertex v : vertices) {
          buf.append(v.id).append(" ")
             .append(v.distance).append("\n");
      }

      System.out.print(buf);
    }
    public int convIdToIndex(int id) {
      return id - Vertex. DIFF_ID_INDEX;
    }
    public boolean isConnected(int idS, int idT) {
      return vertices[idS].state == vertices[idT].state;
    }

    private void GroupingByBFS(int index, int color) {
      vertices[index].state = Vertex.GRAY;
      vertices[index].distance = 0;
      queue.offer(vertices[index]);

      Vertex v;
      while(queue.peek() != null) {
        v = queue.poll();
        for (int ajcIndex : v.ajacent) {
          if(vertices[ajcIndex].state == Vertex.WHITE) {
            vertices[ajcIndex].state = Vertex.GRAY;
            vertices[ajcIndex].distance = v.distance + 1;
            queue.offer(vertices[ajcIndex]);
          }
        }
        v.state =color;
      }
    }

    class Vertex {

      static final int WHITE = 0;
      static final int GRAY  = 1;
      static final int BLACK = 2;
      static final int DIFF_ID_INDEX = 0;
      int id;
      int index;
      int state;
      List<Integer> ajacent;
      int findTime;
      int doneTime;
      int distance;

      public Vertex(int id) {
        this.id = id;
        index = id-DIFF_ID_INDEX;
        state = WHITE;
        distance = -1;
        ajacent = new LinkedList<>();
      }
    }
  }
}

</source>
</class>

</clones>
