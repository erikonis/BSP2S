<clones>
<systeminfo processor="nicad6" system="hum_codes_raw" granularity="files" threshold="0%" minlines="10" maxlines="2500"/>
<cloneinfo npcs="33864" npairs="377"/>
<runinfo ncompares="6690223" cputime="1644428"/>
<classinfo nclasses="313"/>

<class classid="1" nclones="2" nlines="88" similarity="100">
<source file="../hum_codes_raw/s002237166.java" startline="1" endline="108" pcid="62">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

class Card {
  String suit;
  int value;
  int storedNo;

  public Card( String suit, int value, int storedNo ) {
    this.suit  = suit;
    this.value = value;
    this.storedNo = storedNo;
  }
  public Card( Card card ) {
    this(card.suit, card.value, card.storedNo);
  }

  @Override
  public String toString() {
    return suit + String.valueOf(value);
  }
}

public class Main {

  public static void main(String[] args) throws IOException {
    
    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      int n = Integer.parseInt(br.readLine());
      Card[][] cards = new Card[2][n];
      String[] line = br.readLine().split(" ");
      for (int i=0; i < n; i++) {
        cards[0][i] = new Card(
          line[i].substring(0, 1),
          Integer.parseInt(line[i].substring(1)),
          i );
        cards[1][i] = new Card(cards[0][i]);
      }

      bubbleSort(cards[0], n);
      dispIntArray(cards[0]);
      System.out.println(isStableSorted(cards[0], n) ? "Stable" : "Not stable");
      selectionSort(cards[1], n);
      dispIntArray(cards[1]);
      System.out.println(isStableSorted(cards[1], n) ? "Stable" : "Not stable");
    }
  }

  static int bubbleSort(Card[] a, int n) {
    int count=0;
    Card t;

    for(int i=0,f=1; f==1 || i<n; i++ ) {
      f=0;
      for(int j=n-1; j>0; j-- ) {
        if( a[j].value < a[j-1].value) {
          t = a[j]; a[j] = a[j-1]; a[j-1] = t;
          count++;
          f=1;
        }
      }
    }

    return count;
  }

  static int selectionSort(Card a[], int n) {
    int count = 0;
    Card t;

    for(int i=0,min; i<n-1; i++ ) {
      min = i;
      for(int j=i+1; j<n; j++ ) {
        if( a[min].value > a[j].value) min = j;
      }
      if( min != i ) {
        t = a[i]; a[i] = a[min]; a[min] = t;
        count++;
      }
    }

    return count;
  }

  static boolean isStableSorted(Card[] sorted, int n) {
    boolean ret = true;

    for (int i=0, max=n-1; i < max; i++) {
      if( sorted[i].value == sorted[i+1].value
        && sorted[i].storedNo > sorted[i+1].storedNo )
        ret = false;
    }

    return ret;
  }

  public static void dispIntArray(Card[] a) {
    StringBuilder s = new StringBuilder();

    for (Card c : a) { s.append(c.toString()).append(" "); }
    s.setLength(s.length()-1);

    System.out.println(s);
  }
}

</source>
<source file="../hum_codes_raw/s005012101.java" startline="1" endline="108" pcid="165">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

class Card {
  String suit;
  int value;
  int storedNo;

  public Card( String suit, int value, int storedNo ) {
    this.suit  = suit;
    this.value = value;
    this.storedNo = storedNo;
  }
  public Card( Card card ) {
    this(card.suit, card.value, card.storedNo);
  }

  @Override
  public String toString() {
    return suit + String.valueOf(value);
  }
}

public class Main {

  public static void main(String[] args) throws IOException {
    
    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      int n = Integer.parseInt(br.readLine());
      Card[][] cards = new Card[2][n];
      String[] line = br.readLine().split(" ");
      for (int i=0; i < n; i++) {
        cards[0][i] = new Card(
          line[i].substring(0, 1),
          Integer.parseInt(line[i].substring(1)),
          i );
        cards[1][i] = new Card(cards[0][i]);
      }

      bubbleSort(cards[0], n);
      dispIntArray(cards[0]);
      System.out.println(isStableSorted(cards[0], n) ? "Stable" : "Not stable");
      selectionSort(cards[1], n);
      dispIntArray(cards[1]);
      System.out.println(isStableSorted(cards[1], n) ? "Stable" : "Not stable");
    }
  }

  static int bubbleSort(Card[] a, int n) {
    int count=0;
    Card t;

    for(int i=0,f=1; f==1 || i<n; i++ ) {
      f=0;
      for(int j=n-1; j>0; j-- ) {
        if( a[j].value < a[j-1].value) {
          t = a[j]; a[j] = a[j-1]; a[j-1] = t;
          count++;
          f=1;
        }
      }
    }

    return count;
  }

  static int selectionSort(Card a[], int n) {
    int count = 0;
    Card t;

    for(int i=0,min; i<n-1; i++ ) {
      min = i;
      for(int j=i+1; j<n; j++ ) {
        if( a[min].value > a[j].value) min = j;
      }
      if( min != i ) {
        t = a[i]; a[i] = a[min]; a[min] = t;
        count++;
      }
    }

    return count;
  }

  static boolean isStableSorted(Card[] sorted, int n) {
    boolean ret = true;

    for (int i=0, max=n-1; i < max; i++) {
      if( sorted[i].value == sorted[i+1].value
        && sorted[i].storedNo > sorted[i+1].storedNo )
        ret = false;
    }

    return ret;
  }

  public static void dispIntArray(Card[] a) {
    StringBuilder s = new StringBuilder();

    for (Card c : a) { s.append(c.toString()).append(" "); }
    s.setLength(s.length()-1);

    System.out.println(s);
  }
}

</source>
</class>

<class classid="2" nclones="3" nlines="173" similarity="100">
<source file="../hum_codes_raw/s002901400.java" startline="1" endline="207" pcid="92">
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Deque;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

public class Main {

	static PrintWriter out;
	static InputReader ir;
	static boolean debug = false;

	static void solve() {
		int R=ir.nextInt();
		int C=ir.nextInt();
		int N=ir.nextInt();
		ArrayList<int[]> ps=new ArrayList<>();
		for(int i=0;i<N;i++){
			int[] p=ir.nextIntArray(2);
			int[] q=ir.nextIntArray(2);
			if(!(p[0]==0||p[0]==R||p[1]==0||p[1]==C)){
				continue;
			}
			if(!(q[0]==0||q[0]==R||q[1]==0||q[1]==C)){
				continue;
			}
			ps.add(new int[]{i,dist(p,R,C)});
			ps.add(new int[]{i,dist(q,R,C)});
		}
		Collections.sort(ps,new Comparator<int[]>(){
			public int compare(int[] A,int[] B){
				return A[1]-B[1];
			}
		});
		Deque<Integer> que=new ArrayDeque<>();
		for(int[] p : ps){
			if(!que.isEmpty()&&que.peekFirst()==p[0]){
				que.pollFirst();
			}
			else{
				que.offerFirst(p[0]);
			}
		}
		out.println(que.isEmpty()?"YES":"NO");
	}

	static int dist(int[] x,int R,int C){
		if(x[0]==0){
			return x[1];
		}
		else if(x[1]==C){
			return x[0]+C;
		}
		else if(x[0]==R){
			return C-x[1]+R+C;
		}
		else{
			return 2*(R+C)-x[0];
		}
	}

	public static void main(String[] args) {
		ir = new InputReader(System.in);
		out = new PrintWriter(System.out);
		solve();
		out.flush();
	}

	static class InputReader {

		private InputStream in;
		private byte[] buffer = new byte[1024];
		private int curbuf;
		private int lenbuf;

		public InputReader(InputStream in) {
			this.in = in;
			this.curbuf = this.lenbuf = 0;
		}

		public boolean hasNextByte() {
			if (curbuf >= lenbuf) {
				curbuf = 0;
				try {
					lenbuf = in.read(buffer);
				} catch (IOException e) {
					throw new InputMismatchException();
				}
				if (lenbuf <= 0)
					return false;
			}
			return true;
		}

		private int readByte() {
			if (hasNextByte())
				return buffer[curbuf++];
			else
				return -1;
		}

		private boolean isSpaceChar(int c) {
			return !(c >= 33 && c <= 126);
		}

		private void skip() {
			while (hasNextByte() && isSpaceChar(buffer[curbuf]))
				curbuf++;
		}

		public boolean hasNext() {
			skip();
			return hasNextByte();
		}

		public String next() {
			if (!hasNext())
				throw new NoSuchElementException();
			StringBuilder sb = new StringBuilder();
			int b = readByte();
			while (!isSpaceChar(b)) {
				sb.appendCodePoint(b);
				b = readByte();
			}
			return sb.toString();
		}

		public int nextInt() {
			if (!hasNext())
				throw new NoSuchElementException();
			int c = readByte();
			while (isSpaceChar(c))
				c = readByte();
			boolean minus = false;
			if (c == '-') {
				minus = true;
				c = readByte();
			}
			int res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res = res * 10 + c - '0';
				c = readByte();
			} while (!isSpaceChar(c));
			return (minus) ? -res : res;
		}

		public long nextLong() {
			if (!hasNext())
				throw new NoSuchElementException();
			int c = readByte();
			while (isSpaceChar(c))
				c = readByte();
			boolean minus = false;
			if (c == '-') {
				minus = true;
				c = readByte();
			}
			long res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res = res * 10 + c - '0';
				c = readByte();
			} while (!isSpaceChar(c));
			return (minus) ? -res : res;
		}

		public double nextDouble() {
			return Double.parseDouble(next());
		}

		public int[] nextIntArray(int n) {
			int[] a = new int[n];
			for (int i = 0; i < n; i++)
				a[i] = nextInt();
			return a;
		}

		public long[] nextLongArray(int n) {
			long[] a = new long[n];
			for (int i = 0; i < n; i++)
				a[i] = nextLong();
			return a;
		}

		public char[][] nextCharMap(int n, int m) {
			char[][] map = new char[n][m];
			for (int i = 0; i < n; i++)
				map[i] = next().toCharArray();
			return map;
		}
	}

	static void tr(Object... o) {
		if (debug)
			out.println(Arrays.deepToString(o));
	}
}

</source>
<source file="../hum_codes_raw/s770657796.java" startline="1" endline="207" pcid="25873">
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Deque;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

public class Main {

	static PrintWriter out;
	static InputReader ir;
	static boolean debug = false;

	static void solve() {
		int R=ir.nextInt();
		int C=ir.nextInt();
		int N=ir.nextInt();
		ArrayList<int[]> ps=new ArrayList<>();
		for(int i=0;i<N;i++){
			int[] p=ir.nextIntArray(2);
			int[] q=ir.nextIntArray(2);
			if(!(p[0]==0||p[0]==R||p[1]==0||p[1]==C)){
				continue;
			}
			if(!(q[0]==0||q[0]==R||q[1]==0||q[1]==C)){
				continue;
			}
			ps.add(new int[]{i,dist(p,R,C)});
			ps.add(new int[]{i,dist(q,R,C)});
		}
		Collections.sort(ps,new Comparator<int[]>(){
			public int compare(int[] A,int[] B){
				return A[1]-B[1];
			}
		});
		Deque<Integer> que=new ArrayDeque<>();
		for(int[] p : ps){
			if(!que.isEmpty()&&que.peekFirst()==p[0]){
				que.pollFirst();
			}
			else{
				que.offerFirst(p[0]);
			}
		}
		out.println(que.isEmpty()?"YES":"NO");
	}

	static int dist(int[] x,int R,int C){
		if(x[0]==0){
			return x[1];
		}
		else if(x[1]==C){
			return x[0]+C;
		}
		else if(x[0]==R){
			return C-x[1]+R+C;
		}
		else{
			return 2*(R+C)-x[0];
		}
	}

	public static void main(String[] args) {
		ir = new InputReader(System.in);
		out = new PrintWriter(System.out);
		solve();
		out.flush();
	}

	static class InputReader {

		private InputStream in;
		private byte[] buffer = new byte[1024];
		private int curbuf;
		private int lenbuf;

		public InputReader(InputStream in) {
			this.in = in;
			this.curbuf = this.lenbuf = 0;
		}

		public boolean hasNextByte() {
			if (curbuf >= lenbuf) {
				curbuf = 0;
				try {
					lenbuf = in.read(buffer);
				} catch (IOException e) {
					throw new InputMismatchException();
				}
				if (lenbuf <= 0)
					return false;
			}
			return true;
		}

		private int readByte() {
			if (hasNextByte())
				return buffer[curbuf++];
			else
				return -1;
		}

		private boolean isSpaceChar(int c) {
			return !(c >= 33 && c <= 126);
		}

		private void skip() {
			while (hasNextByte() && isSpaceChar(buffer[curbuf]))
				curbuf++;
		}

		public boolean hasNext() {
			skip();
			return hasNextByte();
		}

		public String next() {
			if (!hasNext())
				throw new NoSuchElementException();
			StringBuilder sb = new StringBuilder();
			int b = readByte();
			while (!isSpaceChar(b)) {
				sb.appendCodePoint(b);
				b = readByte();
			}
			return sb.toString();
		}

		public int nextInt() {
			if (!hasNext())
				throw new NoSuchElementException();
			int c = readByte();
			while (isSpaceChar(c))
				c = readByte();
			boolean minus = false;
			if (c == '-') {
				minus = true;
				c = readByte();
			}
			int res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res = res * 10 + c - '0';
				c = readByte();
			} while (!isSpaceChar(c));
			return (minus) ? -res : res;
		}

		public long nextLong() {
			if (!hasNext())
				throw new NoSuchElementException();
			int c = readByte();
			while (isSpaceChar(c))
				c = readByte();
			boolean minus = false;
			if (c == '-') {
				minus = true;
				c = readByte();
			}
			long res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res = res * 10 + c - '0';
				c = readByte();
			} while (!isSpaceChar(c));
			return (minus) ? -res : res;
		}

		public double nextDouble() {
			return Double.parseDouble(next());
		}

		public int[] nextIntArray(int n) {
			int[] a = new int[n];
			for (int i = 0; i < n; i++)
				a[i] = nextInt();
			return a;
		}

		public long[] nextLongArray(int n) {
			long[] a = new long[n];
			for (int i = 0; i < n; i++)
				a[i] = nextLong();
			return a;
		}

		public char[][] nextCharMap(int n, int m) {
			char[][] map = new char[n][m];
			for (int i = 0; i < n; i++)
				map[i] = next().toCharArray();
			return map;
		}
	}

	static void tr(Object... o) {
		if (debug)
			out.println(Arrays.deepToString(o));
	}
}

</source>
<source file="../hum_codes_raw/s451652701.java" startline="1" endline="207" pcid="15146">
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Deque;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

public class Main {

	static PrintWriter out;
	static InputReader ir;
	static boolean debug = false;

	static void solve() {
		int R=ir.nextInt();
		int C=ir.nextInt();
		int N=ir.nextInt();
		ArrayList<int[]> ps=new ArrayList<>();
		for(int i=0;i<N;i++){
			int[] p=ir.nextIntArray(2);
			int[] q=ir.nextIntArray(2);
			if(!(p[0]==0||p[0]==R||p[1]==0||p[1]==C)){
				continue;
			}
			if(!(q[0]==0||q[0]==R||q[1]==0||q[1]==C)){
				continue;
			}
			ps.add(new int[]{i,dist(p,R,C)});
			ps.add(new int[]{i,dist(q,R,C)});
		}
		Collections.sort(ps,new Comparator<int[]>(){
			public int compare(int[] A,int[] B){
				return A[1]-B[1];
			}
		});
		Deque<Integer> que=new ArrayDeque<>();
		for(int[] p : ps){
			if(!que.isEmpty()&&que.peekFirst()==p[0]){
				que.pollFirst();
			}
			else{
				que.offerFirst(p[0]);
			}
		}
		out.println(que.isEmpty()?"YES":"NO");
	}

	static int dist(int[] x,int R,int C){
		if(x[0]==0){
			return x[1];
		}
		else if(x[1]==C){
			return x[0]+C;
		}
		else if(x[0]==R){
			return C-x[1]+R+C;
		}
		else{
			return 2*(R+C)-x[0];
		}
	}

	public static void main(String[] args) {
		ir = new InputReader(System.in);
		out = new PrintWriter(System.out);
		solve();
		out.flush();
	}

	static class InputReader {

		private InputStream in;
		private byte[] buffer = new byte[1024];
		private int curbuf;
		private int lenbuf;

		public InputReader(InputStream in) {
			this.in = in;
			this.curbuf = this.lenbuf = 0;
		}

		public boolean hasNextByte() {
			if (curbuf >= lenbuf) {
				curbuf = 0;
				try {
					lenbuf = in.read(buffer);
				} catch (IOException e) {
					throw new InputMismatchException();
				}
				if (lenbuf <= 0)
					return false;
			}
			return true;
		}

		private int readByte() {
			if (hasNextByte())
				return buffer[curbuf++];
			else
				return -1;
		}

		private boolean isSpaceChar(int c) {
			return !(c >= 33 && c <= 126);
		}

		private void skip() {
			while (hasNextByte() && isSpaceChar(buffer[curbuf]))
				curbuf++;
		}

		public boolean hasNext() {
			skip();
			return hasNextByte();
		}

		public String next() {
			if (!hasNext())
				throw new NoSuchElementException();
			StringBuilder sb = new StringBuilder();
			int b = readByte();
			while (!isSpaceChar(b)) {
				sb.appendCodePoint(b);
				b = readByte();
			}
			return sb.toString();
		}

		public int nextInt() {
			if (!hasNext())
				throw new NoSuchElementException();
			int c = readByte();
			while (isSpaceChar(c))
				c = readByte();
			boolean minus = false;
			if (c == '-') {
				minus = true;
				c = readByte();
			}
			int res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res = res * 10 + c - '0';
				c = readByte();
			} while (!isSpaceChar(c));
			return (minus) ? -res : res;
		}

		public long nextLong() {
			if (!hasNext())
				throw new NoSuchElementException();
			int c = readByte();
			while (isSpaceChar(c))
				c = readByte();
			boolean minus = false;
			if (c == '-') {
				minus = true;
				c = readByte();
			}
			long res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res = res * 10 + c - '0';
				c = readByte();
			} while (!isSpaceChar(c));
			return (minus) ? -res : res;
		}

		public double nextDouble() {
			return Double.parseDouble(next());
		}

		public int[] nextIntArray(int n) {
			int[] a = new int[n];
			for (int i = 0; i < n; i++)
				a[i] = nextInt();
			return a;
		}

		public long[] nextLongArray(int n) {
			long[] a = new long[n];
			for (int i = 0; i < n; i++)
				a[i] = nextLong();
			return a;
		}

		public char[][] nextCharMap(int n, int m) {
			char[][] map = new char[n][m];
			for (int i = 0; i < n; i++)
				map[i] = next().toCharArray();
			return map;
		}
	}

	static void tr(Object... o) {
		if (debug)
			out.println(Arrays.deepToString(o));
	}
}

</source>
</class>

<class classid="3" nclones="2" nlines="117" similarity="100">
<source file="../hum_codes_raw/s003348081.java" startline="1" endline="143" pcid="109">
import java.io.*;
import java.util.*;

public class Main implements Runnable{
    private boolean[][] graph;
    private int X;
    private int Y;
    public static void main(String[] args) throws Exception {
        new Thread(null, new Main(), "bridge", 16 * 1024 * 1024).start();
    }

    @Override
    public void run() {
        try {
            solve();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void solve() throws Exception{
        FastScanner scanner = new FastScanner(System.in);

        X = scanner.nextInt();
        Y = scanner.nextInt();
        int E = scanner.nextInt();

        if(X == 0 || Y == 0 || E == 0){
            System.out.println("0");
            return;
        }

        graph = new boolean[X][Y];

        for(int i = 0; i < E; ++i){
            int u = scanner.nextInt();
            int v = scanner.nextInt();

            graph[u][v] = true;
        }

        System.out.println(maxBPM());
    }

    private int maxBPM(){
        int[] match = new int[Y];
        Arrays.fill(match, -1);

        int result = 0;
        for(int u = 0; u < X; ++u){
            if(existPath(u, new boolean[Y], match)){
                ++result;
            }
        }

        return result;
    }

    private boolean existPath(int u, boolean[] visited, int[] match){
        for(int v = 0; v < Y; ++v){
            if(graph[u][v] && !visited[v]){
                visited[v] = true;

                if(match[v] < 0 || existPath(match[v], visited, match)){
                    match[v] = u;
                    return true;
                }
            }
        }

        return false;
    }

    static class FastScanner {
        private InputStream in;
        private final byte[] buffer = new byte[1024 * 8];
        private int ptr = 0;
        private int buflen = 0;

        public FastScanner(InputStream in){
            this.in = in;
        }

        private boolean hasNextByte() {
            if (ptr < buflen) {
                return true;
            } else {
                ptr = 0;
                try {
                    buflen = in.read(buffer);
                } catch (IOException e) {
                    e.printStackTrace();
                }
                if (buflen <= 0) {
                    return false;
                }
            }
            return true;
        }

        private int readByte() {
            if (hasNextByte()) return buffer[ptr++];
            else return -1;
        }

        private static boolean isPrintableChar(int c) {
            return 33 <= c && c <= 126;
        }

        private void skipUnprintable() {
            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        }

        public boolean hasNext() {
            skipUnprintable();
            return hasNextByte();
        }

        public String next() {
            if (!hasNext()) throw new NoSuchElementException();
            StringBuilder sb = new StringBuilder();
            int b = readByte();
            while (isPrintableChar(b)) {
                sb.appendCodePoint(b);
                b = readByte();
            }
            return sb.toString();
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }
    }
}

</source>
<source file="../hum_codes_raw/s974382719.java" startline="1" endline="142" pcid="32792">
import java.io.*;
import java.util.*;

public class Main implements Runnable{
    private boolean[][] graph;
    private int X;
    private int Y;
    public static void main(String[] args) throws Exception {
        new Thread(null, new Main(), "bridge", 16 * 1024 * 1024).start();
    }

    @Override
    public void run() {
        try {
            solve();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void solve() throws Exception{
        FastScanner scanner = new FastScanner(System.in);

        X = scanner.nextInt();
        Y = scanner.nextInt();
        int E = scanner.nextInt();

        if(X == 0 || Y == 0 || E == 0){
            System.out.println("0");
            return;
        }

        graph = new boolean[X][Y];

        for(int i = 0; i < E; ++i){
            int u = scanner.nextInt();
            int v = scanner.nextInt();

            graph[u][v] = true;
        }

        System.out.println(maxBPM());
    }

    private int maxBPM(){
        int[] match = new int[Y];
        Arrays.fill(match, -1);

        int result = 0;
        for(int u = 0; u < X; ++u){
            if(existPath(u, new boolean[Y], match)){
                ++result;
            }
        }

        return result;
    }

    private boolean existPath(int u, boolean[] visited, int[] match){
        for(int v = 0; v < Y; ++v){
            if(graph[u][v] && !visited[v]){
                visited[v] = true;
                if(match[v] < 0 || existPath(match[v], visited, match)){
                    match[v] = u;
                    return true;
                }
            }
        }

        return false;
    }

    static class FastScanner {
        private InputStream in;
        private final byte[] buffer = new byte[1024 * 8];
        private int ptr = 0;
        private int buflen = 0;

        public FastScanner(InputStream in){
            this.in = in;
        }

        private boolean hasNextByte() {
            if (ptr < buflen) {
                return true;
            } else {
                ptr = 0;
                try {
                    buflen = in.read(buffer);
                } catch (IOException e) {
                    e.printStackTrace();
                }
                if (buflen <= 0) {
                    return false;
                }
            }
            return true;
        }

        private int readByte() {
            if (hasNextByte()) return buffer[ptr++];
            else return -1;
        }

        private static boolean isPrintableChar(int c) {
            return 33 <= c && c <= 126;
        }

        private void skipUnprintable() {
            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        }

        public boolean hasNext() {
            skipUnprintable();
            return hasNextByte();
        }

        public String next() {
            if (!hasNext()) throw new NoSuchElementException();
            StringBuilder sb = new StringBuilder();
            int b = readByte();
            while (isPrintableChar(b)) {
                sb.appendCodePoint(b);
                b = readByte();
            }
            return sb.toString();
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }
    }
}

</source>
</class>

<class classid="4" nclones="2" nlines="128" similarity="100">
<source file="../hum_codes_raw/s004280554.java" startline="1" endline="161" pcid="142">
import java.io.*;
import java.util.*;

public class Main {
	static PrintWriter out;
	static StringBuilder sb;
	static int n, m, k;
	static long mod = 998244353;
	static Boolean[][] memo;
	static String s;
	static ArrayList<Integer>[] ad;
	static long inf = Long.MAX_VALUE;
	static int[] color;
	static ArrayList<Integer> o;
	static char[][] g;
	static boolean[] vis, vis1;
	static long[] f;
	static long[] a, dest;

	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(System.in);
		out = new PrintWriter(System.out);
		int k = sc.nextInt();
		int n = sc.nextInt();
		f = new long[4001];
		f[0] = 1;
		long[][] tab = new long[4001][4001];
		// for (int i = 1; i < 4001; i++)
		// f[i] = i * f[i - 1] % mod;
		tab[0][0] = 1;
		for (int i = 1; i < 4001; i++) {
			tab[i][0] = 1;
			for (int j = 1; j <= i; j++) {
				tab[i][j] = (tab[i - 1][j] + tab[i - 1][j - 1]) % mod;
			}
		}
		for (int i = 2; i <= 2 * k; i++) {
			long ans = 0;
			int und = i / 2;
			int up = k - (i - i / 2) + 1;
			int av = Math.min(up, und);
			for (int j = 0; j <= av; j++) {
				// System.out.println(i+" "+j+" "+av);
				if (n - j * 2 < 0)
					continue;
				long v = tab[av][j] * tab[n - j * 2 + k - 1][n - j * 2]% mod;
				if (j % 2 == 0) {
					ans = (ans + v) % mod;
				} else {
					ans = (ans - v + mod) % mod;
				}
			}
			out.println(ans);
		}
		out.flush();
	}

	static long nCk(int n, int k) {
		long ll = f[n] * modPow(f[n - k], mod - 2) % mod;
		ll = ll * modPow(f[k], mod - 2) % mod;
		return ll;
	}

	static long modPow(long a, long e)

	{
		long res = 1;
		while (e > 0) {
			if ((e & 1) == 1)
				res = (res * a) % mod;
			a = (a * a) % mod;
			e >>= 1;
		}
		return res;
	}

	static class pair implements Comparable<pair> {
		long x;
		int y, lv;

		pair(long x, int y, int l) {
			this.x = x;
			this.y = y;
			lv = l;
		}

		public String toString() {
			return x + " " + y + " " + lv;
		}

		@Override
		public int compareTo(pair o) {
			if (x == o.x)
				return y - o.y;
			return Long.compare(o.x, x);
		}

	}

	static class Scanner {
		StringTokenizer st;
		BufferedReader br;

		public Scanner(InputStream system) {
			br = new BufferedReader(new InputStreamReader(system));
		}

		public Scanner(String file) throws Exception {
			br = new BufferedReader(new FileReader(file));
		}

		public String next() throws IOException {
			while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}

		public String nextLine() throws IOException {
			return br.readLine();
		}

		public int nextInt() throws IOException {
			return Integer.parseInt(next());
		}

		public double nextDouble() throws IOException {
			return Double.parseDouble(next());
		}

		public char nextChar() throws IOException {
			return next().charAt(0);
		}

		public Long nextLong() throws IOException {
			return Long.parseLong(next());
		}

		public int[] nextArrInt(int n) throws IOException {
			int[] a = new int[n];
			for (int i = 0; i < n; i++)
				a[i] = nextInt();
			return a;
		}

		public long[] nextArrLong(int n) throws IOException {
			long[] a = new long[n];
			for (int i = 0; i < n; i++)
				a[i] = nextLong();
			return a;
		}

		public boolean ready() throws IOException {
			return br.ready();
		}

		public void waitForInput() throws InterruptedException {
			Thread.sleep(3000);
		}
	}
}

</source>
<source file="../hum_codes_raw/s154876882.java" startline="1" endline="161" pcid="5197">
import java.io.*;
import java.util.*;

public class Main {
	static PrintWriter out;
	static StringBuilder sb;
	static int n, m, k;
	static long mod = 998244353;
	static Boolean[][] memo;
	static String s;
	static ArrayList<Integer>[] ad;
	static long inf = Long.MAX_VALUE;
	static int[] color;
	static ArrayList<Integer> o;
	static char[][] g;
	static boolean[] vis, vis1;
	static long[] f;
	static long[] a, dest;

	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(System.in);
		out = new PrintWriter(System.out);
		int k = sc.nextInt();
		int n = sc.nextInt();
		f = new long[4001];
		f[0] = 1;
		long[][] tab = new long[4001][4001];
		// for (int i = 1; i < 4001; i++)
		// f[i] = i * f[i - 1] % mod;
		tab[0][0] = 1;
		for (int i = 1; i < 4001; i++) {
			tab[i][0] = 1;
			for (int j = 1; j <= i; j++) {
				tab[i][j] = (tab[i - 1][j] + tab[i - 1][j - 1]) % mod;
			}
		}
		for (int i = 2; i <= 2 * k; i++) {
			long ans = 0;
			int und = i / 2;
			int up = k - (i - i / 2) + 1;
			int av = Math.min(up, und);
			for (int j = 0; j <= av; j++) {
				// System.out.println(i+" "+j+" "+av);
				if (n - j * 2 < 0)
					continue;
				long v = tab[av][j] * tab[n - j * 2 + k - 1][n - j * 2]% mod;
				if (j % 2 == 0) {
					ans = (ans + v) % mod;
				} else {
					ans = (ans - v + mod) % mod;
				}
			}
			out.println(ans);
		}
		out.flush();
	}

	static long nCk(int n, int k) {
		long ll = f[n] * modPow(f[n - k], mod - 2) % mod;
		ll = ll * modPow(f[k], mod - 2) % mod;
		return ll;
	}

	static long modPow(long a, long e)

	{
		long res = 1;
		while (e > 0) {
			if ((e & 1) == 1)
				res = (res * a) % mod;
			a = (a * a) % mod;
			e >>= 1;
		}
		return res;
	}

	static class pair implements Comparable<pair> {
		long x;
		int y, lv;

		pair(long x, int y, int l) {
			this.x = x;
			this.y = y;
			lv = l;
		}

		public String toString() {
			return x + " " + y + " " + lv;
		}

		@Override
		public int compareTo(pair o) {
			if (x == o.x)
				return y - o.y;
			return Long.compare(o.x, x);
		}

	}

	static class Scanner {
		StringTokenizer st;
		BufferedReader br;

		public Scanner(InputStream system) {
			br = new BufferedReader(new InputStreamReader(system));
		}

		public Scanner(String file) throws Exception {
			br = new BufferedReader(new FileReader(file));
		}

		public String next() throws IOException {
			while (st == null || !st.hasMoreTokens())
				st = new StringTokenizer(br.readLine());
			return st.nextToken();
		}

		public String nextLine() throws IOException {
			return br.readLine();
		}

		public int nextInt() throws IOException {
			return Integer.parseInt(next());
		}

		public double nextDouble() throws IOException {
			return Double.parseDouble(next());
		}

		public char nextChar() throws IOException {
			return next().charAt(0);
		}

		public Long nextLong() throws IOException {
			return Long.parseLong(next());
		}

		public int[] nextArrInt(int n) throws IOException {
			int[] a = new int[n];
			for (int i = 0; i < n; i++)
				a[i] = nextInt();
			return a;
		}

		public long[] nextArrLong(int n) throws IOException {
			long[] a = new long[n];
			for (int i = 0; i < n; i++)
				a[i] = nextLong();
			return a;
		}

		public boolean ready() throws IOException {
			return br.ready();
		}

		public void waitForInput() throws InterruptedException {
			Thread.sleep(3000);
		}
	}
}

</source>
</class>

<class classid="5" nclones="2" nlines="208" similarity="100">
<source file="../hum_codes_raw/s004280841.java" startline="1" endline="252" pcid="143">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            CNuskeVsPhantomThnook solver = new CNuskeVsPhantomThnook();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class CNuskeVsPhantomThnook {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            int m = in.readInt();
            int q = in.readInt();
            //even for vertex, odd for edge
            int[][] mat = new int[n + 1][m + 1];
            //edge with top
            int[][] colEdge = new int[n + 1][m + 1];
            //edge with right
            int[][] rowEdge = new int[n + 1][m + 1];
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    mat[i][j] = in.readChar() - '0';
                }
            }

            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if (mat[i][j] + mat[i + 1][j] == 2) {
                        colEdge[i][j] = 1;
                    }
                    if (mat[i][j] + mat[i][j + 1] == 2) {
                        rowEdge[i][j] = 1;
                    }
                }
            }

            presum(mat);
            presum(colEdge);
            presum(rowEdge);

            for (int i = 0; i < q; i++) {
                int b = in.readInt() - 1;
                int l = in.readInt() - 1;
                int t = in.readInt() - 1;
                int r = in.readInt() - 1;

                int vertexCnt = region(mat, b, t, l, r);
                int edge = region(colEdge, b, t - 1, l, r) +
                        region(rowEdge, b, t, l, r - 1);

                int cc = vertexCnt - edge;
                out.println(cc);
            }
        }

        public int region(int[][] mat, int b, int t, int l, int r) {
            if (b > t || l > r) {
                return 0;
            }

            int ans = mat[t][r];
            if (b > 0) {
                ans -= mat[b - 1][r];
            }
            if (l > 0) {
                ans -= mat[t][l - 1];
            }
            if (b > 0 && l > 0) {
                ans += mat[b - 1][l - 1];
            }
            return ans;
        }

        public void presum(int[][] mat) {
            int n = mat.length;
            int m = mat[0].length;
            for (int i = 0; i < n; i++) {
                for (int j = 1; j < m; j++) {
                    mat[i][j] += mat[i][j - 1];
                }
                if (i > 0) {
                    for (int j = 0; j < m; j++) {
                        mat[i][j] += mat[i - 1][j];
                    }
                }
            }
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

        public char readChar() {
            skipBlank();
            char c = (char) next;
            next = read();
            return c;
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }
}


</source>
<source file="../hum_codes_raw/s940481462.java" startline="1" endline="252" pcid="31621">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            CNuskeVsPhantomThnook solver = new CNuskeVsPhantomThnook();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class CNuskeVsPhantomThnook {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            int m = in.readInt();
            int q = in.readInt();
            //even for vertex, odd for edge
            int[][] mat = new int[n + 1][m + 1];
            //edge with top
            int[][] colEdge = new int[n + 1][m + 1];
            //edge with right
            int[][] rowEdge = new int[n + 1][m + 1];
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    mat[i][j] = in.readChar() - '0';
                }
            }

            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if (mat[i][j] + mat[i + 1][j] == 2) {
                        colEdge[i][j] = 1;
                    }
                    if (mat[i][j] + mat[i][j + 1] == 2) {
                        rowEdge[i][j] = 1;
                    }
                }
            }

            presum(mat);
            presum(colEdge);
            presum(rowEdge);

            for (int i = 0; i < q; i++) {
                int b = in.readInt() - 1;
                int l = in.readInt() - 1;
                int t = in.readInt() - 1;
                int r = in.readInt() - 1;

                int vertexCnt = region(mat, b, t, l, r);
                int edge = region(colEdge, b, t - 1, l, r) +
                        region(rowEdge, b, t, l, r - 1);

                int cc = vertexCnt - edge;
                out.println(cc);
            }
        }

        public int region(int[][] mat, int b, int t, int l, int r) {
            if (b > t || l > r) {
                return 0;
            }

            int ans = mat[t][r];
            if (b > 0) {
                ans -= mat[b - 1][r];
            }
            if (l > 0) {
                ans -= mat[t][l - 1];
            }
            if (b > 0 && l > 0) {
                ans += mat[b - 1][l - 1];
            }
            return ans;
        }

        public void presum(int[][] mat) {
            int n = mat.length;
            int m = mat[0].length;
            for (int i = 0; i < n; i++) {
                for (int j = 1; j < m; j++) {
                    mat[i][j] += mat[i][j - 1];
                }
                if (i > 0) {
                    for (int j = 0; j < m; j++) {
                        mat[i][j] += mat[i - 1][j];
                    }
                }
            }
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

        public char readChar() {
            skipBlank();
            char c = (char) next;
            next = read();
            return c;
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }
}


</source>
</class>

<class classid="6" nclones="2" nlines="16" similarity="100">
<source file="../hum_codes_raw/s004448131.java" startline="1" endline="17" pcid="148">
import java.util.*;
 
public class Main {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        Stack<Integer> stack = new Stack<Integer>();
        while(sc.hasNextInt()){
            int a=sc.nextInt();
            if(a==0){
                System.out.println(stack.pop());
            }else{
                stack.push(a);
            }
        }
    }
}

</source>
<source file="../hum_codes_raw/s302006164.java" startline="1" endline="17" pcid="10174">
import java.util.*;
 
public class Main {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        Stack<Integer> stack = new Stack<Integer>();
        while(sc.hasNextInt()){
            int a=sc.nextInt();
            if(a==0){
                System.out.println(stack.pop());
            }else{
                stack.push(a);
            }
        }
    }
}

</source>
</class>

<class classid="7" nclones="2" nlines="15" similarity="100">
<source file="../hum_codes_raw/s006695439.java" startline="1" endline="18" pcid="220">
import java.util.Scanner;

public class Main {
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		int score[] = new int[5];
		int average = 0;
		for(int i=0;i<5;i++){
			score[i] = sc.nextInt();
			if(score[i]<40) score[i] = 40;
			average += score[i];
		}
		average /= 5;
		System.out.println(average);
	}

}

</source>
<source file="../hum_codes_raw/s697108891.java" startline="1" endline="18" pcid="23447">
import java.util.Scanner;

public class Main {
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		int score[] = new int[5];
		int average = 0;
		for(int i=0;i<5;i++){
			score[i] = sc.nextInt();
			if(score[i]<40) score[i] = 40;
			average += score[i];
		}
		average /= 5;
		System.out.println(average);
	}

}

</source>
</class>

<class classid="8" nclones="2" nlines="171" similarity="100">
<source file="../hum_codes_raw/s007084036.java" startline="1" endline="199" pcid="236">
import java.util.*;
class Main {
  public static void main(String args[]){
    new Main().run();
  }

  int idx;
  String s;

  Scanner sc = new Scanner(System.in);
  void run(){
    while(true){
      s = sc.nextLine();
      if(s.equals("#"))break;
      idx=0;
      Expr e = equation();
      boolean ans = true;
      for(int i = 0 ; i < 1 << 11; i++){
        Map<Character,Boolean> env = new HashMap<Character, Boolean>();
        for(int j = 0 ; j < 11; j++){
          env.put((char)('a' + j), ((i >> j) & 1) == 1);
        }
        ans = ans && e.eval(env);
      }
      System.out.println(ans ? "YES" : "NO");
    }
  }

  Expr equation(){
    Expr e1 = formula();
    idx++;
    Expr e2 = formula();
    return new Eq(e1,e2);
  }

  Expr formula(){
    char c;
    switch(c = s.charAt(idx++)){
      case 'T': 
        return new True();
      case 'F':
        return new False();
      case '-': 
        return new Not(formula());
      case '(':
        Expr e1 = formula();
        Expr e3 = null;
        if(s.charAt(idx) == '*'){
          idx++;
          Expr e2 = formula();
          e3= new And(e1,e2);
        }else if(s.charAt(idx)=='+'){
          idx++;
          Expr e2 = formula();
          e3= new Or(e1,e2);
        } else{
          idx++;
          idx++;
          Expr e2 = formula();
          e3 = new Imp(e1,e2);
        }
        idx++;
        return e3;
      default:
        return new Var(c);
    }
  }
}

abstract class Expr {
  abstract boolean eval(Map<Character, Boolean> env);
}

class Eq extends Expr{
  Expr e1,e2;
  Eq(Expr a, Expr b){
    e1=a;
    e2=b;
  }

  public boolean eval(Map<Character, Boolean> env){
    return e1.eval(env) == e2.eval(env);
  }

  public String toString(){
    return e1 + "=" + e2;
  }
}

class Not extends Expr{
  Expr e;
  Not(Expr expr){
    this.e = expr;
  }

  public boolean eval(Map<Character, Boolean> env){
    return !(e.eval(env));
  }

  public String toString(){
    return "-" + e;
  }
}

class False extends Expr {
  False(){
  }

  public boolean eval(Map<Character, Boolean> env){
    return false;
  }

  public String toString(){
    return "F";
  }
}

class True extends Expr {
  True(){
  }

  public boolean eval(Map<Character, Boolean> env){
    return true;
  }

  public String toString(){
    return "T";
  }
}

class And extends Expr {
  Expr e1;
  Expr e2;
  And(Expr a, Expr b){
    e1 = a;
    e2 = b;
  }

  public boolean eval(Map<Character, Boolean> env){
    return e1.eval(env) && e2.eval(env);
  }

  public String toString(){
    return "(" + e1 + "*" + e2 +")";
  }
}

class Or extends Expr {
  Expr e1;
  Expr e2;
  Or(Expr a, Expr b){
    e1 = a;
    e2 = b;
  }

  public boolean eval(Map<Character, Boolean> env){
    return e1.eval(env) || e2.eval(env);
  }

  public String toString(){
    return "(" + e1 + "+" + e2 +")";
  }
}

class Imp extends Expr {
  Expr e1;
  Expr e2;
  Imp(Expr a, Expr b){
    e1 = a;
    e2 = b;
  }
  public boolean eval(Map<Character, Boolean> env){
    return !(e1.eval(env)) || e2.eval(env);
  }

  public String toString(){
    return "(" + e1 + "->" + e2 +")";
  }
}

class Var extends Expr {
  public char name;
  Var(char c){
    name =c;
  }

  public boolean equals (Var v){
    return name == v.name;
  }

  public boolean eval(Map<Character, Boolean> env){
    return env.get(name);
  }

  public String toString(){
    return name+"";
  }
}

</source>
<source file="../hum_codes_raw/s499329413.java" startline="1" endline="199" pcid="16743">
import java.util.*;
class Main {
  public static void main(String args[]){
    new Main().run();
  }
 
  int idx;
  String s;
 
  Scanner sc = new Scanner(System.in);
  void run(){
    while(true){
      s = sc.nextLine();
      if(s.equals("#"))break;
      idx=0;
      Expr e = equation();
      boolean ans = true;
      for(int i = 0 ; i < 1 << 11; i++){
        Map<Character,Boolean> env = new HashMap<Character, Boolean>();
        for(int j = 0 ; j < 11; j++){
          env.put((char)('a' + j), ((i >> j) & 1) == 1);
        }
        ans = ans && e.eval(env);
      }
      System.out.println(ans ? "YES" : "NO");
    }
  }
 
  Expr equation(){
    Expr e1 = formula();
    idx++;
    Expr e2 = formula();
    return new Eq(e1,e2);
  }
 
  Expr formula(){
    char c;
    switch(c = s.charAt(idx++)){
      case 'T': 
        return new True();
      case 'F':
        return new False();
      case '-': 
        return new Not(formula());
      case '(':
        Expr e1 = formula();
        Expr e3 = null;
        if(s.charAt(idx) == '*'){
          idx++;
          Expr e2 = formula();
          e3= new And(e1,e2);
        }else if(s.charAt(idx)=='+'){
          idx++;
          Expr e2 = formula();
          e3= new Or(e1,e2);
        } else{
          idx++;
          idx++;
          Expr e2 = formula();
          e3 = new Imp(e1,e2);
        }
        idx++;
        return e3;
      default:
        return new Var(c);
    }
  }
}
 
abstract class Expr {
  abstract boolean eval(Map<Character, Boolean> env);
}
 
class Eq extends Expr{
  Expr e1,e2;
  Eq(Expr a, Expr b){
    e1=a;
    e2=b;
  }
 
  public boolean eval(Map<Character, Boolean> env){
    return e1.eval(env) == e2.eval(env);
  }
 
  public String toString(){
    return e1 + "=" + e2;
  }
}
 
class Not extends Expr{
  Expr e;
  Not(Expr expr){
    this.e = expr;
  }
 
  public boolean eval(Map<Character, Boolean> env){
    return !(e.eval(env));
  }
 
  public String toString(){
    return "-" + e;
  }
}
 
class False extends Expr {
  False(){
  }
 
  public boolean eval(Map<Character, Boolean> env){
    return false;
  }
 
  public String toString(){
    return "F";
  }
}
 
class True extends Expr {
  True(){
  }
 
  public boolean eval(Map<Character, Boolean> env){
    return true;
  }
 
  public String toString(){
    return "T";
  }
}
 
class And extends Expr {
  Expr e1;
  Expr e2;
  And(Expr a, Expr b){
    e1 = a;
    e2 = b;
  }
 
  public boolean eval(Map<Character, Boolean> env){
    return e1.eval(env) && e2.eval(env);
  }
 
  public String toString(){
    return "(" + e1 + "*" + e2 +")";
  }
}
 
class Or extends Expr {
  Expr e1;
  Expr e2;
  Or(Expr a, Expr b){
    e1 = a;
    e2 = b;
  }
 
  public boolean eval(Map<Character, Boolean> env){
    return e1.eval(env) || e2.eval(env);
  }
 
  public String toString(){
    return "(" + e1 + "+" + e2 +")";
  }
}
 
class Imp extends Expr {
  Expr e1;
  Expr e2;
  Imp(Expr a, Expr b){
    e1 = a;
    e2 = b;
  }
  public boolean eval(Map<Character, Boolean> env){
    return !(e1.eval(env)) || e2.eval(env);
  }
 
  public String toString(){
    return "(" + e1 + "->" + e2 +")";
  }
}
 
class Var extends Expr {
  public char name;
  Var(char c){
    name =c;
  }
 
  public boolean equals (Var v){
    return name == v.name;
  }
 
  public boolean eval(Map<Character, Boolean> env){
    return env.get(name);
  }
 
  public String toString(){
    return name+"";
  }
}

</source>
</class>

<class classid="9" nclones="2" nlines="41" similarity="100">
<source file="../hum_codes_raw/s007673167.java" startline="1" endline="45" pcid="255">
import java.util.Scanner;

//Rectangular Searching
public class Main{

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int h = sc.nextInt();
			int w = sc.nextInt();
			if((h|w)==0)break;
			char[][] m = new char[h][w];
			for(int i=0;i<h;i++)m[i]=sc.next().toCharArray();
			int[][] c = new int[h][w];
			for(int i=0;i<h;i++){
				int x = 1;
				for(int j=w-1;j>=0;j--){
					if(m[i][j]=='.'){
						c[i][j] = x++;
					}
					else{
						c[i][j] = 0;
						x = 1;
					}
				}
			}
			int max = 0;
			for(int i=0;i<h;i++){
				for(int j=0;j<w;j++){
					if(0<i&&c[i][j]==c[i-1][j]||c[i][j]==0)continue;
					int k = 1;
					int min = c[i][j];
					max = Math.max(max, k*min);
					while(i+k<h&&c[i+k][j]>0){
						min = Math.min(min, c[i+k][j]);
						k++;
						max = Math.max(max, k*min);
					}
				}
			}
			System.out.println(max);
		}
	}
}

</source>
<source file="../hum_codes_raw/s742875524.java" startline="1" endline="45" pcid="24961">
import java.util.Scanner;

//Rectangular Searching
public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int h = sc.nextInt();
			int w = sc.nextInt();
			if((h|w)==0)break;
			char[][] m = new char[h][w];
			for(int i=0;i<h;i++)m[i]=sc.next().toCharArray();
			int[][] c = new int[h][w];
			for(int i=0;i<h;i++){
				int x = 1;
				for(int j=w-1;j>=0;j--){
					if(m[i][j]=='.'){
						c[i][j] = x++;
					}
					else{
						c[i][j] = 0;
						x = 1;
					}
				}
			}
			int max = 0;
			for(int i=0;i<h;i++){
				for(int j=0;j<w;j++){
					if(0<i&&c[i][j]==c[i-1][j]||c[i][j]==0)continue;
					int k = 1;
					int min = c[i][j];
					max = Math.max(max, k*min);
					while(i+k<h&&c[i+k][j]>0){
						min = Math.min(min, c[i+k][j]);
						k++;
						max = Math.max(max, k*min);
					}
				}
			}
			System.out.println(max);
		}
	}
}

</source>
</class>

<class classid="10" nclones="2" nlines="45" similarity="100">
<source file="../hum_codes_raw/s008973744.java" startline="1" endline="56" pcid="296">
import java.util.*;

import javax.xml.crypto.Data;

import java.math.*;

public class Main {
	
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int[] listA = new int[n];
		for(int i = 0; i < n; i++) {
			listA[i] = sc.nextInt() * 3600 + sc.nextInt() * 60;
		}
		int m = sc.nextInt();
		int[] listB = new int[m];
		for(int i = 0; i < m; i++) {
			listB[i] = sc.nextInt() * 3600 + sc.nextInt() * 60;
		}
		int[] list = new int[n + m];
		for(int i = 0; i < n; i++) {
			list[i] = listA[i];
		}
		for(int i = 0; i < m; i++) {
			list[i + n] = listB[i];
		}
		
		Arrays.sort(list);
		int pre = list[0];
		show(pre);
		for(int i = 1; i < n+m; i++) {
			if(list[i] == pre) continue;
			System.out.print(" ");
			show(list[i]);
			pre = list[i];
		}
		System.out.println();
		
	}
	
	static void show(int a) {
		int h = a / 3600;
		System.out.print(h + ":");
		
		a -= h * 3600;
		a /= 60;
		if(a < 10) {
			System.out.print("0");
		}
		System.out.print(a);
	}
	
}

</source>
<source file="../hum_codes_raw/s953865763.java" startline="1" endline="56" pcid="32055">
import java.util.*;
 
import javax.xml.crypto.Data;
 
import java.math.*;
 
public class Main {
     
     
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] listA = new int[n];
        for(int i = 0; i < n; i++) {
            listA[i] = sc.nextInt() * 3600 + sc.nextInt() * 60;
        }
        int m = sc.nextInt();
        int[] listB = new int[m];
        for(int i = 0; i < m; i++) {
            listB[i] = sc.nextInt() * 3600 + sc.nextInt() * 60;
        }
        int[] list = new int[n + m];
        for(int i = 0; i < n; i++) {
            list[i] = listA[i];
        }
        for(int i = 0; i < m; i++) {
            list[i + n] = listB[i];
        }
         
        Arrays.sort(list);
        int pre = list[0];
        show(pre);
        for(int i = 1; i < n+m; i++) {
            if(list[i] == pre) continue;
            System.out.print(" ");
            show(list[i]);
            pre = list[i];
        }
        System.out.println();
         
    }
     
    static void show(int a) {
        int h = a / 3600;
        System.out.print(h + ":");
         
        a -= h * 3600;
        a /= 60;
        if(a < 10) {
            System.out.print("0");
        }
        System.out.print(a);
    }
     
}

</source>
</class>

<class classid="11" nclones="2" nlines="22" similarity="100">
<source file="../hum_codes_raw/s009927387.java" startline="1" endline="26" pcid="326">
import java.util.Scanner;

//Delivery Fee
public class Main{

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int[] s = {60,80,100,120,140,160};
		int[] w = {2,5,10,15,20,25};
		int[] p = {600,800,1000,1200,1400,1600,0};
		while(true){
			int n = sc.nextInt();
			if(n==0)break;
			int t = 0;
			for(int i=0;i<n;i++){
				int size = sc.nextInt()+sc.nextInt()+sc.nextInt();
				int we = sc.nextInt();
				int k = 0;
				while(k<6 && !(size<=s[k]&&we<=w[k]))k++;
				t+=p[k];
			}
			System.out.println(t);
		}
	}
}

</source>
<source file="../hum_codes_raw/s330442435.java" startline="1" endline="25" pcid="11060">
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int[] s = {60,80,100,120,140,160};
		int[] w = {2,5,10,15,20,25};
		int[] p = {600,800,1000,1200,1400,1600,0};
		while(true){
			int n = sc.nextInt();
			if(n==0)break;
			int t = 0;
			for(int i=0;i<n;i++){
				int size = sc.nextInt()+sc.nextInt()+sc.nextInt();
				int we = sc.nextInt();
				int k = 0;
				while(k<6 && !(size<=s[k]&&we<=w[k]))k++;
				t+=p[k];
			}
			System.out.println(t);
		}
	}
}

</source>
</class>

<class classid="12" nclones="2" nlines="16" similarity="100">
<source file="../hum_codes_raw/s010329415.java" startline="1" endline="14" pcid="343">
//Volume5-0543
import java.util.Scanner;
public class Main {
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		while(true){
			int sum = sc.nextInt();
			if(sum==0){break;}
			for(int i=0;i<9;i++){sum -= sc.nextInt();}
			System.out.println(sum);
		}
	}
}

</source>
<source file="../hum_codes_raw/s345660098.java" startline="1" endline="25" pcid="11608">
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		while(true){
			int sum = sc.nextInt();
			
			if(sum == 0){
				break;
			}
			
			for(int i = 0; i < 9; i++){
				sum -= sc.nextInt();
			}
			
			System.out.println(sum);
		}
		
	}

}

</source>
</class>

<class classid="13" nclones="2" nlines="140" similarity="100">
<source file="../hum_codes_raw/s012414151.java" startline="1" endline="151" pcid="424">
import java.io.*;
import java.util.*;
import java.util.Map.Entry;
import java.util.stream.Collectors;

@SuppressWarnings("unused")
public class Main {
	String fileName = "input.txt";
	final boolean isDebug = false;
	//final boolean isDebug = true;
	FastScanner in = new FastScanner(System.in);
	PrintWriter out = new PrintWriter(System.out);
	final int MOD = (int)1e9+7;
	final long INF = Long.MAX_VALUE / 2;
	//final int INF = Integer.MAX_VALUE / 2;
	
	void solve() throws Exception{
		int N = in.nextInt(), K = in.nextInt();
		
		if(K == 0){
			System.out.println((long)N*N);
		}else{
			long ans = 0;
			for(int b = K + 1; b <= N; b++){
				long num = N / b;
				int q = N % b;
				ans += num * (b - K);
				if(q >= K) ans += (q - K + 1);
			}
			System.out.println(ans);
		}
	}
	
	/* end solve */
	
	/* main */
	public static void main(String[] args) throws Exception {
		new Main().m();
	}
	
	void m() throws Exception {
		if(isDebug) in = new FastScanner(new FileInputStream(fileName));
		solve();
		out.flush();
	}
	/* end main */
}
/* end Main */

class FastScanner {
	Reader input;

	FastScanner() {this(System.in);}
	FastScanner(InputStream stream) {this.input = new BufferedReader(new InputStreamReader(stream));}
	
	int nextInt() {return (int) nextLong();}

	long nextLong() {
		try {
			int sign = 1;
			int b = input.read();
			while ((b < '0' || '9' < b) && b != '-' && b != '+') {
				b = input.read();
			}
			if (b == '-') {
				sign = -1;
				b = input.read();
			} else if (b == '+') {
				b = input.read();
			}
			long ret = b - '0';
			while (true) {
				b = input.read();
				if (b < '0' || '9' < b) return ret * sign;
				ret *= 10;
				ret += b - '0';
			}
		} catch (IOException e) {
			e.printStackTrace();
			return -1;
		}
	}

	double nextDouble() {
		try {
			double sign = 1;
			int b = input.read();
			while ((b < '0' || '9' < b) && b != '-' && b != '+') {
				b = input.read();
			}
			if (b == '-') {
				sign = -1;
				b = input.read();
			} else if (b == '+') {
				b = input.read();
			}
			double ret = b - '0';
			while (true) {
				b = input.read();
				if (b < '0' || '9' < b) break;
				ret *= 10;
				ret += b - '0';
			}
			if (b != '.') return sign * ret;
			double div = 1;
			b = input.read();
			while ('0' <= b && b <= '9') {
				ret *= 10;
				ret += b - '0';
				div *= 10;
				b = input.read();
			}
			return sign * ret / div;
		} catch (IOException e) {
			e.printStackTrace();
			return Double.NaN;
		}
	}

	char nextChar() {
		try {
			int b = input.read();
			while (Character.isWhitespace(b)) {
				b = input.read();
			}
			return (char) b;
		} catch (IOException e) {
			e.printStackTrace();
			return 0;
		}
	}

	String nextStr() {
		try {
			StringBuilder sb = new StringBuilder();
			int b = input.read();
			while (Character.isWhitespace(b)) {
				b = input.read();
			}
			while (b != -1 && !Character.isWhitespace(b)) {
				sb.append((char) b);
				b = input.read();
			}
			return sb.toString();
		} catch (IOException e) {
			e.printStackTrace();
			return "";
		}
	}
}

</source>
<source file="../hum_codes_raw/s185507055.java" startline="1" endline="151" pcid="6250">
import java.io.*;
import java.util.*;
import java.util.Map.Entry;
import java.util.stream.Collectors;

@SuppressWarnings("unused")
public class Main {
	String fileName = "input.txt";
	final boolean isDebug = false;
	//final boolean isDebug = true;
	FastScanner in = new FastScanner(System.in);
	PrintWriter out = new PrintWriter(System.out);
	final int MOD = (int)1e9+7;
	final long INF = Long.MAX_VALUE / 2;
	//final int INF = Integer.MAX_VALUE / 2;
	
	void solve() throws Exception{
		int N = in.nextInt(), K = in.nextInt();
		
		if(K == 0){
			System.out.println((long)N*N);
		}else{
			long ans = 0;
			for(int b = K + 1; b <= N; b++){
				long num = N / b;
				int q = N % b;
				ans += num * (b - K);
				if(q >= K) ans += (q - K + 1);
			}
			System.out.println(ans);
		}
	}
	
	/* end solve */
	
	/* main */
	public static void main(String[] args) throws Exception {
		new Main().m();
	}
	
	void m() throws Exception {
		if(isDebug) in = new FastScanner(new FileInputStream(fileName));
		solve();
		out.flush();
	}
	/* end main */
}
/* end Main */

class FastScanner {
	Reader input;

	FastScanner() {this(System.in);}
	FastScanner(InputStream stream) {this.input = new BufferedReader(new InputStreamReader(stream));}
	
	int nextInt() {return (int) nextLong();}

	long nextLong() {
		try {
			int sign = 1;
			int b = input.read();
			while ((b < '0' || '9' < b) && b != '-' && b != '+') {
				b = input.read();
			}
			if (b == '-') {
				sign = -1;
				b = input.read();
			} else if (b == '+') {
				b = input.read();
			}
			long ret = b - '0';
			while (true) {
				b = input.read();
				if (b < '0' || '9' < b) return ret * sign;
				ret *= 10;
				ret += b - '0';
			}
		} catch (IOException e) {
			e.printStackTrace();
			return -1;
		}
	}

	double nextDouble() {
		try {
			double sign = 1;
			int b = input.read();
			while ((b < '0' || '9' < b) && b != '-' && b != '+') {
				b = input.read();
			}
			if (b == '-') {
				sign = -1;
				b = input.read();
			} else if (b == '+') {
				b = input.read();
			}
			double ret = b - '0';
			while (true) {
				b = input.read();
				if (b < '0' || '9' < b) break;
				ret *= 10;
				ret += b - '0';
			}
			if (b != '.') return sign * ret;
			double div = 1;
			b = input.read();
			while ('0' <= b && b <= '9') {
				ret *= 10;
				ret += b - '0';
				div *= 10;
				b = input.read();
			}
			return sign * ret / div;
		} catch (IOException e) {
			e.printStackTrace();
			return Double.NaN;
		}
	}

	char nextChar() {
		try {
			int b = input.read();
			while (Character.isWhitespace(b)) {
				b = input.read();
			}
			return (char) b;
		} catch (IOException e) {
			e.printStackTrace();
			return 0;
		}
	}

	String nextStr() {
		try {
			StringBuilder sb = new StringBuilder();
			int b = input.read();
			while (Character.isWhitespace(b)) {
				b = input.read();
			}
			while (b != -1 && !Character.isWhitespace(b)) {
				sb.append((char) b);
				b = input.read();
			}
			return sb.toString();
		} catch (IOException e) {
			e.printStackTrace();
			return "";
		}
	}
}

</source>
</class>

<class classid="14" nclones="2" nlines="39" similarity="100">
<source file="../hum_codes_raw/s018327802.java" startline="1" endline="39" pcid="619">
import java.util.*;
public class Main {
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		int day=sc.nextInt(),n=sc.nextInt();//
		int[] high=new int[day];
		for(int i=0;i<day;i++){
			high[i]=sc.nextInt();
		}
		int[] ht=new int[n];
		int[] lt=new int[n];
		int[] loud=new int[n];
		for(int i=0;i<n;i++){
			lt[i]=sc.nextInt();ht[i]=sc.nextInt();loud[i]=sc.nextInt();
		}//
		
		int[][] dp=new int[day][n];
		for(int i=0;i<day;i++){
			for(int j=0;j<n;j++){
				dp[i][j] = 0;
			}
		}
		int ans=0;
		for(int i=1;i<day;i++){
			for(int j=0;j<n;j++){
				if(lt[j]<=high[i]&&high[i]<=ht[j]);
				else continue;
				for(int k=0;k<n;k++){
					if(lt[k]<=high[i-1]&&high[i-1]<=ht[k]);
					else continue;
					dp[i][j]=Math.max(dp[i][j],Math.abs(loud[j]-loud[k]) + dp[i-1][k]);
					ans=Math.max(ans,dp[i][j]);
				}
			}	
		}	
		System.out.println(ans);
	}
}

</source>
<source file="../hum_codes_raw/s975590468.java" startline="1" endline="39" pcid="32830">
import java.util.*;
public class Main {
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		int day=sc.nextInt(),n=sc.nextInt();//
		int[] high=new int[day];
		for(int i=0;i<day;i++){
			high[i]=sc.nextInt();
		}
		int[] ht=new int[n];
		int[] lt=new int[n];
		int[] loud=new int[n];
		for(int i=0;i<n;i++){
			lt[i]=sc.nextInt();ht[i]=sc.nextInt();loud[i]=sc.nextInt();
		}//
		
		int[][] dp=new int[day][n];
		for(int i=0;i<day;i++){//
			for(int j=0;j<n;j++){
				dp[i][j] = 0;
			}
		}
		int ans=0;
		for(int i=1;i<day;i++){//-1
			for(int j=0;j<n;j++){//i
				if(lt[j]<=high[i]&&high[i]<=ht[j]);//
				else continue;
				for(int k=0;k<n;k++){//i-1
					if(lt[k]<=high[i-1]&&high[i-1]<=ht[k]);//
					else continue;
					dp[i][j]=Math.max(dp[i][j],Math.abs(loud[j]-loud[k])+dp[i-1][k]);//
					ans=Math.max(ans,dp[i][j]);
				}
			}	
		}	
		System.out.println(ans);
	}
}

</source>
</class>

<class classid="15" nclones="2" nlines="112" similarity="100">
<source file="../hum_codes_raw/s018652122.java" startline="1" endline="128" pcid="635">
public class Main {
	MyScanner sc = new MyScanner();
	int N, M, a, b, w;
	int[] parent;
	Node[] node;

	void run() {
		for (;;) {
			N = sc.nextInt(); // 
			M = sc.nextInt(); // 
			if ((N | M) == 0) {
				return;
			}
			parent = new int[N + 1];
			node = new Node[N + 1];
			init();

			for (int i = 0; i < M; i++) {
				String query = sc.next();
				a = sc.nextInt();
				b = sc.nextInt();
				if (query.equals("!")) {
					w = sc.nextInt();
					union(a, b, w);
				} else if (query.equals("?")) {
					System.out.println(same(a, b) ? node[b].weight
							- node[a].weight : "UNKNOWN");
				}
			}
		}
	}

	void init() {
		for (int i = 0; i <= N; i++) {
			parent[i] = i;
			node[i] = new Node(0, 0);
		}
	}

	void union(int x, int y, int w) {
		int rootX = find(x);
		int rootY = find(y);
		if (rootX == rootY) {
			return;
		}
		if (node[rootX].rank < node[rootY].rank) {
			node[rootX].weight = -w - node[x].weight + node[y].weight;
			parent[rootX] = rootY;
		} else {
			node[rootY].weight = w - node[y].weight + node[x].weight;
			parent[rootY] = rootX;

			if (node[rootX].rank == node[rootY].rank) {
				node[rootX].rank++;
			}
		}
	}

	int find(int target) {
		if (parent[target] == target) {
			return target;
		} else {
			int tmp = find(parent[target]);
			node[target].weight += node[parent[target]].weight;
			return parent[target] = tmp;
		}
	}

	boolean same(int x, int y) {
		return find(x) == find(y);
	}

	class Node {
		int weight;
		int rank;

		/**
		 * @param weight
		 * @param rank
		 */
		public Node(int weight, int rank) {
			super();
			this.weight = weight;
			this.rank = rank;
		}
	}

	public static void main(String[] args) {
		new Main().run();
	}

	class MyScanner {
		int nextInt() {
			try {
				int c = System.in.read();
				while (c != '-' && (c < '0' || '9' < c))
					c = System.in.read();
				if (c == '-')
					return -nextInt();
				int res = 0;
				do {
					res *= 10;
					res += c - '0';
					c = System.in.read();
				} while ('0' <= c && c <= '9');
				return res;
			} catch (Exception e) {
				return -1;
			}
		}

		String next() {
			try {
				StringBuilder res = new StringBuilder("");
				int c = System.in.read();
				while (Character.isWhitespace(c))
					c = System.in.read();
				do {
					res.append((char) c);
				} while (!Character.isWhitespace(c = System.in.read()));
				return res.toString();
			} catch (Exception e) {
				return null;
			}
		}
	}
}

</source>
<source file="../hum_codes_raw/s413172553.java" startline="1" endline="128" pcid="13893">
public class Main {
	MyScanner sc = new MyScanner();
	int N, M, a, b, w;
	int[] parent;
	Node[] node;

	void run() {
		for (;;) {
			N = sc.nextInt(); // 
			M = sc.nextInt(); // 
			if ((N | M) == 0) {
				return;
			}
			parent = new int[N + 1];
			node = new Node[N + 1];
			init();

			for (int i = 0; i < M; i++) {
				String query = sc.next();
				a = sc.nextInt();
				b = sc.nextInt();
				if (query.equals("!")) {
					w = sc.nextInt();
					union(a, b, w);
				} else if (query.equals("?")) {
					System.out.println(same(a, b) ? node[b].weight
							- node[a].weight : "UNKNOWN");
				}
			}
		}
	}

	void init() {
		for (int i = 0; i <= N; i++) {
			parent[i] = i;
			node[i] = new Node(0, 0);
		}
	}

	void union(int x, int y, int w) {
		int rootX = find(x);
		int rootY = find(y);
		if (rootX == rootY) {
			return;
		}
		if (node[rootX].rank < node[rootY].rank) {
			node[rootX].weight = -w - node[x].weight + node[y].weight;
			parent[rootX] = rootY;
		} else {
			node[rootY].weight = w - node[y].weight + node[x].weight;
			parent[rootY] = rootX;

			if (node[rootX].rank == node[rootY].rank) {
				node[rootX].rank++;
			}
		}
	}

	int find(int target) {
		if (parent[target] == target) {
			return target;
		} else {
			int tmp = find(parent[target]);
			node[target].weight += node[parent[target]].weight;
			return parent[target] = tmp;
		}
	}

	boolean same(int x, int y) {
		return find(x) == find(y);
	}

	class Node {
		int weight;
		int rank;

		/**
		 * @param weight
		 * @param rank
		 */
		public Node(int weight, int rank) {
			super();
			this.weight = weight;
			this.rank = rank;
		}
	}

	public static void main(String[] args) {
		new Main().run();
	}

	class MyScanner {
		int nextInt() {
			try {
				int c = System.in.read();
				while (c != '-' && (c < '0' || '9' < c))
					c = System.in.read();
				if (c == '-')
					return -nextInt();
				int res = 0;
				do {
					res *= 10;
					res += c - '0';
					c = System.in.read();
				} while ('0' <= c && c <= '9');
				return res;
			} catch (Exception e) {
				return -1;
			}
		}

		String next() {
			try {
				StringBuilder res = new StringBuilder("");
				int c = System.in.read();
				while (Character.isWhitespace(c))
					c = System.in.read();
				do {
					res.append((char) c);
				} while (!Character.isWhitespace(c = System.in.read()));
				return res.toString();
			} catch (Exception e) {
				return null;
			}
		}
	}
}

</source>
</class>

<class classid="16" nclones="2" nlines="16" similarity="100">
<source file="../hum_codes_raw/s020151971.java" startline="1" endline="30" pcid="693">
import java.util.Scanner;

public class Main {

	// ????????????10??????
	public static int LOAN = 100000;

	public static void main(String[] args) {

		// ???????????????
		@SuppressWarnings("resource")
		Scanner sc = new Scanner(System.in);
		int input = sc.nextInt();
		double result = LOAN;

		// ???????????????????
		for (int i = 0; input > i; i++) {

			// ??????????????????
			result = result * 1.05;

			// 1000???????????????????\??????????????????
			result = Math.ceil(result / 1000);
			// ?????????????????????
			result = result * 1000;
		}
		System.out.println((int) result);
	}
}

</source>
<source file="../hum_codes_raw/s111684299.java" startline="1" endline="30" pcid="3720">
import java.util.Scanner;

public class Main{

	// 10
	public static int LOAN = 100000;

	public static void main(String[] args) {

		// 
		@SuppressWarnings("resource")
		Scanner sc = new Scanner(System.in);
		int input = sc.nextInt();
		double result = LOAN;

		// 
		for (int i = 0; input > i; i++) {

			// 
			result = result * 1.05;

			// 1000
			result = Math.ceil(result / 1000);
			// 
			result = result * 1000;
		}
		System.out.println((int) result);
	}
}

</source>
</class>

<class classid="17" nclones="2" nlines="49" similarity="100">
<source file="../hum_codes_raw/s022887755.java" startline="1" endline="48" pcid="780">
import java.io.*;
class Main {
    public static void main(String[] args) {
        try {
                BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
            String str = br.readLine();
            int n = Integer.parseInt(str.split(" ")[0]);
            int k = Integer.parseInt(str.split(" ")[1]);
            int[] nimotu = new int[n];
            int totalWeight = 0;
            for (int i = 0; i < n; i++) {
                nimotu[i] = Integer.parseInt(br.readLine());
                totalWeight += nimotu[i];
            }
            int aver = totalWeight / k;
            int maxweight = aver;
            int tracknum;
            while(maxweight <= totalWeight){
                int weight = 0;
                tracknum = 1;
                boolean flg = true;
                for(int i = 0;i < n && tracknum <= k;) {
                    if(weight + nimotu[i] <= maxweight){
                        weight += nimotu[i];
                        i++;
                    } else if(weight > 0){
                        if(maxweight < weight){
                            maxweight = weight;
                        }
                        weight = 0;
                        tracknum++;
                    } else {
                        flg = false;
                        break;
                    }
                }
                if(tracknum <= k && flg){
                    System.out.println(maxweight);
                    break;
                }
                maxweight++;
            }
        } catch (IOException e) {
            System.out.println("error");
        }
    }
}

</source>
<source file="../hum_codes_raw/s191365573.java" startline="1" endline="66" pcid="6443">
import java.io.*;

class Main {
	public static void main(String[] args) {
		// BufferedReader br = new BufferedReader(new
		// InputStreamReader(System.in));
		try {
		        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
			String str = br.readLine();
			// n:??????????????k:?????????????????
			int n = Integer.parseInt(str.split(" ")[0]);
			int k = Integer.parseInt(str.split(" ")[1]);
			// ??????????????????????????
			int[] nimotu = new int[n];
			// ???????????????????????????????????????????
			int totalWeight = 0;
			// ?????????????????????????????????????????????????
			for (int i = 0; i < n; i++) {
				nimotu[i] = Integer.parseInt(br.readLine());
				totalWeight += nimotu[i];
			}
			// ??????????????????????????
			int aver = totalWeight / k;
			int maxweight = aver;
			int tracknum;
			while(maxweight <= totalWeight){
				//if(limit == 1)break;
				int weight = 0;
				tracknum = 1;
				boolean flg = true;
				// ??????????????????????????????????????????????????????????????
				for(int i = 0;i < n && tracknum <= k;) {
					// ?????????????????????????????????????????
					if(weight + nimotu[i] <= maxweight){
						weight += nimotu[i];
						i++;
					//????????????????????????????????????????????????????????????????????????
					} else if(weight > 0){
						if(maxweight < weight){
							maxweight = weight;
						}
						weight = 0;
						tracknum++;
					//???????????????????????????????????????????????????????????????????
					} else {
						flg = false;
						break;
					}
				}
				/* ???????????
				 * 1.tracknum = k????????????????????????????????????????????????
				 * 2.flg = true?????????????????????????????????????????????????
				*/
				if(tracknum <= k && flg){
					System.out.println(maxweight);
					break;
				}
				// ??????????????????????????????????????????????
				maxweight++;
			}
		} catch (IOException e) {
			System.out.println("error");
		}
	}
}

</source>
</class>

<class classid="18" nclones="2" nlines="143" similarity="100">
<source file="../hum_codes_raw/s023291288.java" startline="1" endline="165" pcid="797">
import java.io.*;
import java.util.*;

public class Main {

    private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));    
	private static StringTokenizer st;

    public static void main ( String [] args ) throws IOException
    {

	int h,w,s;

	while(true){
	
		st = new StringTokenizer(br.readLine());
		h = Integer.parseInt(st.nextToken());
		w = Integer.parseInt(st.nextToken());
		s = Integer.parseInt(st.nextToken());
		if( h == 0 && w == 0 && s == 0)	break;
	    new Main().cal(h,w,s);
	}
	
    }


int min;
int[][] area;
int[][][][] sumArea;
int[][] basicSum;
int[][][][] grouparray;
int[][][][] minDep;

    private void cal(int h, int w, int s) throws IOException 
    {
	int areaSum = 0;
	area = new int[h][w];
	grouparray = new int[h][w][h][w];
	minDep =new int[h][w][h][w];
	for(int i=0; i < h; i++){
		st = new StringTokenizer(br.readLine());
		for(int j=0; j < w; j++){
			area[i][j] = Integer.parseInt(st.nextToken());
			areaSum += area[i][j];
		}
	}
	calBasicSum(h,w);
	calSum(h,w);

	//cal max
	min = areaSum - s;
	int[] out = grouping(0,0,h-1,w-1);

	System.out.println(out[0]+" "+(out[1]-min));

    }


    private int[] grouping(int hs, int ws, int hl, int wl){
	int[] ret = new int[2];
	if( grouparray[hs][ws][hl][wl] != -1 ){
		ret[0] = grouparray[hs][ws][hl][wl];
		ret[1] = minDep[hs][ws][hl][wl];
		return ret;
	}
	grouparray[hs][ws][hl][wl] = 0;
	ret[0] = 1;
	ret[1] = sumArea[hs][ws][hl][wl];
	int[] tmp = new int[2];
	int grptmp;
	int tempDep;

	//&#44032;&#47196;&#47196; &#51900;&#44060;&#44592;
	for(int i = hs; i < hl; i++){
		if(sumArea[hs][ws][i][wl] < min){
			continue;
		}
		if(sumArea[i+1][ws][hl][wl] < min){
			break;
		}
		tmp = grouping(hs, ws, i, wl);
		grptmp = tmp[0];
		tempDep = tmp[1];

		tmp = grouping(i+1, ws, hl, wl);
		grptmp += tmp[0];
		if( tempDep < tmp[1] ){ tmp[1] = tempDep; }

		if( grptmp > ret[0] ){ ret[0] = grptmp; ret[1] = tmp[1]; }
		if( grptmp == ret[0] && tmp[1] > ret[1] ){ ret[1] = tmp[1]; }
	}
	//&#49464;&#47196;&#47196; &#51900;&#44060;&#44592;
	for(int i = ws; i < wl; i++){
		if(sumArea[hs][ws][hl][i] < min){
			continue;
		}
		if(sumArea[hs][i+1][hl][wl] < min){
			break;
		}
		tmp = grouping(hs, ws, hl, i);
		grptmp = tmp[0];
		tempDep = tmp[1];

		tmp = grouping(hs, i+1, hl, wl);
		grptmp += tmp[0];

		if( tempDep < tmp[1] ){ tmp[1] = tempDep; }

		if( grptmp > ret[0] ){ ret[0] = grptmp; ret[1] = tmp[1]; }
		if( grptmp == ret[0] && tmp[1] > ret[1] ){ ret[1] = tmp[1]; }

	}

	grouparray[hs][ws][hl][wl] = ret[0];
	minDep[hs][ws][hl][wl] = ret[1];
	return ret;
	
    }


   private void calBasicSum(int h, int w){
	basicSum = new int[h][w];
	basicSum[0][0] = area[0][0];
	for(int j = 1; j < w; j++){
		basicSum[0][j] = basicSum[0][j-1] + area[0][j];
	}
	for(int i = 1; i < h; i++){
		basicSum[i][0] = basicSum[i-1][0] + area[i][0];
	}
	for(int i = 1; i < h; i++){
		for(int j=1; j < w; j++){
			basicSum[i][j] = basicSum[i][j-1] + basicSum[i-1][j] + area[i][j] - basicSum[i-1][j-1];
		}
	}
   }

   private void calSum(int h, int w ){
	sumArea = new int[h][w][h][w];

	for(int i = 0; i < h; i++){
	for(int j = 0; j < w; j++){
		for(int l = i; l < h; l++){
		for(int k = j; k < w; k++){
			grouparray[i][j][l][k] = -1;
			if( i == 0 && j ==0 ){
				sumArea[0][0][l][k] = basicSum[l][k];
			}
			else if( i == 0 ){
				sumArea[0][j][l][k] = basicSum[l][k] - basicSum[l][j-1];
			}
			else if( j == 0 ){
				sumArea[i][0][l][k] = basicSum[l][k] - basicSum[i-1][k];
			}
			else{
				sumArea[i][j][l][k] = basicSum[l][k] - basicSum[l][j-1] - basicSum[i-1][k] + basicSum[i-1][j-1];
			}
		}
		}
	}
	}
   }


}

</source>
<source file="../hum_codes_raw/s226173606.java" startline="1" endline="163" pcid="7646">
import java.io.*;
import java.util.*;

public class Main {

    private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));    
	private static StringTokenizer st;

    public static void main ( String [] args ) throws IOException
    {

	int h,w,s;

	while(true){
	
		st = new StringTokenizer(br.readLine());
		h = Integer.parseInt(st.nextToken());
		w = Integer.parseInt(st.nextToken());
		s = Integer.parseInt(st.nextToken());
		if( h == 0 && w == 0 && s == 0)	break;
	    new Main().cal(h,w,s);
	}
	
    }


int min;
int[][] area;
int[][][][] sumArea;
int[][] basicSum;
int[][][][] grouparray;
int[][][][] minDep;

    private void cal(int h, int w, int s) throws IOException 
    {
	int areaSum = 0;
	area = new int[h][w];
	grouparray = new int[h][w][h][w];
	minDep =new int[h][w][h][w];
	for(int i=0; i < h; i++){
		st = new StringTokenizer(br.readLine());
		for(int j=0; j < w; j++){
			area[i][j] = Integer.parseInt(st.nextToken());
			areaSum += area[i][j];
		}
	}
	calBasicSum(h,w);
	calSum(h,w);

	//cal max
	min = areaSum - s;
	int[] out = grouping(0,0,h-1,w-1);

	System.out.println(out[0]+" "+(out[1]-min));

    }


    private int[] grouping(int hs, int ws, int hl, int wl){
	int[] ret = new int[2];
	if( grouparray[hs][ws][hl][wl] != -1 ){
		ret[0] = grouparray[hs][ws][hl][wl];
		ret[1] = minDep[hs][ws][hl][wl];
		return ret;
	}
	grouparray[hs][ws][hl][wl] = 0;
	ret[0] = 1;
	ret[1] = sumArea[hs][ws][hl][wl];
	int[] tmp = new int[2];
	int grptmp;
	int tempDep;

	for(int i = hs; i < hl; i++){
		if(sumArea[hs][ws][i][wl] < min){
			continue;
		}
		if(sumArea[i+1][ws][hl][wl] < min){
			break;
		}
		tmp = grouping(hs, ws, i, wl);
		grptmp = tmp[0];
		tempDep = tmp[1];

		tmp = grouping(i+1, ws, hl, wl);
		grptmp += tmp[0];
		if( tempDep < tmp[1] ){ tmp[1] = tempDep; }

		if( grptmp > ret[0] ){ ret[0] = grptmp; ret[1] = tmp[1]; }
		if( grptmp == ret[0] && tmp[1] > ret[1] ){ ret[1] = tmp[1]; }
	}
	for(int i = ws; i < wl; i++){
		if(sumArea[hs][ws][hl][i] < min){
			continue;
		}
		if(sumArea[hs][i+1][hl][wl] < min){
			break;
		}
		tmp = grouping(hs, ws, hl, i);
		grptmp = tmp[0];
		tempDep = tmp[1];

		tmp = grouping(hs, i+1, hl, wl);
		grptmp += tmp[0];

		if( tempDep < tmp[1] ){ tmp[1] = tempDep; }

		if( grptmp > ret[0] ){ ret[0] = grptmp; ret[1] = tmp[1]; }
		if( grptmp == ret[0] && tmp[1] > ret[1] ){ ret[1] = tmp[1]; }

	}

	grouparray[hs][ws][hl][wl] = ret[0];
	minDep[hs][ws][hl][wl] = ret[1];
	return ret;
	
    }


   private void calBasicSum(int h, int w){
	basicSum = new int[h][w];
	basicSum[0][0] = area[0][0];
	for(int j = 1; j < w; j++){
		basicSum[0][j] = basicSum[0][j-1] + area[0][j];
	}
	for(int i = 1; i < h; i++){
		basicSum[i][0] = basicSum[i-1][0] + area[i][0];
	}
	for(int i = 1; i < h; i++){
		for(int j=1; j < w; j++){
			basicSum[i][j] = basicSum[i][j-1] + basicSum[i-1][j] + area[i][j] - basicSum[i-1][j-1];
		}
	}
   }

   private void calSum(int h, int w ){
	sumArea = new int[h][w][h][w];

	for(int i = 0; i < h; i++){
	for(int j = 0; j < w; j++){
		for(int l = i; l < h; l++){
		for(int k = j; k < w; k++){
			grouparray[i][j][l][k] = -1;
			if( i == 0 && j ==0 ){
				sumArea[0][0][l][k] = basicSum[l][k];
			}
			else if( i == 0 ){
				sumArea[0][j][l][k] = basicSum[l][k] - basicSum[l][j-1];
			}
			else if( j == 0 ){
				sumArea[i][0][l][k] = basicSum[l][k] - basicSum[i-1][k];
			}
			else{
				sumArea[i][j][l][k] = basicSum[l][k] - basicSum[l][j-1] - basicSum[i-1][k] + basicSum[i-1][j-1];
			}
		}
		}
	}
	}
   }


}

</source>
</class>

<class classid="19" nclones="2" nlines="111" similarity="100">
<source file="../hum_codes_raw/s027059550.java" startline="1" endline="117" pcid="898">
import java.io.IOException;
import java.io.InputStream;
import java.util.NoSuchElementException;
public class Main {
    public static void main(String[] args) {
       FS fs = new FS();
        int n = fs.nextInt();
        int a[] = new int[n];
        int max= Integer.MIN_VALUE;
        int min =Integer.MAX_VALUE;
        for(int i =0;i<n;i++){
            a[i]=fs.nextInt();
            if (a[i]>max)max=a[i];
            if (a[i]<min)min=a[i];
        }
        int mm = max - min + 1;
        int[] b = new int[mm];
        for(int i=0;i<n;i++){
            b[a[i]-min]++;
        }
        for (int i=1;i<mm;i++){
            b[i]+=b[i-1];
        }
        int[] c = new int[n];
        for (int i=n-1;i>=0;i--){
             c[b[a[i]-min]-1]=a[i];
             b[a[i]-min]--;
        }
        StringBuilder sb= new StringBuilder();
        for(int i=0;i<n;i++){
            sb.append(c[i]+" ");
        }
        sb.deleteCharAt(sb.length()-1);
        System.out.println(sb.toString());
    }
   static class FS {
    private final InputStream in = System.in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        } else {
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }

    private int readByte() {
        return hasNextByte() ? buffer[ptr++] : -1;
    }

    private boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }

    private void skipUnprintable() {
        while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
    }

    public boolean hasNext() {
        skipUnprintable();
        return hasNextByte();
    }

    public String next() {
        if (!hasNext()) throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while (isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }

    public int nextInt() {
        return (int) nextLong();
    }

    public long nextLong() {
        if (!hasNext()) throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                n *= 10;
                n += b - '0';
            } else if (b == -1 || !isPrintableChar(b)) {
                return minus ? -n : n;
            } else {
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
}
}

</source>
<source file="../hum_codes_raw/s132834697.java" startline="1" endline="117" pcid="4430">
import java.io.IOException;
import java.io.InputStream;
import java.util.NoSuchElementException;
public class Main {
    public static void main(String[] args) {
       FS fs = new FS();
        int n = fs.nextInt();
        int a[] = new int[n];
        int max= Integer.MIN_VALUE;
        int min =Integer.MAX_VALUE;
        for(int i =0;i<n;i++){
            a[i]=fs.nextInt();
            if (a[i]>max)max=a[i];
            if (a[i]<min)min=a[i];
        }
        int mm = max - min + 1;
        int[] b = new int[mm];
        for(int i=0;i<n;i++){
            b[a[i]-min]++;
        }
        for (int i=1;i<mm;i++){
            b[i]+=b[i-1];
        }
        int[] c = new int[n];
        for (int i=n-1;i>=0;i--){
             c[b[a[i]-min]-1]=a[i];
             b[a[i]-min]--;
        }
        StringBuilder sb= new StringBuilder();
        for(int i=0;i<n;i++){
            sb.append(c[i]+" ");
        }
        sb.deleteCharAt(sb.length()-1);
        System.out.println(sb.toString());
    }
   static class FS {
    private final InputStream in = System.in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        } else {
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }

    private int readByte() {
        return hasNextByte() ? buffer[ptr++] : -1;
    }

    private boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }

    private void skipUnprintable() {
        while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
    }

    public boolean hasNext() {
        skipUnprintable();
        return hasNextByte();
    }

    public String next() {
        if (!hasNext()) throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while (isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }

    public int nextInt() {
        return (int) nextLong();
    }

    public long nextLong() {
        if (!hasNext()) throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                n *= 10;
                n += b - '0';
            } else if (b == -1 || !isPrintableChar(b)) {
                return minus ? -n : n;
            } else {
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
}
}

</source>
</class>

<class classid="20" nclones="2" nlines="34" similarity="100">
<source file="../hum_codes_raw/s029203789.java" startline="1" endline="37" pcid="968">
import java.util.BitSet;
import java.util.HashMap;
import java.util.Scanner;
 
public class Main{
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        BitSet gdp = gdp(300000);
        while(true){
            int n = in.nextInt();
            if(n == 1) return;
            StringBuilder sb = new StringBuilder();
            sb.append(n+": ");
            for(int i=gdp.nextSetBit(0); i!=-1 && i<=n; i=gdp.nextSetBit(i+1)){
                if(n%i==0) sb.append(i+" ");
            }
            System.out.println(sb.toString().trim());
        }
    }
     
    public static BitSet gdp(int max){
        BitSet gdn = new BitSet(max+1);
        for(int i=1; i<=max; i++){
            int mod = i%7;
            if(mod == 6 || mod == 1) gdn.set(i);
        }
        BitSet gdp = (BitSet)gdn.clone();
        gdp.clear(1);
        for(int i=gdn.nextSetBit(2); i!=-1; i=gdn.nextSetBit(i+1)){
            for(long j=gdn.nextSetBit(2); j!=-1 && j*i<=max; j=gdn.nextSetBit((int)j+1)){
                gdp.clear((int)j*i);
            }
        }
        return gdp;
    }
}

</source>
<source file="../hum_codes_raw/s904246863.java" startline="1" endline="37" pcid="30430">
import java.util.BitSet;
import java.util.HashMap;
import java.util.Scanner;
 
public class Main{
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        BitSet gdp = gdp(300000);
        while(true){
            int n = in.nextInt();
            if(n == 1) return;
            StringBuilder sb = new StringBuilder();
            sb.append(n+": ");
            for(int i=gdp.nextSetBit(0); i!=-1 && i<=n; i=gdp.nextSetBit(i+1)){
                if(n%i==0) sb.append(i+" ");
            }
            System.out.println(sb.toString().trim());
        }
    }
     
    public static BitSet gdp(int max){
        BitSet gdn = new BitSet(max+1);
        for(int i=1; i<=max; i++){
            int mod = i%7;
            if(mod == 6 || mod == 1) gdn.set(i);
        }
        BitSet gdp = (BitSet)gdn.clone();
        gdp.clear(1);
        for(int i=gdn.nextSetBit(2); i!=-1; i=gdn.nextSetBit(i+1)){
            for(long j=gdn.nextSetBit(2); j!=-1 && j*i<=max; j=gdn.nextSetBit((int)j+1)){
                gdp.clear((int)j*i);
            }
        }
        return gdp;
    }
}

</source>
</class>

<class classid="21" nclones="2" nlines="67" similarity="100">
<source file="../hum_codes_raw/s030330886.java" startline="1" endline="88" pcid="1002">
import java.io.*;
import java.util.*;
 
public class Main {
	static Scanner sc = new Scanner(System.in);
	static PrintWriter out = new PrintWriter(System.out);
 
	public static void main(String[] args) throws Exception {
		int n = sc.nextInt();
		long arr[] = new long[n], xor = 0;
		
		for(int i = 0; i < n; i++) {
			arr[i] = sc.nextLong();
			xor ^= i < 2 ? 0 : arr[i];
		}
		
		long sum = arr[0] + arr[1];
		long and = (sum - xor) >> 1;
		long a = 0, b = 0;
		
		for(int i = 60; i >= 0; i--) {
			boolean xi = (xor & (1L << i)) > 0;
			boolean ai = (and & (1L << i)) > 0;
			
			if(!xi && ai) {
				a |= 1L << i;
				b |= 1L << i;
			}
		}
		
		
		for(int i = 60; i >= 0; i--) {
			boolean xi = (xor & (1L << i)) > 0;
			boolean ai = (and & (1L << i)) > 0;
			
			if(xi && !ai) {
				if((a | 1L << i) <= arr[0]) {
					a |= 1L << i;
				}else {
					b |= 1L << i;
				}
			}
		}
		
		boolean flag = (a + b) == sum && (a ^ b) == xor;
		flag &= a >= 1 && a <= arr[0] && b >= arr[1];
		
		out.println(flag ? arr[0] - a : -1);
		out.close();
	}
 
}
 
class Scanner {
	StringTokenizer st;
	BufferedReader br;
 
	public Scanner(InputStream system) {
		br = new BufferedReader(new InputStreamReader(system));
	}
 
	public Scanner(String file) throws Exception {
		br = new BufferedReader(new FileReader(file));
	}
 
	public String next() throws IOException {
		while (st == null || !st.hasMoreTokens())
			st = new StringTokenizer(br.readLine());
		return st.nextToken();
	}
 
	public String nextLine() throws IOException {
		return br.readLine();
	}
 
	public int nextInt() throws IOException {
		return Integer.parseInt(next());
	}
 
	public double nextDouble() throws IOException {
		return Double.parseDouble(next());
	}
 
	public Long nextLong() throws IOException {
		return Long.parseLong(next());
	}
}

</source>
<source file="../hum_codes_raw/s488982935.java" startline="1" endline="88" pcid="16426">
import java.io.*;
import java.util.*;

public class Main {
	static Scanner sc = new Scanner(System.in);
	static PrintWriter out = new PrintWriter(System.out);

	public static void main(String[] args) throws Exception {
		int n = sc.nextInt();
		long arr[] = new long[n], xor = 0;
		
		for(int i = 0; i < n; i++) {
			arr[i] = sc.nextLong();
			xor ^= i < 2 ? 0 : arr[i];
		}
		
		long sum = arr[0] + arr[1];
		long and = (sum - xor) >> 1;
		long a = 0, b = 0;
		
		for(int i = 60; i >= 0; i--) {
			boolean xi = (xor & (1L << i)) > 0;
			boolean ai = (and & (1L << i)) > 0;
			
			if(!xi && ai) {
				a |= 1L << i;
				b |= 1L << i;
			}
		}
		
		
		for(int i = 60; i >= 0; i--) {
			boolean xi = (xor & (1L << i)) > 0;
			boolean ai = (and & (1L << i)) > 0;
			
			if(xi && !ai) {
				if((a | 1L << i) <= arr[0]) {
					a |= 1L << i;
				}else {
					b |= 1L << i;
				}
			}
		}
		
		boolean flag = (a + b) == sum && (a ^ b) == xor;
		flag &= a >= 1 && a <= arr[0] && b >= arr[1];
		
		out.println(flag ? arr[0] - a : -1);
		out.close();
	}

}

class Scanner {
	StringTokenizer st;
	BufferedReader br;

	public Scanner(InputStream system) {
		br = new BufferedReader(new InputStreamReader(system));
	}

	public Scanner(String file) throws Exception {
		br = new BufferedReader(new FileReader(file));
	}

	public String next() throws IOException {
		while (st == null || !st.hasMoreTokens())
			st = new StringTokenizer(br.readLine());
		return st.nextToken();
	}

	public String nextLine() throws IOException {
		return br.readLine();
	}

	public int nextInt() throws IOException {
		return Integer.parseInt(next());
	}

	public double nextDouble() throws IOException {
		return Double.parseDouble(next());
	}

	public Long nextLong() throws IOException {
		return Long.parseLong(next());
	}
}

</source>
</class>

<class classid="22" nclones="5" nlines="10" similarity="100">
<source file="../hum_codes_raw/s031103200.java" startline="1" endline="17" pcid="1029">

import java.util.Scanner;

class Main {

    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int p = scan.nextInt();
        int m = scan.nextInt();
        int c = scan.nextInt();
        System.out.println(p + m + c);

    }

}


</source>
<source file="../hum_codes_raw/s465667606.java" startline="1" endline="16" pcid="15628">
import java.util.Scanner;

class Main {

    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int p = scan.nextInt();
        int m = scan.nextInt();
        int c = scan.nextInt();
        
        System.out.println(p+m+c);
        }

    }


</source>
<source file="../hum_codes_raw/s327150544.java" startline="1" endline="20" pcid="10951">

import java.util.Scanner;

class Main {

    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int p = scan.nextInt();
        int m = scan.nextInt();
        int c = scan.nextInt();
        System.out.println(p+m+c);
        
        
        }
        
    }




</source>
<source file="../hum_codes_raw/s720895574.java" startline="1" endline="17" pcid="24229">

import java.util.Scanner;

class Main {

    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int p = scan.nextInt();
        int m = scan.nextInt();
        int c = scan.nextInt();

        System.out.println(p + m + c);

    }
}


</source>
<source file="../hum_codes_raw/s110992293.java" startline="1" endline="19" pcid="3688">
import java.util.Scanner;

class Main {

    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int p = scan.nextInt();
        int m = scan.nextInt();
        int c = scan.nextInt();
        
       System.out.println(p+m+c);
       
       
           }
        
    }



</source>
</class>

<class classid="23" nclones="2" nlines="67" similarity="100">
<source file="../hum_codes_raw/s031315623.java" startline="1" endline="70" pcid="1042">
import java.util.*;

class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(true){
        int h = scanner.nextInt();
        int w = scanner.nextInt();
        if(h == 0 && w == 0){
            break;
        }
        int[][] yard = new int[h][w];
        int max = 0;
        int cap = 0;
        int lakemax = 0;
        int yardmin = 10;
        int flag = 0;
        int cap1 = 0;
        for(int i = 0;i<h;i++){
            for(int j = 0;j<w;j++){
                yard[i][j] = scanner.nextInt();
            }
        }

        for(int i = 3;i <= h;i++){
            for(int j = 3;j<=w;j++){
                for(int h_start = 0;h_start<=h-i;h_start++){
                    for(int w_start = 0;w_start<=w-j;w_start++){
                        for(int h_yardsearch = h_start;h_yardsearch<h_start+i;h_yardsearch++){
                            for(int w_yardsearch = w_start;w_yardsearch<w_start+j;w_yardsearch++){
                                if(h_yardsearch != h_start && h_yardsearch != h_start+i-1){
                                    yardmin = yardmin>yard[h_yardsearch][w_yardsearch]?yard[h_yardsearch][w_yardsearch]:yardmin;
                                    yardmin = yardmin>yard[h_yardsearch][w_yardsearch+j-1]?yard[h_yardsearch][w_yardsearch+j-1]:yardmin;
                                    break;
                                }
                                yardmin = yardmin>yard[h_yardsearch][w_yardsearch]?yard[h_yardsearch][w_yardsearch]:yardmin;
                                
                            }
                        }
                        for(int h_lakesearch = h_start+1;h_lakesearch<h_start+i-1;h_lakesearch++){
                            for(int w_lakesearch = w_start+1;w_lakesearch<w_start+j-1;w_lakesearch++){
                                cap1 = yardmin-yard[h_lakesearch][w_lakesearch];
                                if(cap1<=0){
                                    flag = 1;
                                    break;
                                }else{
                                    cap += cap1;
                                }
                            }
                            if(flag == 1){
                                break;
                            }
                        }
                        if(flag ==1){
                        }else{
                            max = max<cap?cap:max;
                        }
                        cap = 0;
                        flag = 0;
                        yardmin = 10;
                    }
                }
            }
        }

        System.out.println(max);
    }
    }
}

</source>
<source file="../hum_codes_raw/s687849691.java" startline="1" endline="70" pcid="23106">
import java.util.*;

class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        while(true){
        int h = scanner.nextInt();
        int w = scanner.nextInt();
        if(h == 0 && w == 0){
            break;
        }
        int[][] yard = new int[h][w];
        int max = 0;
        int cap = 0;
        int lakemax = 0;
        int yardmin = 10;
        int flag = 0;
        int cap1 = 0;
        for(int i = 0;i<h;i++){
            for(int j = 0;j<w;j++){
                yard[i][j] = scanner.nextInt();
            }
        }

        for(int i = 3;i <= h;i++){
            for(int j = 3;j<=w;j++){
                for(int h_start = 0;h_start<=h-i;h_start++){
                    for(int w_start = 0;w_start<=w-j;w_start++){
                        for(int h_yardsearch = h_start;h_yardsearch<h_start+i;h_yardsearch++){
                            for(int w_yardsearch = w_start;w_yardsearch<w_start+j;w_yardsearch++){
                                if(h_yardsearch != h_start && h_yardsearch != h_start+i-1){
                                    yardmin = yardmin>yard[h_yardsearch][w_yardsearch]?yard[h_yardsearch][w_yardsearch]:yardmin;
                                    yardmin = yardmin>yard[h_yardsearch][w_yardsearch+j-1]?yard[h_yardsearch][w_yardsearch+j-1]:yardmin;
                                    break;
                                }
                                yardmin = yardmin>yard[h_yardsearch][w_yardsearch]?yard[h_yardsearch][w_yardsearch]:yardmin;
                                
                            }
                        }
                        for(int h_lakesearch = h_start+1;h_lakesearch<h_start+i-1;h_lakesearch++){
                            for(int w_lakesearch = w_start+1;w_lakesearch<w_start+j-1;w_lakesearch++){
                                cap1 = yardmin-yard[h_lakesearch][w_lakesearch];
                                if(cap1<=0){
                                    flag = 1;
                                    break;
                                }else{
                                    cap += cap1;
                                }
                            }
                            if(flag == 1){
                                break;
                            }
                        }
                        if(flag ==1){
                        }else{
                            max = max<cap?cap:max;
                        }
                        cap = 0;
                        flag = 0;
                        yardmin = 10;
                    }
                }
            }
        }

        System.out.println(max);
    }
    }
}

</source>
</class>

<class classid="24" nclones="2" nlines="47" similarity="100">
<source file="../hum_codes_raw/s033141889.java" startline="1" endline="57" pcid="1101">
import java.io.*;
import java.math.*;
import java.util.*;

public class Main {
    private static boolean debug = false;
    private static boolean elapsed = false;

    private static PrintWriter _out = new PrintWriter(System.out);
    private static PrintWriter _err = new PrintWriter(System.err);

    private void solve(Scanner sc) {
        long X = sc.nextLong();
        long Y = sc.nextLong();

        if (Math.abs(X - Y) <= 1) {
            _out.println("Brown");
        } else {
            _out.println("Alice");
        }
    }
    private static BigInteger C(long n, long r) {
        BigInteger res = BigInteger.ONE;
        for (long i = n; i > n - r; --i) {
            res = res.multiply(BigInteger.valueOf(i));
        }
        for (long i = r; i > 1; --i) {
            res = res.divide(BigInteger.valueOf(i));
        }
        return res;
    }
    private static BigInteger P(long n, long r) {
        BigInteger res = BigInteger.ONE;
        for (long i = n; i > n - r; --i) {
            res = res.multiply(BigInteger.valueOf(i));
        }
        return res;
    }
    /*
     * 10^10 > Integer.MAX_VALUE = 2147483647 > 10^9
     * 10^19 > Long.MAX_VALUE = 9223372036854775807L > 10^18
     */
    public static void main(String[] args) {
        long S = System.currentTimeMillis();

        Scanner sc = new Scanner(System.in);
        new Main().solve(sc);
        _out.flush();

        long G = System.currentTimeMillis();
        if (elapsed) {
            _err.println((G - S) + "ms");
        }
        _err.flush();
    }
}

</source>
<source file="../hum_codes_raw/s740915416.java" startline="1" endline="57" pcid="24899">
import java.io.*;
import java.math.*;
import java.util.*;

public class Main {
    private static boolean debug = false;
    private static boolean elapsed = false;

    private static PrintWriter _out = new PrintWriter(System.out);
    private static PrintWriter _err = new PrintWriter(System.err);

    private void solve(Scanner sc) {
        long X = sc.nextLong();
        long Y = sc.nextLong();

        if (Math.abs(X - Y) <= 1) {
            _out.println("Brown");
        } else {
            _out.println("Alice");
        }
    }
    private static BigInteger C(long n, long r) {
        BigInteger res = BigInteger.ONE;
        for (long i = n; i > n - r; --i) {
            res = res.multiply(BigInteger.valueOf(i));
        }
        for (long i = r; i > 1; --i) {
            res = res.divide(BigInteger.valueOf(i));
        }
        return res;
    }
    private static BigInteger P(long n, long r) {
        BigInteger res = BigInteger.ONE;
        for (long i = n; i > n - r; --i) {
            res = res.multiply(BigInteger.valueOf(i));
        }
        return res;
    }
    /*
     * 10^10 > Integer.MAX_VALUE = 2147483647 > 10^9
     * 10^19 > Long.MAX_VALUE = 9223372036854775807L > 10^18
     */
    public static void main(String[] args) {
        long S = System.currentTimeMillis();

        Scanner sc = new Scanner(System.in);
        new Main().solve(sc);
        _out.flush();

        long G = System.currentTimeMillis();
        if (elapsed) {
            _err.println((G - S) + "ms");
        }
        _err.flush();
    }
}

</source>
</class>

<class classid="25" nclones="2" nlines="143" similarity="100">
<source file="../hum_codes_raw/s034088895.java" startline="1" endline="174" pcid="1134">
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.PriorityQueue;
import java.util.Comparator;
 
class Point implements Comparable<Point>{
    public static int nextId = 0;
  
    public int id;
    public int x;
    public int y;
    public int type;
    public int distanceFromStart;
    
    public Point() {
        this(-1, -1, -1);
    }
     
    public Point(final int x, final int y, final int type) {
        init(x, y, type);
    }
  
    public int distance(final Point p) {
        return abs(this.x - p.x) + abs(this.y - p.y);
    }
     
    public void init(final int x, final int y, final int type){
        this.id = nextId++;
        this.x = x;
        this.y = y;
        this.type = type;
        this.distanceFromStart = Integer.MAX_VALUE;
    }
    
    @Override
    public int compareTo(final Point p) {
        return this.distanceFromStart - p.distanceFromStart;
    }
     
    private static int abs(final int n) {
        int mask = n >> 31;
        return (n ^ mask) - mask;
    }
}
  
public class Main {
    public static final BufferedReader br =
            new BufferedReader(new InputStreamReader(System.in));
  
    public static final Point start = new Point();
    public static final Point goal = new Point();

    public static final PriorityQueue<Point> q = new PriorityQueue<Point>();
     
    public static final List<List<Point> > pointListByType =
            new ArrayList<List<Point> >();
     
    static {
        for(int i = 0; i < 5; i++) {
            pointListByType.add(new ArrayList<Point>());
        }
    }
  
    public static void main(String args[]) throws IOException {
        while(true) {
            final String mapSizeStr = br.readLine();
            if("0 0".equals(mapSizeStr)) break;
  
            final String[] splittedStr = mapSizeStr.split(" ");
            final int x = Integer.parseInt(splittedStr[0]);
            final int y = Integer.parseInt(splittedStr[1]);

            for(int i = 0; i < 5; i++) {
                pointListByType.get(i).clear();
            }
            Point.nextId = 0;
  
            for(int r = 0; r < y; r++){
                final String line = br.readLine();
                final char[] caray = line.toCharArray();
                for(int c = 0; c < x; c++) {
                    char pointLiteral = caray[c];
                    switch(pointLiteral) {
                    case '.':
                        //Do Nothing
                        break;
                    case 'S':
                        start.init(c, r, -1);
                        start.distanceFromStart = 0;
                        break;
                    case 'G':
                        goal.init(c, r, -1);
                        break;
                    default:
                        final int type = (int)pointLiteral - (int)'1';
                        pointListByType.get(type).add(new Point(c, r, type));
                    }
                }
            }
  
            int minLenType = -1;
            int minLen = Integer.MAX_VALUE;
            for (int firstType = 0; firstType < 5; firstType++) { 
                final int shortestPathLen = searchShortestPath(firstType, minLen);
  
                if(minLen > shortestPathLen) {
                    minLen = shortestPathLen;
                    minLenType = firstType;
                }
  
                if(firstType == 4) break;
                
                for(int i = 0; i < 5; i++) {
                    final List<Point> tempPointList = pointListByType.get(i);
                    final int pointListSize = tempPointList.size();
                    for(int j = 0; j < pointListSize; j++) {
                        tempPointList.get(j).distanceFromStart = Integer.MAX_VALUE;
                    }
                }
                goal.distanceFromStart = Integer.MAX_VALUE;
            }
  
            if(minLen == Integer.MAX_VALUE) {
                System.out.println("NA");
            } else {
                System.out.println((minLenType + 1) + " " + minLen);
            }
        }
    }
  
    private static int searchShortestPath(final int firstType, final int minLen) {
        final int lastType = (firstType + 4) % 5;
            
        q.clear();
  
        q.add(start);
        start.type = firstType;
           
        while(!q.isEmpty()) {
            final Point searchingPoint = q.poll();

            if(searchingPoint.distanceFromStart >= minLen) return Integer.MAX_VALUE;
            if(searchingPoint.id == goal.id) return goal.distanceFromStart;

            if(searchingPoint.type == lastType) {
                final int distance = searchingPoint.distance(goal);
                final int searchingPointDistance = searchingPoint.distanceFromStart;
                if(goal.distanceFromStart > searchingPointDistance + distance) {
                    goal.distanceFromStart = searchingPointDistance + distance;
                    q.add(goal);
                }
            } else {
                final List<Point> nextPointList = pointListByType.get((searchingPoint.type + 1) % 5);
                final int nextPointListSize = nextPointList.size();
                
                for(int i = 0; i < nextPointListSize; i++) {
                    final Point tempNextPoint = nextPointList.get(i);
                    final int distance = searchingPoint.distance(tempNextPoint);
                    final int searchingPointDistance = searchingPoint.distanceFromStart;
                    if(tempNextPoint.distanceFromStart > searchingPointDistance + distance) {
                        tempNextPoint.distanceFromStart = searchingPointDistance + distance;
                        q.add(tempNextPoint);
                    }
                }
            }
        }
        return Integer.MAX_VALUE;
    }
}   

</source>
<source file="../hum_codes_raw/s497904534.java" startline="1" endline="174" pcid="16704">
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.PriorityQueue;
import java.util.Comparator;
 
class Point implements Comparable<Point>{
    public static int nextId = 0;
  
    public int id;
    public int x;
    public int y;
    public int type;
    public int distanceFromStart;
    
    public Point() {
        this(-1, -1, -1);
    }
     
    public Point(final int x, final int y, final int type) {
        init(x, y, type);
    }
  
    public int distance(final Point p) {
        return abs(this.x - p.x) + abs(this.y - p.y);
    }
     
    public void init(final int x, final int y, final int type){
        this.id = nextId++;
        this.x = x;
        this.y = y;
        this.type = type;
        this.distanceFromStart = Integer.MAX_VALUE;
    }
    
    @Override
    public int compareTo(final Point p) {
        return this.distanceFromStart - p.distanceFromStart;
    }
     
    private static int abs(final int n) {
        int mask = n >> 31;
        return (n ^ mask) - mask;
    }
}
  
public class Main {
    public static final BufferedReader br =
            new BufferedReader(new InputStreamReader(System.in));
  
    public static final Point start = new Point();
    public static final Point goal = new Point();

    public static final PriorityQueue<Point> q = new PriorityQueue<Point>();
     
    public static final List<List<Point> > pointListByType =
            new ArrayList<List<Point> >();
     
    static {
        for(int i = 0; i < 5; i++) {
            pointListByType.add(new ArrayList<Point>());
        }
    }
  
    public static void main(String args[]) throws IOException {
        while(true) {
            final String mapSizeStr = br.readLine();
            if("0 0".equals(mapSizeStr)) break;
  
            final String[] splittedStr = mapSizeStr.split(" ");
            final int x = Integer.parseInt(splittedStr[0]);
            final int y = Integer.parseInt(splittedStr[1]);

            for(int i = 0; i < 5; i++) {
                pointListByType.get(i).clear();
            }
            Point.nextId = 0;
  
            for(int r = 0; r < y; r++){
                final String line = br.readLine();
                final char[] caray = line.toCharArray();
                for(int c = 0; c < x; c++) {
                    char pointLiteral = caray[c];
                    switch(pointLiteral) {
                    case '.':
                        //Do Nothing
                        break;
                    case 'S':
                        start.init(c, r, -1);
                        start.distanceFromStart = 0;
                        break;
                    case 'G':
                        goal.init(c, r, -1);
                        break;
                    default:
                        final int type = (int)pointLiteral - (int)'1';
                        pointListByType.get(type).add(new Point(c, r, type));
                    }
                }
            }
  
            int minLenType = -1;
            int minLen = Integer.MAX_VALUE;
            for (int firstType = 0; firstType < 5; firstType++) { 
                final int shortestPathLen = searchShortestPath(firstType, minLen);
  
                if(minLen > shortestPathLen) {
                    minLen = shortestPathLen;
                    minLenType = firstType;
                }
  
                if(firstType == 4) break;
                
                for(int i = 0; i < 5; i++) {
                    final List<Point> tempPointList = pointListByType.get(i);
                    final int pointListSize = tempPointList.size();
                    for(int j = 0; j < pointListSize; j++) {
                        tempPointList.get(j).distanceFromStart = Integer.MAX_VALUE;
                    }
                }
                goal.distanceFromStart = Integer.MAX_VALUE;
            }
  
            if(minLen == Integer.MAX_VALUE) {
                System.out.println("NA");
            } else {
                System.out.println((minLenType + 1) + " " + minLen);
            }
        }
    }
  
    private static int searchShortestPath(final int firstType, final int minLen) {
        final int lastType = (firstType + 4) % 5;
            
        q.clear();
  
        q.add(start);
        start.type = firstType;
           
        while(!q.isEmpty()) {
            final Point searchingPoint = q.poll();

            if(searchingPoint.distanceFromStart >= minLen) return Integer.MAX_VALUE;
            if(searchingPoint.id == goal.id) return goal.distanceFromStart;

            if(searchingPoint.type == lastType) {
                final int distance = searchingPoint.distance(goal);
                final int searchingPointDistance = searchingPoint.distanceFromStart;
                if(goal.distanceFromStart > searchingPointDistance + distance) {
                    goal.distanceFromStart = searchingPointDistance + distance;
                    q.add(goal);
                }
            } else {
                final List<Point> nextPointList = pointListByType.get((searchingPoint.type + 1) % 5);
                final int nextPointListSize = nextPointList.size();
                
                for(int i = 0; i < nextPointListSize; i++) {
                    final Point tempNextPoint = nextPointList.get(i);
                    final int distance = searchingPoint.distance(tempNextPoint);
                    final int searchingPointDistance = searchingPoint.distanceFromStart;
                    if(tempNextPoint.distanceFromStart > searchingPointDistance + distance) {
                        tempNextPoint.distanceFromStart = searchingPointDistance + distance;
                        q.add(tempNextPoint);
                    }
                }
            }
        }
        return Integer.MAX_VALUE;
    }
}   

</source>
</class>

<class classid="26" nclones="2" nlines="83" similarity="100">
<source file="../hum_codes_raw/s034131919.java" startline="1" endline="86" pcid="1136">
import java.util.Scanner;

public class Main {
    static int[][][] caves = new int[2][1000][1000];
    static boolean[] primes = new boolean[1000000];
    static int[][] dp = new int[2][1000];
    static int[] vx = {1, 0, -1, 0};
    static int[] vy = {0, -1, 0, 1};

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        MakeCaves();
        while (true){
            int m = sc.nextInt();
            int n = sc.nextInt();
            if(m==0 && n==0) break;

            int x = -1, y = -1;
            for (int i = 0; i < 1000; i++) {
                for (int j = 0; j < 1000; j++) {
                    if(caves[0][i][j]==n){
                        x = j; y = i;
                        break;
                    }
                }
                if(x!=-1) break;
            }
            for (int i = 0; i <1000 ; i++) {
                dp[0][i] = dp[1][i] = 0;
            }

            int max = 0, dy = 0, mx = x, my = y;
            while (y+dy<1000){
                for (int i = (x-dy>=0)?x-dy:0; i <= ((x+dy<1000)?x+dy:999); i++) {
                    if(caves[0][y+dy][i]>m) continue;
                    dp[dy%2][i] = dp[(dy+1)%2][i] + caves[1][y+dy][i];
                    if(i>0&&dp[(dy+1)%2][i-1]!=0){
                        dp[dy%2][i] = Math.max(dp[dy%2][i], dp[(dy+1)%2][i-1] + caves[1][y+dy][i]);
                    }
                    if(i<999&&dp[(dy+1)%2][i+1]!=0){
                        dp[dy%2][i] = Math.max(dp[dy%2][i], dp[(dy+1)%2][i+1] + caves[1][y+dy][i]);
                    }
                    if(max<dp[dy%2][i]){
                        max = dp[dy%2][i];
                        mx = i; my = y + dy;
                    }else if(max==dp[dy%2][i] && caves[1][y+dy][i]==1){
                        if(caves[0][my][mx]<caves[0][y+dy][i]){
                            mx = i; my = y + dy;
                        }
                    }
                }
                dy++;
            }
            System.out.println(max+" "+((max!=0)?caves[0][my][mx]:0));
        }
    }

    static void FindPrimes() {
        primes[0] = true;
        for (int i = 1; i < 500000; i++) {
            if(primes[i]) continue;
            int j = (i+1)*2;
            while (j<1000000){
                primes[j-1] = true;
                j += i+1;
            }
        }
    }

    static void MakeCaves() {
        int n = 2, x = 499, y = 500;
        FindPrimes();
        caves[0][y][x] = 1;
        caves[1][y][x] = 0;

        for (int i = 0; i < 2000; i++) {
            for (int j = 0; j <= i/2; j++, n++) {
                if(n==1000001) break;
                x+=vx[i%4]; y+=vy[i%4];
                caves[0][y][x] = n;
                caves[1][y][x] = (primes[n-1])?0:1;
            }
        }
    }
}

</source>
<source file="../hum_codes_raw/s239204937.java" startline="1" endline="86" pcid="8079">
import java.util.Scanner;

public class Main{
    static int[][][] caves = new int[2][1000][1000];
    static boolean[] primes = new boolean[1000000];
    static int[][] dp = new int[2][1000];
    static int[] vx = {1, 0, -1, 0};
    static int[] vy = {0, -1, 0, 1};

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        MakeCaves();
        while (true){
            int m = sc.nextInt();
            int n = sc.nextInt();
            if(m==0 && n==0) break;

            int x = -1, y = -1;
            for (int i = 0; i < 1000; i++) {
                for (int j = 0; j < 1000; j++) {
                    if(caves[0][i][j]==n){
                        x = j; y = i;
                        break;
                    }
                }
                if(x!=-1) break;
            }
            for (int i = 0; i <1000 ; i++) {
                dp[0][i] = dp[1][i] = 0;
            }

            int max = 0, dy = 0, mx = x, my = y;
            while (y+dy<1000){
                for (int i = (x-dy>=0)?x-dy:0; i <= ((x+dy<1000)?x+dy:999); i++) {
                    if(caves[0][y+dy][i]>m) continue;
                    dp[dy%2][i] = dp[(dy+1)%2][i] + caves[1][y+dy][i];
                    if(i>0&&dp[(dy+1)%2][i-1]!=0){
                        dp[dy%2][i] = Math.max(dp[dy%2][i], dp[(dy+1)%2][i-1] + caves[1][y+dy][i]);
                    }
                    if(i<999&&dp[(dy+1)%2][i+1]!=0){
                        dp[dy%2][i] = Math.max(dp[dy%2][i], dp[(dy+1)%2][i+1] + caves[1][y+dy][i]);
                    }
                    if(max<dp[dy%2][i]){
                        max = dp[dy%2][i];
                        mx = i; my = y + dy;
                    }else if(max==dp[dy%2][i] && caves[1][y+dy][i]==1){
                        if(caves[0][my][mx]<caves[0][y+dy][i]){
                            mx = i; my = y + dy;
                        }
                    }
                }
                dy++;
            }
            System.out.println(max+" "+((max!=0)?caves[0][my][mx]:0));
        }
    }

    static void FindPrimes() {
        primes[0] = true;
        for (int i = 1; i < 500000; i++) {
            if(primes[i]) continue;
            int j = (i+1)*2;
            while (j<1000000){
                primes[j-1] = true;
                j += i+1;
            }
        }
    }

    static void MakeCaves() {
        int n = 2, x = 499, y = 500;
        FindPrimes();
        caves[0][y][x] = 1;
        caves[1][y][x] = 0;

        for (int i = 0; i < 2000; i++) {
            for (int j = 0; j <= i/2; j++, n++) {
                if(n==1000001) break;
                x+=vx[i%4]; y+=vy[i%4];
                caves[0][y][x] = n;
                caves[1][y][x] = (primes[n-1])?0:1;
            }
        }
    }
}

</source>
</class>

<class classid="27" nclones="2" nlines="220" similarity="100">
<source file="../hum_codes_raw/s034727591.java" startline="1" endline="265" pcid="1156">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.io.IOException;
import java.util.ArrayList;
import java.io.UncheckedIOException;
import java.util.List;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            DIsomorphismFreak solver = new DIsomorphismFreak();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class DIsomorphismFreak {
        int[] seq;
        int depthest;
        int minDepth;
        long minLeaf;

        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            Node[] nodes = new Node[n];
            for (int i = 0; i < n; i++) {
                nodes[i] = new Node();
                nodes[i].id = i;
            }
            int[][] edges = new int[n - 1][2];
            for (int i = 0; i < n - 1; i++) {
                edges[i][0] = in.readInt() - 1;
                edges[i][1] = in.readInt() - 1;
                Node a = nodes[edges[i][0]];
                Node b = nodes[edges[i][1]];
                a.adj.add(b);
                b.adj.add(a);
            }
            seq = new int[n];


            minDepth = n;
            minLeaf = Long.MAX_VALUE;
            for (int i = 0; i < n; i++) {
                reset();
                dfs(nodes[i], null, 0);
                update(1);
            }

            for (int[] e : edges) {
                Node a = nodes[e[0]];
                Node b = nodes[e[1]];
                reset();
                dfs(a, b, 0);
                dfs(b, a, 0);
                update(2);
            }

            out.println(minDepth + 1).println(minLeaf);
        }

        public void update(int mul) {
            int depth = depthest;
            long leaf = mul;
            for (int j = 0; j <= depth; j++) {
                leaf *= seq[j];
            }

            if (depth < minDepth) {
                minDepth = depth;
                minLeaf = Long.MAX_VALUE;
            }
            if (depth == minDepth) {
                minLeaf = Math.min(minLeaf, leaf);
            }
        }

        public void reset() {
            Arrays.fill(seq, 1);
            depthest = 0;
        }

        public void dfs(Node root, Node p, int d) {
            depthest = Math.max(depthest, d);
            int degree = root.adj.size() - (p == null ? 0 : 1);
            seq[d] = Math.max(seq[d], degree);
            for (Node node : root.adj) {
                if (node == p) {
                    continue;
                }
                dfs(node, root, d + 1);
            }
        }

    }

    static class Node {
        List<Node> adj = new ArrayList<>();
        int id;

        public String toString() {
            return "" + (id + 1);
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(long c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println(long c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }
}


</source>
<source file="../hum_codes_raw/s160294044.java" startline="1" endline="265" pcid="5378">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.io.IOException;
import java.util.ArrayList;
import java.io.UncheckedIOException;
import java.util.List;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            DIsomorphismFreak solver = new DIsomorphismFreak();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class DIsomorphismFreak {
        int[] seq;
        int depthest;
        int minDepth;
        long minLeaf;

        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            Node[] nodes = new Node[n];
            for (int i = 0; i < n; i++) {
                nodes[i] = new Node();
                nodes[i].id = i;
            }
            int[][] edges = new int[n - 1][2];
            for (int i = 0; i < n - 1; i++) {
                edges[i][0] = in.readInt() - 1;
                edges[i][1] = in.readInt() - 1;
                Node a = nodes[edges[i][0]];
                Node b = nodes[edges[i][1]];
                a.adj.add(b);
                b.adj.add(a);
            }
            seq = new int[n];


            minDepth = n;
            minLeaf = Long.MAX_VALUE;
            for (int i = 0; i < n; i++) {
                reset();
                dfs(nodes[i], null, 0);
                update(1);
            }

            for (int[] e : edges) {
                Node a = nodes[e[0]];
                Node b = nodes[e[1]];
                reset();
                dfs(a, b, 0);
                dfs(b, a, 0);
                update(2);
            }

            out.println(minDepth + 1).println(minLeaf);
        }

        public void update(int mul) {
            int depth = depthest;
            long leaf = mul;
            for (int j = 0; j <= depth; j++) {
                leaf *= seq[j];
            }

            if (depth < minDepth) {
                minDepth = depth;
                minLeaf = Long.MAX_VALUE;
            }
            if (depth == minDepth) {
                minLeaf = Math.min(minLeaf, leaf);
            }
        }

        public void reset() {
            Arrays.fill(seq, 1);
            depthest = 0;
        }

        public void dfs(Node root, Node p, int d) {
            depthest = Math.max(depthest, d);
            int degree = root.adj.size() - (p == null ? 0 : 1);
            seq[d] = Math.max(seq[d], degree);
            for (Node node : root.adj) {
                if (node == p) {
                    continue;
                }
                dfs(node, root, d + 1);
            }
        }

    }

    static class Node {
        List<Node> adj = new ArrayList<>();
        int id;

        public String toString() {
            return "" + (id + 1);
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(long c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println(long c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }
}


</source>
</class>

<class classid="28" nclones="2" nlines="17" similarity="100">
<source file="../hum_codes_raw/s035027406.java" startline="1" endline="19" pcid="1176">
import java.util.Scanner;
public class Main {

	public static void main(String[] args){

		Scanner sc = new Scanner(System.in);
		int a = sc.nextInt();
		int b = sc.nextInt();

		if(a + b == 15){
			System.out.println("+");
		}else if(a * b == 15){
			System.out.println("*");
		}else{
			System.out.println("x");
		}
	}
}

</source>
<source file="../hum_codes_raw/s180691434.java" startline="1" endline="28" pcid="6087">
import java.util.Scanner;
 
 
public class Main {
 
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc = new Scanner(System.in);
		
		int a = sc.nextInt();
		int b = sc.nextInt();
		
		if(a + b == 15){
			System.out.println("+");
		}
		else if(a * b == 15){
			System.out.println("*");
		}
		else {
			System.out.println("x");
		}
	}
 
}

</source>
</class>

<class classid="29" nclones="2" nlines="123" similarity="100">
<source file="../hum_codes_raw/s035477307.java" startline="1" endline="153" pcid="1194">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.PriorityQueue;
import java.util.Queue;

public class Main {

  public static void main(String[] args) {
    
    new Main().run();
  }

  public void run() {

    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      int n = Integer.parseInt(br.readLine());
      Graph graph = new Graph(n);
      String[] vInfo;
      int id,degree,key,val;
      IntTuple[] ajacent;

      for(int i=0; i<n; i++) {
        vInfo = br.readLine().split(" ");
        id     = Integer.parseInt(vInfo[0]);
        degree = Integer.parseInt(vInfo[1]);
        ajacent = new IntTuple[degree];
        for (int j=0,k=2; j<degree; j++) {
          key = Integer.parseInt(vInfo[k++]);
          val = Integer.parseInt(vInfo[k++]);
          ajacent[j] = new IntTuple(key, val);
        }
        graph.setVertex(id, ajacent);
      }

      graph.calcSSSPWeightSum();

      StringBuilder buf = new StringBuilder();
      for (Vertex v : graph.vertices) {
        buf.append(v.id).append(" ").append(v.minPathCost)
           .append("\n");
      }
      System.out.print(buf);
    }
    catch (IOException e) {
      System.err.println(e);
    }
  }


  class Graph {

    Vertex[] vertices;
    Queue<IntTuple> queue;

    public Graph(int size ) {
      vertices  = new Vertex[size];
      queue = new PriorityQueue<>(size);
    }

    public void setVertex(int id) {
      vertices[id] = new Vertex(id);
    }
    public void setVertex(int id, int[] distance) {
      setVertex(id);
      setAjacent(id, distance);
    }
    public void setVertex(int id, IntTuple[] ajacent) {
      setVertex(id);
      setAjacent(id, ajacent);
    }
    public void setAjacent(int id, int[] distance) {
      vertices[id].distance = distance;
    }
    public void setAjacent(int id, IntTuple[] ajasent) {
      vertices[id].ajacent = ajasent;
    }

    public void calcSSSPWeightSum() {
      algorithmDijkstra(0);
    }

    private void algorithmDijkstra(int s) {
      vertices[s].minPathCost = 0;
      Vertex current,next;
      queue.offer(new IntTuple(vertices[s].id, vertices[s].minPathCost));
      vertices[s].state = Vertex.GRAY;

      IntTuple v;
      while( (v = queue.poll()) != null ) {
        vertices[v.key].state = Vertex.BLACK;

        if(vertices[v.key].minPathCost < v.val) continue;
        
        current = vertices[v.key];
        for (IntTuple w: current.ajacent) {
          next = vertices[w.key];
          if( (next.state != Vertex.BLACK) &&
              (current.minPathCost + w.val < next.minPathCost) ) {
            next.minPathCost = current.minPathCost + w.val;
            queue.offer(new IntTuple(next.id, next.minPathCost));
            next.state = Vertex.GRAY;
          }
        }
        continue;
      }
    }
  }

  class Vertex {

    static final int NILL  =-1;
    static final int WHITE = 0;
    static final int GRAY  = 1;
    static final int BLACK = 2;
    int id;
    int state;
    int minPathCost;
    int parent;
    int[] distance;
    IntTuple[] ajacent;

    public Vertex(int id) {
      this.id = id;
      state = WHITE;
      minPathCost = Integer.MAX_VALUE;
    }
  }

  class IntTuple implements Comparable<IntTuple> {
    public int key;
    public int val;

    public IntTuple(int key, int val) {
      this.key = key;
      this.val = val;
    }

    @Override
    public String toString() {
      return "[" + key + "," + val + "]";
    }
    @Override
    public int compareTo(IntTuple obj) {
      if(this.val < obj.val) return -1;
      if(this.val > obj.val) return  1;

      return 0;
    }
  }
}

</source>
<source file="../hum_codes_raw/s150933663.java" startline="1" endline="153" pcid="5051">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.PriorityQueue;
import java.util.Queue;

public class Main {

  public static void main(String[] args) {
    
    new Main().run();
  }

  public void run() {

    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      int n = Integer.parseInt(br.readLine());
      Graph graph = new Graph(n);
      String[] vInfo;
      int id,degree,key,val;
      IntTuple[] ajacent;

      for(int i=0; i<n; i++) {
        vInfo = br.readLine().split(" ");
        id     = Integer.parseInt(vInfo[0]);
        degree = Integer.parseInt(vInfo[1]);
        ajacent = new IntTuple[degree];
        for (int j=0,k=2; j<degree; j++) {
          key = Integer.parseInt(vInfo[k++]);
          val = Integer.parseInt(vInfo[k++]);
          ajacent[j] = new IntTuple(key, val);
        }
        graph.setVertex(id, ajacent);
      }

      graph.calcSSSPWeightSum();

      StringBuilder buf = new StringBuilder();
      for (Vertex v : graph.vertices) {
        buf.append(v.id).append(" ").append(v.minPathCost)
           .append("\n");
      }
      System.out.print(buf);
    }
    catch (IOException e) {
      System.err.println(e);
    }
  }


  class Graph {

    Vertex[] vertices;
    Queue<IntTuple> queue;

    public Graph(int size ) {
      vertices  = new Vertex[size];
      queue = new PriorityQueue<>(size);
    }

    public void setVertex(int id) {
      vertices[id] = new Vertex(id);
    }
    public void setVertex(int id, int[] distance) {
      setVertex(id);
      setAjacent(id, distance);
    }
    public void setVertex(int id, IntTuple[] ajacent) {
      setVertex(id);
      setAjacent(id, ajacent);
    }
    public void setAjacent(int id, int[] distance) {
      vertices[id].distance = distance;
    }
    public void setAjacent(int id, IntTuple[] ajasent) {
      vertices[id].ajacent = ajasent;
    }

    public void calcSSSPWeightSum() {
      algorithmDijkstra(0);
    }

    private void algorithmDijkstra(int s) {
      vertices[s].minPathCost = 0;
      Vertex current,next;
      queue.offer(new IntTuple(vertices[s].id, vertices[s].minPathCost));
      vertices[s].state = Vertex.GRAY;

      IntTuple v;
      while( (v = queue.poll()) != null ) {
        vertices[v.key].state = Vertex.BLACK;

        if(vertices[v.key].minPathCost < v.val) continue;
        
        current = vertices[v.key];
        for (IntTuple w: current.ajacent) {
          next = vertices[w.key];
          if( (next.state != Vertex.BLACK) &&
              (current.minPathCost + w.val < next.minPathCost) ) {
            next.minPathCost = current.minPathCost + w.val;
            queue.offer(new IntTuple(next.id, next.minPathCost));
            next.state = Vertex.GRAY;
          }
        }
        continue;
      }
    }
  }

  class Vertex {

    static final int NILL  =-1;
    static final int WHITE = 0;
    static final int GRAY  = 1;
    static final int BLACK = 2;
    int id;
    int state;
    int minPathCost;
    int parent;
    int[] distance;
    IntTuple[] ajacent;

    public Vertex(int id) {
      this.id = id;
      state = WHITE;
      minPathCost = Integer.MAX_VALUE;
    }
  }

  class IntTuple implements Comparable<IntTuple> {
    public int key;
    public int val;

    public IntTuple(int key, int val) {
      this.key = key;
      this.val = val;
    }

    @Override
    public String toString() {
      return "[" + key + "," + val + "]";
    }
    @Override
    public int compareTo(IntTuple obj) {
      if(this.val < obj.val) return -1;
      if(this.val > obj.val) return  1;

      return 0;
    }
  }
}

</source>
</class>

<class classid="30" nclones="2" nlines="362" similarity="100">
<source file="../hum_codes_raw/s035539207.java" startline="1" endline="445" pcid="1198">
import java.io.*;
import java.math.*;
import java.util.*;
import java.util.stream.*;

public class Main {

	static final int P = 998_244_353;

	void submit() {
		int[] cnt = new int[100_000];
		int n = nextInt();
		for (int i = 0; i < 2 * n; i++) {
			cnt[nextInt() - 1]++;
		}

		long[] pair = new long[n + 1];
		pair[0] = 1;
		for (int i = 1; i < pair.length; i++) {
			pair[i] = pair[i - 1] * (2 * i - 1) % P;
		}

		long[] inv = new long[2 * n + 1];
		inv[1] = 1;

		for (int i = 2; i < inv.length; i++) {
			inv[i] = P - (long) (P / i) * inv[P % i] % P;
		}

		PriorityQueue<int[]> pq = new PriorityQueue<>((int[] a, int[] b) -> Integer.compare(a.length, b.length));
		pq.add(new int[] { 1 });
		for (int x : cnt) {
			if (x < 2) {
				continue;
			}
			int[] p = new int[x / 2 + 1];
			long cur = p[0] = 1;
			for (int i = 1; i < p.length; i++) {
				cur = cur * (x - 2 * i + 2) % P * (x - 2 * i + 1) % P * inv[2 * i - 1] % P * inv[2 * i] % P;
				p[i] = (int) (cur * pair[i] % P);
			}
			pq.add(p);
		}

		while (pq.size() > 1) {
			int[] a = pq.poll();
			int[] b = pq.poll();
			pq.add(mult(a, b));
		}

		int[] p = pq.poll();
		long ans = 0;
		for (int i = 0; i < p.length; i++) {
			ans += (1 - i % 2 * 2) * p[i] * pair[n - i];
			if (ans >= P2) {
				ans -= P2;
			}
			if (ans < 0) {
				ans += P2;
			}
		}
		out.println(ans % P);
	}

	static final int NAIVE_MULT_THRESHOLD = 128;
	static final long P2 = (long) P * P;

	int[] mult(int[] a, int[] b) {
		int[] ret = multSmall(a, b);
		return ret != null ? ret : multFFT(a, b);
	}

	static int[] getNonZeroesIdx(int[] p) {
		int n = 0;
		for (int i = 0; i < p.length; i++) {
			if (p[i] != 0) {
				n++;
			}
		}
		int[] ret = new int[n];
		for (int i = 0; i < p.length; i++) {
			if (p[i] != 0) {
				ret[--n] = i;
			}
		}
		return ret;
	}

	static int[] removeLeadingZeroes(int[] a) {
		int i = a.length - 1;
		while (i >= 0 && a[i] == 0) {
			i--;
		}
		return i == a.length - 1 ? a : Arrays.copyOf(a, i + 1);
	}

	int[] multSmall(int[] a, int[] b) {
		int[] nza = getNonZeroesIdx(a);
		int[] nzb = getNonZeroesIdx(b);
		if (nza.length == 0 || nzb.length == 0) {
			return new int[] { 0 };
		}
		if (Math.min(nza.length, nzb.length) <= NAIVE_MULT_THRESHOLD) {
			long[] c = new long[nza[0] + nzb[0] + 1];
			for (int i : nza) {
				for (int j : nzb) {
					c[i + j] += (long) a[i] * b[j];
					if (c[i + j] >= P2) {
						c[i + j] -= P2;
					}
				}
			}
			int[] ret = new int[c.length];
			for (int i = 0; i < c.length; i++) {
				ret[i] = (int) (c[i] % P);
			}
			return removeLeadingZeroes(ret);
		}
		return null;
	}

	static int nextPowerOf2(int x) {
		return x == 1 ? 1 : Integer.highestOneBit(x - 1) << 1;
	}

	static final int L = (int) Math.sqrt(P);
	static final int L2 = L * L;

	/**
	 * Decomposes intV into vectors a and b s.t. intV = a + b * L.
	 * 
	 * @param len - length to pad intV to. !!! MUST BE A POWER OF 2 !!!
	 * @return double[][]{FFT(a), FFT(b)}.
	 */
	static double[][] decomposeAndFFT(int[] intV, int len) {
		// pack into one complex vector
		double[] f = new double[len << 1];
		for (int i = 0; i < intV.length; i++) {
			f[i << 1] = intV[i] % L;
			f[i << 1 | 1] = intV[i] / L;
		}

		fft(f, false);

		// unpack
		double[] f1 = new double[len << 1];
		double[] f2 = new double[len << 1];
		int zzz = (len << 1) - 1;
		for (int i = 0; i < len << 1; i += 2) {
			int j = (-i) & zzz;
			f1[i] = .5 * (f[i] + f[j]);
			f1[i + 1] = .5 * (f[i + 1] - f[j + 1]);
			f2[i] = .5 * (f[i + 1] + f[j + 1]);
			f2[i + 1] = .5 * (f[j] - f[i]);
		}

		return new double[][] { f1, f2 };
	}

	public static int[] multFFT(int[] a, int[] b) {
		int len = nextPowerOf2(a.length + b.length - 1);
		int len2 = len << 1;

		double[][] fA = decomposeAndFFT(a, len);
		double[][] fB = decomposeAndFFT(b, len);

		// Multiply FFT-ed vectors and pack them in pairs for inverse FFT.
		// We need to calcualte smth like (a0 b0) + L(a0 b1 + a1 b0) + L^2 (a1 b1)
		// a0 b0 goes into invF[0] real part
		// (a0 b1 + a1 b0) invF[0] imag part
		// a1 b1 -> invF[1] real part
		double[][] invF = new double[2][len2];
		for (int ia = 0; ia < 2; ia++) {
			for (int ib = 0; ib < 2; ib++) {

				double[] r = invF[(ia + ib) >> 1];
				double[] p = fA[ia];
				double[] q = fB[ib];

				if (((ia + ib) & 1) == 0) {
					for (int i = 0; i < len2; i += 2) {
						r[i] += p[i] * q[i] - p[i + 1] * q[i + 1];
						r[i + 1] += p[i] * q[i + 1] + p[i + 1] * q[i];
					}

				} else {
					for (int i = 0; i < len2; i += 2) {
						r[i] -= p[i] * q[i + 1] + p[i + 1] * q[i];
						r[i + 1] += p[i] * q[i] - p[i + 1] * q[i + 1];
					}
				}

			}
		}

		fft(invF[0], true);
		fft(invF[1], true);

		int[] ret = new int[len];

		for (int i = 0; i < len2; i += 2) {
			long v0 = Math.round(invF[0][i]);
			long v1 = Math.round(invF[0][i + 1]) % P * L;
			long v2 = Math.round(invF[1][i]) % P * L2;
			ret[i >> 1] = (int) ((v0 + v1 + v2) % P);
		}

		return removeLeadingZeroes(ret);
	}

	public static void fft(double[] v, boolean invert) {
		int n2 = v.length;
		int n = n2 >> 1;
		int logN = Integer.numberOfTrailingZeros(n);
		prepareArrays(logN);
		int[] rev = rev2D[logN];

		for (int i = 0; i < n2; i += 2) {
			int j = rev[i >> 1] << 1;
			if (i < j) {
				double t = v[i];
				v[i] = v[j];
				v[j] = t;
				t = v[i + 1];
				v[i + 1] = v[j + 1];
				v[j + 1] = t;
			}
		}

		double conj = invert ? -1 : 1;

		for (int len = 2, row = 0; len <= n; len <<= 1, row++) {
			double[] pow = pow2D[row];
			for (int i = 0; i < n; i += len) {
				for (int j1 = i << 1, j2 = j1 + len, k = 0; k < len; j1 += 2, j2 += 2, k += 2) {
					double uA = v[j1];
					double uB = v[j1 + 1];

					double mRe = pow[k];
					double mIm = pow[k + 1] * conj;

					double vA = v[j2] * mRe - v[j2 + 1] * mIm;
					double vB = v[j2] * mIm + v[j2 + 1] * mRe;

					v[j1] = uA + vA;
					v[j1 + 1] = uB + vB;
					v[j2] = uA - vA;
					v[j2 + 1] = uB - vB;
				}
			}
		}
		if (invert) {
			for (int i = 0; i < n2; i++) {
				v[i] /= n;
			}
		}
	}

	static double[][] pow2D = { { 1, 0 } };
	static int[][] rev2D = {};

	static void prepareArrays(int n) {
		if (rev2D.length < n + 1) {
			rev2D = Arrays.copyOf(rev2D, n + 1);
		}

		if (rev2D[n] == null) {
			int[] tmp = rev2D[n] = new int[1 << n];
			for (int i = 0; i < (1 << n); i++) {
				tmp[i] = (tmp[i >> 1] >> 1) | ((i & 1) << (n - 1));
			}
		}

		int oldN = pow2D.length;

		if (oldN >= n) {
			return;
		}

		pow2D = Arrays.copyOf(pow2D, n);

		for (int i = oldN; i < n; i++) {
			double angle = Math.PI / (1 << i);

			double mRe = Math.cos(angle);
			double mIm = Math.sin(angle);

			double[] dst = pow2D[i] = new double[2 << i];
			double[] src = pow2D[i - 1];

			for (int j = 0; j < 1 << i; j += 2) {
				double re = src[j];
				double im = src[j + 1];

				dst[j << 1] = re;
				dst[j << 1 | 1] = im;
				dst[j << 1 | 2] = re * mRe - im * mIm;
				dst[j << 1 | 3] = re * mIm + im * mRe;
			}
		}
	}

	void test() {

	}

	void stress() {
		for (int tst = 0;; tst++) {
			if (false) {
				throw new AssertionError();
			}
			System.err.println(tst);
		}
	}

	Main() throws IOException {
		is = System.in;
		out = new PrintWriter(System.out);
		submit();
		// stress();
		// test();
		out.close();
	}

	static final Random rng = new Random();
	static final int C = 5;

	static int rand(int l, int r) {
		return l + rng.nextInt(r - l + 1);
	}

	public static void main(String[] args) throws IOException {
		new Main();
	}

	private InputStream is;
	PrintWriter out;

	private byte[] buf = new byte[1 << 14];
	private int bufSz = 0, bufPtr = 0;

	private int readByte() {
		if (bufSz == -1)
			throw new RuntimeException("Reading past EOF");
		if (bufPtr >= bufSz) {
			bufPtr = 0;
			try {
				bufSz = is.read(buf);
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
			if (bufSz <= 0)
				return -1;
		}
		return buf[bufPtr++];
	}

	private boolean isTrash(int c) {
		return c < 33 || c > 126;
	}

	private int skip() {
		int b;
		while ((b = readByte()) != -1 && isTrash(b))
			;
		return b;
	}

	String nextToken() {
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while (!isTrash(b)) {
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}

	String nextString() {
		int b = readByte();
		StringBuilder sb = new StringBuilder();
		while (!isTrash(b) || b == ' ') {
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}

	double nextDouble() {
		return Double.parseDouble(nextToken());
	}

	char nextChar() {
		return (char) skip();
	}

	int nextInt() {
		int ret = 0;
		int b = skip();
		if (b != '-' && (b < '0' || b > '9')) {
			throw new InputMismatchException();
		}
		boolean neg = false;
		if (b == '-') {
			neg = true;
			b = readByte();
		}
		while (true) {
			if (b >= '0' && b <= '9') {
				ret = ret * 10 + (b - '0');
			} else {
				if (b != -1 && !isTrash(b)) {
					throw new InputMismatchException();
				}
				return neg ? -ret : ret;
			}
			b = readByte();
		}
	}

	long nextLong() {
		long ret = 0;
		int b = skip();
		if (b != '-' && (b < '0' || b > '9')) {
			throw new InputMismatchException();
		}
		boolean neg = false;
		if (b == '-') {
			neg = true;
			b = readByte();
		}
		while (true) {
			if (b >= '0' && b <= '9') {
				ret = ret * 10 + (b - '0');
			} else {
				if (b != -1 && !isTrash(b)) {
					throw new InputMismatchException();
				}
				return neg ? -ret : ret;
			}
			b = readByte();
		}
	}
}

</source>
<source file="../hum_codes_raw/s770870772.java" startline="1" endline="445" pcid="25878">
import java.io.*;
import java.math.*;
import java.util.*;
import java.util.stream.*;

public class Main {

	static final int P = 998_244_353;

	void submit() {
		int[] cnt = new int[100_000];
		int n = nextInt();
		for (int i = 0; i < 2 * n; i++) {
			cnt[nextInt() - 1]++;
		}

		long[] pair = new long[n + 1];
		pair[0] = 1;
		for (int i = 1; i < pair.length; i++) {
			pair[i] = pair[i - 1] * (2 * i - 1) % P;
		}

		long[] inv = new long[2 * n + 1];
		inv[1] = 1;

		for (int i = 2; i < inv.length; i++) {
			inv[i] = P - (long) (P / i) * inv[P % i] % P;
		}

		PriorityQueue<int[]> pq = new PriorityQueue<>((int[] a, int[] b) -> Integer.compare(a.length, b.length));
		pq.add(new int[] { 1 });
		for (int x : cnt) {
			if (x < 2) {
				continue;
			}
			int[] p = new int[x / 2 + 1];
			long cur = p[0] = 1;
			for (int i = 1; i < p.length; i++) {
				cur = cur * (x - 2 * i + 2) % P * (x - 2 * i + 1) % P * inv[2 * i - 1] % P * inv[2 * i] % P;
				p[i] = (int) (cur * pair[i] % P);
			}
			pq.add(p);
		}

		while (pq.size() > 1) {
			int[] a = pq.poll();
			int[] b = pq.poll();
			pq.add(mult(a, b));
		}

		int[] p = pq.poll();
		long ans = 0;
		for (int i = 0; i < p.length; i++) {
			ans += (1 - i % 2 * 2) * p[i] * pair[n - i];
			if (ans >= P2) {
				ans -= P2;
			}
			if (ans < 0) {
				ans += P2;
			}
		}
		out.println(ans % P);
	}

	static final int NAIVE_MULT_THRESHOLD = 128;
	static final long P2 = (long) P * P;

	int[] mult(int[] a, int[] b) {
		int[] ret = multSmall(a, b);
		return ret != null ? ret : multFFT(a, b);
	}

	static int[] getNonZeroesIdx(int[] p) {
		int n = 0;
		for (int i = 0; i < p.length; i++) {
			if (p[i] != 0) {
				n++;
			}
		}
		int[] ret = new int[n];
		for (int i = 0; i < p.length; i++) {
			if (p[i] != 0) {
				ret[--n] = i;
			}
		}
		return ret;
	}

	static int[] removeLeadingZeroes(int[] a) {
		int i = a.length - 1;
		while (i >= 0 && a[i] == 0) {
			i--;
		}
		return i == a.length - 1 ? a : Arrays.copyOf(a, i + 1);
	}

	int[] multSmall(int[] a, int[] b) {
		int[] nza = getNonZeroesIdx(a);
		int[] nzb = getNonZeroesIdx(b);
		if (nza.length == 0 || nzb.length == 0) {
			return new int[] { 0 };
		}
		if (Math.min(nza.length, nzb.length) <= NAIVE_MULT_THRESHOLD) {
			long[] c = new long[nza[0] + nzb[0] + 1];
			for (int i : nza) {
				for (int j : nzb) {
					c[i + j] += (long) a[i] * b[j];
					if (c[i + j] >= P2) {
						c[i + j] -= P2;
					}
				}
			}
			int[] ret = new int[c.length];
			for (int i = 0; i < c.length; i++) {
				ret[i] = (int) (c[i] % P);
			}
			return removeLeadingZeroes(ret);
		}
		return null;
	}

	static int nextPowerOf2(int x) {
		return x == 1 ? 1 : Integer.highestOneBit(x - 1) << 1;
	}

	static final int L = (int) Math.sqrt(P);
	static final int L2 = L * L;

	/**
	 * Decomposes intV into vectors a and b s.t. intV = a + b * L.
	 * 
	 * @param len - length to pad intV to. !!! MUST BE A POWER OF 2 !!!
	 * @return double[][]{FFT(a), FFT(b)}.
	 */
	static double[][] decomposeAndFFT(int[] intV, int len) {
		// pack into one complex vector
		double[] f = new double[len << 1];
		for (int i = 0; i < intV.length; i++) {
			f[i << 1] = intV[i] % L;
			f[i << 1 | 1] = intV[i] / L;
		}

		fft(f, false);

		// unpack
		double[] f1 = new double[len << 1];
		double[] f2 = new double[len << 1];
		int zzz = (len << 1) - 1;
		for (int i = 0; i < len << 1; i += 2) {
			int j = (-i) & zzz;
			f1[i] = .5 * (f[i] + f[j]);
			f1[i + 1] = .5 * (f[i + 1] - f[j + 1]);
			f2[i] = .5 * (f[i + 1] + f[j + 1]);
			f2[i + 1] = .5 * (f[j] - f[i]);
		}

		return new double[][] { f1, f2 };
	}

	public static int[] multFFT(int[] a, int[] b) {
		int len = nextPowerOf2(a.length + b.length - 1);
		int len2 = len << 1;

		double[][] fA = decomposeAndFFT(a, len);
		double[][] fB = decomposeAndFFT(b, len);

		// Multiply FFT-ed vectors and pack them in pairs for inverse FFT.
		// We need to calcualte smth like (a0 b0) + L(a0 b1 + a1 b0) + L^2 (a1 b1)
		// a0 b0 goes into invF[0] real part
		// (a0 b1 + a1 b0) invF[0] imag part
		// a1 b1 -> invF[1] real part
		double[][] invF = new double[2][len2];
		for (int ia = 0; ia < 2; ia++) {
			for (int ib = 0; ib < 2; ib++) {

				double[] r = invF[(ia + ib) >> 1];
				double[] p = fA[ia];
				double[] q = fB[ib];

				if (((ia + ib) & 1) == 0) {
					for (int i = 0; i < len2; i += 2) {
						r[i] += p[i] * q[i] - p[i + 1] * q[i + 1];
						r[i + 1] += p[i] * q[i + 1] + p[i + 1] * q[i];
					}

				} else {
					for (int i = 0; i < len2; i += 2) {
						r[i] -= p[i] * q[i + 1] + p[i + 1] * q[i];
						r[i + 1] += p[i] * q[i] - p[i + 1] * q[i + 1];
					}
				}

			}
		}

		fft(invF[0], true);
		fft(invF[1], true);

		int[] ret = new int[len];

		for (int i = 0; i < len2; i += 2) {
			long v0 = Math.round(invF[0][i]);
			long v1 = Math.round(invF[0][i + 1]) % P * L;
			long v2 = Math.round(invF[1][i]) % P * L2;
			ret[i >> 1] = (int) ((v0 + v1 + v2) % P);
		}

		return removeLeadingZeroes(ret);
	}

	public static void fft(double[] v, boolean invert) {
		int n2 = v.length;
		int n = n2 >> 1;
		int logN = Integer.numberOfTrailingZeros(n);
		prepareArrays(logN);
		int[] rev = rev2D[logN];

		for (int i = 0; i < n2; i += 2) {
			int j = rev[i >> 1] << 1;
			if (i < j) {
				double t = v[i];
				v[i] = v[j];
				v[j] = t;
				t = v[i + 1];
				v[i + 1] = v[j + 1];
				v[j + 1] = t;
			}
		}

		double conj = invert ? -1 : 1;

		for (int len = 2, row = 0; len <= n; len <<= 1, row++) {
			double[] pow = pow2D[row];
			for (int i = 0; i < n; i += len) {
				for (int j1 = i << 1, j2 = j1 + len, k = 0; k < len; j1 += 2, j2 += 2, k += 2) {
					double uA = v[j1];
					double uB = v[j1 + 1];

					double mRe = pow[k];
					double mIm = pow[k + 1] * conj;

					double vA = v[j2] * mRe - v[j2 + 1] * mIm;
					double vB = v[j2] * mIm + v[j2 + 1] * mRe;

					v[j1] = uA + vA;
					v[j1 + 1] = uB + vB;
					v[j2] = uA - vA;
					v[j2 + 1] = uB - vB;
				}
			}
		}
		if (invert) {
			for (int i = 0; i < n2; i++) {
				v[i] /= n;
			}
		}
	}

	static double[][] pow2D = { { 1, 0 } };
	static int[][] rev2D = {};

	static void prepareArrays(int n) {
		if (rev2D.length < n + 1) {
			rev2D = Arrays.copyOf(rev2D, n + 1);
		}

		if (rev2D[n] == null) {
			int[] tmp = rev2D[n] = new int[1 << n];
			for (int i = 0; i < (1 << n); i++) {
				tmp[i] = (tmp[i >> 1] >> 1) | ((i & 1) << (n - 1));
			}
		}

		int oldN = pow2D.length;

		if (oldN >= n) {
			return;
		}

		pow2D = Arrays.copyOf(pow2D, n);

		for (int i = oldN; i < n; i++) {
			double angle = Math.PI / (1 << i);

			double mRe = Math.cos(angle);
			double mIm = Math.sin(angle);

			double[] dst = pow2D[i] = new double[2 << i];
			double[] src = pow2D[i - 1];

			for (int j = 0; j < 1 << i; j += 2) {
				double re = src[j];
				double im = src[j + 1];

				dst[j << 1] = re;
				dst[j << 1 | 1] = im;
				dst[j << 1 | 2] = re * mRe - im * mIm;
				dst[j << 1 | 3] = re * mIm + im * mRe;
			}
		}
	}

	void test() {

	}

	void stress() {
		for (int tst = 0;; tst++) {
			if (false) {
				throw new AssertionError();
			}
			System.err.println(tst);
		}
	}

	Main() throws IOException {
		is = System.in;
		out = new PrintWriter(System.out);
		submit();
		// stress();
		// test();
		out.close();
	}

	static final Random rng = new Random();
	static final int C = 5;

	static int rand(int l, int r) {
		return l + rng.nextInt(r - l + 1);
	}

	public static void main(String[] args) throws IOException {
		new Main();
	}

	private InputStream is;
	PrintWriter out;

	private byte[] buf = new byte[1 << 14];
	private int bufSz = 0, bufPtr = 0;

	private int readByte() {
		if (bufSz == -1)
			throw new RuntimeException("Reading past EOF");
		if (bufPtr >= bufSz) {
			bufPtr = 0;
			try {
				bufSz = is.read(buf);
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
			if (bufSz <= 0)
				return -1;
		}
		return buf[bufPtr++];
	}

	private boolean isTrash(int c) {
		return c < 33 || c > 126;
	}

	private int skip() {
		int b;
		while ((b = readByte()) != -1 && isTrash(b))
			;
		return b;
	}

	String nextToken() {
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while (!isTrash(b)) {
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}

	String nextString() {
		int b = readByte();
		StringBuilder sb = new StringBuilder();
		while (!isTrash(b) || b == ' ') {
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}

	double nextDouble() {
		return Double.parseDouble(nextToken());
	}

	char nextChar() {
		return (char) skip();
	}

	int nextInt() {
		int ret = 0;
		int b = skip();
		if (b != '-' && (b < '0' || b > '9')) {
			throw new InputMismatchException();
		}
		boolean neg = false;
		if (b == '-') {
			neg = true;
			b = readByte();
		}
		while (true) {
			if (b >= '0' && b <= '9') {
				ret = ret * 10 + (b - '0');
			} else {
				if (b != -1 && !isTrash(b)) {
					throw new InputMismatchException();
				}
				return neg ? -ret : ret;
			}
			b = readByte();
		}
	}

	long nextLong() {
		long ret = 0;
		int b = skip();
		if (b != '-' && (b < '0' || b > '9')) {
			throw new InputMismatchException();
		}
		boolean neg = false;
		if (b == '-') {
			neg = true;
			b = readByte();
		}
		while (true) {
			if (b >= '0' && b <= '9') {
				ret = ret * 10 + (b - '0');
			} else {
				if (b != -1 && !isTrash(b)) {
					throw new InputMismatchException();
				}
				return neg ? -ret : ret;
			}
			b = readByte();
		}
	}
}

</source>
</class>

<class classid="31" nclones="2" nlines="26" similarity="100">
<source file="../hum_codes_raw/s037591628.java" startline="1" endline="27" pcid="1268">
import java.util.Scanner;
public class Main{
  public static void main(String[] args){
    Scanner sc = new Scanner(System.in);
    int n=sc.nextInt();
    long[] a=new long[n];
   double l=0,sum=0;
    for(int i=0;i<n;i++) {
    	a[i]=sc.nextLong();
    	sum+=a[i];
    }
    for(int i=0;i<n;i++) {
    	if(l<sum/2) {
    		l+=a[i];
    	}
    	if(l==sum/2){
    		System.out.println("0");
    		break;
    	}
    	if(l>sum/2){
    		System.out.println((long)Math.min(Math.abs(2*l-sum), Math.abs(2*(l-a[i])-sum)));
    		break;
    	}
    }
  }
}

</source>
<source file="../hum_codes_raw/s248723278.java" startline="1" endline="27" pcid="8362">
import java.util.Scanner;
public class Main{
  public static void main(String[] args){
    Scanner sc = new Scanner(System.in);
    int n=sc.nextInt();
    long[] a=new long[n];
   double l=0,sum=0;
    for(int i=0;i<n;i++) {
    	a[i]=sc.nextLong();
    	sum+=a[i];
    }
    for(int i=0;i<n;i++) {
    	if(l<sum/2) {
    		l+=a[i];
    	}
    	if(l==sum/2){
    		System.out.println("0");
    		break;
    	}
    	if(l>sum/2){
    		System.out.println((long)Math.min(Math.abs(2*l-sum), Math.abs(2*(l-a[i])-sum)));
    		break;
    	}
    }
  }
}

</source>
</class>

<class classid="32" nclones="2" nlines="428" similarity="100">
<source file="../hum_codes_raw/s037905705.java" startline="1" endline="522" pcid="1275">
import java.io.*;
import java.math.*;
import java.util.*;
import java.util.stream.*;

public class Main {

	static final int P = 998_244_353;

	void submit() {
		int n = nextInt();
		int[] cnt = new int[100_000];
		for (int i = 0; i < 2 * n; i++) {
			cnt[nextInt() - 1]++;
		}

		long[] pair = new long[n + 1];
		pair[0] = 1;
		for (int i = 1; i < pair.length; i++) {
			pair[i] = pair[i - 1] * (2 * i - 1) % P;
		}

		long[] inv = new long[2 * n + 1];
		inv[1] = 1;

		for (int i = 2; i < inv.length; i++) {
			inv[i] = P - (long) (P / i) * inv[P % i] % P;
		}

		PriorityQueue<int[]> pq = new PriorityQueue<>((int[] a, int[] b) -> Integer.compare(a.length, b.length));
		pq.add(new int[] { 1 });
		for (int x : cnt) {
			if (x < 2) {
				continue;
			}
			int[] p = new int[x / 2 + 1];
			long cur = p[0] = 1;
			for (int i = 1; i < p.length; i++) {
				cur = cur * (x - 2 * i + 2) % P * (x - 2 * i + 1) % P * inv[2 * i - 1] % P * inv[2 * i] % P;
				p[i] = (int) (cur * pair[i] % P);
			}
			pq.add(p);
		}

		while (pq.size() > 1) {
			int[] a = pq.poll();
			int[] b = pq.poll();
			pq.add(mult(a, b));
		}
		
		int[] p = pq.poll();
		long ans = 0;
		for (int i = 0; i < p.length; i++) {
			ans += (1 - i % 2 * 2) * p[i] * pair[n - i];
			if (ans >= P2) {
				ans -= P2;
			}
			if (ans < 0) {
				ans += P2;
			}
		}
		out.println(ans % P);
	}

	static final int NAIVE_MULT_THRESHOLD = 32;
	static final long P2 = (long)P * P;
	
	int[] mult(int[] a, int[] b) {
		return multSmall(a, b).orElse(multFFT(a, b));
	}
	
	static int[] getNonZeroesIdx(int[] p) {
		int n = 0;
		for (int i = 0; i < p.length; i++) {
			if (p[i] != 0) {
				n++;
			}
		}
		int[] ret = new int[n];
		for (int i = 0; i < p.length; i++) {
			if (p[i] != 0) {
				ret[--n] = i;
			}
		}
		return ret;
	}
	
	static int[] removeLeadingZeroes(int[] a) {
		int i = a.length - 1;
		while (i >= 0 && a[i] == 0) {
			i--;
		}
		return i == a.length - 1 ? a : Arrays.copyOf(a, i + 1);
	}

	Optional<int[]> multSmall(int[] a, int[] b) {
		int[] nza = getNonZeroesIdx(a);
		int[] nzb = getNonZeroesIdx(b);
		if (nza.length == 0 || nzb.length == 0) {
			return Optional.of(new int[] {0});
		}
		if (Math.min(nza.length, nzb.length) <= NAIVE_MULT_THRESHOLD) {
			long[] c = new long[nza[0] + nzb[0] + 1];
			for (int i : nza) {
				for (int j : nzb) {
					c[i + j] += (long)a[i] * b[j];
					if (c[i + j] >= P2) {
						c[i + j] -= P2;
					}
				}
			}
			int[] ret = new int[c.length];
			for (int i = 0; i < c.length; i++) {
				ret[i] = (int) (c[i] % P);
			}
			return Optional.of(removeLeadingZeroes(ret));
		}
		return Optional.empty();
	}
	
	static int nextPowerOf2(int x) {
		return x == 1 ? 1 : Integer.highestOneBit(x - 1) << 1;
	}

	static class CompV {
		double[] re, im;

		void add(CompV o) {
			for (int i = 0; i < re.length; i++) {
				re[i] += o.re[i];
				im[i] += o.im[i];
			}
		}

		static CompV times(CompV a, CompV b) {
			double[] aRe = a.re;
			double[] aIm = a.im;
			double[] bRe = b.re;
			double[] bIm = b.im;
			double[] re = new double[aRe.length];
			double[] im = new double[aRe.length];

			for (int i = 0; i < aRe.length; i++) {
				re[i] = aRe[i] * bRe[i] - aIm[i] * bIm[i];
				im[i] = aRe[i] * bIm[i] + aIm[i] * bRe[i];
			}

			return new CompV(re, im);
		}

		static CompV plus(CompV a, CompV b) {
			double[] aRe = a.re;
			double[] aIm = a.im;
			double[] bRe = b.re;
			double[] bIm = b.im;
			double[] re = new double[aRe.length];
			double[] im = new double[aRe.length];

			for (int i = 0; i < aRe.length; i++) {
				re[i] = aRe[i] + bRe[i];
				im[i] = aIm[i] + bIm[i];
			}

			return new CompV(re, im);
		}

		/**
		 * @return a + bi
		 */
		static CompV packFFT(CompV a, CompV b) {
			double[] aRe = a.re;
			double[] aIm = a.im;
			double[] bRe = b.re;
			double[] bIm = b.im;
			double[] re = new double[aRe.length];
			double[] im = new double[aRe.length];
			for (int i = 0; i < aRe.length; i++) {
				re[i] = aRe[i] - bIm[i];
				im[i] = aIm[i] + bRe[i];
			}
			return new CompV(re, im);
		}

		/**
		 * for real-valued a and b restores FFT(a) and FFT(b) from FFT(a + bi)
		 */
		void unpackFFT(CompV a, CompV b) {
			int n = re.length;
			double[] aRe = a.re;
			double[] aIm = a.im;
			double[] bRe = b.re;
			double[] bIm = b.im;
			for (int i = 0; i < n; i++) {
				int j = i == 0 ? 0 : n - i;
				aRe[i] = (re[i] + re[j]) * 0.5;
				aIm[i] = (im[i] - im[j]) * 0.5;
				bRe[i] = (im[i] + im[j]) * 0.5;
				bIm[i] = (re[j] - re[i]) * 0.5;
			}
		}

		public CompV(double[] re, double[] im) {
			this.re = re;
			this.im = im;
		}

		public CompV(int len) {
			re = new double[len];
			im = new double[len];
		}
	}

	static final int L = (int) Math.sqrt(P);
	static final int L2 = L * L;

	public static int[] multFFT(int[] a, int[] b) {
		int len = nextPowerOf2(a.length + b.length - 1);

		double[] p1 = new double[len];
		double[] q1 = new double[len];
		for (int i = 0; i < a.length; i++) {
			p1[i] = a[i] % L;
			q1[i] = a[i] / L;
		}

		double[] p2 = new double[len];
		double[] q2 = new double[len];
		for (int i = 0; i < b.length; i++) {
			p2[i] = b[i] % L;
			q2[i] = b[i] / L;
		}

		CompV p1p2Pack = new CompV(p1, p2);
		CompV q1q2Pack = new CompV(q1, q2);

		fft(p1p2Pack, false);
		fft(q1q2Pack, false);

		CompV fp1 = new CompV(len);
		CompV fp2 = new CompV(len);
		p1p2Pack.unpackFFT(fp1, fp2);

		CompV fq1 = new CompV(len);
		CompV fq2 = new CompV(len);
		q1q2Pack.unpackFFT(fq1, fq2);

		CompV back0 = CompV.times(fp1, fp2);

		CompV back1 = CompV.times(fp1, fq2);
		back1.add(CompV.times(fq1, fp2));

		CompV back2 = CompV.times(fq1, fq2);

		CompV back01 = CompV.packFFT(back0, back1);

		fft(back01, true);
		fft(back2, true);

		int[] ret = new int[len];

		for (int i = 0; i < len; i++) {
			long v0 = Math.round(back01.re[i]) % P;
			long v1 = Math.round(back01.im[i]) % P * L % P;
			long v2 = Math.round(back2.re[i]) % P * L2 % P;
			ret[i] = (int) ((v0 + v1 + v2) % P);
		}

		return removeLeadingZeroes(ret);
	}

	public static void fft(CompV v, boolean invert) {
		double[] a = v.re;
		double[] b = v.im;
		
		int n = a.length;
		int shift = 32 - Integer.numberOfTrailingZeros(n);
		prepareArrays(32 - shift);
		int[] rev = rev2D[32 - shift];
		for (int i = 1; i < n; i++) {
			int j = rev[i];
			if (i < j) {
				double temp = a[i];
				a[i] = a[j];
				a[j] = temp;
				temp = b[i];
				b[i] = b[j];
				b[j] = temp;
			}
		}

		double multInv = invert ? -1 : 1;

		for (int len = 2, row = 0; len <= n; len <<= 1, row++) {
			int halfLen = len >> 1;
			double[] multReArr = powRe[row];
			double[] multImArr = powIm[row];
			for (int i = 0; i < n; i += len) {
				int toJ = i + halfLen;

				for (int j1 = i, j2 = toJ, k = 0; k < halfLen; j1++, j2++, k++) {
					double uA = a[j1];
					double uB = b[j1];

					double multRe = multReArr[k];
					double multIm = multImArr[k] * multInv;

					double vA = a[j2] * multRe - b[j2] * multIm;
					double vB = a[j2] * multIm + b[j2] * multRe;
					a[j1] = uA + vA;
					b[j1] = uB + vB;
					a[j2] = uA - vA;
					b[j2] = uB - vB;
				}
			}
		}
		if (invert) {
			for (int i = 0; i < n; i++) {
				a[i] /= n;
				b[i] /= n;
			}
		}
	}

	static double[][] powRe = { { 1 } };
	static double[][] powIm = { { 0 } };
	static int[][] rev2D = {};

	static void prepareArrays(int n) {

		if (rev2D.length < n + 1) {
				rev2D = Arrays.copyOf(rev2D, n + 1);
		}

		if (rev2D[n] == null) {
			int[] tmp = rev2D[n] = new int[1 << n];
			for (int i = 0; i < (1 << n); i++) {
				tmp[i] = tmp[i >> 1] >> 1;
				if ((i & 1) == 1) {
					tmp[i] |= 1 << (n - 1);
				}
			}
		}

		int oldN = powRe.length;

		if (oldN >= n) {
			return;
		}

		powRe = Arrays.copyOf(powRe, n);
		powIm = Arrays.copyOf(powIm, n);

		for (int i = oldN; i < n; i++) {

			double angle = Math.PI / (1 << i);

			double multRe = Math.cos(angle);
			double multIm = Math.sin(angle);

			double[] toRe = powRe[i] = new double[1 << i];
			double[] toIm = powIm[i] = new double[1 << i];

			double[] fromRe = powRe[i - 1];
			double[] fromIm = powIm[i - 1];

			for (int j = 0; j < 1 << (i - 1); j++) {

				double re = fromRe[j];
				double im = fromIm[j];

				toRe[j << 1] = re;
				toIm[j << 1] = im;
				toRe[(j << 1) | 1] = re * multRe - im * multIm;
				toIm[(j << 1) | 1] = re * multIm + im * multRe;
			}
		}
	}


	void test() {
		
	}

	void stress() {
		for (int tst = 0;; tst++) {
			if (false) {
				throw new AssertionError();
			}
			System.err.println(tst);
		}
	}

	Main() throws IOException {
		is = System.in;
		out = new PrintWriter(System.out);
		submit();
		// stress();
		// test();
		out.close();
	}

	static final Random rng = new Random();
	static final int C = 5;

	static int rand(int l, int r) {
		return l + rng.nextInt(r - l + 1);
	}

	public static void main(String[] args) throws IOException {
		new Main();
	}

	private InputStream is;
	PrintWriter out;

	private byte[] buf = new byte[1 << 14];
	private int bufSz = 0, bufPtr = 0;

	private int readByte() {
		if (bufSz == -1)
			throw new RuntimeException("Reading past EOF");
		if (bufPtr >= bufSz) {
			bufPtr = 0;
			try {
				bufSz = is.read(buf);
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
			if (bufSz <= 0)
				return -1;
		}
		return buf[bufPtr++];
	}

	private boolean isTrash(int c) {
		return c < 33 || c > 126;
	}

	private int skip() {
		int b;
		while ((b = readByte()) != -1 && isTrash(b))
			;
		return b;
	}

	String nextToken() {
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while (!isTrash(b)) {
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}

	String nextString() {
		int b = readByte();
		StringBuilder sb = new StringBuilder();
		while (!isTrash(b) || b == ' ') {
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}

	double nextDouble() {
		return Double.parseDouble(nextToken());
	}

	char nextChar() {
		return (char) skip();
	}

	int nextInt() {
		int ret = 0;
		int b = skip();
		if (b != '-' && (b < '0' || b > '9')) {
			throw new InputMismatchException();
		}
		boolean neg = false;
		if (b == '-') {
			neg = true;
			b = readByte();
		}
		while (true) {
			if (b >= '0' && b <= '9') {
				ret = ret * 10 + (b - '0');
			} else {
				if (b != -1 && !isTrash(b)) {
					throw new InputMismatchException();
				}
				return neg ? -ret : ret;
			}
			b = readByte();
		}
	}

	long nextLong() {
		long ret = 0;
		int b = skip();
		if (b != '-' && (b < '0' || b > '9')) {
			throw new InputMismatchException();
		}
		boolean neg = false;
		if (b == '-') {
			neg = true;
			b = readByte();
		}
		while (true) {
			if (b >= '0' && b <= '9') {
				ret = ret * 10 + (b - '0');
			} else {
				if (b != -1 && !isTrash(b)) {
					throw new InputMismatchException();
				}
				return neg ? -ret : ret;
			}
			b = readByte();
		}
	}
}

</source>
<source file="../hum_codes_raw/s226367837.java" startline="1" endline="522" pcid="7653">
import java.io.*;
import java.math.*;
import java.util.*;
import java.util.stream.*;

public class Main {

	static final int P = 998_244_353;

	void submit() {
		int n = nextInt();
		int[] cnt = new int[100_000];
		for (int i = 0; i < 2 * n; i++) {
			cnt[nextInt() - 1]++;
		}

		long[] pair = new long[n + 1];
		pair[0] = 1;
		for (int i = 1; i < pair.length; i++) {
			pair[i] = pair[i - 1] * (2 * i - 1) % P;
		}

		long[] inv = new long[2 * n + 1];
		inv[1] = 1;

		for (int i = 2; i < inv.length; i++) {
			inv[i] = P - (long) (P / i) * inv[P % i] % P;
		}

		PriorityQueue<int[]> pq = new PriorityQueue<>((int[] a, int[] b) -> Integer.compare(a.length, b.length));
		pq.add(new int[] { 1 });
		for (int x : cnt) {
			if (x < 2) {
				continue;
			}
			int[] p = new int[x / 2 + 1];
			long cur = p[0] = 1;
			for (int i = 1; i < p.length; i++) {
				cur = cur * (x - 2 * i + 2) % P * (x - 2 * i + 1) % P * inv[2 * i - 1] % P * inv[2 * i] % P;
				p[i] = (int) (cur * pair[i] % P);
			}
			pq.add(p);
		}

		while (pq.size() > 1) {
			int[] a = pq.poll();
			int[] b = pq.poll();
			pq.add(mult(a, b));
		}
		
		int[] p = pq.poll();
		long ans = 0;
		for (int i = 0; i < p.length; i++) {
			ans += (1 - i % 2 * 2) * p[i] * pair[n - i];
			if (ans >= P2) {
				ans -= P2;
			}
			if (ans < 0) {
				ans += P2;
			}
		}
		out.println(ans % P);
	}

	static final int NAIVE_MULT_THRESHOLD = 32;
	static final long P2 = (long)P * P;
	
	int[] mult(int[] a, int[] b) {
		return multSmall(a, b).orElse(multFFT(a, b));
	}
	
	static int[] getNonZeroesIdx(int[] p) {
		int n = 0;
		for (int i = 0; i < p.length; i++) {
			if (p[i] != 0) {
				n++;
			}
		}
		int[] ret = new int[n];
		for (int i = 0; i < p.length; i++) {
			if (p[i] != 0) {
				ret[--n] = i;
			}
		}
		return ret;
	}
	
	static int[] removeLeadingZeroes(int[] a) {
		int i = a.length - 1;
		while (i >= 0 && a[i] == 0) {
			i--;
		}
		return i == a.length - 1 ? a : Arrays.copyOf(a, i + 1);
	}

	Optional<int[]> multSmall(int[] a, int[] b) {
		int[] nza = getNonZeroesIdx(a);
		int[] nzb = getNonZeroesIdx(b);
		if (nza.length == 0 || nzb.length == 0) {
			return Optional.of(new int[] {0});
		}
		if (Math.min(nza.length, nzb.length) <= NAIVE_MULT_THRESHOLD) {
			long[] c = new long[nza[0] + nzb[0] + 1];
			for (int i : nza) {
				for (int j : nzb) {
					c[i + j] += (long)a[i] * b[j];
					if (c[i + j] >= P2) {
						c[i + j] -= P2;
					}
				}
			}
			int[] ret = new int[c.length];
			for (int i = 0; i < c.length; i++) {
				ret[i] = (int) (c[i] % P);
			}
			return Optional.of(removeLeadingZeroes(ret));
		}
		return Optional.empty();
	}
	
	static int nextPowerOf2(int x) {
		return x == 1 ? 1 : Integer.highestOneBit(x - 1) << 1;
	}

	static class CompV {
		double[] re, im;

		void add(CompV o) {
			for (int i = 0; i < re.length; i++) {
				re[i] += o.re[i];
				im[i] += o.im[i];
			}
		}

		static CompV times(CompV a, CompV b) {
			double[] aRe = a.re;
			double[] aIm = a.im;
			double[] bRe = b.re;
			double[] bIm = b.im;
			double[] re = new double[aRe.length];
			double[] im = new double[aRe.length];

			for (int i = 0; i < aRe.length; i++) {
				re[i] = aRe[i] * bRe[i] - aIm[i] * bIm[i];
				im[i] = aRe[i] * bIm[i] + aIm[i] * bRe[i];
			}

			return new CompV(re, im);
		}

		static CompV plus(CompV a, CompV b) {
			double[] aRe = a.re;
			double[] aIm = a.im;
			double[] bRe = b.re;
			double[] bIm = b.im;
			double[] re = new double[aRe.length];
			double[] im = new double[aRe.length];

			for (int i = 0; i < aRe.length; i++) {
				re[i] = aRe[i] + bRe[i];
				im[i] = aIm[i] + bIm[i];
			}

			return new CompV(re, im);
		}

		/**
		 * @return a + bi
		 */
		static CompV packFFT(CompV a, CompV b) {
			double[] aRe = a.re;
			double[] aIm = a.im;
			double[] bRe = b.re;
			double[] bIm = b.im;
			double[] re = new double[aRe.length];
			double[] im = new double[aRe.length];
			for (int i = 0; i < aRe.length; i++) {
				re[i] = aRe[i] - bIm[i];
				im[i] = aIm[i] + bRe[i];
			}
			return new CompV(re, im);
		}

		/**
		 * for real-valued a and b restores FFT(a) and FFT(b) from FFT(a + bi)
		 */
		void unpackFFT(CompV a, CompV b) {
			int n = re.length;
			double[] aRe = a.re;
			double[] aIm = a.im;
			double[] bRe = b.re;
			double[] bIm = b.im;
			for (int i = 0; i < n; i++) {
				int j = i == 0 ? 0 : n - i;
				aRe[i] = (re[i] + re[j]) * 0.5;
				aIm[i] = (im[i] - im[j]) * 0.5;
				bRe[i] = (im[i] + im[j]) * 0.5;
				bIm[i] = (re[j] - re[i]) * 0.5;
			}
		}

		public CompV(double[] re, double[] im) {
			this.re = re;
			this.im = im;
		}

		public CompV(int len) {
			re = new double[len];
			im = new double[len];
		}
	}

	static final int L = (int) Math.sqrt(P);
	static final int L2 = L * L;

	public static int[] multFFT(int[] a, int[] b) {
		int len = nextPowerOf2(a.length + b.length - 1);

		double[] p1 = new double[len];
		double[] q1 = new double[len];
		for (int i = 0; i < a.length; i++) {
			p1[i] = a[i] % L;
			q1[i] = a[i] / L;
		}

		double[] p2 = new double[len];
		double[] q2 = new double[len];
		for (int i = 0; i < b.length; i++) {
			p2[i] = b[i] % L;
			q2[i] = b[i] / L;
		}

		CompV p1p2Pack = new CompV(p1, p2);
		CompV q1q2Pack = new CompV(q1, q2);

		fft(p1p2Pack, false);
		fft(q1q2Pack, false);

		CompV fp1 = new CompV(len);
		CompV fp2 = new CompV(len);
		p1p2Pack.unpackFFT(fp1, fp2);

		CompV fq1 = new CompV(len);
		CompV fq2 = new CompV(len);
		q1q2Pack.unpackFFT(fq1, fq2);

		CompV back0 = CompV.times(fp1, fp2);

		CompV back1 = CompV.times(fp1, fq2);
		back1.add(CompV.times(fq1, fp2));

		CompV back2 = CompV.times(fq1, fq2);

		CompV back01 = CompV.packFFT(back0, back1);

		fft(back01, true);
		fft(back2, true);

		int[] ret = new int[len];

		for (int i = 0; i < len; i++) {
			long v0 = Math.round(back01.re[i]) % P;
			long v1 = Math.round(back01.im[i]) % P * L % P;
			long v2 = Math.round(back2.re[i]) % P * L2 % P;
			ret[i] = (int) ((v0 + v1 + v2) % P);
		}

		return removeLeadingZeroes(ret);
	}

	public static void fft(CompV v, boolean invert) {
		double[] a = v.re;
		double[] b = v.im;
		
		int n = a.length;
		int shift = 32 - Integer.numberOfTrailingZeros(n);
		prepareArrays(32 - shift);
		int[] rev = rev2D[32 - shift];
		for (int i = 1; i < n; i++) {
			int j = rev[i];
			if (i < j) {
				double temp = a[i];
				a[i] = a[j];
				a[j] = temp;
				temp = b[i];
				b[i] = b[j];
				b[j] = temp;
			}
		}

		double multInv = invert ? -1 : 1;

		for (int len = 2, row = 0; len <= n; len <<= 1, row++) {
			int halfLen = len >> 1;
			double[] multReArr = powRe[row];
			double[] multImArr = powIm[row];
			for (int i = 0; i < n; i += len) {
				int toJ = i + halfLen;

				for (int j1 = i, j2 = toJ, k = 0; k < halfLen; j1++, j2++, k++) {
					double uA = a[j1];
					double uB = b[j1];

					double multRe = multReArr[k];
					double multIm = multImArr[k] * multInv;

					double vA = a[j2] * multRe - b[j2] * multIm;
					double vB = a[j2] * multIm + b[j2] * multRe;
					a[j1] = uA + vA;
					b[j1] = uB + vB;
					a[j2] = uA - vA;
					b[j2] = uB - vB;
				}
			}
		}
		if (invert) {
			for (int i = 0; i < n; i++) {
				a[i] /= n;
				b[i] /= n;
			}
		}
	}

	static double[][] powRe = { { 1 } };
	static double[][] powIm = { { 0 } };
	static int[][] rev2D = {};

	static void prepareArrays(int n) {

		if (rev2D.length < n + 1) {
				rev2D = Arrays.copyOf(rev2D, n + 1);
		}

		if (rev2D[n] == null) {
			int[] tmp = rev2D[n] = new int[1 << n];
			for (int i = 0; i < (1 << n); i++) {
				tmp[i] = tmp[i >> 1] >> 1;
				if ((i & 1) == 1) {
					tmp[i] |= 1 << (n - 1);
				}
			}
		}

		int oldN = powRe.length;

		if (oldN >= n) {
			return;
		}

		powRe = Arrays.copyOf(powRe, n);
		powIm = Arrays.copyOf(powIm, n);

		for (int i = oldN; i < n; i++) {

			double angle = Math.PI / (1 << i);

			double multRe = Math.cos(angle);
			double multIm = Math.sin(angle);

			double[] toRe = powRe[i] = new double[1 << i];
			double[] toIm = powIm[i] = new double[1 << i];

			double[] fromRe = powRe[i - 1];
			double[] fromIm = powIm[i - 1];

			for (int j = 0; j < 1 << (i - 1); j++) {

				double re = fromRe[j];
				double im = fromIm[j];

				toRe[j << 1] = re;
				toIm[j << 1] = im;
				toRe[(j << 1) | 1] = re * multRe - im * multIm;
				toIm[(j << 1) | 1] = re * multIm + im * multRe;
			}
		}
	}


	void test() {
		
	}

	void stress() {
		for (int tst = 0;; tst++) {
			if (false) {
				throw new AssertionError();
			}
			System.err.println(tst);
		}
	}

	Main() throws IOException {
		is = System.in;
		out = new PrintWriter(System.out);
		submit();
		// stress();
		// test();
		out.close();
	}

	static final Random rng = new Random();
	static final int C = 5;

	static int rand(int l, int r) {
		return l + rng.nextInt(r - l + 1);
	}

	public static void main(String[] args) throws IOException {
		new Main();
	}

	private InputStream is;
	PrintWriter out;

	private byte[] buf = new byte[1 << 14];
	private int bufSz = 0, bufPtr = 0;

	private int readByte() {
		if (bufSz == -1)
			throw new RuntimeException("Reading past EOF");
		if (bufPtr >= bufSz) {
			bufPtr = 0;
			try {
				bufSz = is.read(buf);
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
			if (bufSz <= 0)
				return -1;
		}
		return buf[bufPtr++];
	}

	private boolean isTrash(int c) {
		return c < 33 || c > 126;
	}

	private int skip() {
		int b;
		while ((b = readByte()) != -1 && isTrash(b))
			;
		return b;
	}

	String nextToken() {
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while (!isTrash(b)) {
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}

	String nextString() {
		int b = readByte();
		StringBuilder sb = new StringBuilder();
		while (!isTrash(b) || b == ' ') {
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}

	double nextDouble() {
		return Double.parseDouble(nextToken());
	}

	char nextChar() {
		return (char) skip();
	}

	int nextInt() {
		int ret = 0;
		int b = skip();
		if (b != '-' && (b < '0' || b > '9')) {
			throw new InputMismatchException();
		}
		boolean neg = false;
		if (b == '-') {
			neg = true;
			b = readByte();
		}
		while (true) {
			if (b >= '0' && b <= '9') {
				ret = ret * 10 + (b - '0');
			} else {
				if (b != -1 && !isTrash(b)) {
					throw new InputMismatchException();
				}
				return neg ? -ret : ret;
			}
			b = readByte();
		}
	}

	long nextLong() {
		long ret = 0;
		int b = skip();
		if (b != '-' && (b < '0' || b > '9')) {
			throw new InputMismatchException();
		}
		boolean neg = false;
		if (b == '-') {
			neg = true;
			b = readByte();
		}
		while (true) {
			if (b >= '0' && b <= '9') {
				ret = ret * 10 + (b - '0');
			} else {
				if (b != -1 && !isTrash(b)) {
					throw new InputMismatchException();
				}
				return neg ? -ret : ret;
			}
			b = readByte();
		}
	}
}

</source>
</class>

<class classid="33" nclones="2" nlines="434" similarity="100">
<source file="../hum_codes_raw/s039503237.java" startline="1" endline="407" pcid="1331">
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.lang.reflect.Field;
import java.util.NoSuchElementException;
import java.util.PrimitiveIterator;
import java.util.function.IntUnaryOperator;
import java.util.function.LongUnaryOperator;
import static java.lang.Math.max;

public class Main {
    public static void main(String[] args) throws Exception {
        Field f = System.out.getClass().getDeclaredField("autoFlush");
        f.setAccessible(true);
        f.set(System.out, false);
        Out out = new Out(System.out);
        solve(new FastScanner(), out);
        out.flush();
        out.close();
    }

    public static void solve(FastScanner fsc, Out out) {
        int n = fsc.nextInt();
        int[] v = new int[0x40000];
        int[] w = new int[0x40000];
        for (int i = 1; i <= n; i++) {
            v[i] = fsc.nextInt();
            w[i] = fsc.nextInt();
        }
        int lmax = 100001;
        int[] memo = new int[0x200 * lmax];
        for (int i = 1; i < 0x200; i++) {
            for (int j = 1; j < lmax; j++) {
                if (j >= w[i]) {
                    memo[i * lmax + j] = max(memo[(i >> 1) * lmax + j], memo[(i >> 1) * lmax + j - w[i]] + v[i]);
                } else {
                    memo[i * lmax + j] = memo[(i >> 1) * lmax + j];
                }
                memo[i * lmax + j] = max(memo[i * lmax + j], memo[i * lmax + j - 1]);
            }
        }
        int q = fsc.nextInt();
        LongQueue que = new LongQueue(0x200);
        while (q --> 0) {
            int x = fsc.nextInt();
            int m = fsc.nextInt();
            que.add(0);
            int max = 0;
            for (; x >= 0x200; x >>= 1) {
                int sz = que.size();
                while (sz --> 0) {
                    long vw = que.poll();
                    if ((vw & 0xffff_ffffl) + w[x] <= m) que.add(vw + ((long) v[x] << 32) + w[x]);
                    que.add(vw);
                }
            }
            while (que.size() > 0) {
                long vw = que.poll();
                int vs = (int) (vw >>> 32);
                int ws = (int) (vw & 0xffff_ffffl);
                max = max(max, vs + memo[x * lmax + m - ws]);
            }
            out.write(max).write('\n');
            que.clear();
        }
    }
}


/**
 * @author https://atcoder.jp/users/suisen
 */
final class In {
    public static final FastScanner fsc = new FastScanner();
    public static int ni() {return fsc.nextInt();}
    public static int[] ni(final int n) {
        final int[] a = new int[n];
        for (int i = 0; i < n; i++) a[i] = fsc.nextInt();
        return a;
    }
    public static int[] ni(final int n, final IntUnaryOperator f) {
        final int[] a = new int[n];
        for (int i = 0; i < n; i++) a[i] = f.applyAsInt(fsc.nextInt());
        return a;
    }
    public static int[][] ni(final int n, final int m) {
        final int[][] a = new int[n][m];
        for (int i = 0; i < n; i++) a[i] = ni(m);
        return a;
    }
    public static int[][] ni(final int n, final int m, final IntUnaryOperator f) {
        final int[][] a = new int[n][m];
        for (int i = 0; i < n; i++) a[i] = ni(m, f);
        return a;
    }
    public static long nl() {return fsc.nextLong();}
    public static long[] nl(final int n) {
        final long[] a = new long[n];
        for (int i = 0; i < n; i++) a[i] = fsc.nextLong();
        return a;
    }
    public static long[] nl(final int n, final LongUnaryOperator f) {
        final long[] a = new long[n];
        for (int i = 0; i < n; i++) a[i] = f.applyAsLong(fsc.nextLong());
        return a;
    }
    public static long[][] nl(final int n, final int m) {
        final long[][] a = new long[n][m];
        for (int i = 0; i < n; i++) a[i] = nl(m);
        return a;
    }
    public static long[][] nl(final int n, final int m, final LongUnaryOperator f) {
        final long[][] a = new long[n][m];
        for (int i = 0; i < n; i++) a[i] = nl(m, f);
        return a;
    }
    public static char[] nc() {return fsc.next().toCharArray();}
    public static char[][] nc(final int n) {
        final char[][] c = new char[n][];
        for (int i = 0; i < n; i++) c[i] = nc();
        return c;
    }
    public static double nd() {return fsc.nextDouble();}
    public static double[] nd(final int n) {
        final double[] a = new double[n];
        for (int i = 0; i < n; i++) a[i] = fsc.nextDouble();
        return a;
    }
    public static double[][] nd(final int n, final int m) {
        final double[][] a = new double[n][m];
        for (int i = 0; i < n; i++) a[i] = nd(m);
        return a;
    }
    public static String ns() {return fsc.next();}
    public static String[] ns(final int n) {
        final String[] s = new String[n];
        for (int i = 0; i < n; i++) s[i] = fsc.next();
        return s;
    }
    public static boolean[][] grid(final int h, final int w, final char trueCharacter) {
        final boolean[][] grid = new boolean[h][w];
        for (int i = 0; i < h; i++) {
            final char[] s = fsc.next().toCharArray();
            for (int j = 0; j < w; j++) grid[i][j] = s[j] == trueCharacter;
        }
        return grid;
    }
}


final class FastScanner {
    private final InputStream in = System.in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;
    private boolean hasNextByte() {
        if (ptr < buflen) return true;
        ptr = 0;
        try {buflen = in.read(buffer);}
        catch (final IOException e) {e.printStackTrace();}
        return buflen > 0;
    }
    private int readByte() {return hasNextByte() ? buffer[ptr++] : -1;}
    public boolean hasNext() {
        while (hasNextByte() && !(33 <= buffer[ptr] && buffer[ptr] <= 126)) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new NoSuchElementException();
        final StringBuilder sb = new StringBuilder();
        int b = readByte();
        while (33 <= b && b <= 126) {sb.appendCodePoint(b); b = readByte();}
        return sb.toString();
    }
    public long nextLong() {
        if (!hasNext()) throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {minus = true; b = readByte();}
        if (b < '0' || '9' < b) throw new NumberFormatException();
        for (; ; b = readByte()) {
            if ('0' <= b && b <= '9') n = n * 10 + b - '0';
            else if (b == -1 || !(33 <= b && b <= 126)) return minus ? -n : n;
            else throw new NumberFormatException();
        }
    }
    public int nextInt() {return Math.toIntExact(nextLong());}
    public double nextDouble() {return Double.parseDouble(next());}
}


/**
 * @author https://atcoder.jp/users/suisen
 * 
 * Queue for long type.
 */
final class LongQueue implements Iterable<Long> {
    private static final int DEFAULT_SIZE = 64;
    private long[] q;
    private int head = 0, tail = 0;
    public LongQueue(final int capacity) {this.q = new long[capacity];}
    public LongQueue() {this(DEFAULT_SIZE);}
    public long peek() {
        if (head == tail) throw new NoSuchElementException("No Elements.");
        return q[head];
    }
    public long getFromHead(int index) {
        if (head + index >= tail || index < 0) throw new NoSuchElementException("Index out of bounds.");
        return q[head + index];
    }
    public long getFromTail(int index) {
        if (head + index >= tail || index < 0) throw new NoSuchElementException("Index out of bounds.");
        return q[tail - 1 - index];
    }
    public void add(final long v) {
        if (tail == q.length) grow();
        q[tail++] = v;
    }
    public void add(final long... vals) {for (long v : vals) add(v);}
    public long poll() {
        if (head == tail) throw new NoSuchElementException("No Elements.");
        return q[head++];
    }
    public int size() {return tail - head;}
    public void clear() {head = tail = 0;}
    private void grow() {
        final long[] grown = new long[q.length << 1];
        final int len = size();
        System.arraycopy(q, head, grown, 0, len);
        q = grown;
        tail = len;
        head = 0;
    }
    public PrimitiveIterator.OfLong iterator() {return new LongQueueIterator();}
    private class LongQueueIterator implements PrimitiveIterator.OfLong {
        private int i = head;
        public boolean hasNext() {return i < tail;}
        public long nextLong() {return q[i++];}
    }
}


class Out {
    private final OutputStream out;
    private byte[] buf = new byte[1024];
    private int ptr = 0;
    private static final int AUTO_FLUSH_THRETHOLD = 1 << 17;

    public Out(OutputStream out) {
        this.out = out;
    }

    public void flush() {
        try {
            out.write(buf, 0, ptr);
            out.flush();
            ptr = 0;
        } catch (IOException e) {e.printStackTrace();}
    }

    public void close() {
        try {out.close();} catch (IOException e) {e.printStackTrace();}
    }

    public Out write(Object o) {
        return write(o.toString());
    }

    public Out write(String s) {
        try {
            Field strValueField = s.getClass().getDeclaredField("value");
            strValueField.setAccessible(true);
            byte[] b = (byte[]) strValueField.get(s);
            int l = s.length();
            if (l > AUTO_FLUSH_THRETHOLD) {
                flush();
                int i = 0;
                while (i + AUTO_FLUSH_THRETHOLD < l) {
                    out.write(b, i, AUTO_FLUSH_THRETHOLD);
                    out.flush();
                    i += AUTO_FLUSH_THRETHOLD;
                }
                ensureCapacity(l - i);
                System.arraycopy(b, i, buf, 0, l - i);
                ptr = l - i;
            } else {
                ensureCapacity(ptr + l);
                System.arraycopy(b, 0, buf, ptr, l);
                ptr += l;
            }
        } catch (Exception e) {e.printStackTrace();}
        return this;
    }

    public Out write(char[] c) {
        int l = c.length;
        if (l > AUTO_FLUSH_THRETHOLD) {
            flush();
            ensureCapacity(AUTO_FLUSH_THRETHOLD);
            int i = 0;
            while (i + AUTO_FLUSH_THRETHOLD < l) {
                for (int j = 0; j < AUTO_FLUSH_THRETHOLD; j++) {
                    buf[ptr++] = (byte) c[i + j];
                }
                flush();
                i += AUTO_FLUSH_THRETHOLD;
            }
            for (; i < l; i++) {
                buf[ptr++] = (byte) c[i];
            }
        } else {
            ensureCapacity(ptr + l);
            for (char ch : c) buf[ptr++] = (byte) ch;
        }
        return this;
    }

    public Out write(char c) {
        ensureCapacity(ptr + 1);
        buf[ptr++] = (byte) c;
        return this;
    }

    public Out write(byte b) {
        ensureCapacity(ptr + 1);
        buf[ptr++] = b;
        return this;
    }

    public Out write(int x) {
        if (x == 0) {
            ensureCapacity(ptr + 1);
            buf[ptr++] = '0';
            return this;
        }
        int d = stringSize(x);
        ensureCapacity(ptr + d);
        if (x < 0) {
            buf[ptr++] = '-';
            x = -x;
            d--;
        }
        int j = ptr + d; 
        while (x > 0) {
            buf[--j] = (byte) ('0' + (x % 10));
            x /= 10;
        }
        ptr += d;
        return this;
    }

    public Out write(long x) {
        if (x == 0) {
            ensureCapacity(ptr + 1);
            buf[ptr++] = '0';
            return this;
        }
        int d = stringSize(x);
        ensureCapacity(ptr + d);
        if (x < 0) {
            buf[ptr++] = '-';
            x = -x;
            d--;
        }
        int j = ptr + d; 
        while (x > 0) {
            buf[--j] = (byte) ('0' + (x % 10));
            x /= 10;
        }
        ptr += d;
        return this;
    }

    public Out write(double d) {
        return write(Double.toString(d));
    }

    private void ensureCapacity(int cap) {
        if (cap > AUTO_FLUSH_THRETHOLD) {
            flush();
        }
        if (cap >= buf.length) {
            int newLength = buf.length;
            while (newLength < cap) newLength <<= 1;
            byte[] newBuf = new byte[newLength];
            System.arraycopy(buf, 0, newBuf, 0, buf.length);
            buf = newBuf;
        }
    }
    private static int stringSize(long x) {
        int d = 1;
        if (x >= 0) {d = 0; x = -x;}
        long p = -10;
        for (int i = 1; i < 19; i++, p *= 10) if (x > p) return i + d;
        return 19 + d;
    }
    private static int stringSize(int x) {
        int d = 1;
        if (x >= 0) {d = 0; x = -x;}
        int p = -10;
        for (int i = 1; i < 10; i++, p *= 10) if (x > p) return i + d;
        return 10 + d;
    }
}

</source>
<source file="../hum_codes_raw/s268695582.java" startline="1" endline="407" pcid="8996">
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.lang.reflect.Field;
import java.util.NoSuchElementException;
import java.util.PrimitiveIterator;
import java.util.function.IntUnaryOperator;
import java.util.function.LongUnaryOperator;
import static java.lang.Math.max;

public class Main {
    public static void main(String[] args) throws Exception {
        Field f = System.out.getClass().getDeclaredField("autoFlush");
        f.setAccessible(true);
        f.set(System.out, false);
        Out out = new Out(System.out);
        solve(new FastScanner(), out);
        out.flush();
        out.close();
    }

    public static void solve(FastScanner fsc, Out out) {
        int n = fsc.nextInt();
        int[] v = new int[0x40000];
        int[] w = new int[0x40000];
        for (int i = 1; i <= n; i++) {
            v[i] = fsc.nextInt();
            w[i] = fsc.nextInt();
        }
        int lmax = 100001;
        int[] memo = new int[0x200 * lmax];
        for (int i = 1; i < 0x200; i++) {
            for (int j = 1; j < lmax; j++) {
                if (j >= w[i]) {
                    memo[i * lmax + j] = max(memo[(i >> 1) * lmax + j], memo[(i >> 1) * lmax + j - w[i]] + v[i]);
                } else {
                    memo[i * lmax + j] = memo[(i >> 1) * lmax + j];
                }
                memo[i * lmax + j] = max(memo[i * lmax + j], memo[i * lmax + j - 1]);
            }
        }
        int q = fsc.nextInt();
        LongQueue que = new LongQueue(0x200);
        while (q --> 0) {
            int x = fsc.nextInt();
            int m = fsc.nextInt();
            que.add(0);
            int max = 0;
            for (; x >= 0x200; x >>= 1) {
                int sz = que.size();
                while (sz --> 0) {
                    long vw = que.poll();
                    if ((vw & 0xffff_ffffl) + w[x] <= m) que.add(vw + ((long) v[x] << 32) + w[x]);
                    que.add(vw);
                }
            }
            while (que.size() > 0) {
                long vw = que.poll();
                int vs = (int) (vw >>> 32);
                int ws = (int) (vw & 0xffff_ffffl);
                max = max(max, vs + memo[x * lmax + m - ws]);
            }
            out.write(max).write('\n');
            que.clear();
        }
    }
}


/**
 * @author https://atcoder.jp/users/suisen
 */
final class In {
    public static final FastScanner fsc = new FastScanner();
    public static int ni() {return fsc.nextInt();}
    public static int[] ni(final int n) {
        final int[] a = new int[n];
        for (int i = 0; i < n; i++) a[i] = fsc.nextInt();
        return a;
    }
    public static int[] ni(final int n, final IntUnaryOperator f) {
        final int[] a = new int[n];
        for (int i = 0; i < n; i++) a[i] = f.applyAsInt(fsc.nextInt());
        return a;
    }
    public static int[][] ni(final int n, final int m) {
        final int[][] a = new int[n][m];
        for (int i = 0; i < n; i++) a[i] = ni(m);
        return a;
    }
    public static int[][] ni(final int n, final int m, final IntUnaryOperator f) {
        final int[][] a = new int[n][m];
        for (int i = 0; i < n; i++) a[i] = ni(m, f);
        return a;
    }
    public static long nl() {return fsc.nextLong();}
    public static long[] nl(final int n) {
        final long[] a = new long[n];
        for (int i = 0; i < n; i++) a[i] = fsc.nextLong();
        return a;
    }
    public static long[] nl(final int n, final LongUnaryOperator f) {
        final long[] a = new long[n];
        for (int i = 0; i < n; i++) a[i] = f.applyAsLong(fsc.nextLong());
        return a;
    }
    public static long[][] nl(final int n, final int m) {
        final long[][] a = new long[n][m];
        for (int i = 0; i < n; i++) a[i] = nl(m);
        return a;
    }
    public static long[][] nl(final int n, final int m, final LongUnaryOperator f) {
        final long[][] a = new long[n][m];
        for (int i = 0; i < n; i++) a[i] = nl(m, f);
        return a;
    }
    public static char[] nc() {return fsc.next().toCharArray();}
    public static char[][] nc(final int n) {
        final char[][] c = new char[n][];
        for (int i = 0; i < n; i++) c[i] = nc();
        return c;
    }
    public static double nd() {return fsc.nextDouble();}
    public static double[] nd(final int n) {
        final double[] a = new double[n];
        for (int i = 0; i < n; i++) a[i] = fsc.nextDouble();
        return a;
    }
    public static double[][] nd(final int n, final int m) {
        final double[][] a = new double[n][m];
        for (int i = 0; i < n; i++) a[i] = nd(m);
        return a;
    }
    public static String ns() {return fsc.next();}
    public static String[] ns(final int n) {
        final String[] s = new String[n];
        for (int i = 0; i < n; i++) s[i] = fsc.next();
        return s;
    }
    public static boolean[][] grid(final int h, final int w, final char trueCharacter) {
        final boolean[][] grid = new boolean[h][w];
        for (int i = 0; i < h; i++) {
            final char[] s = fsc.next().toCharArray();
            for (int j = 0; j < w; j++) grid[i][j] = s[j] == trueCharacter;
        }
        return grid;
    }
}


final class FastScanner {
    private final InputStream in = System.in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;
    private boolean hasNextByte() {
        if (ptr < buflen) return true;
        ptr = 0;
        try {buflen = in.read(buffer);}
        catch (final IOException e) {e.printStackTrace();}
        return buflen > 0;
    }
    private int readByte() {return hasNextByte() ? buffer[ptr++] : -1;}
    public boolean hasNext() {
        while (hasNextByte() && !(33 <= buffer[ptr] && buffer[ptr] <= 126)) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new NoSuchElementException();
        final StringBuilder sb = new StringBuilder();
        int b = readByte();
        while (33 <= b && b <= 126) {sb.appendCodePoint(b); b = readByte();}
        return sb.toString();
    }
    public long nextLong() {
        if (!hasNext()) throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {minus = true; b = readByte();}
        if (b < '0' || '9' < b) throw new NumberFormatException();
        for (; ; b = readByte()) {
            if ('0' <= b && b <= '9') n = n * 10 + b - '0';
            else if (b == -1 || !(33 <= b && b <= 126)) return minus ? -n : n;
            else throw new NumberFormatException();
        }
    }
    public int nextInt() {return Math.toIntExact(nextLong());}
    public double nextDouble() {return Double.parseDouble(next());}
}


/**
 * @author https://atcoder.jp/users/suisen
 * 
 * Queue for long type.
 */
final class LongQueue implements Iterable<Long> {
    private static final int DEFAULT_SIZE = 64;
    private long[] q;
    private int head = 0, tail = 0;
    public LongQueue(final int capacity) {this.q = new long[capacity];}
    public LongQueue() {this(DEFAULT_SIZE);}
    public long peek() {
        if (head == tail) throw new NoSuchElementException("No Elements.");
        return q[head];
    }
    public long getFromHead(int index) {
        if (head + index >= tail || index < 0) throw new NoSuchElementException("Index out of bounds.");
        return q[head + index];
    }
    public long getFromTail(int index) {
        if (head + index >= tail || index < 0) throw new NoSuchElementException("Index out of bounds.");
        return q[tail - 1 - index];
    }
    public void add(final long v) {
        if (tail == q.length) grow();
        q[tail++] = v;
    }
    public void add(final long... vals) {for (long v : vals) add(v);}
    public long poll() {
        if (head == tail) throw new NoSuchElementException("No Elements.");
        return q[head++];
    }
    public int size() {return tail - head;}
    public void clear() {head = tail = 0;}
    private void grow() {
        final long[] grown = new long[q.length << 1];
        final int len = size();
        System.arraycopy(q, head, grown, 0, len);
        q = grown;
        tail = len;
        head = 0;
    }
    public PrimitiveIterator.OfLong iterator() {return new LongQueueIterator();}
    private class LongQueueIterator implements PrimitiveIterator.OfLong {
        private int i = head;
        public boolean hasNext() {return i < tail;}
        public long nextLong() {return q[i++];}
    }
}


class Out {
    private final OutputStream out;
    private byte[] buf = new byte[1024];
    private int ptr = 0;
    private static final int AUTO_FLUSH_THRETHOLD = 1 << 17;

    public Out(OutputStream out) {
        this.out = out;
    }

    public void flush() {
        try {
            out.write(buf, 0, ptr);
            out.flush();
            ptr = 0;
        } catch (IOException e) {e.printStackTrace();}
    }

    public void close() {
        try {out.close();} catch (IOException e) {e.printStackTrace();}
    }

    public Out write(Object o) {
        return write(o.toString());
    }

    public Out write(String s) {
        try {
            Field strValueField = s.getClass().getDeclaredField("value");
            strValueField.setAccessible(true);
            byte[] b = (byte[]) strValueField.get(s);
            int l = s.length();
            if (l > AUTO_FLUSH_THRETHOLD) {
                flush();
                int i = 0;
                while (i + AUTO_FLUSH_THRETHOLD < l) {
                    out.write(b, i, AUTO_FLUSH_THRETHOLD);
                    out.flush();
                    i += AUTO_FLUSH_THRETHOLD;
                }
                ensureCapacity(l - i);
                System.arraycopy(b, i, buf, 0, l - i);
                ptr = l - i;
            } else {
                ensureCapacity(ptr + l);
                System.arraycopy(b, 0, buf, ptr, l);
                ptr += l;
            }
        } catch (Exception e) {e.printStackTrace();}
        return this;
    }

    public Out write(char[] c) {
        int l = c.length;
        if (l > AUTO_FLUSH_THRETHOLD) {
            flush();
            ensureCapacity(AUTO_FLUSH_THRETHOLD);
            int i = 0;
            while (i + AUTO_FLUSH_THRETHOLD < l) {
                for (int j = 0; j < AUTO_FLUSH_THRETHOLD; j++) {
                    buf[ptr++] = (byte) c[i + j];
                }
                flush();
                i += AUTO_FLUSH_THRETHOLD;
            }
            for (; i < l; i++) {
                buf[ptr++] = (byte) c[i];
            }
        } else {
            ensureCapacity(ptr + l);
            for (char ch : c) buf[ptr++] = (byte) ch;
        }
        return this;
    }

    public Out write(char c) {
        ensureCapacity(ptr + 1);
        buf[ptr++] = (byte) c;
        return this;
    }

    public Out write(byte b) {
        ensureCapacity(ptr + 1);
        buf[ptr++] = b;
        return this;
    }

    public Out write(int x) {
        if (x == 0) {
            ensureCapacity(ptr + 1);
            buf[ptr++] = '0';
            return this;
        }
        int d = stringSize(x);
        ensureCapacity(ptr + d);
        if (x < 0) {
            buf[ptr++] = '-';
            x = -x;
            d--;
        }
        int j = ptr + d; 
        while (x > 0) {
            buf[--j] = (byte) ('0' + (x % 10));
            x /= 10;
        }
        ptr += d;
        return this;
    }

    public Out write(long x) {
        if (x == 0) {
            ensureCapacity(ptr + 1);
            buf[ptr++] = '0';
            return this;
        }
        int d = stringSize(x);
        ensureCapacity(ptr + d);
        if (x < 0) {
            buf[ptr++] = '-';
            x = -x;
            d--;
        }
        int j = ptr + d; 
        while (x > 0) {
            buf[--j] = (byte) ('0' + (x % 10));
            x /= 10;
        }
        ptr += d;
        return this;
    }

    public Out write(double d) {
        return write(Double.toString(d));
    }

    private void ensureCapacity(int cap) {
        if (cap > AUTO_FLUSH_THRETHOLD) {
            flush();
        }
        if (cap >= buf.length) {
            int newLength = buf.length;
            while (newLength < cap) newLength <<= 1;
            byte[] newBuf = new byte[newLength];
            System.arraycopy(buf, 0, newBuf, 0, buf.length);
            buf = newBuf;
        }
    }
    private static int stringSize(long x) {
        int d = 1;
        if (x >= 0) {d = 0; x = -x;}
        long p = -10;
        for (int i = 1; i < 19; i++, p *= 10) if (x > p) return i + d;
        return 19 + d;
    }
    private static int stringSize(int x) {
        int d = 1;
        if (x >= 0) {d = 0; x = -x;}
        int p = -10;
        for (int i = 1; i < 10; i++, p *= 10) if (x > p) return i + d;
        return 10 + d;
    }
}

</source>
</class>

<class classid="34" nclones="2" nlines="21" similarity="100">
<source file="../hum_codes_raw/s039841887.java" startline="1" endline="25" pcid="1344">

import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int k = sc.nextInt();
		long t = 0;
		long ans = 0;
		if (k % 2 == 0) {
			t = n / k;
			ans += (t * t * t);
			t = ((n*2) / k +1)/2;
			ans += (t * t * t);
		} else {
			t = n / k;
			ans += (t * t * t);
		}

		System.out.println(ans);

	}
}

</source>
<source file="../hum_codes_raw/s717718126.java" startline="1" endline="24" pcid="24128">
import java.util.Scanner;
 
public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int k = sc.nextInt();
		long t = 0;
		long ans = 0;
		if (k % 2 == 0) {
			t = n / k;
			ans += (t * t * t);
			t = ((n*2) / k +1)/2;
			ans += (t * t * t);
		} else {
			t = n / k;
			ans += (t * t * t);
		}
 
		System.out.println(ans);
 
	}
}

</source>
</class>

<class classid="35" nclones="2" nlines="37" similarity="100">
<source file="../hum_codes_raw/s040949687.java" startline="1" endline="45" pcid="1377">
import java.util.*;

public class Main{
    void run(){
        Scanner sc = new Scanner(System.in);
        while(true){
            int[] card_num = new int[101];
            int m = sc.nextInt();
            if(m==0){
                break;
            }
            int[] value = new int[m];
            int[] num = new int[m];
            for(int i = 0; i < m; i++){
                value[i] = sc.nextInt();
                num[i] = sc.nextInt();
            }
            int[] dp = new int[1001];
            dp[0] = 1;
            for(int i = 0; i < m; i++){
                for(int ii = 1000 - value[i] -1; ii >= 0; ii--){
                    for(int iii = 1; iii <= num[i]; iii++){
                        if(ii + value[i]*iii <= 1000){
                            dp[ii + value[i]*iii] += dp[ii];
                        }
                    }
                }
            }
            /*
              System.out.println(Arrays.toString(dp));
              for(int i = 0; i < 100; i++){
              System.out.println(i + " : " + dp[i]);
              }
            */
            int g = sc.nextInt();
            for(int i = 0; i < g; i++){
                System.out.println(dp[sc.nextInt()]);
            }
        }
    }
    public static void main(String[] args){
        new Main().run();
    }
}

</source>
<source file="../hum_codes_raw/s207613195.java" startline="1" endline="45" pcid="6998">
import java.util.*;

public class Main{
    void run(){
        Scanner sc = new Scanner(System.in);
        while(true){
            int[] card_num = new int[101];
            int m = sc.nextInt();
            if(m==0){
                break;
            }
            int[] value = new int[m];
            int[] num = new int[m];
            for(int i = 0; i < m; i++){
                value[i] = sc.nextInt();
                num[i] = sc.nextInt();
            }
            int[] dp = new int[1001];
            dp[0] = 1;
            for(int i = 0; i < m; i++){
                for(int ii = 1000 - value[i] -1; ii >= 0; ii--){
                    for(int iii = 1; iii <= num[i]; iii++){
                        if(ii + value[i]*iii <= 1000){
                            dp[ii + value[i]*iii] += dp[ii];
                        }
                    }
                }
            }
            /*
              System.out.println(Arrays.toString(dp));
              for(int i = 0; i < 100; i++){
              System.out.println(i + " : " + dp[i]);
              }
            */
            int g = sc.nextInt();
            for(int i = 0; i < g; i++){
                System.out.println(dp[sc.nextInt()]);
            }
        }
    }
    public static void main(String[] args){
        new Main().run();
    }
}

</source>
</class>

<class classid="36" nclones="2" nlines="14" similarity="100">
<source file="../hum_codes_raw/s041632907.java" startline="1" endline="16" pcid="1396">
import java.util.*;

public class Main {
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int a = sc.nextInt();
        int b = sc.nextInt();
        if(b%a == 0) {
            System.out.println(a + b);
        } else {
            System.out.println(b - a);
        }
    }
}

</source>
<source file="../hum_codes_raw/s659265746.java" startline="1" endline="17" pcid="22140">

import java.util.*;

public class Main {
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int a = sc.nextInt();
        int b = sc.nextInt();
        if(b%a == 0) {
            System.out.println(a + b);
        } else {
            System.out.println(b - a);
        }
    }
}

</source>
</class>

<class classid="37" nclones="2" nlines="100" similarity="100">
<source file="../hum_codes_raw/s043441489.java" startline="1" endline="104" pcid="1446">
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

//Doctor's Memorable Codes
public class Main{

	public static void main(String[] args) {
		Map<String, Character> t = new HashMap<String, Character>();
		t.put("101", ' ');
		t.put("000000", '\'');
		t.put("000011", ',');
		t.put("10010001", '-');
		t.put("010001", '.');
		t.put("000001", '?');
		t.put("100101", 'A');
		t.put("10011010", 'B');
		t.put("0101", 'C');
		t.put("0001", 'D');
		t.put("110", 'E');
		t.put("01001", 'F');
		t.put("10011011", 'G');
		t.put("010000", 'H');
		t.put("0111", 'I');
		t.put("10011000", 'J');
		t.put("0110", 'K');
		t.put("00100", 'L');
		t.put("10011001", 'M');
		t.put("10011110", 'N');
		t.put("00101", 'O');
		t.put("111", 'P');
		t.put("10011111", 'Q');
		t.put("1000", 'R');
		t.put("00110", 'S');
		t.put("00111", 'T');
		t.put("10011100", 'U');
		t.put("10011101", 'V');
		t.put("000010", 'W');
		t.put("10010010", 'X');
		t.put("10010011", 'Y');
		t.put("10010000", 'Z');
		Map<Character, String> r = new HashMap<Character, String>();
		r.put('A', "00000");
		r.put('B', "00001");
		r.put('C', "00010");
		r.put('D', "00011");
		r.put('E', "00100");
		r.put('F', "00101");
		r.put('G', "00110");
		r.put('H', "00111");
		r.put('I', "01000");
		r.put('J', "01001");
		r.put('K', "01010");
		r.put('L', "01011");
		r.put('M', "01100");
		r.put('N', "01101");
		r.put('O', "01110");
		r.put('P', "01111");
		r.put('Q', "10000");
		r.put('R', "10001");
		r.put('S', "10010");
		r.put('T', "10011");
		r.put('U', "10100");
		r.put('V', "10101");
		r.put('W', "10110");
		r.put('X', "10111");
		r.put('Y', "11000");
		r.put('Z', "11001");
		r.put(' ', "11010");
		r.put('.', "11011");
		r.put(',', "11100");
		r.put('-', "11101");
		r.put('\'', "11110");
		r.put('?', "11111");
		Scanner sc = new Scanner(System.in);
		while(sc.hasNext()){
			char[] m = sc.nextLine().toCharArray();
			StringBuilder sb = new StringBuilder();
			for(char c:m)sb.append(r.get(c));
			String s = sb.toString();
			sb = new StringBuilder();
			int i=0;
			while(i<s.length()){
				int k;
				for(k=3;i+k<=s.length();k++){
					String sub = s.substring(i,i+k);
					boolean f = false;
					for(String v : t.keySet()){
						if(v.equals(sub)){
							f = true;
							break;
						}
					}
					if(f)break;
				}
				if(i+k>s.length())break;
				sb.append(t.get(s.substring(i,i+k)));
				i+=k;
			}
			System.out.println(sb);
		}
	}
}

</source>
<source file="../hum_codes_raw/s760882476.java" startline="1" endline="104" pcid="25563">
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

//Doctor's Memorable Codes
public class Main {

	public static void main(String[] args) {
		Map<String, Character> t = new HashMap<String, Character>();
		t.put("101", ' ');
		t.put("000000", '\'');
		t.put("000011", ',');
		t.put("10010001", '-');
		t.put("010001", '.');
		t.put("000001", '?');
		t.put("100101", 'A');
		t.put("10011010", 'B');
		t.put("0101", 'C');
		t.put("0001", 'D');
		t.put("110", 'E');
		t.put("01001", 'F');
		t.put("10011011", 'G');
		t.put("010000", 'H');
		t.put("0111", 'I');
		t.put("10011000", 'J');
		t.put("0110", 'K');
		t.put("00100", 'L');
		t.put("10011001", 'M');
		t.put("10011110", 'N');
		t.put("00101", 'O');
		t.put("111", 'P');
		t.put("10011111", 'Q');
		t.put("1000", 'R');
		t.put("00110", 'S');
		t.put("00111", 'T');
		t.put("10011100", 'U');
		t.put("10011101", 'V');
		t.put("000010", 'W');
		t.put("10010010", 'X');
		t.put("10010011", 'Y');
		t.put("10010000", 'Z');
		Map<Character, String> r = new HashMap<Character, String>();
		r.put('A', "00000");
		r.put('B', "00001");
		r.put('C', "00010");
		r.put('D', "00011");
		r.put('E', "00100");
		r.put('F', "00101");
		r.put('G', "00110");
		r.put('H', "00111");
		r.put('I', "01000");
		r.put('J', "01001");
		r.put('K', "01010");
		r.put('L', "01011");
		r.put('M', "01100");
		r.put('N', "01101");
		r.put('O', "01110");
		r.put('P', "01111");
		r.put('Q', "10000");
		r.put('R', "10001");
		r.put('S', "10010");
		r.put('T', "10011");
		r.put('U', "10100");
		r.put('V', "10101");
		r.put('W', "10110");
		r.put('X', "10111");
		r.put('Y', "11000");
		r.put('Z', "11001");
		r.put(' ', "11010");
		r.put('.', "11011");
		r.put(',', "11100");
		r.put('-', "11101");
		r.put('\'', "11110");
		r.put('?', "11111");
		Scanner sc = new Scanner(System.in);
		while(sc.hasNext()){
			char[] m = sc.nextLine().toCharArray();
			StringBuilder sb = new StringBuilder();
			for(char c:m)sb.append(r.get(c));
			String s = sb.toString();
			sb = new StringBuilder();
			int i=0;
			while(i<s.length()){
				int k;
				for(k=3;i+k<=s.length();k++){
					String sub = s.substring(i,i+k);
					boolean f = false;
					for(String v : t.keySet()){
						if(v.equals(sub)){
							f = true;
							break;
						}
					}
					if(f)break;
				}
				if(i+k>s.length())break;
				sb.append(t.get(s.substring(i,i+k)));
				i+=k;
			}
			System.out.println(sb);
		}
	}
}

</source>
</class>

<class classid="38" nclones="2" nlines="63" similarity="100">
<source file="../hum_codes_raw/s043731904.java" startline="1" endline="92" pcid="1453">
import java.io.BufferedReader; 
import java.io.*;
import java.io.InputStreamReader; 
import java.util.Scanner; 
import java.util.StringTokenizer; 
import java.util.*;
import java.math.*;
public class Main 
{ 
    static class FastReader 
    { 
        BufferedReader br; 
        StringTokenizer st; 
  
        public FastReader()
        { 
            br = new BufferedReader(new
                     InputStreamReader(System.in)); 
        } 
  
        String next()
        { 
            while (st == null || !st.hasMoreElements()) 
            { 
                try
                { 
                    st = new StringTokenizer(br.readLine()); 
                } 
                catch (IOException  e) 
                { 
                    e.printStackTrace(); 
                } 
            } 
            return st.nextToken(); 
        } 
  
        int nextInt() 
        { 
            return Integer.parseInt(next()); 
        } 
  
        long nextLong() 
        { 
            return Long.parseLong(next()); 
        } 
  
        double nextDouble() 
        { 
            return Double.parseDouble(next()); 
        } 
  
        String nextLine() 
        { 
            String str = ""; 
            try
            { 
                str = br.readLine();
            } 
            catch (IOException e) 
            { 
                e.printStackTrace(); 
            } 
            return str; 
        } 
    } 
   public static void main(String args[])
    {
        FastReader sc=new FastReader();
        PrintWriter pw=new PrintWriter(System.out);
        int t=1;//sc.nextInt();
        while(t-->0)
        {
           int n=sc.nextInt(),f=0,a[]=new int[n];
           for(int i=0;i<n;i++)
           {
             a[i]=sc.nextInt();
           }int ans[]=new int[n],p=0,q=n-1;
           for(int i=n-1;i>=0;i-=2)
           {
             ans[p++]=a[i];
             if(i-1>=0)
             ans[q--]=a[i-1];
           }
           for(int w:ans)
           pw.print(w+" ");
           pw.println();
        }
           pw.close();
    }
}
  

</source>
<source file="../hum_codes_raw/s500506438.java" startline="1" endline="92" pcid="16774">
import java.io.BufferedReader; 
import java.io.*;
import java.io.InputStreamReader; 
import java.util.Scanner; 
import java.util.StringTokenizer; 
import java.util.*;
import java.math.*;
public class Main 
{ 
    static class FastReader 
    { 
        BufferedReader br; 
        StringTokenizer st; 
  
        public FastReader()
        { 
            br = new BufferedReader(new
                     InputStreamReader(System.in)); 
        } 
  
        String next()
        { 
            while (st == null || !st.hasMoreElements()) 
            { 
                try
                { 
                    st = new StringTokenizer(br.readLine()); 
                } 
                catch (IOException  e) 
                { 
                    e.printStackTrace(); 
                } 
            } 
            return st.nextToken(); 
        } 
  
        int nextInt() 
        { 
            return Integer.parseInt(next()); 
        } 
  
        long nextLong() 
        { 
            return Long.parseLong(next()); 
        } 
  
        double nextDouble() 
        { 
            return Double.parseDouble(next()); 
        } 
  
        String nextLine() 
        { 
            String str = ""; 
            try
            { 
                str = br.readLine();
            } 
            catch (IOException e) 
            { 
                e.printStackTrace(); 
            } 
            return str; 
        } 
    } 
   public static void main(String args[])
    {
        FastReader sc=new FastReader();
        PrintWriter pw=new PrintWriter(System.out);
        int t=1;//sc.nextInt();
        while(t-->0)
        {
           int n=sc.nextInt(),f=0,a[]=new int[n];
           for(int i=0;i<n;i++)
           {
             a[i]=sc.nextInt();
           }int ans[]=new int[n],p=0,q=n-1;
           for(int i=n-1;i>=0;i-=2)
           {
             ans[p++]=a[i];
             if(i-1>=0)
             ans[q--]=a[i-1];
           }
           for(int w:ans)
           pw.print(w+" ");
           pw.println();
        }
           pw.close();
    }
}
  

</source>
</class>

<class classid="39" nclones="3" nlines="91" similarity="100">
<source file="../hum_codes_raw/s043913838.java" startline="1" endline="135" pcid="1462">
import java.util.*;
import java.lang.*;
import java.io.*;

class Main{

    private static int[][] used;
    private static int N,M,L;
    private static List<Pox>[] list;
    private static final int INF = 100000000;

    private static class Pox{
	public int B,D,E;
	Pox(){
	    B = D = E = 0;
	}

	Pox(int b,int d,int e){
	    B = b;
	    D = d;
	    E = e;
	}
    }

    private static class Eleac implements Comparable<Eleac>{
	public int id,L,num;

	Eleac(){
	    id = L = num = 0;
	}

	Eleac(int a,int b,int c){
	    id = a;
	    L = b;
	    num = c;
	}

	@Override
	public int compareTo(Eleac a){
	    return 1;
	}

    }

     @SuppressWarnings("unchecked")
      public static void main(String args[])throws IOException{
	  BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
	  
	  while(true)
	      {
		  String[] elements = in.readLine().split(" ");
		  N = Integer.parseInt(elements[0]);
		  M = Integer.parseInt(elements[1]);
		  L = Integer.parseInt(elements[2]);
		  if(N == 0 && M == 0 && L == 0)
		      break;

		  

		  used = new int[N+1][L+1];
		  list = new ArrayList[N+2];

		  for(int i=0;i<N+1;i++)
		      for(int j=0;j<L+1;j++)
			  used[i][j] = INF;

		  for(int i=0;i<N+1;i++)
		      list[i] = new ArrayList<Pox>();
		  
		  for(int i=0;i<M;i++)
		      {
			 elements = in.readLine().split(" ");
			 int A,B,D,E;
			  A = Integer.parseInt(elements[0]);
			  B = Integer.parseInt(elements[1]);
			  D = Integer.parseInt(elements[2]);
			  E = Integer.parseInt(elements[3]);

			  list[A].add(new Pox(B,D,E));  
			  list[B].add(new Pox(A,D,E));
		      }

		  Queue<Eleac> que = new PriorityQueue<Eleac>();

		  que.offer(new Eleac(1,L,0)); //Eleac(id,money,the number of eemy)
		  used[1][L] = 0;		

		  int men = INF;
		  while(que.size() > 0)
		      {
			  Eleac p = que.poll(); 
			  int now = p.id;
			  int money = p.L;
			  int val = p.num;
			  
			  if(now == N)
			      {
				  used[now][money] = Math.min(used[now][money],val);	
				  continue;
			      }
		      
			 
			  for(int i=0;i<list[now].size();i++)
			      {
				  int need = list[now].get(i).D;

				  int new_pos = list[now].get(i).B;
				  int the_number = list[now].get(i).E;
				  
				  if(money-need >= 0 && used[new_pos][money-need] > val)
				      {
					  used[new_pos][money-need] = val;
					  que.add(new Eleac(new_pos,money-need,val));
				      }				  	
				  if(used[new_pos][money] > val+the_number)
				      {
					  used[new_pos][money] = val+the_number;
					  que.add(new Eleac(new_pos,money,val+the_number));
				      }

			      }

		      
		      }

		  for(int i=0;i<=L;i++)
		      {
			  men = Math.min(men,used[N][i]);
		      }
		  System.out.println(men);
	      }
      }

}

</source>
<source file="../hum_codes_raw/s983391347.java" startline="1" endline="135" pcid="33069">
import java.util.*;
import java.lang.*;
import java.io.*;

class Main{

    private static int[][] used;
    private static int N,M,L;
    private static List<Pox>[] list;
    private static final int INF = 100000000;

    private static class Pox{
	public int B,D,E;
	Pox(){
	    B = D = E = 0;
	}

	Pox(int b,int d,int e){
	    B = b;
	    D = d;
	    E = e;
	}
    }

    private static class Eleac implements Comparable<Eleac>{
	public int id,L,num;

	Eleac(){
	    id = L = num = 0;
	}

	Eleac(int a,int b,int c){
	    id = a;
	    L = b;
	    num = c;
	}

	@Override
	public int compareTo(Eleac a){
	    return 1;
	}

    }

     @SuppressWarnings("unchecked")
      public static void main(String args[])throws IOException{
	  BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
	  
	  while(true)
	      {
		  String[] elements = in.readLine().split(" ");
		  N = Integer.parseInt(elements[0]);
		  M = Integer.parseInt(elements[1]);
		  L = Integer.parseInt(elements[2]);
		  if(N == 0 && M == 0 && L == 0)
		      break;

		  

		  used = new int[N+1][L+1];
		  list = new ArrayList[N+2];

		  for(int i=0;i<N+1;i++)
		      for(int j=0;j<L+1;j++)
			  used[i][j] = INF;

		  for(int i=0;i<N+1;i++)
		      list[i] = new ArrayList<Pox>();
		  
		  for(int i=0;i<M;i++)
		      {
			 elements = in.readLine().split(" ");
			 int A,B,D,E;
			  A = Integer.parseInt(elements[0]);
			  B = Integer.parseInt(elements[1]);
			  D = Integer.parseInt(elements[2]);
			  E = Integer.parseInt(elements[3]);

			  list[A].add(new Pox(B,D,E));  
			  list[B].add(new Pox(A,D,E));
		      }

		  Queue<Eleac> que = new PriorityQueue<Eleac>();

		  que.offer(new Eleac(1,L,0)); //Eleac(id,money,the number of eemy)
		  used[1][L] = 0;		

		  int men = INF;
		  while(que.size() > 0)
		      {
			  Eleac p = que.poll(); 
			  int now = p.id;
			  int money = p.L;
			  int val = p.num;
			  
			  if(now == N)
			      {
				  used[now][money] = Math.min(used[now][money],val);	
				  continue;
			      }
		      
			 
			  for(int i=0;i<list[now].size();i++)
			      {
				  int need = list[now].get(i).D;

				  int new_pos = list[now].get(i).B;
				  int the_number = list[now].get(i).E;
				  
				  if(money-need >= 0 && used[new_pos][money-need] > val)
				      {
					  used[new_pos][money-need] = val;
					  que.add(new Eleac(new_pos,money-need,val));
				      }				  	
				  if(used[new_pos][money] > val+the_number)
				      {
					  used[new_pos][money] = val+the_number;
					  que.add(new Eleac(new_pos,money,val+the_number));
				      }

			      }

		      
		      }

		  for(int i=0;i<=L;i++)
		      {
			  men = Math.min(men,used[N][i]);
		      }
		  System.out.println(men);
	      }
      }

}

</source>
<source file="../hum_codes_raw/s133051952.java" startline="1" endline="135" pcid="4440">
import java.util.*;
import java.lang.*;
import java.io.*;
 
class Main{
 
    private static int[][] used;
    private static int N,M,L;
    private static List<Pox>[] list;
    private static final int INF = 100000000;
 
    private static class Pox{
    public int B,D,E;
    Pox(){
        B = D = E = 0;
    }
 
    Pox(int b,int d,int e){
        B = b;
        D = d;
        E = e;
    }
    }
 
    private static class Eleac implements Comparable<Eleac>{
    public int id,L,num;
 
    Eleac(){
        id = L = num = 0;
    }
 
    Eleac(int a,int b,int c){
        id = a;
        L = b;
        num = c;
    }
 
    @Override
    public int compareTo(Eleac a){
        return 1;
    }
 
    }
 
     @SuppressWarnings("unchecked")
      public static void main(String args[])throws IOException{
      BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
       
      while(true)
          {
          String[] elements = in.readLine().split(" ");
          N = Integer.parseInt(elements[0]);
          M = Integer.parseInt(elements[1]);
          L = Integer.parseInt(elements[2]);
          if(N == 0 && M == 0 && L == 0)
              break;
 
           
 
          used = new int[N+1][L+1];
          list = new ArrayList[N+2];
 
          for(int i=0;i<N+1;i++)
              for(int j=0;j<L+1;j++)
              used[i][j] = INF;
 
          for(int i=0;i<N+1;i++)
              list[i] = new ArrayList<Pox>();
           
          for(int i=0;i<M;i++)
              {
             elements = in.readLine().split(" ");
             int A,B,D,E;
              A = Integer.parseInt(elements[0]);
              B = Integer.parseInt(elements[1]);
              D = Integer.parseInt(elements[2]);
              E = Integer.parseInt(elements[3]);
 
              list[A].add(new Pox(B,D,E));  
              list[B].add(new Pox(A,D,E));
              }
 
          Queue<Eleac> que = new PriorityQueue<Eleac>();
 
          que.offer(new Eleac(1,L,0)); //Eleac(id,money,the number of eemy)
          used[1][L] = 0;       
 
          int men = INF;
          while(que.size() > 0)
              {
              Eleac p = que.poll(); 
              int now = p.id;
              int money = p.L;
              int val = p.num;
               
              if(now == N)
                  {
                  used[now][money] = Math.min(used[now][money],val);    
                  continue;
                  }
               
              
              for(int i=0;i<list[now].size();i++)
                  {
                  int need = list[now].get(i).D;
 
                  int new_pos = list[now].get(i).B;
                  int the_number = list[now].get(i).E;
                   
                  if(money-need >= 0 && used[new_pos][money-need] > val)
                      {
                      used[new_pos][money-need] = val;
                      que.add(new Eleac(new_pos,money-need,val));
                      }                 
                  if(used[new_pos][money] > val+the_number)
                      {
                      used[new_pos][money] = val+the_number;
                      que.add(new Eleac(new_pos,money,val+the_number));
                      }
 
                  }
 
               
              }
 
          for(int i=0;i<=L;i++)
              {
              men = Math.min(men,used[N][i]);
              }
          System.out.println(men);
          }
      }
 
}

</source>
</class>

<class classid="40" nclones="2" nlines="242" similarity="100">
<source file="../hum_codes_raw/s045421668.java" startline="1" endline="290" pcid="1506">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.util.Deque;
import java.util.ArrayList;
import java.io.UncheckedIOException;
import java.util.List;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.ArrayDeque;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            CThreeCircuits solver = new CThreeCircuits();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class CThreeCircuits {
        Deque<Node> trace = new ArrayDeque<>();

        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            int m = in.readInt();
            int[] deg = new int[n];
            Node[] nodes = new Node[n];
            for (int i = 0; i < n; i++) {
                nodes[i] = new Node();
            }
            for (int i = 0; i < m; i++) {
                int a = in.readInt() - 1;
                int b = in.readInt() - 1;
                deg[a]++;
                deg[b]++;
                Edge e = new Edge();
                e.a = nodes[a];
                e.b = nodes[b];
                e.a.adj.add(e);
                e.b.adj.add(e);
            }

            String no = "No";
            String yes = "Yes";
            for (int i = 0; i < n; i++) {
                if (deg[i] % 2 == 1) {
                    out.println("No");
                    return;
                }
            }


            List<Node> xy = new ArrayList<>(2);
            for (int i = 0; i < n; i++) {
                if (deg[i] >= 6) {
                    out.println(yes);
                    return;
                }
                if (deg[i] == 4) {
                    xy.add(nodes[i]);
                }
            }

            if (xy.size() >= 3) {
                out.println(yes);
                return;
            }
            if (xy.size() <= 1) {
                out.println(no);
                return;
            }

            dfs(nodes[0]);
            List<Node> list = new ArrayList<>(trace);
            SequenceUtils.reverse(list);

            List<Node> compressed = new ArrayList<>();
            for (Node node : list) {
                if (xy.contains(node)) {
                    compressed.add(node);
                }
            }

            if (compressed.get(0) == compressed.get(1) || compressed.get(1) == compressed.get(2)) {
                out.println(yes);
            } else {
                out.println(no);
            }
        }

        public void dfs(Node root) {
            while (!root.adj.isEmpty()) {
                Edge tail = root.adj.remove(root.adj.size() - 1);
                if (tail.handled) {
                    continue;
                }
                tail.handled = true;
                Node node = tail.other(root);
                dfs(node);
            }
            trace.addLast(root);
        }

    }

    static class SequenceUtils {
        public static <T> void swap(List<T> data, int i, int j) {
            T tmp = data.get(i);
            data.set(i, data.get(j));
            data.set(j, tmp);
        }

        public static <T> void reverse(List<T> data, int l, int r) {
            while (l < r) {
                swap(data, l, r);
                l++;
                r--;
            }
        }

        public static <T> void reverse(List<T> data) {
            reverse(data, 0, data.size() - 1);
        }

    }

    static class Node {
        List<Edge> adj = new ArrayList<>();

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(String c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(String c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class Edge {
        Node a;
        Node b;
        boolean handled;

        Node other(Node x) {
            return a == x ? b : a;
        }

    }
}


</source>
<source file="../hum_codes_raw/s195610269.java" startline="1" endline="290" pcid="6594">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.util.Deque;
import java.util.ArrayList;
import java.io.UncheckedIOException;
import java.util.List;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.ArrayDeque;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            CThreeCircuits solver = new CThreeCircuits();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class CThreeCircuits {
        Deque<Node> trace = new ArrayDeque<>();

        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            int m = in.readInt();
            int[] deg = new int[n];
            Node[] nodes = new Node[n];
            for (int i = 0; i < n; i++) {
                nodes[i] = new Node();
            }
            for (int i = 0; i < m; i++) {
                int a = in.readInt() - 1;
                int b = in.readInt() - 1;
                deg[a]++;
                deg[b]++;
                Edge e = new Edge();
                e.a = nodes[a];
                e.b = nodes[b];
                e.a.adj.add(e);
                e.b.adj.add(e);
            }

            String no = "No";
            String yes = "Yes";
            for (int i = 0; i < n; i++) {
                if (deg[i] % 2 == 1) {
                    out.println("No");
                    return;
                }
            }


            List<Node> xy = new ArrayList<>(2);
            for (int i = 0; i < n; i++) {
                if (deg[i] >= 6) {
                    out.println(yes);
                    return;
                }
                if (deg[i] == 4) {
                    xy.add(nodes[i]);
                }
            }

            if (xy.size() >= 3) {
                out.println(yes);
                return;
            }
            if (xy.size() <= 1) {
                out.println(no);
                return;
            }

            dfs(nodes[0]);
            List<Node> list = new ArrayList<>(trace);
            SequenceUtils.reverse(list);

            List<Node> compressed = new ArrayList<>();
            for (Node node : list) {
                if (xy.contains(node)) {
                    compressed.add(node);
                }
            }

            if (compressed.get(0) == compressed.get(1) || compressed.get(1) == compressed.get(2)) {
                out.println(yes);
            } else {
                out.println(no);
            }
        }

        public void dfs(Node root) {
            while (!root.adj.isEmpty()) {
                Edge tail = root.adj.remove(root.adj.size() - 1);
                if (tail.handled) {
                    continue;
                }
                tail.handled = true;
                Node node = tail.other(root);
                dfs(node);
            }
            trace.addLast(root);
        }

    }

    static class SequenceUtils {
        public static <T> void swap(List<T> data, int i, int j) {
            T tmp = data.get(i);
            data.set(i, data.get(j));
            data.set(j, tmp);
        }

        public static <T> void reverse(List<T> data, int l, int r) {
            while (l < r) {
                swap(data, l, r);
                l++;
                r--;
            }
        }

        public static <T> void reverse(List<T> data) {
            reverse(data, 0, data.size() - 1);
        }

    }

    static class Node {
        List<Edge> adj = new ArrayList<>();

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(String c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(String c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class Edge {
        Node a;
        Node b;
        boolean handled;

        Node other(Node x) {
            return a == x ? b : a;
        }

    }
}


</source>
</class>

<class classid="41" nclones="2" nlines="178" similarity="100">
<source file="../hum_codes_raw/s047739433.java" startline="1" endline="219" pcid="1581">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            EAwkwardResponse solver = new EAwkwardResponse();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class EAwkwardResponse {
        FastOutput out;
        FastInput in;

        public void solve(int testNumber, FastInput in, FastOutput out) {
            this.out = out;
            this.in = in;

            long limit = (long) 1e15;
            long x = 1;
            while (ask(x) && x < limit) {
                x = x * 10;
            }

            if (x >= limit) {
                //all one
                x = 1;
                while (!ask(x + 1)) {
                    x = x * 10;
                }
                answer(x);
                return;
            }

            int len = Long.toString(x).length();
            long min = Math.round(Math.pow(10, len));
            long max = min * 10 - 1;

            LongBinarySearch lbs = new LongBinarySearch() {

                public boolean check(long mid) {
                    return ask(mid);
                }
            };

            long ans = lbs.binarySearch(min, max);
            ans /= 100;
            answer(ans);
        }

        public boolean ask(long x) {
            out.printf("? %d\n", x);
            out.flush();
            return in.readChar() == 'Y';
        }

        public void answer(long x) {
            out.printf("! %d\n", x);
            out.flush();
        }

    }

    static class DigitUtils {
        private DigitUtils() {
        }

        public static long floorAverage(long x, long y) {
            return (x & y) + ((x ^ y) >> 1);
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public char readChar() {
            skipBlank();
            char c = (char) next;
            next = read();
            return c;
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput printf(String format, Object... args) {
            cache.append(String.format(format, args));
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static abstract class LongBinarySearch {
        public abstract boolean check(long mid);

        public long binarySearch(long l, long r) {
            if (l > r) {
                throw new IllegalArgumentException();
            }
            while (l < r) {
                long mid = DigitUtils.floorAverage(l, r);
                if (check(mid)) {
                    r = mid;
                } else {
                    l = mid + 1;
                }
            }
            return l;
        }

    }
}


</source>
<source file="../hum_codes_raw/s998465037.java" startline="1" endline="219" pcid="33615">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            EAwkwardResponse solver = new EAwkwardResponse();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class EAwkwardResponse {
        FastOutput out;
        FastInput in;

        public void solve(int testNumber, FastInput in, FastOutput out) {
            this.out = out;
            this.in = in;

            long limit = (long) 1e15;
            long x = 1;
            while (ask(x) && x < limit) {
                x = x * 10;
            }

            if (x >= limit) {
                //all one
                x = 1;
                while (!ask(x + 1)) {
                    x = x * 10;
                }
                answer(x);
                return;
            }

            int len = Long.toString(x).length();
            long min = Math.round(Math.pow(10, len));
            long max = min * 10 - 1;

            LongBinarySearch lbs = new LongBinarySearch() {

                public boolean check(long mid) {
                    return ask(mid);
                }
            };

            long ans = lbs.binarySearch(min, max);
            ans /= 100;
            answer(ans);
        }

        public boolean ask(long x) {
            out.printf("? %d\n", x);
            out.flush();
            return in.readChar() == 'Y';
        }

        public void answer(long x) {
            out.printf("! %d\n", x);
            out.flush();
        }

    }

    static class DigitUtils {
        private DigitUtils() {
        }

        public static long floorAverage(long x, long y) {
            return (x & y) + ((x ^ y) >> 1);
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public char readChar() {
            skipBlank();
            char c = (char) next;
            next = read();
            return c;
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput printf(String format, Object... args) {
            cache.append(String.format(format, args));
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static abstract class LongBinarySearch {
        public abstract boolean check(long mid);

        public long binarySearch(long l, long r) {
            if (l > r) {
                throw new IllegalArgumentException();
            }
            while (l < r) {
                long mid = DigitUtils.floorAverage(l, r);
                if (check(mid)) {
                    r = mid;
                } else {
                    l = mid + 1;
                }
            }
            return l;
        }

    }
}


</source>
</class>

<class classid="42" nclones="2" nlines="387" similarity="100">
<source file="../hum_codes_raw/s048659297.java" startline="1" endline="472" pcid="1615">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.util.Collection;
import java.io.IOException;
import java.util.HashMap;
import java.util.Deque;
import java.util.ArrayList;
import java.io.UncheckedIOException;
import java.util.List;
import java.io.Closeable;
import java.util.Map;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.ArrayDeque;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author daltao
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "daltao", 1 << 27);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            TaskD solver = new TaskD();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class TaskD {
        int n;
        int m;

        int idOfRow(int i) {
            return i;
        }

        int idOfCol(int i) {
            return n + i;
        }

        int idOfSrc() {
            return n + m + 1;
        }

        int idOfDst() {
            return idOfSrc() + 1;
        }

        public void solve(int testNumber, FastInput in, FastOutput out) {
            n = in.readInt();
            m = in.readInt();

            int inf = (int) 1e8;
            ISAP isap = new ISAP(idOfDst());
            for (int i = 1; i <= n; i++) {
                for (int j = 1; j <= m; j++) {
                    char c = in.readChar();
                    if (c == '.') {
                        continue;
                    }
                    isap.getChannel(idOfRow(i), idOfCol(j)).modify(2, 1);
                    if (c == 'S') {
                        isap.getChannel(idOfSrc(), idOfRow(i)).modify(inf, 0);
                        isap.getChannel(idOfSrc(), idOfCol(j)).modify(inf, 0);
                    }
                    if (c == 'T') {
                        isap.getChannel(idOfRow(i), idOfDst()).modify(inf, 0);
                        isap.getChannel(idOfCol(j), idOfDst()).modify(inf, 0);
                    }
                }
            }

            isap.setSource(idOfSrc());
            isap.setTarget(idOfDst());

            int f = (int) (isap.sendFlow(inf) + 0.5);
            if (f == inf) {
                out.println(-1);
                return;
            }
            out.println(f);
        }

    }

    static class ISAP {
        ISAP.Node[] nodes;
        int[] distanceCnt;
        ISAP.Node source;
        ISAP.Node target;
        int nodeNum;
        Map<Long, ISAP.DirectChannel> channelMap = new HashMap();
        Deque<ISAP.Node> deque;
        boolean bfsFlag = false;

        private Collection<ISAP.DirectChannel> getChannels() {
            return channelMap.values();
        }

        private ISAP.DirectChannel addChannel(int src, int dst) {
            ISAP.DirectChannel channel = new ISAP.DirectChannel(nodes[src], nodes[dst], 0, 0);
            nodes[src].channelList.add(channel);
            nodes[dst].channelList.add(channel.getInverse());
            return channel;
        }

        public ISAP.DirectChannel getChannel(int src, int dst) {
            Long id = (((long) src) << 32) | dst;
            ISAP.DirectChannel channel = channelMap.get(id);
            if (channel == null) {
                channel = addChannel(src, dst);
                channelMap.put(id, channel);
            }
            return channel;
        }

        public ISAP(int nodeNum) {
            this.nodeNum = nodeNum;
            deque = new ArrayDeque(nodeNum);
            nodes = new ISAP.Node[nodeNum + 1];
            distanceCnt = new int[nodeNum + 2];
            for (int i = 1; i <= nodeNum; i++) {
                ISAP.Node node = new ISAP.Node();
                node.id = i;
                nodes[i] = node;
            }
        }

        public double sendFlow(double flow) {
            bfs();
            double flowSnapshot = flow;
            while (flow > 0 && source.distance < nodeNum) {
                flow -= send(source, flow);
            }
            return flowSnapshot - flow;
        }

        private double send(ISAP.Node node, double flowRemain) {
            if (node == target) {
                return flowRemain;
            }

            double flowSnapshot = flowRemain;
            int nextDistance = node.distance - 1;
            for (ISAP.Channel channel : node.channelList) {
                double channelRemain = channel.getCapacity() - channel.getFlow();
                ISAP.Node dst = channel.getDst();
                if (channelRemain == 0 || dst.distance != nextDistance) {
                    continue;
                }
                double actuallySend = send(channel.getDst(), Math.min(flowRemain, channelRemain));
                channel.sendFlow(actuallySend);
                flowRemain -= actuallySend;
                if (flowRemain == 0) {
                    break;
                }
            }

            if (flowSnapshot == flowRemain) {
                if (--distanceCnt[node.distance] == 0) {
                    distanceCnt[source.distance]--;
                    source.distance = nodeNum;
                    distanceCnt[source.distance]++;
                    if (node != source) {
                        distanceCnt[++node.distance]++;
                    }
                } else {
                    distanceCnt[++node.distance]++;
                }
            }

            return flowSnapshot - flowRemain;
        }

        public void setSource(int id) {
            source = nodes[id];
        }

        public void setTarget(int id) {
            target = nodes[id];
        }

        private void bfs() {
            if (bfsFlag) {
                return;
            }
            bfsFlag = true;
            Arrays.fill(distanceCnt, 0);
            deque.clear();

            for (int i = 1; i <= nodeNum; i++) {
                nodes[i].distance = nodeNum;
            }

            target.distance = 0;
            deque.addLast(target);

            while (!deque.isEmpty()) {
                ISAP.Node head = deque.removeFirst();
                distanceCnt[head.distance]++;
                for (ISAP.Channel channel : head.channelList) {
                    ISAP.Channel inverse = channel.getInverse();
                    if (inverse.getCapacity() == inverse.getFlow()) {
                        continue;
                    }
                    ISAP.Node dst = channel.getDst();
                    if (dst.distance != nodeNum) {
                        continue;
                    }
                    dst.distance = head.distance + 1;
                    deque.addLast(dst);
                }
            }
        }

        public String toString() {
            StringBuilder builder = new StringBuilder();
            for (ISAP.DirectChannel channel : getChannels()) {
                if (channel.getFlow() == 0) {
                    continue;
                }
                builder.append(channel).append('\n');
            }

            for (ISAP.DirectChannel channel : getChannels()) {
                if (channel.getFlow() != 0) {
                    continue;
                }
                builder.append(channel).append('\n');
            }
            return builder.toString();
        }

        public static interface Channel {
            public ISAP.Node getSrc();

            public ISAP.Node getDst();

            public double getCapacity();

            public double getFlow();

            public void sendFlow(double volume);

            public ISAP.Channel getInverse();

        }

        public static class DirectChannel implements ISAP.Channel {
            final ISAP.Node src;
            final ISAP.Node dst;
            final int id;
            double capacity;
            double flow;
            ISAP.Channel inverse;

            public DirectChannel(ISAP.Node src, ISAP.Node dst, int capacity, int id) {
                this.src = src;
                this.dst = dst;
                this.capacity = capacity;
                this.id = id;
                inverse = new ISAP.InverseChannelWrapper(this);
            }

            public void modify(double cap, double flow) {
                this.capacity += cap;
                this.flow += flow;
            }

            public String toString() {
                return String.format("%s--%s/%s-->%s", getSrc(), getFlow(), getCapacity(), getDst());
            }

            public ISAP.Node getSrc() {
                return src;
            }

            public ISAP.Channel getInverse() {
                return inverse;
            }

            public ISAP.Node getDst() {
                return dst;
            }

            public double getCapacity() {
                return capacity;
            }

            public double getFlow() {
                return flow;
            }

            public void sendFlow(double volume) {
                flow += volume;
            }

        }

        public static class InverseChannelWrapper implements ISAP.Channel {
            final ISAP.Channel channel;

            public InverseChannelWrapper(ISAP.Channel channel) {
                this.channel = channel;
            }

            public ISAP.Channel getInverse() {
                return channel;
            }

            public ISAP.Node getSrc() {
                return channel.getDst();
            }

            public ISAP.Node getDst() {
                return channel.getSrc();
            }

            public double getCapacity() {
                return channel.getFlow();
            }

            public double getFlow() {
                return 0;
            }

            public void sendFlow(double volume) {
                channel.sendFlow(-volume);
            }

            public String toString() {
                return String.format("%s--%s/%s-->%s", getSrc(), getFlow(), getCapacity(), getDst());
            }

        }

        public static class Node {
            int id;
            int distance;
            List<ISAP.Channel> channelList = new ArrayList(1);

            public String toString() {
                return "" + id;
            }

        }

    }

    static class FastOutput implements AutoCloseable, Closeable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput println(int c) {
            cache.append(c).append('\n');
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

        public char readChar() {
            skipBlank();
            char c = (char) next;
            next = read();
            return c;
        }

    }
}


</source>
<source file="../hum_codes_raw/s569549516.java" startline="1" endline="472" pcid="19155">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.util.Collection;
import java.io.IOException;
import java.util.HashMap;
import java.util.Deque;
import java.util.ArrayList;
import java.io.UncheckedIOException;
import java.util.List;
import java.io.Closeable;
import java.util.Map;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.ArrayDeque;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author daltao
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "daltao", 1 << 27);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            TaskD solver = new TaskD();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class TaskD {
        int n;
        int m;

        int idOfRow(int i) {
            return i;
        }

        int idOfCol(int i) {
            return n + i;
        }

        int idOfSrc() {
            return n + m + 1;
        }

        int idOfDst() {
            return idOfSrc() + 1;
        }

        public void solve(int testNumber, FastInput in, FastOutput out) {
            n = in.readInt();
            m = in.readInt();

            int inf = (int) 1e8;
            ISAP isap = new ISAP(idOfDst());
            for (int i = 1; i <= n; i++) {
                for (int j = 1; j <= m; j++) {
                    char c = in.readChar();
                    if (c == '.') {
                        continue;
                    }
                    isap.getChannel(idOfRow(i), idOfCol(j)).modify(2, 1);
                    if (c == 'S') {
                        isap.getChannel(idOfSrc(), idOfRow(i)).modify(inf, 0);
                        isap.getChannel(idOfSrc(), idOfCol(j)).modify(inf, 0);
                    }
                    if (c == 'T') {
                        isap.getChannel(idOfRow(i), idOfDst()).modify(inf, 0);
                        isap.getChannel(idOfCol(j), idOfDst()).modify(inf, 0);
                    }
                }
            }

            isap.setSource(idOfSrc());
            isap.setTarget(idOfDst());

            int f = (int) (isap.sendFlow(inf) + 0.5);
            if (f == inf) {
                out.println(-1);
                return;
            }
            out.println(f);
        }

    }

    static class ISAP {
        ISAP.Node[] nodes;
        int[] distanceCnt;
        ISAP.Node source;
        ISAP.Node target;
        int nodeNum;
        Map<Long, ISAP.DirectChannel> channelMap = new HashMap();
        Deque<ISAP.Node> deque;
        boolean bfsFlag = false;

        private Collection<ISAP.DirectChannel> getChannels() {
            return channelMap.values();
        }

        private ISAP.DirectChannel addChannel(int src, int dst) {
            ISAP.DirectChannel channel = new ISAP.DirectChannel(nodes[src], nodes[dst], 0, 0);
            nodes[src].channelList.add(channel);
            nodes[dst].channelList.add(channel.getInverse());
            return channel;
        }

        public ISAP.DirectChannel getChannel(int src, int dst) {
            Long id = (((long) src) << 32) | dst;
            ISAP.DirectChannel channel = channelMap.get(id);
            if (channel == null) {
                channel = addChannel(src, dst);
                channelMap.put(id, channel);
            }
            return channel;
        }

        public ISAP(int nodeNum) {
            this.nodeNum = nodeNum;
            deque = new ArrayDeque(nodeNum);
            nodes = new ISAP.Node[nodeNum + 1];
            distanceCnt = new int[nodeNum + 2];
            for (int i = 1; i <= nodeNum; i++) {
                ISAP.Node node = new ISAP.Node();
                node.id = i;
                nodes[i] = node;
            }
        }

        public double sendFlow(double flow) {
            bfs();
            double flowSnapshot = flow;
            while (flow > 0 && source.distance < nodeNum) {
                flow -= send(source, flow);
            }
            return flowSnapshot - flow;
        }

        private double send(ISAP.Node node, double flowRemain) {
            if (node == target) {
                return flowRemain;
            }

            double flowSnapshot = flowRemain;
            int nextDistance = node.distance - 1;
            for (ISAP.Channel channel : node.channelList) {
                double channelRemain = channel.getCapacity() - channel.getFlow();
                ISAP.Node dst = channel.getDst();
                if (channelRemain == 0 || dst.distance != nextDistance) {
                    continue;
                }
                double actuallySend = send(channel.getDst(), Math.min(flowRemain, channelRemain));
                channel.sendFlow(actuallySend);
                flowRemain -= actuallySend;
                if (flowRemain == 0) {
                    break;
                }
            }

            if (flowSnapshot == flowRemain) {
                if (--distanceCnt[node.distance] == 0) {
                    distanceCnt[source.distance]--;
                    source.distance = nodeNum;
                    distanceCnt[source.distance]++;
                    if (node != source) {
                        distanceCnt[++node.distance]++;
                    }
                } else {
                    distanceCnt[++node.distance]++;
                }
            }

            return flowSnapshot - flowRemain;
        }

        public void setSource(int id) {
            source = nodes[id];
        }

        public void setTarget(int id) {
            target = nodes[id];
        }

        private void bfs() {
            if (bfsFlag) {
                return;
            }
            bfsFlag = true;
            Arrays.fill(distanceCnt, 0);
            deque.clear();

            for (int i = 1; i <= nodeNum; i++) {
                nodes[i].distance = nodeNum;
            }

            target.distance = 0;
            deque.addLast(target);

            while (!deque.isEmpty()) {
                ISAP.Node head = deque.removeFirst();
                distanceCnt[head.distance]++;
                for (ISAP.Channel channel : head.channelList) {
                    ISAP.Channel inverse = channel.getInverse();
                    if (inverse.getCapacity() == inverse.getFlow()) {
                        continue;
                    }
                    ISAP.Node dst = channel.getDst();
                    if (dst.distance != nodeNum) {
                        continue;
                    }
                    dst.distance = head.distance + 1;
                    deque.addLast(dst);
                }
            }
        }

        public String toString() {
            StringBuilder builder = new StringBuilder();
            for (ISAP.DirectChannel channel : getChannels()) {
                if (channel.getFlow() == 0) {
                    continue;
                }
                builder.append(channel).append('\n');
            }

            for (ISAP.DirectChannel channel : getChannels()) {
                if (channel.getFlow() != 0) {
                    continue;
                }
                builder.append(channel).append('\n');
            }
            return builder.toString();
        }

        public static interface Channel {
            public ISAP.Node getSrc();

            public ISAP.Node getDst();

            public double getCapacity();

            public double getFlow();

            public void sendFlow(double volume);

            public ISAP.Channel getInverse();

        }

        public static class DirectChannel implements ISAP.Channel {
            final ISAP.Node src;
            final ISAP.Node dst;
            final int id;
            double capacity;
            double flow;
            ISAP.Channel inverse;

            public DirectChannel(ISAP.Node src, ISAP.Node dst, int capacity, int id) {
                this.src = src;
                this.dst = dst;
                this.capacity = capacity;
                this.id = id;
                inverse = new ISAP.InverseChannelWrapper(this);
            }

            public void modify(double cap, double flow) {
                this.capacity += cap;
                this.flow += flow;
            }

            public String toString() {
                return String.format("%s--%s/%s-->%s", getSrc(), getFlow(), getCapacity(), getDst());
            }

            public ISAP.Node getSrc() {
                return src;
            }

            public ISAP.Channel getInverse() {
                return inverse;
            }

            public ISAP.Node getDst() {
                return dst;
            }

            public double getCapacity() {
                return capacity;
            }

            public double getFlow() {
                return flow;
            }

            public void sendFlow(double volume) {
                flow += volume;
            }

        }

        public static class InverseChannelWrapper implements ISAP.Channel {
            final ISAP.Channel channel;

            public InverseChannelWrapper(ISAP.Channel channel) {
                this.channel = channel;
            }

            public ISAP.Channel getInverse() {
                return channel;
            }

            public ISAP.Node getSrc() {
                return channel.getDst();
            }

            public ISAP.Node getDst() {
                return channel.getSrc();
            }

            public double getCapacity() {
                return channel.getFlow();
            }

            public double getFlow() {
                return 0;
            }

            public void sendFlow(double volume) {
                channel.sendFlow(-volume);
            }

            public String toString() {
                return String.format("%s--%s/%s-->%s", getSrc(), getFlow(), getCapacity(), getDst());
            }

        }

        public static class Node {
            int id;
            int distance;
            List<ISAP.Channel> channelList = new ArrayList(1);

            public String toString() {
                return "" + id;
            }

        }

    }

    static class FastOutput implements AutoCloseable, Closeable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput println(int c) {
            cache.append(c).append('\n');
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

        public char readChar() {
            skipBlank();
            char c = (char) next;
            next = read();
            return c;
        }

    }
}


</source>
</class>

<class classid="43" nclones="2" nlines="165" similarity="100">
<source file="../hum_codes_raw/s049532884.java" startline="1" endline="213" pcid="1653">
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.PriorityQueue;
import java.util.Queue;
public class Main {
    private static final PrintStream ps     = System.out;
    private static final InputStream IS     = System.in;
    private static final byte[]      BUFFER = new byte[1024];
    private static int               ptr    = 0;
    private static int               buflen = 0;

    public static void main(String[] args) {

        int n = ni();
        //
        @SuppressWarnings("unchecked")
        List<Edge>[] edges = new List[n];
        for (int i = 0; i < edges.length; i++) {
            edges[i] = new ArrayList<Edge>();
        }
        for (int i = 0; i < n; i++) {
            int u = ni();
            int m = ni();
            for (int j = 0; j < m; j++) {
                edges[i].add(new Edge(u, ni(), ni()));
            }   
        }
        int[] d = dijkstra(n, edges, 0);
        
        for (int i = 0; i < n; i++) {
            System.out.println(i + " " + d[i]);
        }
    }
    //[(Single Source Shortest Path)]
    static int[] dijkstra(int n, List<Edge>[] edges, int s) {
        int[] distance = new int[n];        //

        Arrays.fill(distance, Integer.MAX_VALUE);    //(INF )
        distance[s] = 0;    //

        Queue<Edge> q = new PriorityQueue<Edge>();
        q.add(new Edge(s, s, 0));     //

        while (!q.isEmpty()) {
            Edge e = q.poll();        //(cost)
            if (distance[e.target] < e.cost) {
                continue;
            }

            //
            for (Edge v : edges[e.target]) {
                if (distance[v.target] > distance[e.target] + v.cost) {  //()    
                    distance[v.target] = distance[e.target] + v.cost;    //
                    q.add(new Edge(e.target, v.target, distance[v.target]));  //    
                }
            }
        }

        return distance;    //INF 
    }

    static class Edge implements Comparable<Edge> {
        public int source = 0;    //
        public int target = 0;    //
        public int cost = 0;      //

        public Edge(int source, int target, int cost) {
            this.source = source;
            this.target = target;
            this.cost = cost;
        }

        @Override
        public int compareTo(Edge o) {
            return this.cost - o.cost;
        }

        @Override
        public String toString() {    //
            return "source = " + source + ", target = " + target + ", cost = " + cost;
        }
    }

    private static boolean hasNextByte() {
        if (ptr < buflen)
            return true;
        else {
            ptr = 0;
            try {
                buflen = IS.read(BUFFER);
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0)
                return false;
        }
        return true;
    }

    private static int readByte() {
        if (hasNextByte())
            return BUFFER[ptr++];
        else
            return -1;
    }

    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }

    public static boolean hasNext() {
        while (hasNextByte() && !isPrintableChar(BUFFER[ptr]))
            ptr++;
        return hasNextByte();
    }

    public static String n() {
        if (!hasNext())
            throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while (isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }

    public static long nl() {
        if (!hasNext())
            throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b)
            throw new NumberFormatException();
        while (true) {
            if ('0' <= b && b <= '9') {
                n *= 10;
                n += b - '0';
            } else if (b == -1 || !isPrintableChar(b))
                return minus ? -n : n;
            else
                throw new NumberFormatException();
            b = readByte();
        }
    }

    public static int ni() {
        long nl = nl();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)
            throw new NumberFormatException();
        return (int) nl;
    }

    public static double nextDouble() {
        return Double.parseDouble(n());
    }

    private static int[] nia(int n) {
        int[] a = new int[n];
        for (int i = 0; i < n; i++)
            a[i] = ni();
        return a;
    }

    private static long[] nla(int n) {
        long[] a = new long[n];
        for (int i = 0; i < n; i++)
            a[i] = nl();
        return a;
    }

    private static String[] na(int n) {
        String[] a = new String[n];
        for (int i = 0; i < n; i++)
            a[i] = n();
        return a;
    }

    private static int[][] nia2(int n, int m) {
        int[][] a = new int[n][m];
        for (int i = 0; i < n; i++)
            a[i] = nia(m);
        return a;
    }

    private static long[][] nla2(int n, int m) {
        long[][] a = new long[n][m];
        for (int i = 0; i < n; i++)
            a[i] = nla(m);
        return a;
    }

    private static char[][] nca2(int n) {
        char[][] a = new char[n][];
        for (int i = 0; i < n; i++)
            a[i] = n().toCharArray();
        return a;

    }
}


</source>
<source file="../hum_codes_raw/s691517963.java" startline="1" endline="213" pcid="23266">
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.PriorityQueue;
import java.util.Queue;
public class Main {
    private static final PrintStream ps     = System.out;
    private static final InputStream IS     = System.in;
    private static final byte[]      BUFFER = new byte[1024];
    private static int               ptr    = 0;
    private static int               buflen = 0;

    public static void main(String[] args) {

        int n = ni();
        //
        @SuppressWarnings("unchecked")
        List<Edge>[] edges = new List[n];
        for (int i = 0; i < edges.length; i++) {
            edges[i] = new ArrayList<Edge>();
        }
        for (int i = 0; i < n; i++) {
            int u = ni();
            int m = ni();
            for (int j = 0; j < m; j++) {
                edges[i].add(new Edge(u, ni(), ni()));
            }   
        }
        int[] d = dijkstra(n, edges, 0);
        
        for (int i = 0; i < n; i++) {
            System.out.println(i + " " + d[i]);
        }
    }
    //[(Single Source Shortest Path)]
    static int[] dijkstra(int n, List<Edge>[] edges, int s) {
        int[] distance = new int[n];        //

        Arrays.fill(distance, Integer.MAX_VALUE);    //(INF )
        distance[s] = 0;    //

        Queue<Edge> q = new PriorityQueue<Edge>();
        q.add(new Edge(s, s, 0));     //

        while (!q.isEmpty()) {
            Edge e = q.poll();        //(cost)
            if (distance[e.target] < e.cost) {
                continue;
            }

            //
            for (Edge v : edges[e.target]) {
                if (distance[v.target] > distance[e.target] + v.cost) {  //()    
                    distance[v.target] = distance[e.target] + v.cost;    //
                    q.add(new Edge(e.target, v.target, distance[v.target]));  //    
                }
            }
        }

        return distance;    //INF 
    }

    static class Edge implements Comparable<Edge> {
        public int source = 0;    //
        public int target = 0;    //
        public int cost = 0;      //

        public Edge(int source, int target, int cost) {
            this.source = source;
            this.target = target;
            this.cost = cost;
        }

        @Override
        public int compareTo(Edge o) {
            return this.cost - o.cost;
        }

        @Override
        public String toString() {    //
            return "source = " + source + ", target = " + target + ", cost = " + cost;
        }
    }

    private static boolean hasNextByte() {
        if (ptr < buflen)
            return true;
        else {
            ptr = 0;
            try {
                buflen = IS.read(BUFFER);
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0)
                return false;
        }
        return true;
    }

    private static int readByte() {
        if (hasNextByte())
            return BUFFER[ptr++];
        else
            return -1;
    }

    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }

    public static boolean hasNext() {
        while (hasNextByte() && !isPrintableChar(BUFFER[ptr]))
            ptr++;
        return hasNextByte();
    }

    public static String n() {
        if (!hasNext())
            throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while (isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }

    public static long nl() {
        if (!hasNext())
            throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b)
            throw new NumberFormatException();
        while (true) {
            if ('0' <= b && b <= '9') {
                n *= 10;
                n += b - '0';
            } else if (b == -1 || !isPrintableChar(b))
                return minus ? -n : n;
            else
                throw new NumberFormatException();
            b = readByte();
        }
    }

    public static int ni() {
        long nl = nl();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)
            throw new NumberFormatException();
        return (int) nl;
    }

    public static double nextDouble() {
        return Double.parseDouble(n());
    }

    private static int[] nia(int n) {
        int[] a = new int[n];
        for (int i = 0; i < n; i++)
            a[i] = ni();
        return a;
    }

    private static long[] nla(int n) {
        long[] a = new long[n];
        for (int i = 0; i < n; i++)
            a[i] = nl();
        return a;
    }

    private static String[] na(int n) {
        String[] a = new String[n];
        for (int i = 0; i < n; i++)
            a[i] = n();
        return a;
    }

    private static int[][] nia2(int n, int m) {
        int[][] a = new int[n][m];
        for (int i = 0; i < n; i++)
            a[i] = nia(m);
        return a;
    }

    private static long[][] nla2(int n, int m) {
        long[][] a = new long[n][m];
        for (int i = 0; i < n; i++)
            a[i] = nla(m);
        return a;
    }

    private static char[][] nca2(int n) {
        char[][] a = new char[n][];
        for (int i = 0; i < n; i++)
            a[i] = n().toCharArray();
        return a;

    }
}


</source>
</class>

<class classid="44" nclones="4" nlines="136" similarity="100">
<source file="../hum_codes_raw/s050821645.java" startline="1" endline="153" pcid="1688">
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.util.Arrays;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        double INF = Double.MAX_VALUE / 2;
        while (true) {
            int n = sc.nextInt();
            if (n == 0)
                break;
            Circle[] cs = new Circle[n];
            for (int i = 0; i < n; i++) {
                cs[i] = new Circle(sc.nextInt(), sc.nextInt(), sc.nextInt());
            }
            Point[] ps = new Point[2 * n];
            ps[0] = new Point(cs[0].x, cs[0].y);
            ps[ps.length - 1] = new Point(cs[n - 1].x, cs[n - 1].y);
            int c = 1;
            Line[] ls = new Line[n - 1];
            for (int i = 1; i < n; i++) {
                Point[] cis = cs[i].circleInterSection(cs[i - 1]);
                ps[c++] = cis[0];
                ps[c++] = cis[1];
                ls[i - 1] = new Line(cis[0], cis[1]);
            }
            double[][] cost = new double[2 * n][2 * n];
            for (int i = 0; i < 2 * n; i++) {
                Arrays.fill(cost[i], INF);
            }
            for (int i = 0; i <= 2 * n - 4; i++) {
                for (int j = i + 1; j < 2 * n; j++) {
                    if (j % 2 == 0) {
                        Line l1 = new Line(ps[i], ps[j]);
                        boolean inCircle = true;
                        for (int k = i % 2 == 0 ? i / 2 : i / 2 + 1; k < j / 2 - 1; k++) {
                            Line l2 = ls[k];
                            if (!l2.intersectsLine(l1)) {
                                inCircle = false;
                                break;
                            }
                        }
                        if (inCircle) {
                            cost[i][j] = l1.length();
                        }
                    } else {
                        Line l1 = new Line(ps[i], ps[j]);
                        boolean inCircle = true;
                        for (int k = i % 2 == 0 ? i / 2 : i / 2 + 1; k < j / 2; k++) {
                            Line l2 = ls[k];
                            if (!l2.intersectsLine(l1)) {
                                inCircle = false;
                                break;
                            }
                        }
                        if (inCircle) {
                            cost[i][j] = l1.length();
                        }
                    }
                }
            }
            cost[2 * n - 3][2 * n - 1] = new Line(ps[2 * n - 3], ps[2 * n - 1])
                    .length();
            cost[2 * n - 2][2 * n - 1] = new Line(ps[2 * n - 2], ps[2 * n - 1])
                    .length();
            for (int k = 0; k < 2 * n; k++) {
                for (int i = 0; i < 2 * n; i++) {
                    if (k < i)
                        break;
                    for (int j = i + 1; j < 2 * n; j++) {
                        cost[i][j] = Math.min(cost[i][j], cost[i][k]
                                + cost[k][j]);
                    }
                }
            }
            System.out.printf("%.5f\n", cost[0][2 * n - 1]);
        }
    }
}

@SuppressWarnings("serial")
class Point extends Point2D.Double {
    Point(int x, int y) {
        super(x, y);
    }

    Point(double x, double y) {
        super(x, y);
    }
}

@SuppressWarnings("serial")
class Line extends Line2D.Double {

    Line(Point p1, Point p2) {
        super(p1, p2);
    }

    public double length() {
        return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
    }

    public double ip(Line l) {
        Point q1 = new Point(l.x1, l.y1);
        Point q2 = new Point(l.x2, l.y2);
        return (x2 - x1) * (q2.x - q1.x) + (y2 - y1) * (q2.y - q1.y);
    }

    public double ep(Line l) {
        Point q1 = new Point(l.x1, l.y1);
        Point q2 = new Point(l.x2, l.y2);
        return (x2 - x1) * (q2.y - q1.y) - (y2 - y1) * (q2.x - q1.x);
    }
}

class Circle {
    int x;
    int y;
    int r;

    Circle(int x, int y, int r) {
        this.x = x;
        this.y = y;
        this.r = r;
    }

    public Point[] circleInterSection(Circle c2) {
        Circle c1 = this;
        double a = c1.x;
        double b = c1.y;
        double r = c1.r;
        double c = c2.x;
        double d = c2.y;
        double s = c2.r;
        double norm = (c - a) * (c - a) + (d - b) * (d - b);
        double t = 0.5 * (norm + r * r - s * s) / Math.sqrt(norm);
        double th = Math.acos(t / r);
        double th0 = Math.atan2((d - b), (c - a));
        double p1 = a + r * Math.cos(th + th0);
        double q1 = b + r * Math.sin(th + th0);
        double p2 = a + r * Math.cos(-th + th0);
        double q2 = b + r * Math.sin(-th + th0);
        Point[] ps = { new Point(p1, q1), new Point(p2, q2) };
        return ps;
    }
    public String toString() {
        return "x,y,r " + x + " " + y + " " + r + " ";
    }
}

</source>
<source file="../hum_codes_raw/s224566516.java" startline="1" endline="162" pcid="7586">
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.util.Arrays;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        double INF = Double.MAX_VALUE / 2;
        while (true) {
            int n = sc.nextInt();
            if (n == 0)
                break;
            Circle[] cs = new Circle[n];
            for (int i = 0; i < n; i++) {
                cs[i] = new Circle(sc.nextInt(), sc.nextInt(), sc.nextInt());
            }
            Point[] ps = new Point[2 * n];
            ps[0] = new Point(cs[0].x, cs[0].y);
            ps[ps.length - 1] = new Point(cs[n - 1].x, cs[n - 1].y);
            int c = 1;
            Line[] ls = new Line[n - 1];
            for (int i = 1; i < n; i++) {
                Point[] cis = cs[i].circleInterSection(cs[i - 1]);
                ps[c++] = cis[0];
                ps[c++] = cis[1];
                ls[i - 1] = new Line(cis[0], cis[1]);
            }
            // System.out.println(Arrays.toString(ps));
            double[][] cost = new double[2 * n][2 * n];
            for (int i = 0; i < 2 * n; i++) {
                Arrays.fill(cost[i], INF);
            }
            for (int i = 0; i <= 2 * n - 4; i++) {
                for (int j = i + 1; j < 2 * n; j++) {
                    if (j % 2 == 0) {
                        Line l1 = new Line(ps[i], ps[j]);
                        boolean inCircle = true;
                        for (int k = i % 2 == 0 ? i / 2 : i / 2 + 1; k < j / 2 - 1; k++) {
                            Line l2 = ls[k];
                            if (!l2.intersectsLine(l1)) {
                                inCircle = false;
                                break;
                            }
                        }
                        if (inCircle) {
                            // System.out.println(i + " => " + j);
                            cost[i][j] = l1.length();
                        }
                    } else {
                        Line l1 = new Line(ps[i], ps[j]);
                        boolean inCircle = true;
                        for (int k = i % 2 == 0 ? i / 2 : i / 2 + 1; k < j / 2; k++) {
                            Line l2 = ls[k];
                            if (!l2.intersectsLine(l1)) {
                                inCircle = false;
                                break;
                            }
                        }
                        if (inCircle) {
                            // System.out.println(i + " => " + j);
                            cost[i][j] = l1.length();
                        }
                    }
                }
            }
            // for (int i = 0; i < 2 * n; i++) {
            // System.out.println(Arrays.toString(cost[i]));
            // }
            cost[2 * n - 3][2 * n - 1] = new Line(ps[2 * n - 3], ps[2 * n - 1])
                    .length();
            cost[2 * n - 2][2 * n - 1] = new Line(ps[2 * n - 2], ps[2 * n - 1])
                    .length();
            for (int k = 0; k < 2 * n; k++) {
                for (int i = 0; i < 2 * n; i++) {
                    if (k < i)
                        break;
                    for (int j = i + 1; j < 2 * n; j++) {
                        cost[i][j] = Math.min(cost[i][j], cost[i][k]
                                + cost[k][j]);
                    }
                }
            }
            System.out.printf("%.5f\n", cost[0][2 * n - 1]);
        }

    }
}

@SuppressWarnings("serial")
class Point extends Point2D.Double {
    Point(int x, int y) {
        super(x, y);
    }

    Point(double x, double y) {
        super(x, y);
    }
}

@SuppressWarnings("serial")
class Line extends Line2D.Double {

    Line(Point p1, Point p2) {
        super(p1, p2);
    }

    public double length() {
        return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
    }

    public double ip(Line l) {
        Point q1 = new Point(l.x1, l.y1);
        Point q2 = new Point(l.x2, l.y2);
        return (x2 - x1) * (q2.x - q1.x) + (y2 - y1) * (q2.y - q1.y);
    }

    public double ep(Line l) {
        Point q1 = new Point(l.x1, l.y1);
        Point q2 = new Point(l.x2, l.y2);
        return (x2 - x1) * (q2.y - q1.y) - (y2 - y1) * (q2.x - q1.x);
    }
}

class Circle {
    int x;
    int y;
    int r;

    Circle(int x, int y, int r) {
        this.x = x;
        this.y = y;
        this.r = r;
    }

    public Point[] circleInterSection(Circle c2) {
        Circle c1 = this;
        double a = c1.x;
        double b = c1.y;
        double r = c1.r;
        double c = c2.x;
        double d = c2.y;
        double s = c2.r;
        double norm = (c - a) * (c - a) + (d - b) * (d - b);
        double t = 0.5 * (norm + r * r - s * s) / Math.sqrt(norm);
        double th = Math.acos(t / r);
        double th0 = Math.atan2((d - b), (c - a));
        double p1 = a + r * Math.cos(th + th0);
        double q1 = b + r * Math.sin(th + th0);
        double p2 = a + r * Math.cos(-th + th0);
        double q2 = b + r * Math.sin(-th + th0);
        Point[] ps = { new Point(p1, q1), new Point(p2, q2) };
        return ps;
    }

    public String toString() {
        return "x,y,r " + x + " " + y + " " + r + " ";
    }

}

</source>
<source file="../hum_codes_raw/s799573041.java" startline="1" endline="153" pcid="26863">
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.util.Arrays;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        double INF = Double.MAX_VALUE / 2;
        while (true) {
            int n = sc.nextInt();
            if (n == 0)
                break;
            Circle[] cs = new Circle[n];
            for (int i = 0; i < n; i++) {
                cs[i] = new Circle(sc.nextInt(), sc.nextInt(), sc.nextInt());
            }
            Point[] ps = new Point[2 * n];
            ps[0] = new Point(cs[0].x, cs[0].y);
            ps[ps.length - 1] = new Point(cs[n - 1].x, cs[n - 1].y);
            int c = 1;
            Line[] ls = new Line[n - 1];
            for (int i = 1; i < n; i++) {
                Point[] cis = cs[i].circleInterSection(cs[i - 1]);
                ps[c++] = cis[0];
                ps[c++] = cis[1];
                ls[i - 1] = new Line(cis[0], cis[1]);
            }
            double[][] cost = new double[2 * n][2 * n];
            for (int i = 0; i < 2 * n; i++) {
                Arrays.fill(cost[i], INF);
            }
            for (int i = 0; i <= 2 * n - 4; i++) {
                for (int j = i + 1; j < 2 * n; j++) {
                    if (j % 2 == 0) {
                        Line l1 = new Line(ps[i], ps[j]);
                        boolean inCircle = true;
                        for (int k = i % 2 == 0 ? i / 2 : i / 2 + 1; k < j / 2 - 1; k++) {
                            Line l2 = ls[k];
                            if (!l2.intersectsLine(l1)) {
                                inCircle = false;
                                break;
                            }
                        }
                        if (inCircle) {
                            cost[i][j] = l1.length();
                        }
                    } else {
                        Line l1 = new Line(ps[i], ps[j]);
                        boolean inCircle = true;
                        for (int k = i % 2 == 0 ? i / 2 : i / 2 + 1; k < j / 2; k++) {
                            Line l2 = ls[k];
                            if (!l2.intersectsLine(l1)) {
                                inCircle = false;
                                break;
                            }
                        }
                        if (inCircle) {
                            cost[i][j] = l1.length();
                        }
                    }
                }
            }
            cost[2 * n - 3][2 * n - 1] = new Line(ps[2 * n - 3], ps[2 * n - 1])
                    .length();
            cost[2 * n - 2][2 * n - 1] = new Line(ps[2 * n - 2], ps[2 * n - 1])
                    .length();
            for (int k = 0; k < 2 * n; k++) {
                for (int i = 0; i < 2 * n; i++) {
                    if (k < i)
                        break;
                    for (int j = i + 1; j < 2 * n; j++) {
                        cost[i][j] = Math.min(cost[i][j], cost[i][k]
                                + cost[k][j]);
                    }
                }
            }
            System.out.printf("%.5f\n", cost[0][2 * n - 1]);
        }
    }
}

@SuppressWarnings("serial")
class Point extends Point2D.Double {
    Point(int x, int y) {
        super(x, y);
    }

    Point(double x, double y) {
        super(x, y);
    }
}

@SuppressWarnings("serial")
class Line extends Line2D.Double {

    Line(Point p1, Point p2) {
        super(p1, p2);
    }

    public double length() {
        return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
    }

    public double ip(Line l) {
        Point q1 = new Point(l.x1, l.y1);
        Point q2 = new Point(l.x2, l.y2);
        return (x2 - x1) * (q2.x - q1.x) + (y2 - y1) * (q2.y - q1.y);
    }

    public double ep(Line l) {
        Point q1 = new Point(l.x1, l.y1);
        Point q2 = new Point(l.x2, l.y2);
        return (x2 - x1) * (q2.y - q1.y) - (y2 - y1) * (q2.x - q1.x);
    }
}

class Circle {
    int x;
    int y;
    int r;

    Circle(int x, int y, int r) {
        this.x = x;
        this.y = y;
        this.r = r;
    }

    public Point[] circleInterSection(Circle c2) {
        Circle c1 = this;
        double a = c1.x;
        double b = c1.y;
        double r = c1.r;
        double c = c2.x;
        double d = c2.y;
        double s = c2.r;
        double norm = (c - a) * (c - a) + (d - b) * (d - b);
        double t = 0.5 * (norm + r * r - s * s) / Math.sqrt(norm);
        double th = Math.acos(t / r);
        double th0 = Math.atan2((d - b), (c - a));
        double p1 = a + r * Math.cos(th + th0);
        double q1 = b + r * Math.sin(th + th0);
        double p2 = a + r * Math.cos(-th + th0);
        double q2 = b + r * Math.sin(-th + th0);
        Point[] ps = { new Point(p1, q1), new Point(p2, q2) };
        return ps;
    }
    public String toString() {
        return "x,y,r " + x + " " + y + " " + r + " ";
    }
}

</source>
<source file="../hum_codes_raw/s639372154.java" startline="1" endline="153" pcid="21449">
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.util.Arrays;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        double INF = Double.MAX_VALUE / 2;
        while (true) {
            int n = sc.nextInt();
            if (n == 0)
                break;
            Circle[] cs = new Circle[n];
            for (int i = 0; i < n; i++) {
                cs[i] = new Circle(sc.nextInt(), sc.nextInt(), sc.nextInt());
            }
            Point[] ps = new Point[2 * n];
            ps[0] = new Point(cs[0].x, cs[0].y);
            ps[ps.length - 1] = new Point(cs[n - 1].x, cs[n - 1].y);
            int c = 1;
            Line[] ls = new Line[n - 1];
            for (int i = 1; i < n; i++) {
                Point[] cis = cs[i].circleInterSection(cs[i - 1]);
                ps[c++] = cis[0];
                ps[c++] = cis[1];
                ls[i - 1] = new Line(cis[0], cis[1]);
            }
            double[][] cost = new double[2 * n][2 * n];
            for (int i = 0; i < 2 * n; i++) {
                Arrays.fill(cost[i], INF);
            }
            for (int i = 0; i <= 2 * n - 4; i++) {
                for (int j = i + 1; j < 2 * n; j++) {
                    if (j % 2 == 0) {
                        Line l1 = new Line(ps[i], ps[j]);
                        boolean inCircle = true;
                        for (int k = i % 2 == 0 ? i / 2 : i / 2 + 1; k < j / 2 - 1; k++) {
                            Line l2 = ls[k];
                            if (!l2.intersectsLine(l1)) {
                                inCircle = false;
                                break;
                            }
                        }
                        if (inCircle) {
                            cost[i][j] = l1.length();
                        }
                    } else {
                        Line l1 = new Line(ps[i], ps[j]);
                        boolean inCircle = true;
                        for (int k = i % 2 == 0 ? i / 2 : i / 2 + 1; k < j / 2; k++) {
                            Line l2 = ls[k];
                            if (!l2.intersectsLine(l1)) {
                                inCircle = false;
                                break;
                            }
                        }
                        if (inCircle) {
                            cost[i][j] = l1.length();
                        }
                    }
                }
            }
            cost[2 * n - 3][2 * n - 1] = new Line(ps[2 * n - 3], ps[2 * n - 1])
                    .length();
            cost[2 * n - 2][2 * n - 1] = new Line(ps[2 * n - 2], ps[2 * n - 1])
                    .length();
            for (int k = 0; k < 2 * n; k++) {
                for (int i = 0; i < 2 * n; i++) {
                    if (k < i)
                        break;
                    for (int j = i + 1; j < 2 * n; j++) {
                        cost[i][j] = Math.min(cost[i][j], cost[i][k]
                                + cost[k][j]);
                    }
                }
            }
            System.out.printf("%.5f\n", cost[0][2 * n - 1]);
        }
    }
}

@SuppressWarnings("serial")
class Point extends Point2D.Double {
    Point(int x, int y) {
        super(x, y);
    }

    Point(double x, double y) {
        super(x, y);
    }
}

@SuppressWarnings("serial")
class Line extends Line2D.Double {

    Line(Point p1, Point p2) {
        super(p1, p2);
    }

    public double length() {
        return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
    }

    public double ip(Line l) {
        Point q1 = new Point(l.x1, l.y1);
        Point q2 = new Point(l.x2, l.y2);
        return (x2 - x1) * (q2.x - q1.x) + (y2 - y1) * (q2.y - q1.y);
    }

    public double ep(Line l) {
        Point q1 = new Point(l.x1, l.y1);
        Point q2 = new Point(l.x2, l.y2);
        return (x2 - x1) * (q2.y - q1.y) - (y2 - y1) * (q2.x - q1.x);
    }
}

class Circle {
    int x;
    int y;
    int r;

    Circle(int x, int y, int r) {
        this.x = x;
        this.y = y;
        this.r = r;
    }

    public Point[] circleInterSection(Circle c2) {
        Circle c1 = this;
        double a = c1.x;
        double b = c1.y;
        double r = c1.r;
        double c = c2.x;
        double d = c2.y;
        double s = c2.r;
        double norm = (c - a) * (c - a) + (d - b) * (d - b);
        double t = 0.5 * (norm + r * r - s * s) / Math.sqrt(norm);
        double th = Math.acos(t / r);
        double th0 = Math.atan2((d - b), (c - a));
        double p1 = a + r * Math.cos(th + th0);
        double q1 = b + r * Math.sin(th + th0);
        double p2 = a + r * Math.cos(-th + th0);
        double q2 = b + r * Math.sin(-th + th0);
        Point[] ps = { new Point(p1, q1), new Point(p2, q2) };
        return ps;
    }
    public String toString() {
        return "x,y,r " + x + " " + y + " " + r + " ";
    }
}

</source>
</class>

<class classid="45" nclones="2" nlines="135" similarity="100">
<source file="../hum_codes_raw/s054668339.java" startline="1" endline="171" pcid="1824">

import java.io.*;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.MathContext;
import java.text.DecimalFormat;
import java.util.*;

public class Main {


    static MyScanner sc;
    private static PrintWriter out;
    static long M = 1000000007;

    public static void main(String[] s) throws Exception {
//        sc = new MyScanner(new BufferedReader(new StringReader("8\n" +
//                "1 1 1 1 1 1 1 2")));
        sc = new MyScanner(System.in);


        out = new PrintWriter(new OutputStreamWriter(System.out));
        long t = System.currentTimeMillis();
        solve();
        out.flush();
    }


    private static void solve() {

        int a = sc.nextInt();
        int b = sc.nextInt();
        int c = sc.nextInt();
        int d = sc.nextInt();
        int e = sc.nextInt();
        int f = sc.nextInt();
        boolean[] cans = new boolean[3001];
        boolean[] canw = new boolean[3001];
        cans[0] = true;
        canw[0] = true;
        for (int i = 0; i < 3000; i++) {
            if (cans[i]) {
                if (i + c <= 3000) {
                    cans[i + c] = true;
                }

                if (i + d <= 3000) {
                    cans[i + d] = true;
                }
            }
        }
        for (int i = 0; i < 30; i++) {
            if (canw[i]) {
                if (i + b <= 30) {
                    canw[i + a] = true;
                }

                if (i + d <= 30) {
                    canw[i + b] = true;
                }
            }
        }


        int[] max = new int[]{0,  a};
        Comparator<int[]> rr = new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                return Double.compare(100.0 * o1[0] / (o1[0] + 100 * o1[1]), 100.0 * o2[0] / (o2[0] +  100 * o2[1]) );
            }
        };

        for (int i = 0 ; i <= 3000; i++) {
            for (int j = 1 ; j <= 30; j++) {
                if (i + j * 100 > f) continue;
                if (j * e < i) continue;
                if (!cans[i]) continue;
                if (!canw[j]) continue;
                if (rr.compare(max, new int[]{i, j}) < 0){
                    max = new int[]{i, j};
                };

            }
        }

        out.println((max[1] * 100 + max[0]) + " " + max[0]);
    }


    private static void solveT() {
        int t = sc.nextInt();
        while (t-- > 0) {
            solve();
        }
    }

    private static long gcd(long l, long l1) {
        if (l > l1) return gcd(l1, l);
        if (l == 0) return l1;
        return gcd(l1 % l, l);
    }

    private static long pow(long a, long b, long m) {
        if (b == 0) return 1;
        if (b == 1) return a;
        long pp = pow(a, b / 2, m);
        pp *= pp;
        pp %= m;
        return (pp * (b % 2 == 0 ? 1 : a)) % m;
    }


    static class MyScanner {
        BufferedReader br;
        StringTokenizer st;

        MyScanner(BufferedReader br) {
            this.br = br;
        }

        public MyScanner(InputStream in) {
            this(new BufferedReader(new InputStreamReader(in)));
        }

        void findToken() {
            while (st == null || !st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
        }

        String next() {
            findToken();
            return st.nextToken();
        }

        int[] na(int n) {
            int[] k = new int[n];
            for (int i = 0; i < n; i++) {
                k[i] = sc.nextInt();
            }
            return k;
        }

        long[] nl(int n) {
            long[] k = new long[n];
            for (int i = 0; i < n; i++) {
                k[i] = sc.nextLong();
            }
            return k;
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }
    }


}

</source>
<source file="../hum_codes_raw/s322425265.java" startline="1" endline="171" pcid="10803">

import java.io.*;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.MathContext;
import java.text.DecimalFormat;
import java.util.*;

public class Main {


    static MyScanner sc;
    private static PrintWriter out;
    static long M = 1000000007;

    public static void main(String[] s) throws Exception {
//        sc = new MyScanner(new BufferedReader(new StringReader("8\n" +
//                "1 1 1 1 1 1 1 2")));
        sc = new MyScanner(System.in);


        out = new PrintWriter(new OutputStreamWriter(System.out));
        long t = System.currentTimeMillis();
        solve();
        out.flush();
    }


    private static void solve() {

        int a = sc.nextInt();
        int b = sc.nextInt();
        int c = sc.nextInt();
        int d = sc.nextInt();
        int e = sc.nextInt();
        int f = sc.nextInt();
        boolean[] cans = new boolean[3001];
        boolean[] canw = new boolean[3001];
        cans[0] = true;
        canw[0] = true;
        for (int i = 0; i < 3000; i++) {
            if (cans[i]) {
                if (i + c <= 3000) {
                    cans[i + c] = true;
                }

                if (i + d <= 3000) {
                    cans[i + d] = true;
                }
            }
        }
        for (int i = 0; i < 30; i++) {
            if (canw[i]) {
                if (i + b <= 30) {
                    canw[i + a] = true;
                }

                if (i + d <= 30) {
                    canw[i + b] = true;
                }
            }
        }


        int[] max = new int[]{0,  a};
        Comparator<int[]> rr = new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                return Double.compare(100.0 * o1[0] / (o1[0] + 100 * o1[1]), 100.0 * o2[0] / (o2[0] +  100 * o2[1]) );
            }
        };

        for (int i = 0 ; i <= 3000; i++) {
            for (int j = 1 ; j <= 30; j++) {
                if (i + j * 100 > f) continue;
                if (j * e < i) continue;
                if (!cans[i]) continue;
                if (!canw[j]) continue;
                if (rr.compare(max, new int[]{i, j}) < 0){
                    max = new int[]{i, j};
                };

            }
        }

        out.println((max[1] * 100 + max[0]) + " " + max[0]);
    }


    private static void solveT() {
        int t = sc.nextInt();
        while (t-- > 0) {
            solve();
        }
    }

    private static long gcd(long l, long l1) {
        if (l > l1) return gcd(l1, l);
        if (l == 0) return l1;
        return gcd(l1 % l, l);
    }

    private static long pow(long a, long b, long m) {
        if (b == 0) return 1;
        if (b == 1) return a;
        long pp = pow(a, b / 2, m);
        pp *= pp;
        pp %= m;
        return (pp * (b % 2 == 0 ? 1 : a)) % m;
    }


    static class MyScanner {
        BufferedReader br;
        StringTokenizer st;

        MyScanner(BufferedReader br) {
            this.br = br;
        }

        public MyScanner(InputStream in) {
            this(new BufferedReader(new InputStreamReader(in)));
        }

        void findToken() {
            while (st == null || !st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
        }

        String next() {
            findToken();
            return st.nextToken();
        }

        int[] na(int n) {
            int[] k = new int[n];
            for (int i = 0; i < n; i++) {
                k[i] = sc.nextInt();
            }
            return k;
        }

        long[] nl(int n) {
            long[] k = new long[n];
            for (int i = 0; i < n; i++) {
                k[i] = sc.nextLong();
            }
            return k;
        }

        int nextInt() {
            return Integer.parseInt(next());
        }

        long nextLong() {
            return Long.parseLong(next());
        }

        double nextDouble() {
            return Double.parseDouble(next());
        }
    }


}

</source>
</class>

<class classid="46" nclones="2" nlines="193" similarity="100">
<source file="../hum_codes_raw/s057521857.java" startline="1" endline="229" pcid="1929">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.io.IOException;
import java.util.TreeSet;
import java.util.ArrayList;
import java.io.UncheckedIOException;
import java.util.List;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            DBlackAndWhiteTree solver = new DBlackAndWhiteTree();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class DBlackAndWhiteTree {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            Node[] nodes = new Node[n];
            for (int i = 0; i < n; i++) {
                nodes[i] = new Node();
                nodes[i].id = i;
            }
            for (int i = 0; i < n - 1; i++) {
                Node a = nodes[in.readInt() - 1];
                Node b = nodes[in.readInt() - 1];
                a.adj.add(b);
                b.adj.add(a);
                a.deg++;
                b.deg++;
            }

            TreeSet<Node> set = new TreeSet<>((a, b) -> a.deg == b.deg ? Integer.compare(a.id, b.id) : Integer.compare(a.deg, b.deg));
            set.addAll(Arrays.asList(nodes));
            while (!set.isEmpty()) {
                Node head = set.pollFirst();
                if (head.deg == 0) {
                    out.println("First");
                    return;
                }
                head.removed = true;
                Node nearby = null;
                for (Node node : head.adj) {
                    if (node.removed) {
                        continue;
                    }
                    nearby = node;
                    set.remove(nearby);
                }
                nearby.removed = true;
                for (Node node : nearby.adj) {
                    if (node.removed) {
                        continue;
                    }
                    set.remove(node);
                    node.deg--;
                    set.add(node);
                }
            }

            out.println("Second");
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(String c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(String c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class Node {
        List<Node> adj = new ArrayList<>();
        int deg;
        int id;
        boolean removed;

        public String toString() {
            return "" + (id + 1);
        }

    }
}


</source>
<source file="../hum_codes_raw/s781367822.java" startline="1" endline="229" pcid="26234">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.io.IOException;
import java.util.TreeSet;
import java.util.ArrayList;
import java.io.UncheckedIOException;
import java.util.List;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            DBlackAndWhiteTree solver = new DBlackAndWhiteTree();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class DBlackAndWhiteTree {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            Node[] nodes = new Node[n];
            for (int i = 0; i < n; i++) {
                nodes[i] = new Node();
                nodes[i].id = i;
            }
            for (int i = 0; i < n - 1; i++) {
                Node a = nodes[in.readInt() - 1];
                Node b = nodes[in.readInt() - 1];
                a.adj.add(b);
                b.adj.add(a);
                a.deg++;
                b.deg++;
            }

            TreeSet<Node> set = new TreeSet<>((a, b) -> a.deg == b.deg ? Integer.compare(a.id, b.id) : Integer.compare(a.deg, b.deg));
            set.addAll(Arrays.asList(nodes));
            while (!set.isEmpty()) {
                Node head = set.pollFirst();
                if (head.deg == 0) {
                    out.println("First");
                    return;
                }
                head.removed = true;
                Node nearby = null;
                for (Node node : head.adj) {
                    if (node.removed) {
                        continue;
                    }
                    nearby = node;
                    set.remove(nearby);
                }
                nearby.removed = true;
                for (Node node : nearby.adj) {
                    if (node.removed) {
                        continue;
                    }
                    set.remove(node);
                    node.deg--;
                    set.add(node);
                }
            }

            out.println("Second");
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(String c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(String c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class Node {
        List<Node> adj = new ArrayList<>();
        int deg;
        int id;
        boolean removed;

        public String toString() {
            return "" + (id + 1);
        }

    }
}


</source>
</class>

<class classid="47" nclones="4" nlines="59" similarity="100">
<source file="../hum_codes_raw/s058915520.java" startline="1" endline="71" pcid="1977">
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;

class Main {

	static int n;
	static double[] x1, y1, x2, y2;
	static double sx, sy, gx, gy;
	static ArrayList<Integer>[] g;

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int q = sc.nextInt();
		while (q-- > 0) {
			long x0, y0, x1, y1, x2, y2, x3, y3;
			x0 = sc.nextLong();
			y0 = sc.nextLong();
			x1 = sc.nextLong();
			y1 = sc.nextLong();
			x2 = sc.nextLong();
			y2 = sc.nextLong();
			x3 = sc.nextLong();
			y3 = sc.nextLong();
			Point p0 = new Point(x0, y0);
			Point p1 = new Point(x1, y1);
			Point p2 = new Point(x2, y2);
			Point p3 = new Point(x3, y3);
			if (linesIntersect(p0, p1, p2, p3)) {
				System.out.println(1);
			} else {
				System.out.println(0);
			}
		}

	}

	static class Point {
		long x, y;
		int id;

		public Point(long x, long y) {
			this.x = x;
			this.y = y;
		}
	}

	static boolean linesIntersect(Point s1, Point d1, Point s2, Point d2) {
		long prd1 = crossProduct(s1, d1, s1, d2) * crossProduct(s1, d1, s1, s2);
		long prd2 = crossProduct(s2, d2, s2, s1) * crossProduct(s2, d2, s2, d1);
		if (prd1 == 0 && prd2 == 0) {
			if (((s2.x - s1.x) * (s2.x - d1.x) <= 0 && (s2.y - s1.y) * (s2.y - d1.y) <= 0)
					|| ((d2.x - s1.x) * (d2.x - d1.x) <= 0 && (d2.y - s1.y) * (d2.y - d1.y) <= 0)
					|| ((s1.x - s2.x) * (s1.x - d2.x) <= 0 && (s1.y - s2.y) * (s1.y - d2.y) <= 0)
					|| ((d1.x - s2.x) * (d1.x - d2.x) <= 0 && (d1.y - s2.y) * (d1.y - d2.y) <= 0)) {
				return true;
			} else
				return false;
		} else
			return prd1 <= 0 && prd2 <= 0;
	}

	static long crossProduct(Point s1, Point d1, Point s2, Point d2) {
		return (d1.x - s1.x) * (d2.y - s2.y) - (d1.y - s1.y) * (d2.x - s2.x);
	}

	static void tr(Object... objects) {
		System.out.println(Arrays.deepToString(objects));
	}
}

</source>
<source file="../hum_codes_raw/s734381119.java" startline="1" endline="71" pcid="24685">
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;

class Main {

	static int n;
	static double[] x1, y1, x2, y2;
	static double sx, sy, gx, gy;
	static ArrayList<Integer>[] g;

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int q = sc.nextInt();
		while (q-- > 0) {
			long x0, y0, x1, y1, x2, y2, x3, y3;
			x0 = sc.nextLong();
			y0 = sc.nextLong();
			x1 = sc.nextLong();
			y1 = sc.nextLong();
			x2 = sc.nextLong();
			y2 = sc.nextLong();
			x3 = sc.nextLong();
			y3 = sc.nextLong();
			Point p0 = new Point(x0, y0);
			Point p1 = new Point(x1, y1);
			Point p2 = new Point(x2, y2);
			Point p3 = new Point(x3, y3);
			if (linesIntersect(p0, p1, p2, p3)) {
				System.out.println(1);
			} else {
				System.out.println(0);
			}
		}

	}

	static class Point {
		long x, y;
		int id;

		public Point(long x, long y) {
			this.x = x;
			this.y = y;
		}
	}

	static boolean linesIntersect(Point s1, Point d1, Point s2, Point d2) {
		long prd1 = crossProduct(s1, d1, s1, d2) * crossProduct(s1, d1, s1, s2);
		long prd2 = crossProduct(s2, d2, s2, s1) * crossProduct(s2, d2, s2, d1);
		if (prd1 == 0 && prd2 == 0) {
			if (((s2.x - s1.x) * (s2.x - d1.x) <= 0 && (s2.y - s1.y) * (s2.y - d1.y) <= 0)
					|| ((d2.x - s1.x) * (d2.x - d1.x) <= 0 && (d2.y - s1.y) * (d2.y - d1.y) <= 0)
					|| ((s1.x - s2.x) * (s1.x - d2.x) <= 0 && (s1.y - s2.y) * (s1.y - d2.y) <= 0)
					|| ((d1.x - s2.x) * (d1.x - d2.x) <= 0 && (d1.y - s2.y) * (d1.y - d2.y) <= 0)) {
				return true;
			} else
				return false;
		} else
			return prd1 <= 0 && prd2 <= 0;
	}

	static long crossProduct(Point s1, Point d1, Point s2, Point d2) {
		return (d1.x - s1.x) * (d2.y - s2.y) - (d1.y - s1.y) * (d2.x - s2.x);
	}

	static void tr(Object... objects) {
		System.out.println(Arrays.deepToString(objects));
	}
}

</source>
<source file="../hum_codes_raw/s703249395.java" startline="1" endline="71" pcid="23656">
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;

class Main {

	static int n;
	static double[] x1, y1, x2, y2;
	static double sx, sy, gx, gy;
	static ArrayList<Integer>[] g;

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int q = sc.nextInt();
		while (q-- > 0) {
			long x0, y0, x1, y1, x2, y2, x3, y3;
			x0 = sc.nextLong();
			y0 = sc.nextLong();
			x1 = sc.nextLong();
			y1 = sc.nextLong();
			x2 = sc.nextLong();
			y2 = sc.nextLong();
			x3 = sc.nextLong();
			y3 = sc.nextLong();
			Point p0 = new Point(x0, y0);
			Point p1 = new Point(x1, y1);
			Point p2 = new Point(x2, y2);
			Point p3 = new Point(x3, y3);
			if (linesIntersect(p0, p1, p2, p3)) {
				System.out.println(1);
			} else {
				System.out.println(0);
			}
		}

	}

	static class Point {
		long x, y;
		int id;

		public Point(long x, long y) {
			this.x = x;
			this.y = y;
		}
	}

	static boolean linesIntersect(Point s1, Point d1, Point s2, Point d2) {
		long prd1 = crossProduct(s1, d1, s1, d2) * crossProduct(s1, d1, s1, s2);
		long prd2 = crossProduct(s2, d2, s2, s1) * crossProduct(s2, d2, s2, d1);
		if (prd1 == 0 && prd2 == 0) {
			if (((s2.x - s1.x) * (s2.x - d1.x) <= 0 && (s2.y - s1.y) * (s2.y - d1.y) <= 0)
					|| ((d2.x - s1.x) * (d2.x - d1.x) <= 0 && (d2.y - s1.y) * (d2.y - d1.y) <= 0)
					|| ((s1.x - s2.x) * (s1.x - d2.x) <= 0 && (s1.y - s2.y) * (s1.y - d2.y) <= 0)
					|| ((d1.x - s2.x) * (d1.x - d2.x) <= 0 && (d1.y - s2.y) * (d1.y - d2.y) <= 0)) {
				return true;
			} else
				return false;
		} else
			return prd1 <= 0 && prd2 <= 0;
	}

	static long crossProduct(Point s1, Point d1, Point s2, Point d2) {
		return (d1.x - s1.x) * (d2.y - s2.y) - (d1.y - s1.y) * (d2.x - s2.x);
	}

	static void tr(Object... objects) {
		System.out.println(Arrays.deepToString(objects));
	}
}

</source>
<source file="../hum_codes_raw/s310504887.java" startline="1" endline="71" pcid="10450">
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;

class Main {

	static int n;
	static double[] x1, y1, x2, y2;
	static double sx, sy, gx, gy;
	static ArrayList<Integer>[] g;

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int q = sc.nextInt();
		while (q-- > 0) {
			long x0, y0, x1, y1, x2, y2, x3, y3;
			x0 = sc.nextLong();
			y0 = sc.nextLong();
			x1 = sc.nextLong();
			y1 = sc.nextLong();
			x2 = sc.nextLong();
			y2 = sc.nextLong();
			x3 = sc.nextLong();
			y3 = sc.nextLong();
			Point p0 = new Point(x0, y0);
			Point p1 = new Point(x1, y1);
			Point p2 = new Point(x2, y2);
			Point p3 = new Point(x3, y3);
			if (linesIntersect(p0, p1, p2, p3)) {
				System.out.println(1);
			} else {
				System.out.println(0);
			}
		}

	}

	static class Point {
		long x, y;
		int id;

		public Point(long x, long y) {
			this.x = x;
			this.y = y;
		}
	}

	static boolean linesIntersect(Point s1, Point d1, Point s2, Point d2) {
		long prd1 = crossProduct(s1, d1, s1, d2) * crossProduct(s1, d1, s1, s2);
		long prd2 = crossProduct(s2, d2, s2, s1) * crossProduct(s2, d2, s2, d1);
		if (prd1 == 0 && prd2 == 0) {
			if (((s2.x - s1.x) * (s2.x - d1.x) <= 0 && (s2.y - s1.y) * (s2.y - d1.y) <= 0)
					|| ((d2.x - s1.x) * (d2.x - d1.x) <= 0 && (d2.y - s1.y) * (d2.y - d1.y) <= 0)
					|| ((s1.x - s2.x) * (s1.x - d2.x) <= 0 && (s1.y - s2.y) * (s1.y - d2.y) <= 0)
					|| ((d1.x - s2.x) * (d1.x - d2.x) <= 0 && (d1.y - s2.y) * (d1.y - d2.y) <= 0)) {
				return true;
			} else
				return false;
		} else
			return prd1 <= 0 && prd2 <= 0;
	}

	static long crossProduct(Point s1, Point d1, Point s2, Point d2) {
		return (d1.x - s1.x) * (d2.y - s2.y) - (d1.y - s1.y) * (d2.x - s2.x);
	}

	static void tr(Object... objects) {
		System.out.println(Arrays.deepToString(objects));
	}
}

</source>
</class>

<class classid="48" nclones="2" nlines="30" similarity="100">
<source file="../hum_codes_raw/s059024828.java" startline="1" endline="44" pcid="1983">
import java.util.Arrays;
import java.util.Scanner;
public class Main
{
	public static void main(String arg[])
	{
		Scanner sc=new Scanner(System.in);
		boolean a[] =new boolean[10001];
		Arrays.fill(a, true);
		for(int i=2; i*i<=10000; i++)
		{
			if(!a[i])
				continue;
			for(int j=i*2; j<=10000; j+=i)
				a[j]=false;
		}
		while(sc.hasNext())
		{
			int n=sc.nextInt();
			if(n==0)
				return;
			int sum=0;
			int ans=0;
			for(int i=2; i<=n; i++)
			{
				sum =0;
				if(a[i])
					for(int j=i; j<=n; j++)
					{
						if(a[j])
						{
							sum+=j;
							if(n==sum)
								ans++;
						}
						if(sum>=n)
							break;
					}
			}
			System.out.println(ans);
		}
	}
}

</source>
<source file="../hum_codes_raw/s862432766.java" startline="1" endline="44" pcid="28998">
import java.util.Arrays;
import java.util.Scanner;
public class Main
{
    public static void main(String arg[])
    {
        Scanner sc=new Scanner(System.in);
        boolean a[] =new boolean[10001];
        Arrays.fill(a, true);
        for(int i=2; i*i<=10000; i++)
        {
            if(!a[i])
                continue;
            for(int j=i*2; j<=10000; j+=i)
                a[j]=false;
        }
        while(sc.hasNext())
        {
            int n=sc.nextInt();
            if(n==0)
                return;
            int sum=0;
            int ans=0;
            for(int i=2; i<=n; i++)
            {
                sum =0;
                if(a[i])
                    for(int j=i; j<=n; j++)
                    {
                        if(a[j])
                        {
                            sum+=j;
                            if(n==sum)
                                ans++;
                        }
                        if(sum>=n)
                            break;
                    }
            }
            System.out.println(ans);
        }
    }
}

</source>
</class>

<class classid="49" nclones="2" nlines="284" similarity="100">
<source file="../hum_codes_raw/s062380094.java" startline="1" endline="336" pcid="2083">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.io.UncheckedIOException;
import java.util.List;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            EGraph solver = new EGraph();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class EGraph {
        long val = Long.MIN_VALUE;
        boolean valid = true;

        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            int m = in.readInt();
            Node[] nodes = new Node[n];
            for (int i = 0; i < n; i++) {
                nodes[i] = new Node();
            }
            for (int i = 0; i < m; i++) {
                Node a = nodes[in.readInt() - 1];
                Node b = nodes[in.readInt() - 1];
                Edge e = new Edge();
                e.a = a;
                e.b = b;
                e.w = in.readInt() - 2;
                a.adj.add(e);
                b.adj.add(e);
            }

            dfs(nodes[0], null, new DoubleLinearFunction(1, 0));
            long l = 0;
            long r = Integer.MAX_VALUE;
            for (Node node : nodes) {
                DoubleLinearFunction df = node.func;
                if (df.a == 0) {
                    if (df.b < 0) {
                        valid = false;
                    }
                    continue;
                }
                if (df.a < 0) {
                    r = Math.min(r, DigitUtils.floorDiv((long) -df.b, (long) df.a));
                } else {
                    l = Math.max(l, DigitUtils.ceilDiv((long) -df.b, (long) df.a));
                }
            }

            if (l > r) {
                valid = false;
            }
            if (!valid) {
                out.println(0);
                return;
            }
            if (val != Long.MIN_VALUE) {
                if (val >= l && val <= r) {
                    out.println(1);
                } else {
                    out.println(0);
                }
                return;
            }

            out.println(r - l + 1);
        }

        public void dfs(Node root, Edge p, DoubleLinearFunction func) {
            if (root.func != null) {
                DoubleLinearFunction delta = DoubleLinearFunction.subtract(root.func, func);
                if (delta.a == 0) {
                    if (delta.b == 0) {
                        return;
                    }
                    valid = false;
                } else {
                    if (-(long) delta.b % (long) delta.a != 0) {
                        valid = false;
                    }
                    if (val != Long.MIN_VALUE && -(long) delta.b / (long) delta.a != val) {
                        valid = false;
                    }
                    val = -(long) delta.b / (long) delta.a;
                }
                return;
            }
            root.func = func;
            for (Edge e : root.adj) {
                if (e == p) {
                    continue;
                }
                dfs(e.other(root), e, DoubleLinearFunction.subtract(
                        new DoubleLinearFunction(0, e.w), root.func));
            }
        }

    }

    static class DigitUtils {
        private DigitUtils() {
        }

        public static long floorDiv(long a, long b) {
            return a < 0 ? -ceilDiv(-a, b) : a / b;
        }

        public static long ceilDiv(long a, long b) {
            if (a < 0) {
                return -floorDiv(-a, b);
            }
            long c = a / b;
            if (c * b < a) {
                return c + 1;
            }
            return c;
        }

    }

    static class Edge {
        Node a;
        Node b;
        int w;

        Node other(Node x) {
            return a == x ? b : a;
        }

    }

    static class DoubleLinearFunction {
        public final double a;
        public final double b;

        public DoubleLinearFunction(double a, double b) {
            this.a = a;
            this.b = b;
        }

        public static DoubleLinearFunction subtract(DoubleLinearFunction a, DoubleLinearFunction b) {
            return new DoubleLinearFunction(a.a - b.a, a.b - b.b);
        }

        public boolean equals(Object obj) {
            if (!(obj instanceof DoubleLinearFunction)) {
                return false;
            }
            DoubleLinearFunction function = (DoubleLinearFunction) obj;
            return function.a == a && function.b == b;
        }

        public int hashCode() {
            return Double.hashCode(a) * 31 + Double.hashCode(b);
        }

        public String toString() {
            if (b >= 0) {
                return a + "x+" + b;
            }
            return a + "x" + b;
        }

    }

    static class Node {
        List<Edge> adj = new ArrayList<>();
        DoubleLinearFunction func;

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(long c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println(long c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }
}


</source>
<source file="../hum_codes_raw/s087113353.java" startline="1" endline="336" pcid="2891">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.io.UncheckedIOException;
import java.util.List;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            EGraph solver = new EGraph();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class EGraph {
        long val = Long.MIN_VALUE;
        boolean valid = true;

        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            int m = in.readInt();
            Node[] nodes = new Node[n];
            for (int i = 0; i < n; i++) {
                nodes[i] = new Node();
            }
            for (int i = 0; i < m; i++) {
                Node a = nodes[in.readInt() - 1];
                Node b = nodes[in.readInt() - 1];
                Edge e = new Edge();
                e.a = a;
                e.b = b;
                e.w = in.readInt() - 2;
                a.adj.add(e);
                b.adj.add(e);
            }

            dfs(nodes[0], null, new DoubleLinearFunction(1, 0));
            long l = 0;
            long r = Integer.MAX_VALUE;
            for (Node node : nodes) {
                DoubleLinearFunction df = node.func;
                if (df.a == 0) {
                    if (df.b < 0) {
                        valid = false;
                    }
                    continue;
                }
                if (df.a < 0) {
                    r = Math.min(r, DigitUtils.floorDiv((long) -df.b, (long) df.a));
                } else {
                    l = Math.max(l, DigitUtils.ceilDiv((long) -df.b, (long) df.a));
                }
            }

            if (l > r) {
                valid = false;
            }
            if (!valid) {
                out.println(0);
                return;
            }
            if (val != Long.MIN_VALUE) {
                if (val >= l && val <= r) {
                    out.println(1);
                } else {
                    out.println(0);
                }
                return;
            }

            out.println(r - l + 1);
        }

        public void dfs(Node root, Edge p, DoubleLinearFunction func) {
            if (root.func != null) {
                DoubleLinearFunction delta = DoubleLinearFunction.subtract(root.func, func);
                if (delta.a == 0) {
                    if (delta.b == 0) {
                        return;
                    }
                    valid = false;
                } else {
                    if (-(long) delta.b % (long) delta.a != 0) {
                        valid = false;
                    }
                    if (val != Long.MIN_VALUE && -(long) delta.b / (long) delta.a != val) {
                        valid = false;
                    }
                    val = -(long) delta.b / (long) delta.a;
                }
                return;
            }
            root.func = func;
            for (Edge e : root.adj) {
                if (e == p) {
                    continue;
                }
                dfs(e.other(root), e, DoubleLinearFunction.subtract(
                        new DoubleLinearFunction(0, e.w), root.func));
            }
        }

    }

    static class DigitUtils {
        private DigitUtils() {
        }

        public static long floorDiv(long a, long b) {
            return a < 0 ? -ceilDiv(-a, b) : a / b;
        }

        public static long ceilDiv(long a, long b) {
            if (a < 0) {
                return -floorDiv(-a, b);
            }
            long c = a / b;
            if (c * b < a) {
                return c + 1;
            }
            return c;
        }

    }

    static class Edge {
        Node a;
        Node b;
        int w;

        Node other(Node x) {
            return a == x ? b : a;
        }

    }

    static class DoubleLinearFunction {
        public final double a;
        public final double b;

        public DoubleLinearFunction(double a, double b) {
            this.a = a;
            this.b = b;
        }

        public static DoubleLinearFunction subtract(DoubleLinearFunction a, DoubleLinearFunction b) {
            return new DoubleLinearFunction(a.a - b.a, a.b - b.b);
        }

        public boolean equals(Object obj) {
            if (!(obj instanceof DoubleLinearFunction)) {
                return false;
            }
            DoubleLinearFunction function = (DoubleLinearFunction) obj;
            return function.a == a && function.b == b;
        }

        public int hashCode() {
            return Double.hashCode(a) * 31 + Double.hashCode(b);
        }

        public String toString() {
            if (b >= 0) {
                return a + "x+" + b;
            }
            return a + "x" + b;
        }

    }

    static class Node {
        List<Edge> adj = new ArrayList<>();
        DoubleLinearFunction func;

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(long c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println(long c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }
}


</source>
</class>

<class classid="50" nclones="2" nlines="77" similarity="100">
<source file="../hum_codes_raw/s063720635.java" startline="1" endline="97" pcid="2130">
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		int n = sc.nextInt();
		long x[] = new long[n], y[] = new long[n];
		
		for(int i=0;i<n;i++){
			x[i] = sc.nextLong();
			y[i] = sc.nextLong();
		}
		
		long parity = Math.abs((x[0] + y[0]) % 2);
		
		boolean f = true;
		for(int i=1;i<n;i++){
			if(Math.abs((x[i]+y[i])%2) != parity)
				f = false;
		}
		
		if(f){
			long a[] = new long[31];
			
			a[0] = 1;
			for(int i=1;i<31;i++){
				a[i] = a[i-1]*2;
			}
			
			
			if(parity==0){
				System.out.println(32);
				System.out.print(1+" ");
			}
			else{
				System.out.println(31);
			}
			
			for(int i=30;i>=0;i--){
				System.out.print(i==30 ? a[i]:" "+a[i]);
			}
			System.out.println();
			
			
			for(int i=0;i<n;i++){
				if(parity==0){
					if(Math.abs(x[i]-1) + Math.abs(y[i]) <= (1L<<31) -1){
						x[i] -= 1;
						System.out.print("R");
					}
					else if(Math.abs(x[i]+1) + Math.abs(y[i]) <= (1L<<31) -1){
						x[i] += 1;
						System.out.print("L");
					}
					else if(Math.abs(x[i]) + Math.abs(y[i]-1) <= (1L<<31) -1){
						y[i] -=1;
						System.out.print("U");
					}
					else{
						y[i]+=1;
						System.out.print("D");
					}
				}
				
				
				for(int j=30;j>=0;j--){
					
					if(Math.abs(x[i]-a[j]) + Math.abs(y[i]) <= (1L<<j) -1){
						x[i] -= a[j];
						System.out.print("R");
					}
					else if(Math.abs(x[i]+a[j]) + Math.abs(y[i]) <= (1L<<j) -1){
						x[i] += a[j];
						System.out.print("L");
					}
					else if(Math.abs(x[i]) + Math.abs(y[i]-a[j]) <= (1L<<j) -1){
						y[i] -= a[j];
						System.out.print("U");
					}
					else{
						y[i] += a[j];
						System.out.print("D");
					}
				}
				System.out.println();
			}
			
		}
		else{
			System.out.println(-1);
		}
	}

}

</source>
<source file="../hum_codes_raw/s905058124.java" startline="1" endline="97" pcid="30460">
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		int n = sc.nextInt();
		long x[] = new long[n], y[] = new long[n];
		
		for(int i=0;i<n;i++){
			x[i] = sc.nextLong();
			y[i] = sc.nextLong();
		}
		
		long parity = Math.abs((x[0] + y[0]) % 2);
		
		boolean f = true;
		for(int i=1;i<n;i++){
			if(Math.abs((x[i]+y[i])%2) != parity)
				f = false;
		}
		
		if(f){
			long a[] = new long[31];
			
			a[0] = 1;
			for(int i=1;i<31;i++){
				a[i] = a[i-1]*2;
			}
			
			
			if(parity==0){
				System.out.println(32);
				System.out.print(1+" ");
			}
			else{
				System.out.println(31);
			}
			
			for(int i=30;i>=0;i--){
				System.out.print(i==30 ? a[i]:" "+a[i]);
			}
			System.out.println();
			
			
			for(int i=0;i<n;i++){
				if(parity==0){
					if(Math.abs(x[i]-1) + Math.abs(y[i]) <= (1L<<31) -1){
						x[i] -= 1;
						System.out.print("R");
					}
					else if(Math.abs(x[i]+1) + Math.abs(y[i]) <= (1L<<31) -1){
						x[i] += 1;
						System.out.print("L");
					}
					else if(Math.abs(x[i]) + Math.abs(y[i]-1) <= (1L<<31) -1){
						y[i] -=1;
						System.out.print("U");
					}
					else{
						y[i]+=1;
						System.out.print("D");
					}
				}
				
				
				for(int j=30;j>=0;j--){
					
					if(Math.abs(x[i]-a[j]) + Math.abs(y[i]) <= (1L<<j) -1){
						x[i] -= a[j];
						System.out.print("R");
					}
					else if(Math.abs(x[i]+a[j]) + Math.abs(y[i]) <= (1L<<j) -1){
						x[i] += a[j];
						System.out.print("L");
					}
					else if(Math.abs(x[i]) + Math.abs(y[i]-a[j]) <= (1L<<j) -1){
						y[i] -= a[j];
						System.out.print("U");
					}
					else{
						y[i] += a[j];
						System.out.print("D");
					}
				}
				System.out.println();
			}
			
		}
		else{
			System.out.println(-1);
		}
	}

}

</source>
</class>

<class classid="51" nclones="2" nlines="15" similarity="100">
<source file="../hum_codes_raw/s063975139.java" startline="1" endline="18" pcid="2141">
import java.util.Scanner;

public class Main {
	public static void main (String[] args) {
		Scanner sc = new Scanner(System.in);

		int a = sc.nextInt();
		int b = sc.nextInt();
		int c = sc.nextInt();
		
		if (a + b >= c){
			System.out.println("Yes");
		} else {
			System.out.println("No");
		}
	}
}

</source>
<source file="../hum_codes_raw/s401751248.java" startline="1" endline="19" pcid="13531">
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        int a=sc.nextInt();
        int b=sc.nextInt();
        int c=sc.nextInt();
        if(a+b>=c) {
            System.out.println("Yes");
        }else {
            System.out.println("No");
        }

    }

}

</source>
</class>

<class classid="52" nclones="2" nlines="436" similarity="100">
<source file="../hum_codes_raw/s064541745.java" startline="1" endline="488" pcid="2161">
import java.io.*;
import java.util.*;

public class Main {
  private static final int INF = 10_000_000;

  private static final UpdateRangeGetRangeSegmentTree.Operator<Integer, Integer> OPERATOR = new UpdateRangeGetRangeSegmentTree.Operator<>() {
    @Override
    public Integer multiplyLazyValue(Integer lazy, int count) {
      return lazy;
    }

    @Override
    public Integer applyOffset(Integer lazy, int offset) {
      return lazy + offset;
    }

    @Override
    public Integer mergeLazyValue(Integer oldLazy, Integer newLazy) {
      return newLazy;
    }

    @Override
    public Integer apply(Integer value, Integer lazy) {
      return lazy;
    }

    @Override
    public Integer mergeValue(Integer smallIndexValue, Integer largeIndexValue) {
      return Math.min(smallIndexValue, largeIndexValue);
    }

    @Override
    public Integer getUnitValue() {
      return INF;
    }
  };

  private static List<Integer> solve(int h, int w, int[][] abs) {
    Integer[] initialValues = new Integer[w + 1];
    Arrays.fill(initialValues, Integer.valueOf(0));
    initialValues[0] = INF;

    UpdateRangeGetRangeSegmentTree<Integer, Integer> segmentTree = new UpdateRangeGetRangeSegmentTree<>(OPERATOR, initialValues);
    List<Integer> answers = new ArrayList<>();
    for (int i = 0; i < h; i++) {
      int a = abs[i][0];
      int b = abs[i][1];
      int answer = segmentTree.getRange(0, a);
      if (b + 1 < w + 1) {
        answer = Math.min(answer, segmentTree.getRange(b + 1, w + 1));
      }
      if (answer < INF) {
        answers.add(answer + i + 1);
      } else {
        answers.add(-1);
      }
      int v = segmentTree.get(a - 1) - a + 1;
      segmentTree.update(a, b + 1, v);
    }
    return answers;
  }

  private static void execute(ContestReader reader, ContestWriter out) {
    int h = reader.nextInt();
    int w = reader.nextInt();
    int[][] abs = reader.nextInt(h, 2);
    out.printList(solve(h, w, abs));
  }
  
  public static void main(String[] args) {
    ContestReader reader = new ContestReader(System.in);
    ContestWriter out = new ContestWriter(System.out);
    execute(reader, out);
    out.flush();
  }
}

class UpdateRangeGetRangeSegmentTree<T, S> {
  public interface Operator<T, S> {
    T multiplyLazyValue(T lazy, int count);
//    T getUnitLazy();
    T applyOffset(T lazy, int offset);
    T mergeLazyValue(T oldLazy, T newLazy);
    S apply(S value, T lazy);
    S mergeValue(S smallIndexValue, S largeIndexValue);
    S getUnitValue();
  }
  
  private final Operator<T, S> operator;
  private final int n;
  private final List<T> lazies;
  private final List<S> values;
  
  public UpdateRangeGetRangeSegmentTree(Operator<T, S> operator, S[] initialValues) {
    this.operator = operator;
    
    int tempN = 1;
    while (tempN < initialValues.length) {
      tempN *= 2;
    }
    n = tempN;
    lazies = new ArrayList<>();
    values = new ArrayList<>();
    for (int i = 0; i < 2 * n - 1; i++) {
      lazies.add(null);
      values.add(null);
    }
    for (int i = 0; i < initialValues.length; i++) {
      values.set(i + n - 1, initialValues[i]);
    }
    for (int i = initialValues.length; i < n; i++) {
      values.set(i + n - 1, this.operator.getUnitValue());
    }
    for (int i = n - 2; i >= 0; i--) {
      values.set(i, this.operator.mergeValue(values.get(2 * i + 1), values.get(2 * i + 2)));
    }
  }
  
  private void eval(int k, int l, int r) {
    if (lazies.get(k) == null) {
      return;
    }
    values.set(k, operator.apply(values.get(k), operator.multiplyLazyValue(lazies.get(k), r - l)));
    if (r - l > 1) {
      lazies.set(2 * k + 1, operator.mergeLazyValue(lazies.get(2 * k + 1), lazies.get(k)));
      lazies.set(2 * k + 2, operator.mergeLazyValue(lazies.get(2 * k + 2), operator.applyOffset(lazies.get(k), (r - l) / 2)));
    }
    lazies.set(k, null);
  }
  
  private void update(int a, int b, T lazy, int k, int l, int r) {
    eval(k, l, r);
    if (b <= l || r <= a) {
      return;
    }
    if (a <= l && r <= b) {
      lazies.set(k, operator.mergeLazyValue(lazies.get(k), lazy));
      eval(k, l, r);
    } else {
      update(a, b, lazy, 2 * k + 1, l, (l + r) / 2);
      update(a, b, operator.applyOffset(lazy, (r - l) / 2), 2 * k + 2, (l + r) / 2, r);
      values.set(k, operator.mergeValue(values.get(2 * k + 1), values.get(2 * k + 2)));
    }
  }
  
  public void update(int a, int b, T lazy) {
    update(a, b, lazy, 0, 0, n);
  }
  
  public void update(int a, T lazy) {
    update(a, a + 1, lazy);
  }
  
  private S getRange(int a, int b, int k, int l, int r) {
    if (b <= l || r <= a) {
      return operator.getUnitValue();
    }
    eval(k, l, r);
    if (a <= l && r <= b) {
      return values.get(k);
    }
    S vl = getRange(a, b, 2 * k + 1, l, (l + r) / 2);
    S vr = getRange(a, b, 2 * k + 2, (l + r) / 2, r);
    return operator.mergeValue(vl, vr);
  }
  
  public S getRange(int a, int b) {
    return getRange(a, b, 0, 0, n);
  }
  
  public S get(int a) {
    return getRange(a, a + 1);
  }

  private void dump(List list) {
    int sum = 0;
    for (int i = 0; sum + (1 << i) <= 2 * n - 1; sum += 1 << i, i++) {
      for (int j = sum; j < sum + (1 << i); j++) {
        System.err.print(list.get(j));
        System.err.print(" ");
      }
      System.err.println();
    }
    System.err.println();
  }
  
  public void dump() {
    System.err.println("values: ");
    dump(values);
    System.err.println("lazies: ");
    dump(lazies);
  }
}

class ContestWriter extends PrintWriter {
  ContestWriter(PrintStream printStream) {
    super(printStream);
  }

  public void printList(List<? extends Object> list) {
    for (Object object : list) {
      println(object);
    }
  }

  public void printListOneLine(List<? extends Object> list) {
    List<String> stringList = new ArrayList<>();
    for (Object object : list) {
      stringList.add(object.toString());
    }
    println(String.join(" ", stringList));
  }
}

class ContestReader {
  private static final int BUFFER_SIZE = 1024;
  
  private final InputStream stream;
  private final byte[] buffer;
  private int pointer;
  private int bufferLength;
  
  ContestReader(InputStream stream) {
    this.stream = stream;
    this.buffer = new byte[BUFFER_SIZE];
    this.pointer = 0;
    this.bufferLength = 0;
  }
  
  private boolean hasNextByte() {
    if (pointer < bufferLength) {
      return true;
    }
    
    pointer = 0;
    try {
      bufferLength = stream.read(buffer);
    } catch (IOException e) {
      throw new RuntimeException(e);
    }
    return bufferLength > 0;
  }
  
  private int readByte() {
    if (hasNextByte()) {
      return buffer[pointer++];
    } else {
      return -1;
    }
  }
  
  private static boolean isPrintableChar(int c) {
    return 33 <= c && c <= 126;
  }
  
  public boolean hasNext() {
    while (hasNextByte() && !isPrintableChar(buffer[pointer])) {
      pointer++;
    }
    return hasNextByte();
  }
  
  public String next() {
    if (!hasNext()) {
      throw new NoSuchElementException();
    }
    StringBuilder sb = new StringBuilder();
    while(true) {
      int b = readByte();
      if (!isPrintableChar(b)) {
        break;
      }
      sb.appendCodePoint(b);
    }
    return sb.toString();
  }
  
  public String nextLine() {
    if (!hasNext()) {
      throw new NoSuchElementException();
    }
    StringBuilder sb = new StringBuilder();
    while(true) {
      int b = readByte();
      if (!isPrintableChar(b) && b != 0x20) {
        break;
      }
      sb.appendCodePoint(b);
    }
    return sb.toString();
  }
  
  public char nextChar() {
    return next().charAt(0);
  }
  
  public int nextInt() {
    if (!hasNext()) {
      throw new NoSuchElementException();
    }
    
    int n = 0;
    boolean minus = false;
    
    {
      int b = readByte();
      if (b == '-') {
        minus = true;
      } else if ('0' <= b && b <= '9') {
        n = b - '0';
      } else {
        throw new NumberFormatException();
      }
    }
    
    while(true){
      int b = readByte();
      if ('0' <= b && b <= '9') {
        n *= 10;
        n += b - '0';
      } else if (b == -1 || !isPrintableChar(b)) {
        return minus ? -n : n;
      } else {
        throw new NumberFormatException();
      }
    }
  }
  
  public long nextLong() {
    if (!hasNext()) {
      throw new NoSuchElementException();
    }
    
    long n = 0;
    boolean minus = false;
    
    {
      int b = readByte();
      if (b == '-') {
        minus = true;
      } else if ('0' <= b && b <= '9') {
        n = b - '0';
      } else {
        throw new NumberFormatException();
      }
    }
    
    while(true){
      int b = readByte();
      if ('0' <= b && b <= '9') {
        n *= 10;
        n += b - '0';
      } else if (b == -1 || !isPrintableChar(b)) {
        return minus ? -n : n;
      } else {
        throw new NumberFormatException();
      }
    }
  }
  
  public double nextDouble() {
    return Double.parseDouble(next());
  }
  
  public String[] next(int n) {
    String[] array = new String[n];
    for (int i = 0; i < n; i++) {
      array[i] = next();
    }
    return array;
  }
  
  public String[] nextLine(int n) {
    String[] array = new String[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextLine();
    }
    return array;
  }
  
  public char[] nextChar(int n) {
    char[] array = new char[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextChar();
    }
    return array;
  }
  
  public int[] nextInt(int n) {
    int[] array = new int[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextInt();
    }
    return array;
  }
  
  public long[] nextLong(int n) {
    long[] array = new long[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextLong();
    }
    return array;
  }
  
  public double[] nextDouble(int n) {
    double[] array = new double[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextDouble();
    }
    return array;
  }
  
  public char[] nextCharArray() {
    return next().toCharArray();
  }
  
  public String[][] next(int n, int m) {
    String[][] matrix = new String[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = next();
      }
    }
    return matrix;
  }
  
  public int[][] nextInt(int n, int m) {
    int[][] matrix = new int[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextInt();
      }
    }
    return matrix;
  }
  
  public char[][] nextChar(int n, int m) {
    char[][] matrix = new char[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextChar();
      }
    }
    return matrix;
  }
  
  public long[][] nextLong(int n, int m) {
    long[][] matrix = new long[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextLong();
      }
    }
    return matrix;
  }
  
  public double[][] nextDouble(int n, int m) {
    double[][] matrix = new double[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextDouble();
      }
    }
    return matrix;
  }
  
  public char[][] nextCharArray(int n) {
    char[][] matrix = new char[n][];
    for (int i = 0; i < n; i++) {
      matrix[i] = next().toCharArray();
    }
    return matrix;
  }
}

class MyAssert {
  public static void myAssert(boolean flag, String message) {
    if (!flag) {
      throw new RuntimeException(message);
    }
  }
 
  public static void myAssert(boolean flag) {
    myAssert(flag, "");
  }
}

</source>
<source file="../hum_codes_raw/s769774624.java" startline="1" endline="487" pcid="25845">
import java.io.*;
import java.util.*;

public class Main {
  private static final int INF = 10_000_000;

  private static final UpdateRangeGetRangeSegmentTree.Operator<Integer, Integer> OPERATOR = new UpdateRangeGetRangeSegmentTree.Operator<>() {
    @Override
    public Integer multiplyLazyValue(Integer lazy, int count) {
      return lazy;
    }

    @Override
    public Integer applyOffset(Integer lazy, int offset) {
      return lazy + offset;
    }

    @Override
    public Integer mergeLazyValue(Integer oldLazy, Integer newLazy) {
      return newLazy;
    }

    @Override
    public Integer apply(Integer value, Integer lazy) {
      return lazy;
    }

    @Override
    public Integer mergeValue(Integer smallIndexValue, Integer largeIndexValue) {
      return Math.min(smallIndexValue, largeIndexValue);
    }

    @Override
    public Integer getUnitValue() {
      return INF;
    }
  };

  private static List<Integer> solve(int h, int w, int[][] abs) {
    Integer[] initialValues = new Integer[w + 1];
    Arrays.fill(initialValues, Integer.valueOf(0));
    initialValues[0] = INF;

    UpdateRangeGetRangeSegmentTree<Integer, Integer> segmentTree = new UpdateRangeGetRangeSegmentTree<>(OPERATOR, initialValues);
    List<Integer> answers = new ArrayList<>();
    for (int i = 0; i < h; i++) {
      int a = abs[i][0];
      int b = abs[i][1];
      int answer = segmentTree.getRange(0, a);
      if (b + 1 < w + 1) {
        answer = Math.min(answer, segmentTree.getRange(b + 1, w + 1));
      }
      if (answer < INF) {
        answers.add(answer + i + 1);
      } else {
        answers.add(-1);
      }
      int v = segmentTree.get(a - 1) - a + 1;
      segmentTree.update(a, b + 1, v);
    }
    return answers;
  }

  private static void execute(ContestReader reader, ContestWriter out) {
    int h = reader.nextInt();
    int w = reader.nextInt();
    int[][] abs = reader.nextInt(h, 2);
    out.printList(solve(h, w, abs));
  }
  
  public static void main(String[] args) {
    ContestReader reader = new ContestReader(System.in);
    ContestWriter out = new ContestWriter(System.out);
    execute(reader, out);
    out.flush();
  }
}

class UpdateRangeGetRangeSegmentTree<T, S> {
  public interface Operator<T, S> {
    T multiplyLazyValue(T lazy, int count);
    T applyOffset(T lazy, int offset);
    T mergeLazyValue(T oldLazy, T newLazy);
    S apply(S value, T lazy);
    S mergeValue(S smallIndexValue, S largeIndexValue);
    S getUnitValue();
  }
  
  private final Operator<T, S> operator;
  private final int n;
  private final List<T> lazies;
  private final List<S> values;
  
  public UpdateRangeGetRangeSegmentTree(Operator<T, S> operator, S[] initialValues) {
    this.operator = operator;
    
    int tempN = 1;
    while (tempN < initialValues.length) {
      tempN *= 2;
    }
    n = tempN;
    lazies = new ArrayList<>();
    values = new ArrayList<>();
    for (int i = 0; i < 2 * n - 1; i++) {
      lazies.add(null);
      values.add(null);
    }
    for (int i = 0; i < initialValues.length; i++) {
      values.set(i + n - 1, initialValues[i]);
    }
    for (int i = initialValues.length; i < n; i++) {
      values.set(i + n - 1, this.operator.getUnitValue());
    }
    for (int i = n - 2; i >= 0; i--) {
      values.set(i, this.operator.mergeValue(values.get(2 * i + 1), values.get(2 * i + 2)));
    }
  }
  
  private void eval(int k, int l, int r) {
    if (lazies.get(k) == null) {
      return;
    }
    values.set(k, operator.apply(values.get(k), operator.multiplyLazyValue(lazies.get(k), r - l)));
    if (r - l > 1) {
      lazies.set(2 * k + 1, operator.mergeLazyValue(lazies.get(2 * k + 1), lazies.get(k)));
      lazies.set(2 * k + 2, operator.mergeLazyValue(lazies.get(2 * k + 2), operator.applyOffset(lazies.get(k), (r - l) / 2)));
    }
    lazies.set(k, null);
  }
  
  private void update(int a, int b, T lazy, int k, int l, int r) {
    eval(k, l, r);
    if (b <= l || r <= a) {
      return;
    }
    if (a <= l && r <= b) {
      lazies.set(k, operator.mergeLazyValue(lazies.get(k), lazy));
      eval(k, l, r);
    } else {
      update(a, b, lazy, 2 * k + 1, l, (l + r) / 2);
      update(a, b, operator.applyOffset(lazy, (r - l) / 2), 2 * k + 2, (l + r) / 2, r);
      values.set(k, operator.mergeValue(values.get(2 * k + 1), values.get(2 * k + 2)));
    }
  }
  
  public void update(int a, int b, T lazy) {
    update(a, b, lazy, 0, 0, n);
  }
  
  public void update(int a, T lazy) {
    update(a, a + 1, lazy);
  }
  
  private S getRange(int a, int b, int k, int l, int r) {
    if (b <= l || r <= a) {
      return operator.getUnitValue();
    }
    eval(k, l, r);
    if (a <= l && r <= b) {
      return values.get(k);
    }
    S vl = getRange(a, b, 2 * k + 1, l, (l + r) / 2);
    S vr = getRange(a, b, 2 * k + 2, (l + r) / 2, r);
    return operator.mergeValue(vl, vr);
  }
  
  public S getRange(int a, int b) {
    return getRange(a, b, 0, 0, n);
  }
  
  public S get(int a) {
    return getRange(a, a + 1);
  }

  private void dump(List list) {
    int sum = 0;
    for (int i = 0; sum + (1 << i) <= 2 * n - 1; sum += 1 << i, i++) {
      for (int j = sum; j < sum + (1 << i); j++) {
        System.err.print(list.get(j));
        System.err.print(" ");
      }
      System.err.println();
    }
    System.err.println();
  }
  
  public void dump() {
    System.err.println("values: ");
    dump(values);
    System.err.println("lazies: ");
    dump(lazies);
  }
}

class ContestWriter extends PrintWriter {
  ContestWriter(PrintStream printStream) {
    super(printStream);
  }

  public void printList(List<? extends Object> list) {
    for (Object object : list) {
      println(object);
    }
  }

  public void printListOneLine(List<? extends Object> list) {
    List<String> stringList = new ArrayList<>();
    for (Object object : list) {
      stringList.add(object.toString());
    }
    println(String.join(" ", stringList));
  }
}

class ContestReader {
  private static final int BUFFER_SIZE = 1024;
  
  private final InputStream stream;
  private final byte[] buffer;
  private int pointer;
  private int bufferLength;
  
  ContestReader(InputStream stream) {
    this.stream = stream;
    this.buffer = new byte[BUFFER_SIZE];
    this.pointer = 0;
    this.bufferLength = 0;
  }
  
  private boolean hasNextByte() {
    if (pointer < bufferLength) {
      return true;
    }
    
    pointer = 0;
    try {
      bufferLength = stream.read(buffer);
    } catch (IOException e) {
      throw new RuntimeException(e);
    }
    return bufferLength > 0;
  }
  
  private int readByte() {
    if (hasNextByte()) {
      return buffer[pointer++];
    } else {
      return -1;
    }
  }
  
  private static boolean isPrintableChar(int c) {
    return 33 <= c && c <= 126;
  }
  
  public boolean hasNext() {
    while (hasNextByte() && !isPrintableChar(buffer[pointer])) {
      pointer++;
    }
    return hasNextByte();
  }
  
  public String next() {
    if (!hasNext()) {
      throw new NoSuchElementException();
    }
    StringBuilder sb = new StringBuilder();
    while(true) {
      int b = readByte();
      if (!isPrintableChar(b)) {
        break;
      }
      sb.appendCodePoint(b);
    }
    return sb.toString();
  }
  
  public String nextLine() {
    if (!hasNext()) {
      throw new NoSuchElementException();
    }
    StringBuilder sb = new StringBuilder();
    while(true) {
      int b = readByte();
      if (!isPrintableChar(b) && b != 0x20) {
        break;
      }
      sb.appendCodePoint(b);
    }
    return sb.toString();
  }
  
  public char nextChar() {
    return next().charAt(0);
  }
  
  public int nextInt() {
    if (!hasNext()) {
      throw new NoSuchElementException();
    }
    
    int n = 0;
    boolean minus = false;
    
    {
      int b = readByte();
      if (b == '-') {
        minus = true;
      } else if ('0' <= b && b <= '9') {
        n = b - '0';
      } else {
        throw new NumberFormatException();
      }
    }
    
    while(true){
      int b = readByte();
      if ('0' <= b && b <= '9') {
        n *= 10;
        n += b - '0';
      } else if (b == -1 || !isPrintableChar(b)) {
        return minus ? -n : n;
      } else {
        throw new NumberFormatException();
      }
    }
  }
  
  public long nextLong() {
    if (!hasNext()) {
      throw new NoSuchElementException();
    }
    
    long n = 0;
    boolean minus = false;
    
    {
      int b = readByte();
      if (b == '-') {
        minus = true;
      } else if ('0' <= b && b <= '9') {
        n = b - '0';
      } else {
        throw new NumberFormatException();
      }
    }
    
    while(true){
      int b = readByte();
      if ('0' <= b && b <= '9') {
        n *= 10;
        n += b - '0';
      } else if (b == -1 || !isPrintableChar(b)) {
        return minus ? -n : n;
      } else {
        throw new NumberFormatException();
      }
    }
  }
  
  public double nextDouble() {
    return Double.parseDouble(next());
  }
  
  public String[] next(int n) {
    String[] array = new String[n];
    for (int i = 0; i < n; i++) {
      array[i] = next();
    }
    return array;
  }
  
  public String[] nextLine(int n) {
    String[] array = new String[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextLine();
    }
    return array;
  }
  
  public char[] nextChar(int n) {
    char[] array = new char[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextChar();
    }
    return array;
  }
  
  public int[] nextInt(int n) {
    int[] array = new int[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextInt();
    }
    return array;
  }
  
  public long[] nextLong(int n) {
    long[] array = new long[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextLong();
    }
    return array;
  }
  
  public double[] nextDouble(int n) {
    double[] array = new double[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextDouble();
    }
    return array;
  }
  
  public char[] nextCharArray() {
    return next().toCharArray();
  }
  
  public String[][] next(int n, int m) {
    String[][] matrix = new String[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = next();
      }
    }
    return matrix;
  }
  
  public int[][] nextInt(int n, int m) {
    int[][] matrix = new int[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextInt();
      }
    }
    return matrix;
  }
  
  public char[][] nextChar(int n, int m) {
    char[][] matrix = new char[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextChar();
      }
    }
    return matrix;
  }
  
  public long[][] nextLong(int n, int m) {
    long[][] matrix = new long[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextLong();
      }
    }
    return matrix;
  }
  
  public double[][] nextDouble(int n, int m) {
    double[][] matrix = new double[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextDouble();
      }
    }
    return matrix;
  }
  
  public char[][] nextCharArray(int n) {
    char[][] matrix = new char[n][];
    for (int i = 0; i < n; i++) {
      matrix[i] = next().toCharArray();
    }
    return matrix;
  }
}

class MyAssert {
  public static void myAssert(boolean flag, String message) {
    if (!flag) {
      throw new RuntimeException(message);
    }
  }
 
  public static void myAssert(boolean flag) {
    myAssert(flag, "");
  }
}

</source>
</class>

<class classid="53" nclones="2" nlines="20" similarity="100">
<source file="../hum_codes_raw/s065444897.java" startline="1" endline="27" pcid="2195">
import java.util.Arrays;
import java.util.Scanner;
import java.util.stream.IntStream;

/**
 * 
 */
public class Main {

	public static void main(String[] args) {
		try (Scanner scanner = new Scanner(System.in)) {
			int n = scanner.nextInt(), m = scanner.nextInt(), q = scanner.nextInt();
			int[][] x = new int[n + 1][n + 1], c = new int[n + 1][n + 1];
			IntStream.range(0, n + 1).forEach(i -> Arrays.fill(x[i], 0));
			IntStream.range(0, m).forEach(i -> x[scanner.nextInt()][scanner.nextInt()]++);
			Arrays.fill(c[0], 0);
			IntStream.rangeClosed(1, n).forEach(i -> c[i][0] = 0);
			IntStream.rangeClosed(1, n)
					.forEach(i -> IntStream.rangeClosed(1, n).forEach(j -> c[i][j] = c[i][j - 1] + x[i][j]));
			IntStream.range(0, q).forEach(i -> {
				int l = scanner.nextInt(), r = scanner.nextInt();
				System.out.println(IntStream.rangeClosed(l, r).map(j -> c[j][r] - c[j][l - 1]).sum());
			});
		}
	}
}

</source>
<source file="../hum_codes_raw/s411025858.java" startline="1" endline="27" pcid="13819">
import java.util.Arrays;
import java.util.Scanner;
import java.util.stream.IntStream;

/**
 * 
 */
public class Main {

	public static void main(String[] args) {
		try (Scanner scanner = new Scanner(System.in)) {
			int n = scanner.nextInt(), m = scanner.nextInt(), q = scanner.nextInt();
			int[][] x = new int[n + 1][n + 1], c = new int[n + 1][n + 1];
			IntStream.range(0, n + 1).forEach(i -> Arrays.fill(x[i], 0));
			IntStream.range(0, m).forEach(i -> x[scanner.nextInt()][scanner.nextInt()]++);
			Arrays.fill(c[0], 0);
			IntStream.rangeClosed(1, n).forEach(i -> c[i][0] = 0);
			IntStream.rangeClosed(1, n)
					.forEach(i -> IntStream.rangeClosed(1, n).forEach(j -> c[i][j] = c[i][j - 1] + x[i][j]));
			IntStream.range(0, q).forEach(i -> {
				int l = scanner.nextInt(), r = scanner.nextInt();
				System.out.println(IntStream.rangeClosed(l, r).map(j -> c[j][r] - c[j][l - 1]).sum());
			});
		}
	}
}

</source>
</class>

<class classid="54" nclones="2" nlines="34" similarity="100">
<source file="../hum_codes_raw/s075686162.java" startline="1" endline="47" pcid="2530">
import java.util.Scanner;

public class Main
{
	public static void main(String[] args)
	{
		Scanner sc = new Scanner(System.in);
		for(;;)
		{
			int N = sc.nextInt(), P = sc.nextInt();
			if (N==0 && P==0) break;
			
			int[] s = new int[N];
			for (int n = 0; ; n = (n + 1) % N)
			{
				if (P != 0)
				{
					P--;
					s[n]++;
					if (P == 0)
					{
						boolean win = true;
						for (int i = 0; i < N; i++)
						{
							if (i != n && s[i] != 0)
							{
								win = false;
								break;
							}
						}
						if (win)
						{
							System.out.println(n);
							break;
						}
					}
				}
				else
				{
					P = s[n];
					s[n] = 0;
				}
			}
		}
	}
}

</source>
<source file="../hum_codes_raw/s762139857.java" startline="1" endline="47" pcid="25599">
import java.util.Scanner;
 
public class Main
{
    public static void main(String[] args)
    {
        Scanner sc = new Scanner(System.in);
        for(;;)
        {
            int N = sc.nextInt(), P = sc.nextInt();
            if (N==0 && P==0) break;
             
            int[] s = new int[N];
            for (int n = 0; ; n = (n + 1) % N)
            {
                if (P != 0)
                {
                    P--;
                    s[n]++;
                    if (P == 0)
                    {
                        boolean win = true;
                        for (int i = 0; i < N; i++)
                        {
                            if (i != n && s[i] != 0)
                            {
                                win = false;
                                break;
                            }
                        }
                        if (win)
                        {
                            System.out.println(n);
                            break;
                        }
                    }
                }
                else
                {
                    P = s[n];
                    s[n] = 0;
                }
            }
        }
    }
}

</source>
</class>

<class classid="55" nclones="2" nlines="18" similarity="100">
<source file="../hum_codes_raw/s079945584.java" startline="1" endline="18" pcid="2676">
import java.util.Scanner;
public class Main {
	public static void main(String[] args) throws java.io.IOException {
		Scanner scan = new Scanner(System.in);
		int i1 =scan.nextInt();
		int i5 =scan.nextInt();
		int i10 =scan.nextInt();
		int i50 =scan.nextInt();
		int i100 =scan.nextInt();
		int i500 =scan.nextInt();
		if(i1 + i5*5 + i10*10 + i50*50 + i100*100 + i500*500 >=1000){
			System.out.println(1);
		}else{
			System.out.println(0);
		}
	}
}

</source>
<source file="../hum_codes_raw/s955858894.java" startline="1" endline="18" pcid="32128">
import java.util.Scanner;
public class Main {
	public static void main(String[] args) throws java.io.IOException {
		Scanner scan = new Scanner(System.in);
		int i1 =scan.nextInt();
		int i5 =scan.nextInt();
		int i10 =scan.nextInt();
		int i50 =scan.nextInt();
		int i100 =scan.nextInt();
		int i500 =scan.nextInt();
		if(i1 + i5*5 + i10*10 + i50*50 + i100*100 + i500*500 >=1000){
			System.out.println(1);
		}else{
			System.out.println(0);
		}
	}
}

</source>
</class>

<class classid="56" nclones="2" nlines="1077" similarity="100">
<source file="../hum_codes_raw/s081663604.java" startline="1" endline="1232" pcid="2728">






import java.awt.Point;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.Locale;
import java.util.NoSuchElementException;
import java.util.Random;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.function.IntPredicate;

public class Main implements Runnable{

	private static final int LIMIT = 1800; // 
	private static final int ESTIMATE_LOOP = 8192; // 1ms

	private static class Marathon implements MarathonInterface {
		private FastIO io;
		private FastRandom rnd;
		private long loop;
		private long score;

		private final int N;
		private final int[] A;
		private final int[] B;
		private final int[] swapB;
		private int[] ans;
		private Stop stop;
		private WantArray want;

		public Marathon(FastIO io) {
			this.io = io;
			rnd = new FastRandom();

			N = io.nextInt();
			A = io.nextInt(N);
			B = io.nextInt(N);
			swapB = new int[N];
		}
		/*
		 * author: 31536000
		 *
		 * 
		 * ABC178F
		 */


		@Override
		public void init(Stop stop) {
			loop = 0;
			for (int i = 0;i < log.length;++ i) log[i] = Math.log(rnd.nextDouble());
			this.stop = stop;
			// 
			greedy();
		}

		// 
		public void greedy() {
			for (int i = 0;i < N;++ i) swapB[i] = B[(i + N / 2) % N];
			for (int i = 0;i < N;++ i) if (A[i] != swapB[i]) ++ score;
			if (score == N) {
				ans = Arrays.copyOf(swapB, N);
				stop.stop();
				return;
			}
			if (N == 1) stop.stop(); // 
			want = new WantArray(N, i -> A[i] == swapB[i]);
			int[] count = new int[200001];
			for (int j : A) ++ count[j];
			for (int j : B) ++ count[j];
			for (int j : count) if (j > N) stop.stop(); // 
		}

		@Override
		public void delayUpdate(int delay) {
			temperature = temperature(delay);
			loop += ESTIMATE_LOOP;
			// 
		}

		private void swap(int i, int j) {
			int swap = swapB[i];
			swapB[i] = swapB[j];
			swapB[j] = swap;
		}

		private static final double START_TEMP = 0.1; // TODO 
		private static final double END_TEMP = 0.00001;
		private static final double DIFF = START_TEMP - END_TEMP;
		private static final double INV_LIMIT = 1.0 / LIMIT;
		private double temperature = START_TEMP;
		private static final int LOG_SIZE = 1 << 12;
		private static final int LOG_MASK = LOG_SIZE - 1;
		final double[] log = new double[LOG_SIZE];

		private static double temperature(int delay) {
			return DIFF * delay * INV_LIMIT + END_TEMP;
		}


		private boolean isChange(int change) {
//			return change >= 0; // 
			return change >= temperature * log[rnd.nextInt() & LOG_MASK]; // 
		}

		@Override
		public void update() {
			int x = rnd.nextInt(want.want());
			int y = rnd.nextInt(N - 1);
			if (y >= x) ++ y;
			int x2 = want.get(x), y2 = want.get(y);
			int diff = 0;
			if (A[x2] != swapB[x2]) -- diff;
			if (A[x2] != swapB[y2]) ++ diff;
			if (A[y2] != swapB[y2]) -- diff;
			if (A[y2] != swapB[x2]) ++ diff;
			if (isChange(diff)) {
				swap(x2,y2);
				want.set(x, y, i -> A[i] == swapB[i]);
				score += diff;
				if (score == N && ans == null) {
					ans = Arrays.copyOf(swapB, N);
					stop.stop();
				}
			}
		}

		@Override
		public void terminate() {
			if (ans != null) {
				io.println("Yes");
				io.println(ans);
			} else {
				io.println("No");
			}
			// 
			io.debugln(loop + "," + score);
			io.flush();
		}

		public long getLoop() {
			return loop;
		}

		public long getScore() {
			return score;
		}

	}

	public static class WantArray {
		private final int[] index;
		private int k = 0;
		public WantArray(int n, IntPredicate want) {
			index = new int[n];
			for (int i = 0;i < n;++ i) index[i] = i;
			set(want);
		}

		private void swap(int i, int j) {
			int swap = index[i];
			index[i] = index[j];
			index[j] = swap;
		}

		public int get(int i) {
			return index[i];
		}

		public void set(IntPredicate want) {
			k = 0;
			for (int i = index.length - 1;i >= k;) {
				if (want.test(index[i])) {
					swap(i, k);
					++ k;
				} else {
					-- i;
				}
			}
		}

		public void set(int i, boolean want) {
			if (i < k) {
				if (want) return;
				swap(i, k - 1);
				-- k;
			} else {
				if (want) {
					swap(i, k);
					++ k;
				} else return;
			}
		}

		public void set(int i, int j, IntPredicate want) {
			if (i < k) {
				if (!want.test(index[i])) {
					swap(i, k - 1);
					if (j == k - 1) j = i;
					-- k;
				}
			} else {
				if (want.test(index[i])) {
					swap(i, k);
					if (j == k) j = i;
					++ k;
				}
			}
			set(j, want.test(index[j]));
		}

		public int want() {
			return k;
		}
	}

	/**  */
	private static boolean DEBUG = false;
	/** (: MB)*/
	private static final long MEMORY = 256;
	private final FastIO io;

	public static void main(String[] args) {
	        Thread.setDefaultUncaughtExceptionHandler((t, e) -> e.printStackTrace());
	        new Thread(null, new Main(), "", MEMORY * 1048576).start();
	}

	public Main() {
		this(new FastIO());
	}

	public Main(FastIO io) {
		this.io = io;
		if (DEBUG) {
			io.setAutoFlush(true);
			io.debugln("debug mode");
		}
	}

	@Override
	public void run() {
		solve(io);
		io.flush();
	}
	Marathon marathon;

	private void solve(FastIO io) {
		io.setAutoFlush(true);
		marathon = new Marathon(io);
		MarathonTimer timer = new MarathonTimer(marathon);
		timer.start(LIMIT);

	}

	public long getLoop() {
		return marathon.getLoop();
	}

	public long getScore() {
		return marathon.getScore();
	}

	// 

	public static final class FastRandom extends Random{
		private static final long serialVersionUID = -302298413684195190L;
		private long rand;
		private static final float FLOAT_INV = 1f / (1 << 24);
		private static final double DOUBLE_INV = 1. / (1L << 53);
		public FastRandom() {
			this(new Random().nextLong());
		}
		public FastRandom(long seed) {
			rand = seed;
		}
		@Override
		public void setSeed(long seed) {
			this.rand = seed;
		}
		@Override
		protected int next(int bits) {
			return (int)nextLong() & (1 << bits) - 1;
		}
		@Override
		public int nextInt() {
			rand = rand ^ (rand << 7);
			rand = rand ^ (rand >>> 9);
			return (int)(rand & Integer.MAX_VALUE);
		}
		@Override
		public int nextInt(int bounds) {
			return nextInt() % bounds;
		}
		public int nextRange(int startInclusive, int endExclusive) {
			return nextInt(endExclusive - startInclusive) + startInclusive;
		}
		@Override
		public long nextLong() {
			rand = rand ^ (rand << 7);
			rand = rand ^ (rand >>> 9);
			return rand & Long.MAX_VALUE;
		}
		@Override
		public boolean nextBoolean() {
			rand = rand ^ (rand << 7);
			rand = rand ^ (rand >>> 9);
			return (rand & 1) != 0;
		}
		@Override
		public float nextFloat() {
			rand = rand ^ (rand << 7);
			rand = rand ^ (rand >>> 9);
			return ((int)(rand & 0x00FFFFFF)) * FLOAT_INV;
		}
		@Override
		public double nextDouble() {
			rand = rand ^ (rand << 7);
			rand = rand ^ (rand >>> 9);
			return (rand & 0x001FFFFFFFFFFFFFL) * DOUBLE_INV;
		}
	}

	private static interface MarathonInterface {
		/**
		 * 
		 */
		public void init(Stop stop);
		/**
		 * 
		 * @param delay 
		 */
		public void delayUpdate(int delay);
		/**
		 * 
		 */
		public void update();
		/**
		 * 
		 */
		public void terminate();
	}

	private static interface Stop {
		public void stop();
	}

	private static class MarathonTimer implements Runnable {

		private MarathonInterface marathon;
		private volatile boolean loopFlag;
		private ScheduledExecutorService  threadPool;
		private ScheduledFuture<?> future;

		public MarathonTimer(Marathon marathon) {
			this.marathon = marathon;
			threadPool = Executors.newScheduledThreadPool(2);
		}

		public void start(int millis) {
			loopFlag = true;
			marathon.init(() -> {
				if (marathon != null) marathon.terminate();
				marathon = null;
			});
			if (marathon == null) {
				return;
			}
			future = threadPool.schedule(() -> loopFlag = false, millis, TimeUnit.MILLISECONDS);
			threadPool.execute(this);
			try {
				threadPool.awaitTermination(7, TimeUnit.DAYS);
			} catch (InterruptedException e) {
				// TODO  catch 
				e.printStackTrace();
			}
		}

		@Override
		public void run() {
			try {
				while(loopFlag) {
					int delay = (int)future.getDelay(TimeUnit.MILLISECONDS);
					if (delay <= 0) {
						loopFlag = false;
						break;
					}
					marathon.delayUpdate(delay);
					for (int i = 0;i < ESTIMATE_LOOP;++ i) marathon.update();
				}
				marathon.terminate();
			} catch (NullPointerException e) {
				// 
			} catch (Throwable e) {
				e.printStackTrace();
			}
			future.cancel(true);
			threadPool.shutdown();
		}
	}

	/**
	 * 
	 * @author 31536000
	 *
	 */
	public static class FastIO {
		private InputStream in;
		private final byte[] buffer = new byte[1024];
		private int read = 0;
		private int length = 0;
		private PrintWriter out;
		private PrintWriter err;
		private boolean autoFlush = false;

		public FastIO() {
			this(System.in, System.out, System.err);
		}

		public FastIO(InputStream in, PrintStream out, PrintStream err) {
			this.in = in;
			this.out = new PrintWriter(out, false);
			this.err = new PrintWriter(err, false);
		}

		public final void setInputStream(InputStream in) {
			this.in = in;
		}

		public final void setInputStream(File in) {
			try {
				this.in = new FileInputStream(in);
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
		}

		public final void setOutputStream(PrintStream out) {
			this.out = new PrintWriter(out, false);
		}

		public final void setOutputStream(File out) {
			try {
				this.out = new PrintWriter(new FileOutputStream(out), false);
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
		}

		public final void setErrorStream(PrintStream err) {
			this.err = new PrintWriter(err, false);
		}

		public final void setErrorStream(File err) {
			try {
				this.err = new PrintWriter(new FileOutputStream(err), false);
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
		}

		public final void setAutoFlush(boolean flush) {
			autoFlush = flush;
		}

		private boolean hasNextByte() {
			if (read < length) return true;
			read = 0;
			try {
				length = in.read(buffer);
			} catch (IOException e) {
				e.printStackTrace();
			}
			return length > 0;
		}

		private int readByte() {
			return hasNextByte() ? buffer[read++] : -1;
		}

		private static boolean isPrintableChar(int c) {
			return 33 <= c && c <= 126;
		}

		private static boolean isNumber(int c) {
			return '0' <= c && c <= '9';
		}

		public final boolean hasNext() {
			while (hasNextByte() && !isPrintableChar(buffer[read])) read++;
			return hasNextByte();
		}

		public final char nextChar() {
			if (!hasNextByte())  throw new NoSuchElementException();
			return (char)readByte();
		}

		public final char[][] nextChar(int height) {
			char[][] ret = new char[height][];
			for (int i = 0;i < ret.length;++ i) ret[i] = next().toCharArray();
			return ret;
		}

		public final String next() {
			if (!hasNext()) throw new NoSuchElementException();
			StringBuilder sb = new StringBuilder();
			int b;
			while (isPrintableChar(b = readByte())) sb.appendCodePoint(b);
			return sb.toString();
		}

		public final String nextLine() {
			StringBuilder sb = new StringBuilder();
			int b;
			while(!isPrintableChar(b = readByte()));
			do sb.appendCodePoint(b); while(isPrintableChar(b = readByte()) || b == ' ');
			return sb.toString();
		}

		public final long nextLong() {
			if (!hasNext()) throw new NoSuchElementException();
			long n = 0;
			boolean minus = false;
			int b = readByte();
			if (b == '-') {
				minus = true;
				b = readByte();
			}
			if (!isNumber(b)) throw new NumberFormatException();
			while (true) {
				if (isNumber(b)) {
					n *= 10;
					n += b - '0';
				} else if (b == -1 || !isPrintableChar(b)) return minus ? -n : n;
				else throw new NumberFormatException();
				b = readByte();
			}
		}

		public final int nextInt() {
			long nl = nextLong();
			if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
			return (int) nl;
		}

		public final double nextDouble() {
			return Double.parseDouble(next());
		}

		public final int[] nextInt(int width) {
			int[] ret = new int[width];
			for (int i = 0;i < width;++ i) ret[i] = nextInt();
			return ret;
		}

		public final int[] nextInts() {
			return nextInts(" ");
		}

		public final int[] nextInts(String parse) {
			String[] get = nextLine().split(parse);
			int[] ret = new int[get.length];
			for (int i = 0;i < ret.length;++ i) ret[i] = Integer.valueOf(get[i]);
			return ret;
		}

		public final long[] nextLong(int width) {
			long[] ret = new long[width];
			for (int i = 0;i < width;++ i) ret[i] = nextLong();
			return ret;
		}

		public final long[] nextLongs() {
			return nextLongs(" ");
		}

		public final long[] nextLongs(String parse) {
			String[] get = nextLine().split(parse);
			long[] ret = new long[get.length];
			for (int i = 0;i < ret.length;++ i) ret[i] = Long.valueOf(get[i]);
			return ret;
		}

		public final int[][] nextInt(int width, int height) {
			int[][] ret = new int[height][width];
			for (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[i][j] = nextInt();
			return ret;
		}

		public final long[][] nextLong(int width, int height) {
			long[][] ret = new long[height][width];
			for (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[j][i] = nextLong();
			return ret;
		}

		public final boolean[] nextBoolean(char T) {
			char[] s = next().toCharArray();
			boolean[] ret = new boolean[s.length];
			for (int i = 0;i < ret.length;++ i) ret[i] = s[i] == T;
			return ret;
		}

		public final boolean[][] nextBoolean(char T, int height) {
			boolean[][] ret = new boolean[height][];
			for (int i = 0;i < ret.length;++ i) {
				char[] s = next().toCharArray();
				ret[i] = new boolean[s.length];
				for (int j = 0;j < ret[i].length;++ j) ret[i][j] = s[j] == T;
			}
			return ret;
		}

		public final Point nextPoint() {
			return new Point(nextInt(), nextInt());
		}

		public final Point[] nextPoint(int width) {
			Point[] ret = new Point[width];
			for (int i = 0;i < width;++ i) ret[i] = nextPoint();
			return ret;
		}

		@Override
		protected void finalize() throws Throwable {
			try {
				super.finalize();
			} finally {
				in.close();
				out.close();
				err.close();
			}
		}

		public final boolean print(boolean b) {
			out.print(b);
			if (autoFlush) flush();
			return b;
		}

		public final Object print(boolean b, Object t, Object f) {
			return b ? print(t) : print(f);
		}

		public final char print(char c) {
			out.print(c);
			if (autoFlush) flush();
			return c;
		}

		public final char[] print(char[] s) {
			out.print(s);
			return s;
		}

		public final double print(double d) {
			out.print(d);
			if (autoFlush) flush();
			return d;
		}

		public final double print(double d, int length) {
			if (d < 0) {
				out.print('-');
				d = -d;
			}
			d += Math.pow(10, -length) / 2;
			out.print((long)d);
			out.print('.');
			d -= (long)d;
			for (int i = 0;i < length;++ i) {
				d *= 10;
				out.print((int)d);
				d -= (int)d;
			}
			if (autoFlush) flush();
			return d;
		}

		public final float print(float f) {
			out.print(f);
			if (autoFlush) flush();
			return f;
		}

		public final int print(int i) {
			out.print(i);
			if (autoFlush) flush();
			return i;
		}

		public final long print(long l) {
			out.print(l);
			if (autoFlush) flush();
			return l;
		}

		public final Object print(Object obj) {
			if (obj.getClass().isArray()) {
				if (obj instanceof boolean[][]) print(obj, "\n", " ");
				else if (obj instanceof byte[][]) print(obj, "\n", " ");
				else if (obj instanceof short[][]) print(obj, "\n", " ");
				else if (obj instanceof int[][]) print(obj, "\n", " ");
				else if (obj instanceof long[][]) print(obj, "\n", " ");
				else if (obj instanceof float[][]) print(obj, "\n", " ");
				else if (obj instanceof double[][]) print(obj, "\n", " ");
				else if (obj instanceof char[][]) print(obj, "\n", " ");
				else if (obj instanceof Object[][]) print(obj, "\n", " ");
				else print(obj, " ");
			} else {
				out.print(obj);
				if (autoFlush) flush();
			}
			return obj;
		}

		public final String print(String s) {
			out.print(s);
			if (autoFlush) flush();
			return s;
		}

		public final Object print(Object array, String... parse) {
			print(array, 0, parse);
			if (autoFlush) flush();
			return array;
		}

		private final Object print(Object array, int check, String... parse) {
			if (check >= parse.length) {
				if (array.getClass().isArray()) throw new IllegalArgumentException("not equal dimension");
				print(array);
				return array;
			}
			String str = parse[check];
			if (array instanceof Object[]) {
				Object[] obj = (Object[]) array;
				if (obj.length == 0) return array;
				print(obj[0], check + 1, parse);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i], check + 1, parse);
				}
				return array;
			}
			if (array instanceof Collection) {
				Iterator<?> iter = ((Collection<?>)array).iterator();
				if (!iter.hasNext()) return array;
				print(iter.next(), check + 1, parse);
				while(iter.hasNext()) {
					print(str);
					print(iter.next(), check + 1, parse);
				}
				return array;
			}
			if (!array.getClass().isArray()) throw new IllegalArgumentException("not equal dimension");
			if (check != parse.length - 1) throw new IllegalArgumentException("not equal dimension");
			if (array instanceof boolean[]) {
				boolean[] obj = (boolean[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
			} else if (array instanceof byte[]) {
				byte[] obj = (byte[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
				return array;
			} else if (array instanceof short[]) {
				short[] obj = (short[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
			} else if (array instanceof int[]) {
				int[] obj = (int[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
			} else if (array instanceof long[]) {
				long[] obj = (long[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
			} else if (array instanceof float[]) {
				float[] obj = (float[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
			} else if (array instanceof double[]) {
				double[] obj = (double[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
			} else if (array instanceof char[]) {
				char[] obj = (char[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
			} else throw new AssertionError();
			return array;
		}

		public final Object[] print(String parse, Object... args) {
			print(args[0]);
			for (int i = 1;i < args.length;++ i) {
				print(parse);
				print(args[i]);
			}
			return args;
		}

		public final Object[] printf(String format, Object... args) {
			out.printf(format, args);
			if (autoFlush) flush();
			return args;
		}

		public final Object printf(Locale l, String format, Object... args) {
			out.printf(l, format, args);
			if (autoFlush) flush();
			return args;
		}

		public final void println() {
			out.println();
			if (autoFlush) flush();
		}

		public final boolean println(boolean b) {
			out.println(b);
			if (autoFlush) flush();
			return b;
		}

		public final Object println(boolean b, Object t, Object f) {
			return b ? println(t) : println(f);
		}

		public final char println(char c) {
			out.println(c);
			if (autoFlush) flush();
			return c;
		}

		public final char[] println(char[] s) {
			out.println(s);
			if (autoFlush) flush();
			return s;
		}

		public final double println(double d) {
			out.println(d);
			if (autoFlush) flush();
			return d;
		}

		public final double println(double d, int length) {
			print(d, length);
			println();
			return d;
		}

		public final float println(float f) {
			out.println(f);
			if (autoFlush) flush();
			return f;
		}

		public final int println(int i) {
			out.println(i);
			if (autoFlush) flush();
			return i;
		}

		public final long println(long l) {
			out.println(l);
			if (autoFlush) flush();
			return l;
		}

		public final Object println(Object obj) {
			print(obj);
			println();
			return obj;
		}

		public final String println(String s) {
			out.println(s);
			if (autoFlush) flush();
			return s;
		}

		public final Object println(Object array, String... parse) {
			print(array, parse);
			println();
			return array;
		}

		public final boolean debug(boolean b) {
			err.print(b);
			if (autoFlush) flush();
			return b;
		}

		public final Object debug(boolean b, Object t, Object f) {
			return b ? debug(t) : debug(f);
		}

		public final char debug(char c) {
			err.print(c);
			if (autoFlush) flush();
			return c;
		}

		public final char[] debug(char[] s) {
			err.print(s);
			return s;
		}

		public final double debug(double d) {
			err.print(d);
			if (autoFlush) flush();
			return d;
		}

		public final double debug(double d, int length) {
			if (d < 0) {
				err.print('-');
				d = -d;
			}
			d += Math.pow(10, -length) / 2;
			err.print((long)d);
			err.print('.');
			d -= (long)d;
			for (int i = 0;i < length;++ i) {
				d *= 10;
				err.print((int)d);
				d -= (int)d;
			}
			if (autoFlush) flush();
			return d;
		}

		public final float debug(float f) {
			err.print(f);
			if (autoFlush) flush();
			return f;
		}

		public final int debug(int i) {
			err.print(i);
			if (autoFlush) flush();
			return i;
		}

		public final long debug(long l) {
			err.print(l);
			if (autoFlush) flush();
			return l;
		}

		public final Object debug(Object obj) {
			if (obj.getClass().isArray()) {
				if (obj instanceof boolean[][]) debug(obj, "\n", " ");
				else if (obj instanceof byte[][]) debug(obj, "\n", " ");
				else if (obj instanceof short[][]) debug(obj, "\n", " ");
				else if (obj instanceof int[][]) debug(obj, "\n", " ");
				else if (obj instanceof long[][]) debug(obj, "\n", " ");
				else if (obj instanceof float[][]) debug(obj, "\n", " ");
				else if (obj instanceof double[][]) debug(obj, "\n", " ");
				else if (obj instanceof char[][]) debug(obj, "\n", " ");
				else if (obj instanceof Object[][]) debug(obj, "\n", " ");
				else debug(obj, " ");
			} else {
				err.print(obj);
				if (autoFlush) flush();
			}
			return obj;
		}

		public final String debug(String s) {
			err.print(s);
			if (autoFlush) flush();
			return s;
		}

		public final Object debug(Object array, String... parse) {
			debug(array, 0, parse);
			if (autoFlush) flush();
			return array;
		}

		private final Object debug(Object array, int check, String... parse) {
			if (check >= parse.length) {
				if (array.getClass().isArray()) throw new IllegalArgumentException("not equal dimension");
				debug(array);
				return array;
			}
			String str = parse[check];
			if (array instanceof Object[]) {
				Object[] obj = (Object[]) array;
				if (obj.length == 0) return array;
				debug(obj[0], check + 1, parse);
				for (int i = 1;i < obj.length;++ i) {
					debug(str);
					debug(obj[i], check + 1, parse);
				}
				return array;
			}
			if (array instanceof Collection) {
				Iterator<?> iter = ((Collection<?>)array).iterator();
				if (!iter.hasNext()) return array;
				debug(iter.next(), check + 1, parse);
				while(iter.hasNext()) {
					debug(str);
					debug(iter.next(), check + 1, parse);
				}
				return array;
			}
			if (!array.getClass().isArray()) throw new IllegalArgumentException("not equal dimension");
			if (check != parse.length - 1) throw new IllegalArgumentException("not equal dimension");
			if (array instanceof boolean[]) {
				boolean[] obj = (boolean[]) array;
				if (obj.length == 0) return array;
				debug(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					debug(str);
					debug(obj[i]);
				}
			} else if (array instanceof byte[]) {
				byte[] obj = (byte[]) array;
				if (obj.length == 0) return array;
				debug(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					debug(str);
					debug(obj[i]);
				}
				return array;
			} else if (array instanceof short[]) {
				short[] obj = (short[]) array;
				if (obj.length == 0) return array;
				debug(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					debug(str);
					debug(obj[i]);
				}
			} else if (array instanceof int[]) {
				int[] obj = (int[]) array;
				if (obj.length == 0) return array;
				debug(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					debug(str);
					debug(obj[i]);
				}
			} else if (array instanceof long[]) {
				long[] obj = (long[]) array;
				if (obj.length == 0) return array;
				debug(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					debug(str);
					debug(obj[i]);
				}
			} else if (array instanceof float[]) {
				float[] obj = (float[]) array;
				if (obj.length == 0) return array;
				debug(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					debug(str);
					debug(obj[i]);
				}
			} else if (array instanceof double[]) {
				double[] obj = (double[]) array;
				if (obj.length == 0) return array;
				debug(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					debug(str);
					debug(obj[i]);
				}
			} else if (array instanceof char[]) {
				char[] obj = (char[]) array;
				if (obj.length == 0) return array;
				debug(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					debug(str);
					debug(obj[i]);
				}
			} else throw new AssertionError();
			return array;
		}

		public final Object[] debug(String parse, Object... args) {
			debug(args[0]);
			for (int i = 1;i < args.length;++ i) {
				debug(parse);
				debug(args[i]);
			}
			return args;
		}

		public final Object[] debugf(String format, Object... args) {
			err.printf(format, args);
			if (autoFlush) flush();
			return args;
		}

		public final Object debugf(Locale l, String format, Object... args) {
			err.printf(l, format, args);
			if (autoFlush) flush();
			return args;
		}

		public final void debugln() {
			err.println();
			if (autoFlush) flush();
		}

		public final boolean debugln(boolean b) {
			err.println(b);
			if (autoFlush) flush();
			return b;
		}

		public final Object debugln(boolean b, Object t, Object f) {
			return b ? debugln(t) : debugln(f);
		}

		public final char debugln(char c) {
			err.println(c);
			if (autoFlush) flush();
			return c;
		}

		public final char[] debugln(char[] s) {
			err.println(s);
			if (autoFlush) flush();
			return s;
		}

		public final double debugln(double d) {
			err.println(d);
			if (autoFlush) flush();
			return d;
		}

		public final double debugln(double d, int length) {
			debug(d, length);
			debugln();
			return d;
		}

		public final float debugln(float f) {
			err.println(f);
			if (autoFlush) flush();
			return f;
		}

		public final int debugln(int i) {
			err.println(i);
			if (autoFlush) flush();
			return i;
		}

		public final long debugln(long l) {
			err.println(l);
			if (autoFlush) flush();
			return l;
		}

		public final Object debugln(Object obj) {
			debug(obj);
			debugln();
			return obj;
		}

		public final String debugln(String s) {
			err.println(s);
			if (autoFlush) flush();
			return s;
		}

		public final Object debugln(Object array, String... parse) {
			debug(array, parse);
			debugln();
			return array;
		}

		public final void flush() {
			out.flush();
			err.flush();
		}
	}
}

</source>
<source file="../hum_codes_raw/s496837774.java" startline="1" endline="1232" pcid="16674">






import java.awt.Point;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.Locale;
import java.util.NoSuchElementException;
import java.util.Random;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.function.IntPredicate;

public class Main implements Runnable{

	private static final int LIMIT = 1800; // 
	private static final int ESTIMATE_LOOP = 8192; // 1ms

	private static class Marathon implements MarathonInterface {
		private FastIO io;
		private FastRandom rnd;
		private long loop;
		private long score;

		private final int N;
		private final int[] A;
		private final int[] B;
		private final int[] swapB;
		private int[] ans;
		private Stop stop;
		private WantArray want;

		public Marathon(FastIO io) {
			this.io = io;
			rnd = new FastRandom();

			N = io.nextInt();
			A = io.nextInt(N);
			B = io.nextInt(N);
			swapB = new int[N];
		}
		/*
		 * author: 31536000
		 *
		 * 
		 * ABC178F
		 */


		@Override
		public void init(Stop stop) {
			loop = 0;
			for (int i = 0;i < log.length;++ i) log[i] = Math.log(rnd.nextDouble());
			this.stop = stop;
			// 
			greedy();
		}

		// 
		public void greedy() {
			for (int i = 0;i < N;++ i) swapB[i] = B[(i + N / 2) % N];
			for (int i = 0;i < N;++ i) if (A[i] != swapB[i]) ++ score;
			if (score == N) {
				ans = Arrays.copyOf(swapB, N);
				stop.stop();
				return;
			}
			if (N == 1) stop.stop(); // 
			want = new WantArray(N, i -> A[i] == swapB[i]);
			int[] count = new int[200001];
			for (int j : A) ++ count[j];
			for (int j : B) ++ count[j];
			for (int j : count) if (j > N) stop.stop(); // 
		}

		@Override
		public void delayUpdate(int delay) {
			temperature = temperature(delay);
			loop += ESTIMATE_LOOP;
			// 
		}

		private void swap(int i, int j) {
			int swap = swapB[i];
			swapB[i] = swapB[j];
			swapB[j] = swap;
		}

		private static final double START_TEMP = 0.1; // TODO 
		private static final double END_TEMP = 0.00001;
		private static final double DIFF = START_TEMP - END_TEMP;
		private static final double INV_LIMIT = 1.0 / LIMIT;
		private double temperature = START_TEMP;
		private static final int LOG_SIZE = 1 << 12;
		private static final int LOG_MASK = LOG_SIZE - 1;
		final double[] log = new double[LOG_SIZE];

		private static double temperature(int delay) {
			return DIFF * delay * INV_LIMIT + END_TEMP;
		}


		private boolean isChange(int change) {
//			return change >= 0; // 
			return change >= temperature * log[rnd.nextInt() & LOG_MASK]; // 
		}

		@Override
		public void update() {
			int x = rnd.nextInt(want.want());
			int y = rnd.nextInt(N - 1);
			if (y >= x) ++ y;
			int x2 = want.get(x), y2 = want.get(y);
			int diff = 0;
			if (A[x2] != swapB[x2]) -- diff;
			if (A[x2] != swapB[y2]) ++ diff;
			if (A[y2] != swapB[y2]) -- diff;
			if (A[y2] != swapB[x2]) ++ diff;
			if (isChange(diff)) {
				swap(x2,y2);
				want.set(x, y, i -> A[i] == swapB[i]);
				score += diff;
				if (score == N && ans == null) {
					ans = Arrays.copyOf(swapB, N);
					stop.stop();
				}
			}
		}

		@Override
		public void terminate() {
			if (ans != null) {
				io.println("Yes");
				io.println(ans);
			} else {
				io.println("No");
			}
			// 
			io.debugln(loop + "," + score);
			io.flush();
		}

		public long getLoop() {
			return loop;
		}

		public long getScore() {
			return score;
		}

	}

	public static class WantArray {
		private final int[] index;
		private int k = 0;
		public WantArray(int n, IntPredicate want) {
			index = new int[n];
			for (int i = 0;i < n;++ i) index[i] = i;
			set(want);
		}

		private void swap(int i, int j) {
			int swap = index[i];
			index[i] = index[j];
			index[j] = swap;
		}

		public int get(int i) {
			return index[i];
		}

		public void set(IntPredicate want) {
			k = 0;
			for (int i = index.length - 1;i >= k;) {
				if (want.test(index[i])) {
					swap(i, k);
					++ k;
				} else {
					-- i;
				}
			}
		}

		public void set(int i, boolean want) {
			if (i < k) {
				if (want) return;
				swap(i, k - 1);
				-- k;
			} else {
				if (want) {
					swap(i, k);
					++ k;
				} else return;
			}
		}

		public void set(int i, int j, IntPredicate want) {
			if (i < k) {
				if (!want.test(index[i])) {
					swap(i, k - 1);
					if (j == k - 1) j = i;
					-- k;
				}
			} else {
				if (want.test(index[i])) {
					swap(i, k);
					if (j == k) j = i;
					++ k;
				}
			}
			set(j, want.test(index[j]));
		}

		public int want() {
			return k;
		}
	}

	/**  */
	private static boolean DEBUG = false;
	/** (: MB)*/
	private static final long MEMORY = 256;
	private final FastIO io;

	public static void main(String[] args) {
	        Thread.setDefaultUncaughtExceptionHandler((t, e) -> e.printStackTrace());
	        new Thread(null, new Main(), "", MEMORY * 1048576).start();
	}

	public Main() {
		this(new FastIO());
	}

	public Main(FastIO io) {
		this.io = io;
		if (DEBUG) {
			io.setAutoFlush(true);
			io.debugln("debug mode");
		}
	}

	@Override
	public void run() {
		solve(io);
		io.flush();
	}
	Marathon marathon;

	private void solve(FastIO io) {
		io.setAutoFlush(true);
		marathon = new Marathon(io);
		MarathonTimer timer = new MarathonTimer(marathon);
		timer.start(LIMIT);

	}

	public long getLoop() {
		return marathon.getLoop();
	}

	public long getScore() {
		return marathon.getScore();
	}

	// 

	public static final class FastRandom extends Random{
		private static final long serialVersionUID = -302298413684195190L;
		private long rand;
		private static final float FLOAT_INV = 1f / (1 << 24);
		private static final double DOUBLE_INV = 1. / (1L << 53);
		public FastRandom() {
			this(new Random().nextLong());
		}
		public FastRandom(long seed) {
			rand = seed;
		}
		@Override
		public void setSeed(long seed) {
			this.rand = seed;
		}
		@Override
		protected int next(int bits) {
			return (int)nextLong() & (1 << bits) - 1;
		}
		@Override
		public int nextInt() {
			rand = rand ^ (rand << 7);
			rand = rand ^ (rand >>> 9);
			return (int)(rand & Integer.MAX_VALUE);
		}
		@Override
		public int nextInt(int bounds) {
			return nextInt() % bounds;
		}
		public int nextRange(int startInclusive, int endExclusive) {
			return nextInt(endExclusive - startInclusive) + startInclusive;
		}
		@Override
		public long nextLong() {
			rand = rand ^ (rand << 7);
			rand = rand ^ (rand >>> 9);
			return rand & Long.MAX_VALUE;
		}
		@Override
		public boolean nextBoolean() {
			rand = rand ^ (rand << 7);
			rand = rand ^ (rand >>> 9);
			return (rand & 1) != 0;
		}
		@Override
		public float nextFloat() {
			rand = rand ^ (rand << 7);
			rand = rand ^ (rand >>> 9);
			return ((int)(rand & 0x00FFFFFF)) * FLOAT_INV;
		}
		@Override
		public double nextDouble() {
			rand = rand ^ (rand << 7);
			rand = rand ^ (rand >>> 9);
			return (rand & 0x001FFFFFFFFFFFFFL) * DOUBLE_INV;
		}
	}

	private static interface MarathonInterface {
		/**
		 * 
		 */
		public void init(Stop stop);
		/**
		 * 
		 * @param delay 
		 */
		public void delayUpdate(int delay);
		/**
		 * 
		 */
		public void update();
		/**
		 * 
		 */
		public void terminate();
	}

	private static interface Stop {
		public void stop();
	}

	private static class MarathonTimer implements Runnable {

		private MarathonInterface marathon;
		private volatile boolean loopFlag;
		private ScheduledExecutorService  threadPool;
		private ScheduledFuture<?> future;

		public MarathonTimer(Marathon marathon) {
			this.marathon = marathon;
			threadPool = Executors.newScheduledThreadPool(2);
		}

		public void start(int millis) {
			loopFlag = true;
			marathon.init(() -> {
				if (marathon != null) marathon.terminate();
				marathon = null;
			});
			if (marathon == null) {
				return;
			}
			future = threadPool.schedule(() -> loopFlag = false, millis, TimeUnit.MILLISECONDS);
			threadPool.execute(this);
			try {
				threadPool.awaitTermination(7, TimeUnit.DAYS);
			} catch (InterruptedException e) {
				// TODO  catch 
				e.printStackTrace();
			}
		}

		@Override
		public void run() {
			try {
				while(loopFlag) {
					int delay = (int)future.getDelay(TimeUnit.MILLISECONDS);
					if (delay <= 0) {
						loopFlag = false;
						break;
					}
					marathon.delayUpdate(delay);
					for (int i = 0;i < ESTIMATE_LOOP;++ i) marathon.update();
				}
				marathon.terminate();
			} catch (NullPointerException e) {
				// 
			} catch (Throwable e) {
				e.printStackTrace();
			}
			future.cancel(true);
			threadPool.shutdown();
		}
	}

	/**
	 * 
	 * @author 31536000
	 *
	 */
	public static class FastIO {
		private InputStream in;
		private final byte[] buffer = new byte[1024];
		private int read = 0;
		private int length = 0;
		private PrintWriter out;
		private PrintWriter err;
		private boolean autoFlush = false;

		public FastIO() {
			this(System.in, System.out, System.err);
		}

		public FastIO(InputStream in, PrintStream out, PrintStream err) {
			this.in = in;
			this.out = new PrintWriter(out, false);
			this.err = new PrintWriter(err, false);
		}

		public final void setInputStream(InputStream in) {
			this.in = in;
		}

		public final void setInputStream(File in) {
			try {
				this.in = new FileInputStream(in);
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
		}

		public final void setOutputStream(PrintStream out) {
			this.out = new PrintWriter(out, false);
		}

		public final void setOutputStream(File out) {
			try {
				this.out = new PrintWriter(new FileOutputStream(out), false);
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
		}

		public final void setErrorStream(PrintStream err) {
			this.err = new PrintWriter(err, false);
		}

		public final void setErrorStream(File err) {
			try {
				this.err = new PrintWriter(new FileOutputStream(err), false);
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
		}

		public final void setAutoFlush(boolean flush) {
			autoFlush = flush;
		}

		private boolean hasNextByte() {
			if (read < length) return true;
			read = 0;
			try {
				length = in.read(buffer);
			} catch (IOException e) {
				e.printStackTrace();
			}
			return length > 0;
		}

		private int readByte() {
			return hasNextByte() ? buffer[read++] : -1;
		}

		private static boolean isPrintableChar(int c) {
			return 33 <= c && c <= 126;
		}

		private static boolean isNumber(int c) {
			return '0' <= c && c <= '9';
		}

		public final boolean hasNext() {
			while (hasNextByte() && !isPrintableChar(buffer[read])) read++;
			return hasNextByte();
		}

		public final char nextChar() {
			if (!hasNextByte())  throw new NoSuchElementException();
			return (char)readByte();
		}

		public final char[][] nextChar(int height) {
			char[][] ret = new char[height][];
			for (int i = 0;i < ret.length;++ i) ret[i] = next().toCharArray();
			return ret;
		}

		public final String next() {
			if (!hasNext()) throw new NoSuchElementException();
			StringBuilder sb = new StringBuilder();
			int b;
			while (isPrintableChar(b = readByte())) sb.appendCodePoint(b);
			return sb.toString();
		}

		public final String nextLine() {
			StringBuilder sb = new StringBuilder();
			int b;
			while(!isPrintableChar(b = readByte()));
			do sb.appendCodePoint(b); while(isPrintableChar(b = readByte()) || b == ' ');
			return sb.toString();
		}

		public final long nextLong() {
			if (!hasNext()) throw new NoSuchElementException();
			long n = 0;
			boolean minus = false;
			int b = readByte();
			if (b == '-') {
				minus = true;
				b = readByte();
			}
			if (!isNumber(b)) throw new NumberFormatException();
			while (true) {
				if (isNumber(b)) {
					n *= 10;
					n += b - '0';
				} else if (b == -1 || !isPrintableChar(b)) return minus ? -n : n;
				else throw new NumberFormatException();
				b = readByte();
			}
		}

		public final int nextInt() {
			long nl = nextLong();
			if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
			return (int) nl;
		}

		public final double nextDouble() {
			return Double.parseDouble(next());
		}

		public final int[] nextInt(int width) {
			int[] ret = new int[width];
			for (int i = 0;i < width;++ i) ret[i] = nextInt();
			return ret;
		}

		public final int[] nextInts() {
			return nextInts(" ");
		}

		public final int[] nextInts(String parse) {
			String[] get = nextLine().split(parse);
			int[] ret = new int[get.length];
			for (int i = 0;i < ret.length;++ i) ret[i] = Integer.valueOf(get[i]);
			return ret;
		}

		public final long[] nextLong(int width) {
			long[] ret = new long[width];
			for (int i = 0;i < width;++ i) ret[i] = nextLong();
			return ret;
		}

		public final long[] nextLongs() {
			return nextLongs(" ");
		}

		public final long[] nextLongs(String parse) {
			String[] get = nextLine().split(parse);
			long[] ret = new long[get.length];
			for (int i = 0;i < ret.length;++ i) ret[i] = Long.valueOf(get[i]);
			return ret;
		}

		public final int[][] nextInt(int width, int height) {
			int[][] ret = new int[height][width];
			for (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[i][j] = nextInt();
			return ret;
		}

		public final long[][] nextLong(int width, int height) {
			long[][] ret = new long[height][width];
			for (int i = 0, j;i < height;++ i) for (j = 0;j < width;++ j) ret[j][i] = nextLong();
			return ret;
		}

		public final boolean[] nextBoolean(char T) {
			char[] s = next().toCharArray();
			boolean[] ret = new boolean[s.length];
			for (int i = 0;i < ret.length;++ i) ret[i] = s[i] == T;
			return ret;
		}

		public final boolean[][] nextBoolean(char T, int height) {
			boolean[][] ret = new boolean[height][];
			for (int i = 0;i < ret.length;++ i) {
				char[] s = next().toCharArray();
				ret[i] = new boolean[s.length];
				for (int j = 0;j < ret[i].length;++ j) ret[i][j] = s[j] == T;
			}
			return ret;
		}

		public final Point nextPoint() {
			return new Point(nextInt(), nextInt());
		}

		public final Point[] nextPoint(int width) {
			Point[] ret = new Point[width];
			for (int i = 0;i < width;++ i) ret[i] = nextPoint();
			return ret;
		}

		@Override
		protected void finalize() throws Throwable {
			try {
				super.finalize();
			} finally {
				in.close();
				out.close();
				err.close();
			}
		}

		public final boolean print(boolean b) {
			out.print(b);
			if (autoFlush) flush();
			return b;
		}

		public final Object print(boolean b, Object t, Object f) {
			return b ? print(t) : print(f);
		}

		public final char print(char c) {
			out.print(c);
			if (autoFlush) flush();
			return c;
		}

		public final char[] print(char[] s) {
			out.print(s);
			return s;
		}

		public final double print(double d) {
			out.print(d);
			if (autoFlush) flush();
			return d;
		}

		public final double print(double d, int length) {
			if (d < 0) {
				out.print('-');
				d = -d;
			}
			d += Math.pow(10, -length) / 2;
			out.print((long)d);
			out.print('.');
			d -= (long)d;
			for (int i = 0;i < length;++ i) {
				d *= 10;
				out.print((int)d);
				d -= (int)d;
			}
			if (autoFlush) flush();
			return d;
		}

		public final float print(float f) {
			out.print(f);
			if (autoFlush) flush();
			return f;
		}

		public final int print(int i) {
			out.print(i);
			if (autoFlush) flush();
			return i;
		}

		public final long print(long l) {
			out.print(l);
			if (autoFlush) flush();
			return l;
		}

		public final Object print(Object obj) {
			if (obj.getClass().isArray()) {
				if (obj instanceof boolean[][]) print(obj, "\n", " ");
				else if (obj instanceof byte[][]) print(obj, "\n", " ");
				else if (obj instanceof short[][]) print(obj, "\n", " ");
				else if (obj instanceof int[][]) print(obj, "\n", " ");
				else if (obj instanceof long[][]) print(obj, "\n", " ");
				else if (obj instanceof float[][]) print(obj, "\n", " ");
				else if (obj instanceof double[][]) print(obj, "\n", " ");
				else if (obj instanceof char[][]) print(obj, "\n", " ");
				else if (obj instanceof Object[][]) print(obj, "\n", " ");
				else print(obj, " ");
			} else {
				out.print(obj);
				if (autoFlush) flush();
			}
			return obj;
		}

		public final String print(String s) {
			out.print(s);
			if (autoFlush) flush();
			return s;
		}

		public final Object print(Object array, String... parse) {
			print(array, 0, parse);
			if (autoFlush) flush();
			return array;
		}

		private final Object print(Object array, int check, String... parse) {
			if (check >= parse.length) {
				if (array.getClass().isArray()) throw new IllegalArgumentException("not equal dimension");
				print(array);
				return array;
			}
			String str = parse[check];
			if (array instanceof Object[]) {
				Object[] obj = (Object[]) array;
				if (obj.length == 0) return array;
				print(obj[0], check + 1, parse);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i], check + 1, parse);
				}
				return array;
			}
			if (array instanceof Collection) {
				Iterator<?> iter = ((Collection<?>)array).iterator();
				if (!iter.hasNext()) return array;
				print(iter.next(), check + 1, parse);
				while(iter.hasNext()) {
					print(str);
					print(iter.next(), check + 1, parse);
				}
				return array;
			}
			if (!array.getClass().isArray()) throw new IllegalArgumentException("not equal dimension");
			if (check != parse.length - 1) throw new IllegalArgumentException("not equal dimension");
			if (array instanceof boolean[]) {
				boolean[] obj = (boolean[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
			} else if (array instanceof byte[]) {
				byte[] obj = (byte[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
				return array;
			} else if (array instanceof short[]) {
				short[] obj = (short[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
			} else if (array instanceof int[]) {
				int[] obj = (int[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
			} else if (array instanceof long[]) {
				long[] obj = (long[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
			} else if (array instanceof float[]) {
				float[] obj = (float[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
			} else if (array instanceof double[]) {
				double[] obj = (double[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
			} else if (array instanceof char[]) {
				char[] obj = (char[]) array;
				if (obj.length == 0) return array;
				print(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					print(str);
					print(obj[i]);
				}
			} else throw new AssertionError();
			return array;
		}

		public final Object[] print(String parse, Object... args) {
			print(args[0]);
			for (int i = 1;i < args.length;++ i) {
				print(parse);
				print(args[i]);
			}
			return args;
		}

		public final Object[] printf(String format, Object... args) {
			out.printf(format, args);
			if (autoFlush) flush();
			return args;
		}

		public final Object printf(Locale l, String format, Object... args) {
			out.printf(l, format, args);
			if (autoFlush) flush();
			return args;
		}

		public final void println() {
			out.println();
			if (autoFlush) flush();
		}

		public final boolean println(boolean b) {
			out.println(b);
			if (autoFlush) flush();
			return b;
		}

		public final Object println(boolean b, Object t, Object f) {
			return b ? println(t) : println(f);
		}

		public final char println(char c) {
			out.println(c);
			if (autoFlush) flush();
			return c;
		}

		public final char[] println(char[] s) {
			out.println(s);
			if (autoFlush) flush();
			return s;
		}

		public final double println(double d) {
			out.println(d);
			if (autoFlush) flush();
			return d;
		}

		public final double println(double d, int length) {
			print(d, length);
			println();
			return d;
		}

		public final float println(float f) {
			out.println(f);
			if (autoFlush) flush();
			return f;
		}

		public final int println(int i) {
			out.println(i);
			if (autoFlush) flush();
			return i;
		}

		public final long println(long l) {
			out.println(l);
			if (autoFlush) flush();
			return l;
		}

		public final Object println(Object obj) {
			print(obj);
			println();
			return obj;
		}

		public final String println(String s) {
			out.println(s);
			if (autoFlush) flush();
			return s;
		}

		public final Object println(Object array, String... parse) {
			print(array, parse);
			println();
			return array;
		}

		public final boolean debug(boolean b) {
			err.print(b);
			if (autoFlush) flush();
			return b;
		}

		public final Object debug(boolean b, Object t, Object f) {
			return b ? debug(t) : debug(f);
		}

		public final char debug(char c) {
			err.print(c);
			if (autoFlush) flush();
			return c;
		}

		public final char[] debug(char[] s) {
			err.print(s);
			return s;
		}

		public final double debug(double d) {
			err.print(d);
			if (autoFlush) flush();
			return d;
		}

		public final double debug(double d, int length) {
			if (d < 0) {
				err.print('-');
				d = -d;
			}
			d += Math.pow(10, -length) / 2;
			err.print((long)d);
			err.print('.');
			d -= (long)d;
			for (int i = 0;i < length;++ i) {
				d *= 10;
				err.print((int)d);
				d -= (int)d;
			}
			if (autoFlush) flush();
			return d;
		}

		public final float debug(float f) {
			err.print(f);
			if (autoFlush) flush();
			return f;
		}

		public final int debug(int i) {
			err.print(i);
			if (autoFlush) flush();
			return i;
		}

		public final long debug(long l) {
			err.print(l);
			if (autoFlush) flush();
			return l;
		}

		public final Object debug(Object obj) {
			if (obj.getClass().isArray()) {
				if (obj instanceof boolean[][]) debug(obj, "\n", " ");
				else if (obj instanceof byte[][]) debug(obj, "\n", " ");
				else if (obj instanceof short[][]) debug(obj, "\n", " ");
				else if (obj instanceof int[][]) debug(obj, "\n", " ");
				else if (obj instanceof long[][]) debug(obj, "\n", " ");
				else if (obj instanceof float[][]) debug(obj, "\n", " ");
				else if (obj instanceof double[][]) debug(obj, "\n", " ");
				else if (obj instanceof char[][]) debug(obj, "\n", " ");
				else if (obj instanceof Object[][]) debug(obj, "\n", " ");
				else debug(obj, " ");
			} else {
				err.print(obj);
				if (autoFlush) flush();
			}
			return obj;
		}

		public final String debug(String s) {
			err.print(s);
			if (autoFlush) flush();
			return s;
		}

		public final Object debug(Object array, String... parse) {
			debug(array, 0, parse);
			if (autoFlush) flush();
			return array;
		}

		private final Object debug(Object array, int check, String... parse) {
			if (check >= parse.length) {
				if (array.getClass().isArray()) throw new IllegalArgumentException("not equal dimension");
				debug(array);
				return array;
			}
			String str = parse[check];
			if (array instanceof Object[]) {
				Object[] obj = (Object[]) array;
				if (obj.length == 0) return array;
				debug(obj[0], check + 1, parse);
				for (int i = 1;i < obj.length;++ i) {
					debug(str);
					debug(obj[i], check + 1, parse);
				}
				return array;
			}
			if (array instanceof Collection) {
				Iterator<?> iter = ((Collection<?>)array).iterator();
				if (!iter.hasNext()) return array;
				debug(iter.next(), check + 1, parse);
				while(iter.hasNext()) {
					debug(str);
					debug(iter.next(), check + 1, parse);
				}
				return array;
			}
			if (!array.getClass().isArray()) throw new IllegalArgumentException("not equal dimension");
			if (check != parse.length - 1) throw new IllegalArgumentException("not equal dimension");
			if (array instanceof boolean[]) {
				boolean[] obj = (boolean[]) array;
				if (obj.length == 0) return array;
				debug(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					debug(str);
					debug(obj[i]);
				}
			} else if (array instanceof byte[]) {
				byte[] obj = (byte[]) array;
				if (obj.length == 0) return array;
				debug(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					debug(str);
					debug(obj[i]);
				}
				return array;
			} else if (array instanceof short[]) {
				short[] obj = (short[]) array;
				if (obj.length == 0) return array;
				debug(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					debug(str);
					debug(obj[i]);
				}
			} else if (array instanceof int[]) {
				int[] obj = (int[]) array;
				if (obj.length == 0) return array;
				debug(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					debug(str);
					debug(obj[i]);
				}
			} else if (array instanceof long[]) {
				long[] obj = (long[]) array;
				if (obj.length == 0) return array;
				debug(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					debug(str);
					debug(obj[i]);
				}
			} else if (array instanceof float[]) {
				float[] obj = (float[]) array;
				if (obj.length == 0) return array;
				debug(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					debug(str);
					debug(obj[i]);
				}
			} else if (array instanceof double[]) {
				double[] obj = (double[]) array;
				if (obj.length == 0) return array;
				debug(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					debug(str);
					debug(obj[i]);
				}
			} else if (array instanceof char[]) {
				char[] obj = (char[]) array;
				if (obj.length == 0) return array;
				debug(obj[0]);
				for (int i = 1;i < obj.length;++ i) {
					debug(str);
					debug(obj[i]);
				}
			} else throw new AssertionError();
			return array;
		}

		public final Object[] debug(String parse, Object... args) {
			debug(args[0]);
			for (int i = 1;i < args.length;++ i) {
				debug(parse);
				debug(args[i]);
			}
			return args;
		}

		public final Object[] debugf(String format, Object... args) {
			err.printf(format, args);
			if (autoFlush) flush();
			return args;
		}

		public final Object debugf(Locale l, String format, Object... args) {
			err.printf(l, format, args);
			if (autoFlush) flush();
			return args;
		}

		public final void debugln() {
			err.println();
			if (autoFlush) flush();
		}

		public final boolean debugln(boolean b) {
			err.println(b);
			if (autoFlush) flush();
			return b;
		}

		public final Object debugln(boolean b, Object t, Object f) {
			return b ? debugln(t) : debugln(f);
		}

		public final char debugln(char c) {
			err.println(c);
			if (autoFlush) flush();
			return c;
		}

		public final char[] debugln(char[] s) {
			err.println(s);
			if (autoFlush) flush();
			return s;
		}

		public final double debugln(double d) {
			err.println(d);
			if (autoFlush) flush();
			return d;
		}

		public final double debugln(double d, int length) {
			debug(d, length);
			debugln();
			return d;
		}

		public final float debugln(float f) {
			err.println(f);
			if (autoFlush) flush();
			return f;
		}

		public final int debugln(int i) {
			err.println(i);
			if (autoFlush) flush();
			return i;
		}

		public final long debugln(long l) {
			err.println(l);
			if (autoFlush) flush();
			return l;
		}

		public final Object debugln(Object obj) {
			debug(obj);
			debugln();
			return obj;
		}

		public final String debugln(String s) {
			err.println(s);
			if (autoFlush) flush();
			return s;
		}

		public final Object debugln(Object array, String... parse) {
			debug(array, parse);
			debugln();
			return array;
		}

		public final void flush() {
			out.flush();
			err.flush();
		}
	}
}

</source>
</class>

<class classid="57" nclones="3" nlines="74" similarity="100">
<source file="../hum_codes_raw/s084168880.java" startline="1" endline="117" pcid="2806">


import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

public class Main {

	/*
	 * ????????????????????????????????????????
	 */
	public static void main(String[] args) throws NumberFormatException, IOException {

		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		// ??????????????
		int set = Integer.parseInt(br.readLine());
		// ??????????????????????????????????????
		Player isono = new Player("Isono-kun");
		Player nakajima = new Player("Nakajima-kun");

		// ???????????????????????????????????????????????
		for (int cnt = 0; cnt < set; cnt++)
			isono.getGesture().add(Action.valueOf(br.readLine()));
		for (int cnt = 0; cnt < set; cnt++)
			nakajima.getGesture().add(Action.valueOf(br.readLine()));
		// ?????????
		for (int turn = 0; turn < set; turn++) {
			for (int swap = 0; swap < 2; swap++) {
				Player p1 = swap == 0 ? isono : nakajima;
				Player p2 = swap == 0 ? nakajima : isono;

				// ?????????????????????p1???????????????????????????????????????
				// p2????????????0?????????????
				if (p2.getGesture().get(turn) == Action.kougekida && p2.getForce() == 0) {
					// p1????????????0?????????????????????
					if (!(p1.getGesture().get(turn) == Action.kougekida)) {
						System.out.println(p1.getPlayerName());
						return;
					}
				}

				// p1????????????1??\????????????????
				if (p1.getGesture().get(turn) == Action.kougekida && p1.getForce() > 0) {
					if (p1.getForce() >= 5 || (p2.getGesture().get(turn) != Action.mamoru
							&& p2.getGesture().get(turn) != Action.kougekida)) {
						System.out.println(p1.getPlayerName());
						return;
					}
					// ?????????????????????????????????
					if (p2.getGesture().get(turn) == Action.kougekida) {
						if (p1.getForce() > p2.getForce()) {
							System.out.println(p1.getPlayerName());
							return;
						}
					}
				}
			}
			// ?????????????????????????????????????????0?????????
			if (isono.getGesture().get(turn) == Action.kougekida)
				isono.setForce(0);
			if (nakajima.getGesture().get(turn) == Action.kougekida)
				nakajima.setForce(0);
			// ?????????
			if (isono.getGesture().get(turn) == Action.tameru)
				isono.setForce(isono.getForce() + 1);
			if (nakajima.getGesture().get(turn) == Action.tameru)
				nakajima.setForce(nakajima.getForce() + 1);
		} // for?????????????????????
		System.out.println("Hikiwake-kun");
	}// ?????????????????????????????????
}// ??????????????????????????????

enum Action {
	kougekida, tameru, mamoru
}// Action?????????????????????

/**
 * ??????????????????????
 *
 * @author ????????????????????
 */
class Player {
	private int force = 0;
	private String PlayerName;
	private List<Action> gesture = new ArrayList<Action>();

	public List<Action> getGesture() {
		return gesture;
	}

	public void setGesture(List<Action> gesture) {
		this.gesture = gesture;
	}

	public String getPlayerName() {
		return PlayerName;
	}

	public void setPlayerName(String playerName) {
		PlayerName = playerName;
	}

	public int getForce() {
		return force;
	}

	public void setForce(int force) {
		this.force = force;
	}

	Player(String name) {
		this.PlayerName = name;
	}
}// Player?????????????????????

</source>
<source file="../hum_codes_raw/s709835362.java" startline="1" endline="118" pcid="23872">


import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

public class Main{

	/*
	 * ????????????????????????????????????????
	 */
	public static void main(String[] args) throws NumberFormatException, IOException {

		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		// ??????????????
		int set = Integer.parseInt(br.readLine());
		// ??????????????????????????????????????
		Player isono = new Player("Isono-kun");
		Player nakajima = new Player("Nakajima-kun");

		// ???????????????????????????????????????????????
		for (int cnt = 0; cnt < set; cnt++)
			isono.getGesture().add(Action.valueOf(br.readLine()));
		for (int cnt = 0; cnt < set; cnt++)
			nakajima.getGesture().add(Action.valueOf(br.readLine()));

		// ????????????????????????????????????
		for (int turn = 0; turn < set; turn++) {
			// ???????????\????????????2???????????????
			for (int swap = 0; swap < 2; swap++) {
				Player p1 = swap == 0 ? isono : nakajima;
				Player p2 = swap == 0 ? nakajima : isono;
				// ?????????????????????p1???????????????????????????????????????

				// p2????????????0?????????????
				if (p2.getGesture().get(turn) == Action.kougekida && p2.getForce() == 0) {
					// p1????????????0?????????????????????
					if (!(p1.getGesture().get(turn) == Action.kougekida)) {
						System.out.println(p1.getPlayerName());
						return;
					}
				}
				// p1????????????1??\????????????????
				if (p1.getGesture().get(turn) == Action.kougekida && p1.getForce() > 0) {
					if (p1.getForce() >= 5 || (p2.getGesture().get(turn) != Action.mamoru
							&& p2.getGesture().get(turn) != Action.kougekida)) {
						System.out.println(p1.getPlayerName());
						return;
					}
					// ????????????????????????????????????????
					if (p2.getGesture().get(turn) == Action.kougekida) {
						if (p1.getForce() > p2.getForce()) {
							System.out.println(p1.getPlayerName());
							return;
						}
					}
				}
			}
			// ?????????????????????????????????????????0?????????
			if (isono.getGesture().get(turn) == Action.kougekida)
				isono.setForce(0);
			if (nakajima.getGesture().get(turn) == Action.kougekida)
				nakajima.setForce(0);
			// ?????????
			if (isono.getGesture().get(turn) == Action.tameru)
				isono.setForce(isono.getForce() + 1);
			if (nakajima.getGesture().get(turn) == Action.tameru)
				nakajima.setForce(nakajima.getForce() + 1);
		} // for?????????????????????
		System.out.println("Hikiwake-kun");
	}// ?????????????????????????????????
}// ??????????????????????????????

enum Action {
	kougekida, tameru, mamoru
}// Action?????????????????????

/**
 * ??????????????????????
 *
 * @author ????????????????????
 */
class Player {
	private int force = 0;
	private String PlayerName;
	private List<Action> gesture = new ArrayList<Action>();

	public List<Action> getGesture() {
		return gesture;
	}

	public void setGesture(List<Action> gesture) {
		this.gesture = gesture;
	}

	public String getPlayerName() {
		return PlayerName;
	}

	public void setPlayerName(String playerName) {
		PlayerName = playerName;
	}

	public int getForce() {
		return force;
	}

	public void setForce(int force) {
		this.force = force;
	}

	Player(String name) {
		this.PlayerName = name;
	}
}// Player?????????????????????

</source>
<source file="../hum_codes_raw/s621658693.java" startline="1" endline="118" pcid="20874">


import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

public class Main{

	/*
	 * ????????????????????????????????????????
	 */
	public static void main(String[] args) throws NumberFormatException, IOException {

		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		// ??????????????
		int set = Integer.parseInt(br.readLine());
		// ??????????????????????????????????????
		Player isono = new Player("Isono-kun");
		Player nakajima = new Player("Nakajima-kun");

		// ???????????????????????????????????????????????
		for (int cnt = 0; cnt < set; cnt++)
			isono.getGesture().add(Action.valueOf(br.readLine()));
		for (int cnt = 0; cnt < set; cnt++)
			nakajima.getGesture().add(Action.valueOf(br.readLine()));

		// ????????????????????????????????????
		for (int turn = 0; turn < set; turn++) {
			// ???????????\????????????2???????????????
			for (int swap = 0; swap < 2; swap++) {
				Player p1 = swap == 0 ? isono : nakajima;
				Player p2 = swap == 0 ? nakajima : isono;
				// ?????????????????????p1???????????????????????????????????????

				// p2????????????0?????????????
				if (p2.getGesture().get(turn) == Action.kougekida && p2.getForce() == 0) {
					// p1????????????0?????????????????????
					if (!(p1.getGesture().get(turn) == Action.kougekida)) {
						System.out.println(p1.getPlayerName());
						return;
					}
				}
				// p1????????????1??\????????????????
				if (p1.getGesture().get(turn) == Action.kougekida && p1.getForce() > 0) {
					if (p1.getForce() >= 5 || (p2.getGesture().get(turn) != Action.mamoru
							&& p2.getGesture().get(turn) != Action.kougekida)) {
						System.out.println(p1.getPlayerName());
						return;
					}
					// ????????????????????????????????????????
					if (p2.getGesture().get(turn) == Action.kougekida) {
						if (p1.getForce() > p2.getForce()) {
							System.out.println(p1.getPlayerName());
							return;
						}
					}
				}
			}
			// ?????????????????????????????????????????0?????????
			if (isono.getGesture().get(turn) == Action.kougekida)
				isono.setForce(0);
			if (nakajima.getGesture().get(turn) == Action.kougekida)
				nakajima.setForce(0);
			// ?????????
			if (isono.getGesture().get(turn) == Action.tameru)
				isono.setForce(isono.getForce() + 1);
			if (nakajima.getGesture().get(turn) == Action.tameru)
				nakajima.setForce(nakajima.getForce() + 1);
		} // for?????????????????????
		System.out.println("Hikiwake-kun");
	}// ?????????????????????????????????
}// ??????????????????????????????

enum Action {
	kougekida, tameru, mamoru
}// Action?????????????????????

/**
 * ??????????????????????
 *
 * @author ????????????????????
 */
class Player {
	private int force = 0;
	private String PlayerName;
	private List<Action> gesture = new ArrayList<Action>();

	public List<Action> getGesture() {
		return gesture;
	}

	public void setGesture(List<Action> gesture) {
		this.gesture = gesture;
	}

	public String getPlayerName() {
		return PlayerName;
	}

	public void setPlayerName(String playerName) {
		PlayerName = playerName;
	}

	public int getForce() {
		return force;
	}

	public void setForce(int force) {
		this.force = force;
	}

	Player(String name) {
		this.PlayerName = name;
	}
}// Player?????????????????????

</source>
</class>

<class classid="58" nclones="2" nlines="60" similarity="100">
<source file="../hum_codes_raw/s088292499.java" startline="1" endline="68" pcid="2932">
import java.util.*;
import java.util.stream.*;

public class Main {

	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		int n = in.nextInt();
		int[] arr = new int[n];
		for (int i = 0; i < n; i++) {
			arr[i] = in.nextInt();
		}
		int[] copy = Arrays.copyOf(arr, arr.length);
		Arrays.sort(copy);

		int left = 0, right = n;
		long x = (long)n * (long)(n + 1) / 4;
		while(left + 1 < right) {
			int mid = (left + right) / 2;
			int am = copy[mid];
			int[] s = new int[n + 1];
			for (int i = 0; i < n; i++) {
				s[i + 1] = am <= arr[i] ? 1 : -1;
			}
			for (int i = 1; i < n + 1; i++) {
				s[i] += s[i - 1];
			}
			BIT bit = new BIT(2 * n + 1);
			long sum = 0;
			for (int i = 0; i < n + 1; i++) {
				sum += bit.sum(s[i] + n);
				bit.add(s[i] + n, 1);
			}
			if(x <= sum) {
				left = mid;
			} else {
				right = mid;
			}
		}
		System.out.println(copy[left]);
	}
}

class BIT {
	private long[] bit;
 
    public BIT(int size){
        bit = new long[size];
    }
 
    public long sum(int i){
        long s = 0;
        while(0 < i){
            s += bit[i];
            i -= i & -i;
        }
        return s;
    }
 
    public void add(int i, long x){
        while(i < bit.length){
            bit[i] += x;
            i += i & -i;
        }
    }
}


</source>
<source file="../hum_codes_raw/s978370901.java" startline="1" endline="68" pcid="33732">
import java.util.*;
import java.util.stream.*;

public class Main {

	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		int n = in.nextInt();
		int[] arr = new int[n];
		for (int i = 0; i < n; i++) {
			arr[i] = in.nextInt();
		}
		int[] copy = Arrays.copyOf(arr, arr.length);
		Arrays.sort(copy);

		int left = 0, right = n;
		long x = (long)n * (long)(n + 1) / 4;
		while(left + 1 < right) {
			int mid = (left + right) / 2;
			int am = copy[mid];
			int[] s = new int[n + 1];
			for (int i = 0; i < n; i++) {
				s[i + 1] = am <= arr[i] ? 1 : -1;
			}
			for (int i = 1; i < n + 1; i++) {
				s[i] += s[i - 1];
			}
			BIT bit = new BIT(2 * n + 1);
			long sum = 0;
			for (int i = 0; i < n + 1; i++) {
				sum += bit.sum(s[i] + n);
				bit.add(s[i] + n, 1);
			}
			if(x <= sum) {
				left = mid;
			} else {
				right = mid;
			}
		}
		System.out.println(copy[left]);
	}
}

class BIT {
	private long[] bit;
 
    public BIT(int size){
        bit = new long[size];
    }
 
    public long sum(int i){
        long s = 0;
        while(0 < i){
            s += bit[i];
            i -= i & -i;
        }
        return s;
    }
 
    public void add(int i, long x){
        while(i < bit.length){
            bit[i] += x;
            i += i & -i;
        }
    }
}


</source>
</class>

<class classid="59" nclones="2" nlines="71" similarity="100">
<source file="../hum_codes_raw/s094370522.java" startline="1" endline="84" pcid="3132">
import java.util.*;
public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();
		long M = sc.nextLong();
		int A[] = new int[N];
		for(int i=0;i<N;i++)A[i]=sc.nextInt();
 		sc.close();
 		
 		rsort(A);
 		
 		//K
 		int R = 2*100000 + 100;
 		int L = 0;
 		while(L+1<R) {		
 			int C = (L+R)/2;//cK
 			long subsum = 0;
 			for(int i=0;i<N;i++) {
 				int base = A[i];
 				int r = N;
 				int l = i-1;
 				while(l+1<r) {
 					int c = (l + r)/2;
 					if(base + A[c]>=C)l=c;
 					else r = c;
 				}
 				if(l-i<0)continue;
 				subsum += 1 + 2*(l-i);
 			}
 			if(subsum>=M) L = C;
 			else R = C;
 		}
 		//LK
 		
 		long memosum = 0;
 		int min = Integer.MAX_VALUE;
 		int memo[] = new int[N];
 		for(int i=0;i<N;i++) {
				int base = A[i];
				int r = N;
				int l = i-1;
				while(l+1<r) {
					int c = (l + r)/2;
					if(base + A[c]>=L)l=c;
					else r = c;
				}
				memo[i]=l-i; 
				
				if(l-i>=0) {
					memosum += 2*(l-i)+1;
					min = Math.min(min,base+A[l]);
				}
				
			}
 		
 		
 		
 		long sum[] = new long[N+1];
 		for(int i=0;i<N;i++)sum[i+1]=sum[i]+ A[i];
 		
 		long ans = 0;
 		for(int i=0;i<N;i++) {
 			if(memo[i]<0)break;
			int last = i+memo[i];
			long tmp = ((long)last-i+1)*2*A[i]+2*(sum[last+1]-sum[i+1]);
			ans += tmp;
 		}
 		long mul = Math.max(0,memosum-M);
 		ans -= mul*min;
 		System.out.println(ans);
	}
	
	static void rsort(int[] x) {
		Arrays.sort(x);
		int len = x.length;
		for(int i=0;i<len/2;i++) {
			int tmp = x[i];
			x[i]=x[len-1-i];
			x[len-1-i]=tmp;
		}
	}
}

</source>
<source file="../hum_codes_raw/s526440712.java" startline="1" endline="84" pcid="17705">
import java.util.*;
public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();
		long M = sc.nextLong();
		int A[] = new int[N];
		for(int i=0;i<N;i++)A[i]=sc.nextInt();
 		sc.close();
 		
 		rsort(A);
 		
 		//K
 		int R = 2*100000 + 100;
 		int L = 0;
 		while(L+1<R) {		
 			int C = (L+R)/2;//cK
 			long subsum = 0;
 			for(int i=0;i<N;i++) {
 				int base = A[i];
 				int r = N;
 				int l = i-1;
 				while(l+1<r) {
 					int c = (l + r)/2;
 					if(base + A[c]>=C)l=c;
 					else r = c;
 				}
 				if(l-i<0)continue;
 				subsum += 1 + 2*(l-i);
 			}
 			if(subsum>=M) L = C;
 			else R = C;
 		}
 		//LX
 		
 		long memosum = 0;
 		int min = Integer.MAX_VALUE;
 		int memo[] = new int[N];
 		for(int i=0;i<N;i++) {
				int base = A[i];
				int r = N;
				int l = i-1;
				while(l+1<r) {
					int c = (l + r)/2;
					if(base + A[c]>=L)l=c;
					else r = c;
				}
				memo[i]=l-i; //
				
				if(l-i>=0) {
					memosum += 2*(l-i)+1;
					min = Math.min(min,base+A[l]);
				}
				
			}
 		
 		
 		
 		long sum[] = new long[N+1];
 		for(int i=0;i<N;i++)sum[i+1]=sum[i]+ A[i];
 		
 		long ans = 0;
 		for(int i=0;i<N;i++) {
 			if(memo[i]<0)break;
			int last = i+memo[i];
			long tmp = ((long)last-i+1)*2*A[i]+2*(sum[last+1]-sum[i+1]);
			ans += tmp;
 		}
 		long mul = Math.max(0,memosum-M);
 		ans -= mul*min;
 		System.out.println(ans);
	}
	
	static void rsort(int[] x) {
		Arrays.sort(x);
		int len = x.length;
		for(int i=0;i<len/2;i++) {
			int tmp = x[i];
			x[i]=x[len-1-i];
			x[len-1-i]=tmp;
		}
	}
}

</source>
</class>

<class classid="60" nclones="3" nlines="13" similarity="100">
<source file="../hum_codes_raw/s096359768.java" startline="1" endline="15" pcid="3200">
import java.util.Scanner;

public class Main {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        String s = sc.next();
        if (s.equals("ABC")) {
            System.out.println("ARC");
        }
        else {
            System.out.println("ABC");
        }
    }
}

</source>
<source file="../hum_codes_raw/s526399829.java" startline="1" endline="21" pcid="17703">
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        // 
        String s = sc.next();

        if (s.equals("ABC")) {
            System.out.println("ARC");
        } else {
            System.out.println("ABC");
        }



    }
}

</source>
<source file="../hum_codes_raw/s228573371.java" startline="1" endline="15" pcid="7721">
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		String s = sc.next();
		if(s.equals("ABC")) {
			System.out.println("ARC");
		}else {
			System.out.println("ABC");
		}

	}
}

</source>
</class>

<class classid="61" nclones="2" nlines="18" similarity="100">
<source file="../hum_codes_raw/s098211726.java" startline="1" endline="24" pcid="3264">
import  java.util.Scanner;

public class Main {
	
	void run(){
		Scanner sc = new Scanner(System.in);
		char[] s = sc.next().toCharArray();
		int[] c = new int[4];
		for(int i=0;i<s.length;i++) {
			if(s[i]=='K')c[0]++;
			if(s[i]=='U')c[1]++;
			if(s[i]=='P')c[2]++;
			if(s[i]=='C')c[3]++;
		}
		System.out.println(Math.min(c[0], Math.min(c[1], Math.min(c[2], c[3]))));
	}

	public static void main(String[] args) {
		new Main().run();
	}

}


</source>
<source file="../hum_codes_raw/s725029473.java" startline="1" endline="22" pcid="24382">
import java.util.Scanner;

public class Main{

	void run(){
		Scanner sc = new Scanner(System.in);
		char[] s = sc.next().toCharArray();
		int[] c = new int[4];
		for(int i=0;i<s.length;i++){
			if(s[i]=='K')c[0]++;
			if(s[i]=='U')c[1]++;
			if(s[i]=='P')c[2]++;
			if(s[i]=='C')c[3]++;
		}
		System.out.println(Math.min(c[0], Math.min(c[1], Math.min(c[2], c[3]))));
	}
	
	public static void main(String[] args) {
		new Main().run();
	}
}

</source>
</class>

<class classid="62" nclones="2" nlines="17" similarity="100">
<source file="../hum_codes_raw/s098592178.java" startline="1" endline="23" pcid="3275">
import java.util.Scanner;

//Room Numbers of a Hospital
public class Main{

	static int[] t = {0,1,2,3,5,7,8,9};
	
	static void f(int n){
		if(n>=8)f(n/8);
		System.out.print(t[n%8]);
	}
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int n = sc.nextInt();
			if(n==0)break;
			f(n);
			System.out.println();
		}
	}
}

</source>
<source file="../hum_codes_raw/s933896254.java" startline="1" endline="23" pcid="31403">
import java.util.Scanner;

//Room Numbers of a Hospital
public class Main {

	static int[] t = {0,1,2,3,5,7,8,9};
	
	static void f(int n){
		if(n>=8)f(n/8);
		System.out.print(t[n%8]);
	}
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int n = sc.nextInt();
			if(n==0)break;
			f(n);
			System.out.println();
		}
	}
}

</source>
</class>

<class classid="63" nclones="2" nlines="88" similarity="100">
<source file="../hum_codes_raw/s098922862.java" startline="1" endline="96" pcid="3291">
import java.util.*;

public class Main{
    int N,M,L,K,A,H;
    int[] d;
    List<Edge>[] adj;
    int INF = 1000000000;
    boolean[] cancold;

    public static void main(String[] args){
	new Main().solve();
    }

    class Edge{
	int t, c;
	public Edge(int t, int c) {
	    this.t = t;
	    this.c = c;
	}
    }

    @SuppressWarnings("unchecked")
    void solve(){
	Scanner sc = new Scanner(System.in);
	N = sc.nextInt();
	while(N!=0){
	    M = sc.nextInt();
	    L = sc.nextInt();
	    K = sc.nextInt();
	    A = sc.nextInt();
	    H = sc.nextInt();
	    cancold = new boolean[N];
	    for(int i=0; i<L; i++){
		cancold[sc.nextInt()] = true;
	    }
	    cancold[A] = true; cancold[H] = true;
	    
	    adj = new List[N];
	    for(int i=0; i<N; i++)adj[i] = new ArrayList<Edge>();
	    for(int i=0; i<K; i++){
		int x = sc.nextInt();
		int y = sc.nextInt();
		int t = sc.nextInt();
		adj[x].add(new Edge(y,t));
		adj[y].add(new Edge(x,t));
	    }

	    d = new int[N*(M+1)];

	    dijkstra(A);

	    if(d[H*(M+1)+M]==INF){
		System.out.println("Help!");
	    }else{
		System.out.println(d[H*(M+1)+M]+Math.max(0,d[H*(M+1)+M]-M));
	    }

	    N = sc.nextInt();
	}
    }

    void dijkstra(int s){
	Arrays.fill(d,INF);
	d[s*(M+1)+M] = 0;
	PriorityQueue<Integer> q = new PriorityQueue<Integer>(N, new Comparator<Integer>() {
		public int compare(Integer o1, Integer o2) {
		    return d[o1]-d[o2];
		}
	    });

	q.add(s*(M+1)+M);
	while(!q.isEmpty()){
	    int v = q.poll();
	    int town = v/(M+1);
	    int left = v%(M+1);
	    for(Edge e:adj[town]){
		if(left-e.c<0)continue;
		int w = d[town*(M+1)+left]+e.c;
		if(cancold[e.t]){
		    if(w<d[e.t*(M+1)+M]){
			q.remove(e.t*(M+1)+M); 
			d[e.t*(M+1)+M] = w; 
			q.add(e.t*(M+1)+M);
		    }
		}else{
		    if(w<d[e.t*(M+1)+left-e.c]){
			q.remove(e.t*(M+1)+left-e.c); 
			d[e.t*(M+1)+left-e.c] = w; 
			q.add(e.t*(M+1)+left-e.c);
		    }
		}
	    }
	}
    }
}

</source>
<source file="../hum_codes_raw/s694646836.java" startline="1" endline="96" pcid="23370">
import java.util.*;

public class Main{
    int N,M,L,K,A,H;
    int[] d;
    List<Edge>[] adj;
    int INF = 1000000000;
    boolean[] cancold;

    public static void main(String[] args){
	new Main().solve();
    }

    class Edge{
	int t, c;
	public Edge(int t, int c) {
	    this.t = t;
	    this.c = c;
	}
    }

    @SuppressWarnings("unchecked")
    void solve(){
	Scanner sc = new Scanner(System.in);
	N = sc.nextInt();
	while(N!=0){
	    M = sc.nextInt();
	    L = sc.nextInt();
	    K = sc.nextInt();
	    A = sc.nextInt();
	    H = sc.nextInt();
	    cancold = new boolean[N];
	    for(int i=0; i<L; i++){
		cancold[sc.nextInt()] = true;
	    }
	    cancold[A] = true; cancold[H] = true;
	    
	    adj = new List[N];
	    for(int i=0; i<N; i++)adj[i] = new ArrayList<Edge>();
	    for(int i=0; i<K; i++){
		int x = sc.nextInt();
		int y = sc.nextInt();
		int t = sc.nextInt();
		adj[x].add(new Edge(y,t));
		adj[y].add(new Edge(x,t));
	    }

	    d = new int[N*(M+1)];

	    dijkstra(A);

	    if(d[H*(M+1)+M]==INF){
		System.out.println("Help!");
	    }else{
		System.out.println(d[H*(M+1)+M]+Math.max(0,d[H*(M+1)+M]-M));
	    }

	    N = sc.nextInt();
	}
    }

    void dijkstra(int s){
	Arrays.fill(d,INF);
	d[s*(M+1)+M] = 0;
	PriorityQueue<Integer> q = new PriorityQueue<Integer>(N, new Comparator<Integer>() {
		public int compare(Integer o1, Integer o2) {
		    return d[o1]-d[o2];
		}
	    });

	q.add(s*(M+1)+M);
	while(!q.isEmpty()){
	    int v = q.poll();
	    int town = v/(M+1);
	    int left = v%(M+1);
	    for(Edge e:adj[town]){
		if(left-e.c<0)continue;
		int w = d[town*(M+1)+left]+e.c;
		if(cancold[e.t]){
		    if(w<d[e.t*(M+1)+M]){
			q.remove(e.t*(M+1)+M); 
			d[e.t*(M+1)+M] = w; 
			q.add(e.t*(M+1)+M);
		    }
		}else{
		    if(w<d[e.t*(M+1)+left-e.c]){
			q.remove(e.t*(M+1)+left-e.c); 
			d[e.t*(M+1)+left-e.c] = w; 
			q.add(e.t*(M+1)+left-e.c);
		    }
		}
	    }
	}
    }
}

</source>
</class>

<class classid="64" nclones="2" nlines="40" similarity="100">
<source file="../hum_codes_raw/s100508872.java" startline="1" endline="57" pcid="3352">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

  public static void main(String[] args) {
    
    new Main().run();
  }

  private void run() {

    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      int heapSize = Integer.parseInt(br.readLine());
      String[] keys = br.readLine().split(" ");
      int[] mHeap = new int[heapSize+1];
      mHeap[0] = heapSize;
      for(int i=1; i<=heapSize; i++)
        mHeap[i] = Integer.parseInt( keys[i-1] );

      buildMaxHeap(mHeap);

      StringBuilder buf = new StringBuilder();
      for(int i=1; i<mHeap.length; i++) 
        buf.append(" ").append(mHeap[i]);

      System.out.println(buf);
    } catch(IOException e) {
      System.out.println("IOException!");
    }
  }
  private void buildMaxHeap(int[] heap) {
    for(int i= heap[0]/2; i>0; i--)
      maxHeapify(heap, i);
  }
  private void maxHeapify(int[] heap, int node) {
    int t,left,right,largest;
    left  = node*2;
    right = left+1;

    if( (left <= heap[0]) && (heap[left] > heap[node]) )
      largest = left;
    else
      largest = node;
    if( (right <= heap[0]) && (heap[right] > heap[largest]) )
      largest = right;

    if( largest != node ) {
      t = heap[node]; heap[node] = heap[largest]; heap[largest] = t;

      maxHeapify(heap, largest);
    }
  }
}

</source>
<source file="../hum_codes_raw/s983166256.java" startline="1" endline="57" pcid="33063">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

  public static void main(String[] args) {
    
    new Main().run();
  }

  private void run() {

    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      int heapSize = Integer.parseInt(br.readLine());
      String[] keys = br.readLine().split(" ");
      int[] mHeap = new int[heapSize+1];
      mHeap[0] = heapSize;
      for(int i=1; i<=heapSize; i++)
        mHeap[i] = Integer.parseInt( keys[i-1] );

      buildMaxHeap(mHeap);

      StringBuilder buf = new StringBuilder();
      for(int i=1; i<mHeap.length; i++) 
        buf.append(" ").append(mHeap[i]);

      System.out.println(buf);
    } catch(IOException e) {
      System.out.println("IOException!");
    }
  }
  private void buildMaxHeap(int[] heap) {
    for(int i= heap[0]/2; i>0; i--)
      maxHeapify(heap, i);
  }
  private void maxHeapify(int[] heap, int node) {
    int t,left,right,largest;
    left  = node*2;
    right = left+1;

    if( (left <= heap[0]) && (heap[left] > heap[node]) )
      largest = left;
    else
      largest = node;
    if( (right <= heap[0]) && (heap[right] > heap[largest]) )
      largest = right;

    if( largest != node ) {
      t = heap[node]; heap[node] = heap[largest]; heap[largest] = t;

      maxHeapify(heap, largest);
    }
  }
}

</source>
</class>

<class classid="65" nclones="3" nlines="16" similarity="100">
<source file="../hum_codes_raw/s102867034.java" startline="1" endline="23" pcid="3426">
import java.util.*;

public class Main{
  static final double EPS = 0.00001;

  public static void main(String[] args){
    Scanner sc = new Scanner(System.in);

    while(true){
      double q = sc.nextInt();
      if(q < 0) break;

      double x = q / 2.0;

      while(Math.abs(x * x * x - q) >= EPS * q){
        x = x - (x * x * x - q) / (3 * x * x);
      }

      System.out.printf("%.6f\n", x);
    }
  }
}

</source>
<source file="../hum_codes_raw/s466374966.java" startline="1" endline="24" pcid="15652">
import java.util.*;

public class Main {
    static final double EPS = 0.00001;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        while (true) {
            double q = sc.nextInt();
            if (q < 0)
                break;

            double x = q / 2.0;

            while (Math.abs(x * x * x - q) >= EPS * q) {
                x = x - (x * x * x - q) / (3 * x * x);
            }

            System.out.printf("%.6f\n", x);
        }
    }
}

</source>
<source file="../hum_codes_raw/s853953365.java" startline="1" endline="23" pcid="28705">
import java.util.*;
 
public class Main{
  static final double EPS = 0.00001;
 
  public static void main(String[] args){
    Scanner sc = new Scanner(System.in);
 
    while(true){
      double q = sc.nextInt();
      if(q < 0) break;
 
      double x = q / 2.0;
 
      while(Math.abs(x * x * x - q) >= EPS * q){
        x = x - (x * x * x - q) / (3 * x * x);
      }
 
      System.out.printf("%.6f\n", x);
    }
  }
}

</source>
</class>

<class classid="66" nclones="2" nlines="242" similarity="100">
<source file="../hum_codes_raw/s106468442.java" startline="1" endline="282" pcid="3546">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.Arrays;

public class Main {

	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		MyInput in = new MyInput(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		TaskX solver = new TaskX();
		solver.solve(1, in, out);
		out.close();
	}

	static int INF = 1 << 30;
	static long LINF = 1L << 55;
	static int MOD = 1000000007;
	static int[] mh4 = { 0, -1, 1, 0 };
	static int[] mw4 = { -1, 0, 0, 1 };
	static int[] mh8 = { -1, -1, -1, 0, 0, 1, 1, 1 };
	static int[] mw8 = { -1, 0, 1, -1, 1, -1, 0, 1 };

	static class TaskX {

		int n, q;
		long[] a;
		public void solve(int testNumber, MyInput in, PrintWriter out) {

			n = in.nextInt(); q = in.nextInt();
			a = in.nextLongArray(n);
			long[] sum = new long[n], odd = new long[n], even = new long[n];
			for (int i = 0; i < n; i++) {
				sum[i] = (i-1 >= 0 ? sum[i-1] : 0) + a[i];
				even[i] = (i-1 >= 0 ? even[i-1] : 0) + (i % 2 == 0 ? a[i] : 0);
				odd[i] = (i-1 >= 0 ? odd[i-1] : 0) + (i % 2 == 1 ? a[i] : 0);
			}

			while (q-- > 0) {
				long x = in.nextLong();
				int ok = 1, ng = n;
				while (ng - ok > 1) {
					int k = (ok + ng) / 2;
					if (check(k, x)) {
						ok = k;
					} else {
						ng = k;
					}
				}

				long ans = sum[n - 1] - sum[n - ok - 1];
				if (n % 2 == 0) {
					ans += n - 2*ok - 1 >= 0 ? odd[n - 2*ok - 1] : 0;
				} else {
					ans += n - 2*ok - 1 >= 0 ? even[n - 2*ok - 1] : 0;
				}

				out.println(ans);
			}

		}

		// k
		boolean check(int k, long x) {
			if (k > n) return false;
			long d = a[n-k] - x;
			int s = lowerBound(a, x - d);

			//  a[n-k] 
			//  [a[n-k] - x, a[n-k] + x] 
			int m = (n - 1 - k + 1) - (s - 1);

			//  a[n-k]  k 
			//  a[n-k]  k 
			return m >= k;
		}
	}

	public static int lowerBound(long[] a, long obj) {
		int l = 0, r = a.length - 1;
		while (r - l >= 0) {
			int c = (l + r) / 2;
			if (obj <= a[c]) {
				r = c - 1;
			} else {
				l = c + 1;
			}
		}
		return l;
	}

	static class MyInput {
		private final BufferedReader in;
		private static int pos;
		private static int readLen;
		private static final char[] buffer = new char[1024 * 8];
		private static char[] str = new char[500 * 8 * 2];
		private static boolean[] isDigit = new boolean[256];
		private static boolean[] isSpace = new boolean[256];
		private static boolean[] isLineSep = new boolean[256];

		static {
			for (int i = 0; i < 10; i++) {
				isDigit['0' + i] = true;
			}
			isDigit['-'] = true;
			isSpace[' '] = isSpace['\r'] = isSpace['\n'] = isSpace['\t'] = true;
			isLineSep['\r'] = isLineSep['\n'] = true;
		}

		public MyInput(InputStream is) {
			in = new BufferedReader(new InputStreamReader(is));
		}

		public int read() {
			if (pos >= readLen) {
				pos = 0;
				try {
					readLen = in.read(buffer);
				} catch (IOException e) {
					throw new RuntimeException();
				}
				if (readLen <= 0) {
					throw new MyInput.EndOfFileRuntimeException();
				}
			}
			return buffer[pos++];
		}

		public int nextInt() {
			int len = 0;
			str[len++] = nextChar();
			len = reads(len, isSpace);
			int i = 0;
			int ret = 0;
			if (str[0] == '-') {
				i = 1;
			}
			for (; i < len; i++)
				ret = ret * 10 + str[i] - '0';
			if (str[0] == '-') {
				ret = -ret;
			}
			return ret;
		}

		public long nextLong() {
			int len = 0;
			str[len++] = nextChar();
			len = reads(len, isSpace);
			int i = 0;
			long ret = 0;
			if (str[0] == '-') {
				i = 1;
			}
			for (; i < len; i++)
				ret = ret * 10 + str[i] - '0';
			if (str[0] == '-') {
				ret = -ret;
			}
			return ret;
		}

		public char nextChar() {
			while (true) {
				final int c = read();
				if (!isSpace[c]) {
					return (char) c;
				}
			}
		}

		public String nextString() {
			return new String(nextChars());
		}

		public char[] nextChars() {
			int len = 0;
			str[len++] = nextChar();
			len = reads(len, isSpace);
			return Arrays.copyOf(str, len);
		}

		public char[][] next2DChars(int h, int w) {
			char[][] s = new char[h][w];
			for (int i = 0; i < h; i++) {
				s[i] = nextChars();
			}
			return s;
		}

		int reads(int len, boolean[] accept) {
			try {
				while (true) {
					final int c = read();
					if (accept[c]) {
						break;
					}
					if (str.length == len) {
						char[] rep = new char[str.length * 3 / 2];
						System.arraycopy(str, 0, rep, 0, str.length);
						str = rep;
					}
					str[len++] = (char) c;
				}
			} catch (MyInput.EndOfFileRuntimeException e) {
			}
			return len;
		}

		public int[] nextIntArray(final int n) {
			final int[] res = new int[n];
			for (int i = 0; i < n; i++) {
				res[i] = nextInt();
			}
			return res;
		}

		public int[] nextIntArray1Index(final int n) {
			final int[] res = new int[n + 1];
			for (int i = 1; i < n + 1; i++) {
				res[i] = nextInt();
			}
			return res;
		}

		public int[] nextIntArrayDec(final int n) {
			final int[] res = new int[n];
			for (int i = 0; i < n; i++) {
				res[i] = nextInt() - 1;
			}
			return res;
		}

		public long[] nextLongArray(final int n) {
			final long[] res = new long[n];
			for (int i = 0; i < n; i++) {
				res[i] = nextLong();
			}
			return res;
		}

		public long[] nextLongArray1Index(final int n) {
			final long[] res = new long[n + 1];
			for (int i = 1; i < n + 1; i++) {
				res[i] = nextLong();
			}
			return res;
		}

		public long[] nextLongArrayDec(final int n) {
			final long[] res = new long[n];
			for (int i = 0; i < n; i++) {
				res[i] = nextLong() - 1;
			}
			return res;
		}

		public double nextDouble() {
			return Double.parseDouble(nextString());
		}

		public double[] nextDoubleArray(int n) {
			double[] res = new double[n];
			for (int i = 0; i < n; i++) {
				res[i] = nextDouble();
			}
			return res;
		}

		static class EndOfFileRuntimeException extends RuntimeException {
		}

	}

}

</source>
<source file="../hum_codes_raw/s723652719.java" startline="1" endline="282" pcid="24336">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.Arrays;

public class Main {

	public static void main(String[] args) {
		InputStream inputStream = System.in;
		OutputStream outputStream = System.out;
		MyInput in = new MyInput(inputStream);
		PrintWriter out = new PrintWriter(outputStream);
		TaskX solver = new TaskX();
		solver.solve(1, in, out);
		out.close();
	}

	static int INF = 1 << 30;
	static long LINF = 1L << 55;
	static int MOD = 1000000007;
	static int[] mh4 = { 0, -1, 1, 0 };
	static int[] mw4 = { -1, 0, 0, 1 };
	static int[] mh8 = { -1, -1, -1, 0, 0, 1, 1, 1 };
	static int[] mw8 = { -1, 0, 1, -1, 1, -1, 0, 1 };

	static class TaskX {

		int n, q;
		long[] a;
		public void solve(int testNumber, MyInput in, PrintWriter out) {

			n = in.nextInt(); q = in.nextInt();
			a = in.nextLongArray(n);
			long[] sum = new long[n], odd = new long[n], even = new long[n];
			for (int i = 0; i < n; i++) {
				sum[i] = (i-1 >= 0 ? sum[i-1] : 0) + a[i];
				even[i] = (i-1 >= 0 ? even[i-1] : 0) + (i % 2 == 0 ? a[i] : 0);
				odd[i] = (i-1 >= 0 ? odd[i-1] : 0) + (i % 2 == 1 ? a[i] : 0);
			}

			while (q-- > 0) {
				long x = in.nextLong();
				int ok = 1, ng = n;
				while (ng - ok > 1) {
					int k = (ok + ng) / 2;
					if (check(k, x)) {
						ok = k;
					} else {
						ng = k;
					}
				}

				long ans = sum[n - 1] - sum[n - ok - 1];
				if (n % 2 == 0) {
					ans += n - 2*ok - 1 >= 0 ? odd[n - 2*ok - 1] : 0;
				} else {
					ans += n - 2*ok - 1 >= 0 ? even[n - 2*ok - 1] : 0;
				}

				out.println(ans);
			}

		}

		// k
		boolean check(int k, long x) {
			if (k > n) return false;
			long d = a[n-k] - x;
			int s = lowerBound(a, x - d);

			//  a[n-k] 
			//  [x - d, x + d] 
			int m = (n - 1 - k + 1) - (s - 1);

			//  a[n-k]  k 
			//  a[n-k]  k 
			return m >= k;
		}
	}

	public static int lowerBound(long[] a, long obj) {
		int l = 0, r = a.length - 1;
		while (r - l >= 0) {
			int c = (l + r) / 2;
			if (obj <= a[c]) {
				r = c - 1;
			} else {
				l = c + 1;
			}
		}
		return l;
	}

	static class MyInput {
		private final BufferedReader in;
		private static int pos;
		private static int readLen;
		private static final char[] buffer = new char[1024 * 8];
		private static char[] str = new char[500 * 8 * 2];
		private static boolean[] isDigit = new boolean[256];
		private static boolean[] isSpace = new boolean[256];
		private static boolean[] isLineSep = new boolean[256];

		static {
			for (int i = 0; i < 10; i++) {
				isDigit['0' + i] = true;
			}
			isDigit['-'] = true;
			isSpace[' '] = isSpace['\r'] = isSpace['\n'] = isSpace['\t'] = true;
			isLineSep['\r'] = isLineSep['\n'] = true;
		}

		public MyInput(InputStream is) {
			in = new BufferedReader(new InputStreamReader(is));
		}

		public int read() {
			if (pos >= readLen) {
				pos = 0;
				try {
					readLen = in.read(buffer);
				} catch (IOException e) {
					throw new RuntimeException();
				}
				if (readLen <= 0) {
					throw new MyInput.EndOfFileRuntimeException();
				}
			}
			return buffer[pos++];
		}

		public int nextInt() {
			int len = 0;
			str[len++] = nextChar();
			len = reads(len, isSpace);
			int i = 0;
			int ret = 0;
			if (str[0] == '-') {
				i = 1;
			}
			for (; i < len; i++)
				ret = ret * 10 + str[i] - '0';
			if (str[0] == '-') {
				ret = -ret;
			}
			return ret;
		}

		public long nextLong() {
			int len = 0;
			str[len++] = nextChar();
			len = reads(len, isSpace);
			int i = 0;
			long ret = 0;
			if (str[0] == '-') {
				i = 1;
			}
			for (; i < len; i++)
				ret = ret * 10 + str[i] - '0';
			if (str[0] == '-') {
				ret = -ret;
			}
			return ret;
		}

		public char nextChar() {
			while (true) {
				final int c = read();
				if (!isSpace[c]) {
					return (char) c;
				}
			}
		}

		public String nextString() {
			return new String(nextChars());
		}

		public char[] nextChars() {
			int len = 0;
			str[len++] = nextChar();
			len = reads(len, isSpace);
			return Arrays.copyOf(str, len);
		}

		public char[][] next2DChars(int h, int w) {
			char[][] s = new char[h][w];
			for (int i = 0; i < h; i++) {
				s[i] = nextChars();
			}
			return s;
		}

		int reads(int len, boolean[] accept) {
			try {
				while (true) {
					final int c = read();
					if (accept[c]) {
						break;
					}
					if (str.length == len) {
						char[] rep = new char[str.length * 3 / 2];
						System.arraycopy(str, 0, rep, 0, str.length);
						str = rep;
					}
					str[len++] = (char) c;
				}
			} catch (MyInput.EndOfFileRuntimeException e) {
			}
			return len;
		}

		public int[] nextIntArray(final int n) {
			final int[] res = new int[n];
			for (int i = 0; i < n; i++) {
				res[i] = nextInt();
			}
			return res;
		}

		public int[] nextIntArray1Index(final int n) {
			final int[] res = new int[n + 1];
			for (int i = 1; i < n + 1; i++) {
				res[i] = nextInt();
			}
			return res;
		}

		public int[] nextIntArrayDec(final int n) {
			final int[] res = new int[n];
			for (int i = 0; i < n; i++) {
				res[i] = nextInt() - 1;
			}
			return res;
		}

		public long[] nextLongArray(final int n) {
			final long[] res = new long[n];
			for (int i = 0; i < n; i++) {
				res[i] = nextLong();
			}
			return res;
		}

		public long[] nextLongArray1Index(final int n) {
			final long[] res = new long[n + 1];
			for (int i = 1; i < n + 1; i++) {
				res[i] = nextLong();
			}
			return res;
		}

		public long[] nextLongArrayDec(final int n) {
			final long[] res = new long[n];
			for (int i = 0; i < n; i++) {
				res[i] = nextLong() - 1;
			}
			return res;
		}

		public double nextDouble() {
			return Double.parseDouble(nextString());
		}

		public double[] nextDoubleArray(int n) {
			double[] res = new double[n];
			for (int i = 0; i < n; i++) {
				res[i] = nextDouble();
			}
			return res;
		}

		static class EndOfFileRuntimeException extends RuntimeException {
		}

	}

}

</source>
</class>

<class classid="67" nclones="2" nlines="81" similarity="100">
<source file="../hum_codes_raw/s112957949.java" startline="1" endline="97" pcid="3756">
import java.util.*;
import java.lang.*;
import java.math.*;
import java.io.*;
import static java.lang.Math.*;
import static java.util.Arrays.*;
import static java.util.Collections.*;

public class Main{
	Scanner sc=new Scanner(System.in);

	int INF=1<<28;
	double EPS=1e-12;

	int n;
	int[] pow;
	String[] names;
	HashSet<String>[] sets;

	@SuppressWarnings("unchecked")
	void run(){
		for(;;){
			n=sc.nextInt();
			if(n==0){
				break;
			}
			names=new String[n];
			pow=new int[n];
			sets=new HashSet[n];
			for(int j=0; j<n; j++){
				names[j]=sc.next();
				pow[j]=sc.nextInt();
				sets[j]=new HashSet<String>();
				int m=sc.nextInt();
				for(int i=0; i<m; i++){
					sets[j].add(sc.next());
				}
			}
			solve();
		}
	}

	long[] g;
	int ans;

	void solve(){
		HashMap<String, Integer> map=new HashMap<String, Integer>();
		for(int i=0; i<n; i++){
			map.put(names[i], i);
		}
		g=new long[n];
		for(int i=0; i<n; i++){
			for(String s : sets[i]){
				int j=map.get(s);
				g[i]|=1L<<j;
			}
		}
		ans=0;
		mis(1, 1, pow[0]);
		println(ans+"");
	}

	void mis(int k, long choosed, int sum){
		if(k==n){
			// TODO
			ans=max(ans, sum);
			return;
		}
		if((choosed&g[k])==0){
			mis(k+1, choosed|(1L<<k), sum+pow[k]);
			long rem=0;
			for(int i=k+1; i<n; i++)
				if((choosed&g[i])==0)
					rem|=g[i];
			if((rem>>>k&1)==0)
				return;
		}
		mis(k+1, choosed, sum);
	}

	void debug(Object... os){
		System.err.println(Arrays.deepToString(os));
	}

	void print(String s){
		System.out.print(s);
	}

	void println(String s){
		System.out.println(s);
	}

	public static void main(String[] args){
		new Main().run();
	}
}

</source>
<source file="../hum_codes_raw/s285786399.java" startline="1" endline="97" pcid="9584">
import java.util.*;
import java.lang.*;
import java.math.*;
import java.io.*;
import static java.lang.Math.*;
import static java.util.Arrays.*;
import static java.util.Collections.*;

public class Main{
	Scanner sc=new Scanner(System.in);

	int INF=1<<28;
	double EPS=1e-12;

	int n;
	int[] pow;
	String[] names;
	HashSet<String>[] sets;

	@SuppressWarnings("unchecked")
	void run(){
		for(;;){
			n=sc.nextInt();
			if(n==0){
				break;
			}
			names=new String[n];
			pow=new int[n];
			sets=new HashSet[n];
			for(int j=0; j<n; j++){
				names[j]=sc.next();
				pow[j]=sc.nextInt();
				sets[j]=new HashSet<String>();
				int m=sc.nextInt();
				for(int i=0; i<m; i++){
					sets[j].add(sc.next());
				}
			}
			solve();
		}
	}

	long[] g;
	int ans;

	void solve(){
		HashMap<String, Integer> map=new HashMap<String, Integer>();
		for(int i=0; i<n; i++){
			map.put(names[i], i);
		}
		g=new long[n];
		for(int i=0; i<n; i++){
			for(String s : sets[i]){
				int j=map.get(s);
				g[i]|=1L<<j;
			}
		}
		ans=0;
		mis(1, 1, pow[0]);
		println(ans+"");
	}

	void mis(int k, long choosed, int sum){
		if(k==n){
			// TODO
			ans=max(ans, sum);
			return;
		}
		if((choosed&g[k])==0){
			mis(k+1, choosed|(1L<<k), sum+pow[k]);
			long rem=0;
			for(int i=k+1; i<n; i++)
				if((choosed&g[i])==0)
					rem|=g[i];
			if((rem>>>k&1)==0)
				return;
		}
		mis(k+1, choosed, sum);
	}

	void debug(Object... os){
		System.err.println(Arrays.deepToString(os));
	}

	void print(String s){
		System.out.print(s);
	}

	void println(String s){
		System.out.println(s);
	}

	public static void main(String[] args){
		new Main().run();
	}
}

</source>
</class>

<class classid="68" nclones="2" nlines="125" similarity="100">
<source file="../hum_codes_raw/s117325689.java" startline="1" endline="158" pcid="3918">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
 
public class Main {
	private	static	BufferedReader	br = null;
	private	static	double[][]		cd = null;
	private	static	int[]			rr = { Integer.MAX_VALUE, Integer.MIN_VALUE };

	static {
		br = new BufferedReader(new InputStreamReader(System.in));
	}
 
    /**
     * @param args
     */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int		size = 0;
		Data	data = null;
		DataTbl	tbl  = new DataTbl();
		
		while ((data = parseData()) != null) {
			tbl.add(data);
		}

		calcDist();

		size = tbl.size();
		for (int i = 0; i < size; i++) {
			data = tbl.get(i);
			System.out.println(solve(data));
		}
	}

	public static String solve(Data data) {
		String	res = "NA";
		double	min = Double.MAX_VALUE;
		double	tmp = 0.0;

		do {
			tmp = (double)data.cr[0]+(double)data.cr[data.cr.length-1];
			for (int i = 0; i < data.cr.length-1; i++) {
				tmp += cd[data.cr[i]-rr[0]][data.cr[i+1]-rr[0]];
			}
			min = Math.min(min, tmp);

			if (min <= data.wi) {
				res = "OK";
				break;
			}
		} while(next_perm(data.cr));

		return res;
	}

	static boolean next_perm(int[] cr) {
		int		i;
		int		j;
		int		t;
		int		l = cr.length;
		boolean	r = false;
	    
		if (l > 0) {
			for(i = l - 1; i > 0 && cr[i-1] >= cr[i]; i--);

			if (i > 0) {
				for(j = l - 1; j > i && cr[i-1] >= cr[j]; j--);

				// swap(p,j,i-1);
				t = cr[j];
				cr[j] = cr[i-1];
				cr[i-1] = t;

				for(j=l-1; i < j; i++, j--){
					// swap(p,i,j);
					t = cr[i];
					cr[i] = cr[j];
					cr[j] = t;
				}

				r = true;
			}
		}

		return r;
	}

	public static void calcDist() {
		int	sz = rr[1]-rr[0];

		cd = new double[sz+1][sz+1];
		for (int i = 0; i <= sz; i++) {
			for (int j = i; j <= sz; j++) {
				double	d = 0.0;
				if (i == j) {
					d = (double)((rr[0]+i)*2);
				} else {
					d = Math.sqrt(Math.pow((double)(rr[0]*2+j+i), 2.0)-Math.pow((double)(j-i), 2.0));
				}
				cd[i][j] = d;
				cd[j][i] = d;
			}
		}
	}

	private static Data parseData() {
		Data	data  = null;
		String	stdin  = null;

		if ((stdin = parseStdin()) != null) {
			String[]	lines = stdin.split(" ");

			data = new Data(lines.length-1);
			for(int i = 0; i < lines.length; i++) {
				if (i == 0) {
					data.wi = Integer.parseInt(lines[i]);
				} else {
					data.cr[i-1] = Integer.parseInt(lines[i]);
					rr[0] = Math.min(rr[0], data.cr[i-1]);
					rr[1] = Math.max(rr[1], data.cr[i-1]);
				}
			}
			Arrays.sort(data.cr);
		}

		return data;
	}

	private static String parseStdin() {
		String  stdin = null;

		try {
			String  tmp = br.readLine();
			if (tmp != null) {
				if (!tmp.isEmpty()) stdin = tmp;
			}
		}
		catch (IOException e) {}

		return stdin;
	}
}

class DataTbl extends ArrayList<Data> {
}

class Data {
	int			wi = 0;
	int[]		cr = null;

	Data (int cc) {
		cr = new int[cc];
	}
}

</source>
<source file="../hum_codes_raw/s138854748.java" startline="1" endline="158" pcid="4639">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
  
public class Main {
    private static  BufferedReader  br = null;
    private static  double[][]      cd = null;
    private static  int[]           rr = { Integer.MAX_VALUE, Integer.MIN_VALUE };
 
    static {
        br = new BufferedReader(new InputStreamReader(System.in));
    }
  
    /**
     * @param args
     */
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        int     size = 0;
        Data    data = null;
        DataTbl tbl  = new DataTbl();
         
        while ((data = parseData()) != null) {
            tbl.add(data);
        }
 
        calcDist();
 
        size = tbl.size();
        for (int i = 0; i < size; i++) {
            data = tbl.get(i);
            System.out.println(solve(data));
        }
    }
 
    public static String solve(Data data) {
        String  res = "NA";
        double  min = Double.MAX_VALUE;
        double  tmp = 0.0;
 
        do {
            tmp = (double)data.cr[0]+(double)data.cr[data.cr.length-1];
            for (int i = 0; i < data.cr.length-1; i++) {
                tmp += cd[data.cr[i]-rr[0]][data.cr[i+1]-rr[0]];
            }
            min = Math.min(min, tmp);
 
            if (min <= data.wi) {
                res = "OK";
                break;
            }
        } while(next_perm(data.cr));
 
        return res;
    }
 
    static boolean next_perm(int[] cr) {
        int     i;
        int     j;
        int     t;
        int     l = cr.length;
        boolean r = false;
         
        if (l > 0) {
            for(i = l - 1; i > 0 && cr[i-1] >= cr[i]; i--);
 
            if (i > 0) {
                for(j = l - 1; j > i && cr[i-1] >= cr[j]; j--);
 
                // swap(p,j,i-1);
                t = cr[j];
                cr[j] = cr[i-1];
                cr[i-1] = t;
 
                for(j=l-1; i < j; i++, j--){
                    // swap(p,i,j);
                    t = cr[i];
                    cr[i] = cr[j];
                    cr[j] = t;
                }
 
                r = true;
            }
        }
 
        return r;
    }
 
    public static void calcDist() {
        int sz = rr[1]-rr[0];
 
        cd = new double[sz+1][sz+1];
        for (int i = 0; i <= sz; i++) {
            for (int j = i; j <= sz; j++) {
                double  d = 0.0;
                if (i == j) {
                    d = (double)((rr[0]+i)*2);
                } else {
                    d = Math.sqrt(Math.pow((double)(rr[0]*2+j+i), 2.0)-Math.pow((double)(j-i), 2.0));
                }
                cd[i][j] = d;
                cd[j][i] = d;
            }
        }
    }
 
    private static Data parseData() {
        Data    data  = null;
        String  stdin  = null;
 
        if ((stdin = parseStdin()) != null) {
            String[]    lines = stdin.split(" ");
 
            data = new Data(lines.length-1);
            for(int i = 0; i < lines.length; i++) {
                if (i == 0) {
                    data.wi = Integer.parseInt(lines[i]);
                } else {
                    data.cr[i-1] = Integer.parseInt(lines[i]);
                    rr[0] = Math.min(rr[0], data.cr[i-1]);
                    rr[1] = Math.max(rr[1], data.cr[i-1]);
                }
            }
            Arrays.sort(data.cr);
        }
 
        return data;
    }
 
    private static String parseStdin() {
        String  stdin = null;
 
        try {
            String  tmp = br.readLine();
            if (tmp != null) {
                if (!tmp.isEmpty()) stdin = tmp;
            }
        }
        catch (IOException e) {}
 
        return stdin;
    }
}
 
class DataTbl extends ArrayList<Data> {
}
 
class Data {
    int         wi = 0;
    int[]       cr = null;
 
    Data (int cc) {
        cr = new int[cc];
    }
}

</source>
</class>

<class classid="69" nclones="2" nlines="161" similarity="100">
<source file="../hum_codes_raw/s119112870.java" startline="1" endline="207" pcid="3984">
import java.io.*;
import java.util.*;

public class Main {
	FastScanner in = new FastScanner(System.in);
	PrintWriter out = new PrintWriter(System.out);

	class State implements Comparable<State> {
		int cnt;
		String s;

		State(int cnt, String s) {
			this.cnt = cnt;
			this.s = s;
		}

		public int compareTo(State s) {
			return cnt - s.cnt;
		}
	}
	
	public void run() {
		int N = in.nextInt(), M = in.nextInt();
		String base = "";
		for (int i = 0; i < N; i++) {
			base += in.nextInt();
		}
		
		String target1 = "", target2 = "";
		for (int i = 0; i < M; i++) {
			int p = in.nextInt();
			for (int j = 0; j < p; j++) {
				target1 += (i % 2 == 0) ? 1 : 0;
				target2 += (i % 2 == 0) ? 0 : 1;
			}
		}
		
		HashMap<String, Integer> map = new HashMap<String, Integer>();
		map.put(base, 0);
		
		
		PriorityQueue<State> pq = new PriorityQueue<State>();
		pq.add(new State(0, base));
		
		while (!pq.isEmpty()) {
			State st = pq.poll();
			ArrayList<String> list = new ArrayList<String>();
			for (int i = 0; i < N - 1; i++) {
				char[] next = st.s.toCharArray();
				char temp = next[i];
				next[i] = next[i+1];
				next[i+1] = temp;
				list.add(new String(next));
			}
			
			for (String next : list) {
				if (map.containsKey(next)) {
					int pvalue = map.get(next);
					if (st.cnt + 1 < pvalue) {
						map.put(next, st.cnt + 1);
						pq.add(new State(st.cnt + 1, next));	
					}
				} else {
					map.put(next, st.cnt + 1);
					pq.add(new State(st.cnt + 1, next));
				}
			}
		}
		
		int res = Integer.MAX_VALUE;
		if (map.containsKey(target1))
			res = Math.min(res, map.get(target1));
		if (map.containsKey(target2))
			res = Math.min(res, map.get(target2));
		System.out.println(res);
		
		out.close();
	}

	public static void main(String[] args) {
		new Main().run();
	}

	public void mapDebug(int[][] a) {
		System.out.println("--------map display---------");

		for (int i = 0; i < a.length; i++) {
			for (int j = 0; j < a[i].length; j++) {
				System.out.printf("%3d ", a[i][j]);
			}
			System.out.println();
		}

		System.out.println("----------------------------");
		System.out.println();
	}

	public void debug(Object... obj) {
		System.out.println(Arrays.deepToString(obj));
	}

	class FastScanner {
		private InputStream stream;
		private byte[] buf = new byte[1024];
		private int curChar;
		private int numChars;

		public FastScanner(InputStream stream) {
			this.stream = stream;
			//stream = new FileInputStream(new File("dec.in"));

		}

		int read() {
			if (numChars == -1)
				throw new InputMismatchException();
			if (curChar >= numChars) {
				curChar = 0;
				try {
					numChars = stream.read(buf);
				} catch (IOException e) {
					throw new InputMismatchException();
				}
				if (numChars <= 0)
					return -1;
			}
			return buf[curChar++];
		}

		boolean isSpaceChar(int c) {
			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
		}

		boolean isEndline(int c) {
			return c == '\n' || c == '\r' || c == -1;
		}

		int nextInt() {
			return Integer.parseInt(next());
		}

		int[] nextIntArray(int n) {
			int[] array = new int[n];
			for (int i = 0; i < n; i++)
				array[i] = nextInt();

			return array;
		}

		long nextLong() {
			return Long.parseLong(next());
		}

		long[] nextLongArray(int n) {
			long[] array = new long[n];
			for (int i = 0; i < n; i++)
				array[i] = nextLong();

			return array;
		}

		double nextDouble() {
			return Double.parseDouble(next());
		}

		double[] nextDoubleArray(int n) {
			double[] array = new double[n];
			for (int i = 0; i < n; i++)
				array[i] = nextDouble();

			return array;
		}

		String next() {
			int c = read();
			while (isSpaceChar(c))
				c = read();
			StringBuilder res = new StringBuilder();
			do {
				res.appendCodePoint(c);
				c = read();
			} while (!isSpaceChar(c));
			return res.toString();
		}

		String[] nextStringArray(int n) {
			String[] array = new String[n];
			for (int i = 0; i < n; i++)
				array[i] = next();

			return array;
		}

		String nextLine() {
			int c = read();
			while (isEndline(c))
				c = read();
			StringBuilder res = new StringBuilder();
			do {
				res.appendCodePoint(c);
				c = read();
			} while (!isEndline(c));
			return res.toString();
		}
	}
}

</source>
<source file="../hum_codes_raw/s739849216.java" startline="1" endline="209" pcid="24854">


import java.io.*;
import java.util.*;

public class Main {
	FastScanner in = new FastScanner(System.in);
	PrintWriter out = new PrintWriter(System.out);

	class State implements Comparable<State> {
		int cnt;
		String s;

		State(int cnt, String s) {
			this.cnt = cnt;
			this.s = s;
		}

		public int compareTo(State s) {
			return cnt - s.cnt;
		}
	}
	
	public void run() {
		int N = in.nextInt(), M = in.nextInt();
		String base = "";
		for (int i = 0; i < N; i++) {
			base += in.nextInt();
		}
		
		String target1 = "", target2 = "";
		for (int i = 0; i < M; i++) {
			int p = in.nextInt();
			for (int j = 0; j < p; j++) {
				target1 += (i % 2 == 0) ? 1 : 0;
				target2 += (i % 2 == 0) ? 0 : 1;
			}
		}
		
		HashMap<String, Integer> map = new HashMap<String, Integer>();
		map.put(base, 0);
		
		
		PriorityQueue<State> pq = new PriorityQueue<State>();
		pq.add(new State(0, base));
		
		while (!pq.isEmpty()) {
			State st = pq.poll();
			ArrayList<String> list = new ArrayList<String>();
			for (int i = 0; i < N - 1; i++) {
				char[] next = st.s.toCharArray();
				char temp = next[i];
				next[i] = next[i+1];
				next[i+1] = temp;
				list.add(new String(next));
			}
			
			for (String next : list) {
				if (map.containsKey(next)) {
					int pvalue = map.get(next);
					if (st.cnt + 1 < pvalue) {
						map.put(next, st.cnt + 1);
						pq.add(new State(st.cnt + 1, next));	
					}
				} else {
					map.put(next, st.cnt + 1);
					pq.add(new State(st.cnt + 1, next));
				}
			}
		}
		
		int res = Integer.MAX_VALUE;
		if (map.containsKey(target1))
			res = Math.min(res, map.get(target1));
		if (map.containsKey(target2))
			res = Math.min(res, map.get(target2));
		System.out.println(res);
		
		out.close();
	}

	public static void main(String[] args) {
		new Main().run();
	}

	public void mapDebug(int[][] a) {
		System.out.println("--------map display---------");

		for (int i = 0; i < a.length; i++) {
			for (int j = 0; j < a[i].length; j++) {
				System.out.printf("%3d ", a[i][j]);
			}
			System.out.println();
		}

		System.out.println("----------------------------");
		System.out.println();
	}

	public void debug(Object... obj) {
		System.out.println(Arrays.deepToString(obj));
	}

	class FastScanner {
		private InputStream stream;
		private byte[] buf = new byte[1024];
		private int curChar;
		private int numChars;

		public FastScanner(InputStream stream) {
			this.stream = stream;
			//stream = new FileInputStream(new File("dec.in"));

		}

		int read() {
			if (numChars == -1)
				throw new InputMismatchException();
			if (curChar >= numChars) {
				curChar = 0;
				try {
					numChars = stream.read(buf);
				} catch (IOException e) {
					throw new InputMismatchException();
				}
				if (numChars <= 0)
					return -1;
			}
			return buf[curChar++];
		}

		boolean isSpaceChar(int c) {
			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
		}

		boolean isEndline(int c) {
			return c == '\n' || c == '\r' || c == -1;
		}

		int nextInt() {
			return Integer.parseInt(next());
		}

		int[] nextIntArray(int n) {
			int[] array = new int[n];
			for (int i = 0; i < n; i++)
				array[i] = nextInt();

			return array;
		}

		long nextLong() {
			return Long.parseLong(next());
		}

		long[] nextLongArray(int n) {
			long[] array = new long[n];
			for (int i = 0; i < n; i++)
				array[i] = nextLong();

			return array;
		}

		double nextDouble() {
			return Double.parseDouble(next());
		}

		double[] nextDoubleArray(int n) {
			double[] array = new double[n];
			for (int i = 0; i < n; i++)
				array[i] = nextDouble();

			return array;
		}

		String next() {
			int c = read();
			while (isSpaceChar(c))
				c = read();
			StringBuilder res = new StringBuilder();
			do {
				res.appendCodePoint(c);
				c = read();
			} while (!isSpaceChar(c));
			return res.toString();
		}

		String[] nextStringArray(int n) {
			String[] array = new String[n];
			for (int i = 0; i < n; i++)
				array[i] = next();

			return array;
		}

		String nextLine() {
			int c = read();
			while (isEndline(c))
				c = read();
			StringBuilder res = new StringBuilder();
			do {
				res.appendCodePoint(c);
				c = read();
			} while (!isEndline(c));
			return res.toString();
		}
	}
}

</source>
</class>

<class classid="70" nclones="2" nlines="111" similarity="100">
<source file="../hum_codes_raw/s121471839.java" startline="1" endline="148" pcid="4051">
import java.util.*;
import java.lang.*;

class Main {

	public static void main(String[] args) {
		new Main().surprise();
	}

	public void surprise() {
		Scanner scanner = new Scanner(System.in);
		int numOps = scanner.nextInt();
		int key, pri;
		Node root = null;

		for(int i = 0; i < numOps; i++) {
			String op = scanner.next();

			if(op.equals("insert")) {
				key = scanner.nextInt();
				pri = scanner.nextInt();
				root = insert(root, key, pri);
			} else if(op.equals("find")) {
				key = scanner.nextInt();
				System.out.println(find(root, key) ? "yes" : "no");
			} else if(op.equals("delete")) {
				key = scanner.nextInt();
				root = erase(root, key);
			} else if(op.equals("print")) {
				printTreap(root);
			}
		}
	}

	public Node rightRotate(Node t) {
		Node s = t.left;
		t.left = s.right;
		s.right = t;
		return s;
	}

	public Node leftRotate(Node t) {
		Node s = t.right;
		t.right = s.left;
		s.left = t;
		return s;
	}

	public Node insert(Node t, int key, int pri) {
		if(t == null)
			return new Node(key, pri);

		if(key == t.key)
			return t;

		if(key < t.key) {
			t.left = insert(t.left, key, pri);
			if(t.pri < t.left.pri)
				t = rightRotate(t);
		} else {
			t.right = insert(t.right, key, pri);
			if(t.pri < t.right.pri)
				t = leftRotate(t);
		}

		return t;
	}

	public Node erase(Node t, int key) {
		if(t == null)
			return null;

		if(key == t.key) {
			if(t.left == null && t.right == null)
				return null;
			else if(t.left == null)
				t = leftRotate(t);
			else if(t.right == null)
				t = rightRotate(t);
			else {
				if(t.left.pri > t.right.pri)
					t = rightRotate(t);
				else 
					t = leftRotate(t);
			}

			return erase(t, key);
		}

		if(key < t.key)
			t.left = erase(t.left, key);
		else
			t.right = erase(t.right, key);

		return t;
	}

	public boolean find(Node root, int target) {
		if(root == null)
			return false;

		if(root.key == target)
			return true;
		else if(root.key < target)
			return find(root.right, target);
		else
			return find(root.left, target);
	}

	public void printTreap(Node root) {
		inorderTraverse(root);
		System.out.println();
		preorderTraverse(root);
		System.out.println();
	}

	private void inorderTraverse(Node root) {
		if(root != null) {
			inorderTraverse(root.left);
			System.out.print(" " + root.key);
			inorderTraverse(root.right);
		}
	}

	private void preorderTraverse(Node root) {
		if(root != null) {
			System.out.print(" " + root.key);
			preorderTraverse(root.left);
			preorderTraverse(root.right);
		}
	}

	class Node {
		int key;
		int pri;
		Node left;
		Node right;

		public Node(int k, int p) {
			key = k;
			pri = p;
			left = null;
			right = null;
		}
	}
}


</source>
<source file="../hum_codes_raw/s432137159.java" startline="1" endline="147" pcid="14511">
import java.util.*;
import java.lang.*;

class Main {

	public static void main(String[] args) {
		new Main().surprise();
	}

	public void surprise() {
		Scanner scanner = new Scanner(System.in);
		int numOps = scanner.nextInt();
		int key, pri;
		Node root = null;

		for(int i = 0; i < numOps; i++) {
			String op = scanner.next();

			if(op.equals("insert")) {
				key = scanner.nextInt();
				pri = scanner.nextInt();
				root = insert(root, key, pri);
			} else if(op.equals("find")) {
				key = scanner.nextInt();
				System.out.println(find(root, key) ? "yes" : "no");
			} else if(op.equals("delete")) {
				key = scanner.nextInt();
				root = erase(root, key);
			} else if(op.equals("print")) {
				printTreap(root);
			}
		}
	}

	public Node rightRotate(Node t) {
		Node s = t.left;
		t.left = s.right;
		s.right = t;
		return s;
	}

	public Node leftRotate(Node t) {
		Node s = t.right;
		t.right = s.left;
		s.left = t;
		return s;
	}

	public Node insert(Node t, int key, int pri) {
		if(t == null)
			return new Node(key, pri);

		if(key == t.key)
			return t;

		if(key < t.key) {
			t.left = insert(t.left, key, pri);
			if(t.pri < t.left.pri)
				t = rightRotate(t);
		} else {
			t.right = insert(t.right, key, pri);
			if(t.pri < t.right.pri)
				t = leftRotate(t);
		}

		return t;
	}

	public Node erase(Node t, int key) {
		if(t == null)
			return null;

		if(key == t.key) {
			if(t.left == null && t.right == null)
				return null;
			else if(t.left == null)
				t = leftRotate(t);
			else if(t.right == null)
				t = rightRotate(t);
			else {
				if(t.left.pri > t.right.pri)
					t = rightRotate(t);
				else 
					t = leftRotate(t);
			}

			return erase(t, key);
		}

		if(key < t.key)
			t.left = erase(t.left, key);
		else
			t.right = erase(t.right, key);

		return t;
	}

	public boolean find(Node root, int target) {
		if(root == null)
			return false;

		if(root.key == target)
			return true;
		else if(root.key < target)
			return find(root.right, target);
		else
			return find(root.left, target);
	}

	public void printTreap(Node root) {
		inorderTraverse(root);
		System.out.println();
		preorderTraverse(root);
		System.out.println();
	}

	private void inorderTraverse(Node root) {
		if(root != null) {
			inorderTraverse(root.left);
			System.out.print(" " + root.key);
			inorderTraverse(root.right);
		}
	}

	private void preorderTraverse(Node root) {
		if(root != null) {
			System.out.print(" " + root.key);
			preorderTraverse(root.left);
			preorderTraverse(root.right);
		}
	}

	class Node {
		int key;
		int pri;
		Node left;
		Node right;

		public Node(int k, int p) {
			key = k;
			pri = p;
			left = null;
			right = null;
		}
	}
}

</source>
</class>

<class classid="71" nclones="2" nlines="17" similarity="100">
<source file="../hum_codes_raw/s122330494.java" startline="1" endline="20" pcid="4069">
import java.util.Scanner;

public class Main {
	static int max(int a, int b, int c) {
		return Math.max(Math.max(a, b),c);
	}
	static int min(int a, int b, int c) {
		return Math.min(Math.min(a, b),c);
	}
	public static void main(String[] args) {
		try(Scanner sc = new Scanner(System.in)) {
			int a = sc.nextInt();
			int b = sc.nextInt();
			int c = sc.nextInt();
			System.out.println(min(a,b,c) + " " + max(a,b,c));
			
		}
	}
}

</source>
<source file="../hum_codes_raw/s773187572.java" startline="1" endline="21" pcid="25960">
import java.util.Scanner;

public class Main {
	static int max(int a, int b, int c) {
		return Math.max(Math.max(a, b),c);
	}
	static int min(int a, int b, int c) {
		return Math.min(Math.min(a, b),c);
	}
	public static void main(String[] args) {
		try(Scanner sc = new Scanner(System.in)) {
			int a = sc.nextInt();
			int b = sc.nextInt();
			int c = sc.nextInt();
			System.out.println(min(a,b,c) + " " + max(a,b,c));

		}
	}
}


</source>
</class>

<class classid="72" nclones="3" nlines="13" similarity="100">
<source file="../hum_codes_raw/s122353815.java" startline="1" endline="17" pcid="4070">
import java.util.*;
public class Main{
  public static void main(String[] args){
    Scanner sc = new Scanner(System.in);
    int x = sc.nextInt();
    if(x<1200){
      System.out.println("ABC");
    }else{
      System.out.println("ARC");
    }

  }
  

  
}

</source>
<source file="../hum_codes_raw/s351618051.java" startline="1" endline="13" pcid="11799">
import java.util.*;
public class Main{
	public static void main(String[] args){
    	Scanner sc = new Scanner(System.in);
      	int x = sc.nextInt();
      	if(x < 1200){
        	System.out.println("ABC");
        }else{
        	System.out.println("ARC");
        }
    }
}

</source>
<source file="../hum_codes_raw/s630000050.java" startline="1" endline="14" pcid="21131">
import java.util.*;

public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int x = sc.nextInt();
        if(x < 1200){
            System.out.println("ABC");
        }else{
            System.out.println("ARC");
        }
    }
}

</source>
</class>

<class classid="73" nclones="2" nlines="20" similarity="100">
<source file="../hum_codes_raw/s124268953.java" startline="1" endline="24" pcid="4145">
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        String S = sc.next();
        int x = 0;
        int max = 0;
        for (int i = 0 ; i < N ; i++ ) {
            if (S.charAt(i) == 'I') {
                x++;
            } else if (S.charAt(i) == 'D') {
                x--;
            }
            max = Math.max(max, x);

        }
        System.out.println(max);
    }

}

</source>
<source file="../hum_codes_raw/s282464824.java" startline="1" endline="22" pcid="9460">
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();
		String S = sc.next();
		int x = 0;
		int max = 0;
		for (int i = 0 ; i < N ; i++) {
			if (S.charAt(i) == 'I') {
				x++;
			} else if (S.charAt(i) == 'D') {
				x--;
			}
			max = Math.max(max, x);
		}
		System.out.println(max);
	}
}

</source>
</class>

<class classid="74" nclones="2" nlines="126" similarity="100">
<source file="../hum_codes_raw/s125047483.java" startline="1" endline="149" pcid="4175">
import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;
public class Main {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		for(;sc.hasNext();){
			String s = sc.next();
			String t = sc.next();
			SuffixArray sa = new SuffixArray(s);
			int left=-1,right=t.length()+1;
			while(left<right-1){
				int len= (left+right)/2;
				boolean f = false;
				for(int i=0;i<t.length();i++){
					if(i+len>t.length())break;
					String sub = t.substring(i,i+len);
					if(sa.contain(sub)){
						f=true;
						break;
					}
				}
				if(f){
					left=len;
				}
				else{
					right=len;
				}
					
			}
			System.out.println(left);			
		}

	}

	static class SuffixArray {
		int n,k=1;
		Integer[] sa,rank,tmp;
		String s;

		SuffixArray(String _s) {
			s=_s;
			n = s.length();
			String[] S = new String[n+1];
			S[n]="";
			for(int i=n-1;i>=0;i--){
				S[i] = s.charAt(i)+S[i+1];
			}
			rank=new Integer[n+1];
			sa=new Integer[n+1];
			tmp=new Integer[n+1];
			for(int i=0;i<n;i++){
				sa[i]=i;
				rank[i]=(int) s.charAt(i);
			}
			sa[n]=n;
			rank[n]=-1;

			for(k=1;k<=n;k<<=1){
				Arrays.sort(sa,new Comparator<Integer>(){
					@Override
					public int compare(Integer o1, Integer o2) {
						int r1=rank[o1];
						int r2=rank[o2];
						if(r1!=r2)return (r1-r2);
						int r11=o1+k <= n ? rank[o1+k] : -1;
						int r22=o2+k <= n ? rank[o2+k] : -1;
						return (r11-r22);
					}
				});
				tmp[sa[0]]=0;
				for(int i=1;i<=n;i++){
					tmp[sa[i]]=tmp[sa[i-1]]+ (compare(sa[i-1],sa[i])!=0?1:0);
				}
				for(int i=0;i<=n;i++){
					rank[i]=tmp[i];
				}
			}
		}
		boolean contain(String t){
			return contain(s,sa,t);
		} 
		private boolean contain(String s,Integer[] sa,String t){
			int a=0,b=s.length();
			while(b-a>1){
				int c = (a+b)/2;
				int com = compare(s,sa[c], Math.min(sa[c]+t.length(), s.length()),t);
				if(com<0){
					a=c;
				}
				else{
					b=c;
				}
			}
			return compare(s,sa[b], Math.min(sa[b]+t.length(), s.length()),t)==0;
		}
		/*
		 * s.substring(i1,i2).compare(t)
		 */
		private int compare(String s,int i1,int i2,String t){
//			if(true)
//				return s.substring(i1,i2).compareTo(t);
					
			for(int i=i1;i<i2;i++){
				if(i-i1>=t.length()){
					return 1;
				}
				if(s.charAt(i)!=t.charAt(i-i1)){
					return s.charAt(i)-t.charAt(i-i1);
				}
			}
			return (i2-i1)-t.length();
		}

		/*
		 * s.substring(i1,i2).compare(t.substring(j1,j2)
		 */
		private int compare(String s,int i1,int i2,String t,int j1,int j2){
			int slen=i2-i1;
			int tlen=j2-j1;
			for(int i=0;i<slen;i++){
				if(i>=tlen){
					return 1;
				}
				if(s.charAt(i+i1)!=t.charAt(i+j1)){
					return s.charAt(i+i1)-t.charAt(i+j1);
				}
			}
			return slen-tlen;
		}

		private int compare(Integer o1, Integer o2) {
			int r1=rank[o1];
			int r2=rank[o2];
			if(r1!=r2)return (r1-r2);
			int r11=o1+k <= n ? rank[o1+k] : -1;
			int r22=o2+k <= n ? rank[o2+k] : -1;

			return (r11-r22);
		}

	}

}

</source>
<source file="../hum_codes_raw/s521951523.java" startline="1" endline="165" pcid="17551">
import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;
public class Main {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		for(;sc.hasNext();){
			String s = sc.next();
			String t = sc.next();
			SuffixArray sa = new SuffixArray(s);
			int left=-1,right=t.length()+1;
			while(left<right-1){
				int len= (left+right)/2;
				
//				System.out.println(left+" "+right+" "+len);
				boolean f = false;
				for(int i=0;i<t.length();i++){
					if(i+len>t.length())break;
					String sub = t.substring(i,i+len);
					if(sa.contain(sub)){
						f=true;
						break;
					}
				}
				if(f){
					left=len;
				}
				else{
					right=len;
				}
					
			}
			System.out.println(left);			
		}

	}

	static class SuffixArray {
		int n,k=1;
		Integer[] sa,rank,tmp;
		String s;

		SuffixArray(String _s) {
			s=_s;
			n = s.length();
			String[] S = new String[n+1];
			S[n]="";
			for(int i=n-1;i>=0;i--){
				S[i] = s.charAt(i)+S[i+1];
			}
			rank=new Integer[n+1];
			sa=new Integer[n+1];
			tmp=new Integer[n+1];
			for(int i=0;i<n;i++){
				sa[i]=i;
				rank[i]=(int) s.charAt(i);
			}
			sa[n]=n;
			rank[n]=-1;

			for(k=1;k<=n;k<<=1){
				Arrays.sort(sa,new Comparator<Integer>(){
					@Override
					public int compare(Integer o1, Integer o2) {
						int r1=rank[o1];
						int r2=rank[o2];
						if(r1!=r2)return (r1-r2);
						int r11=o1+k <= n ? rank[o1+k] : -1;
						int r22=o2+k <= n ? rank[o2+k] : -1;

						return (r11-r22);
					}
				});
				tmp[sa[0]]=0;
				for(int i=1;i<=n;i++){
					tmp[sa[i]]=tmp[sa[i-1]]+ (compare(sa[i-1],sa[i])!=0?1:0);
				}
				for(int i=0;i<=n;i++){
					rank[i]=tmp[i];
				}
			}
		}
		boolean contain(String t){
			return contain(s,sa,t);
		} 
		private boolean contain(String s,Integer[] sa,String t){
			int a=0,b=s.length();
			while(b-a>1){
				int c = (a+b)/2;
//				String sub = s.substring(sa[c], Math.min(sa[c]+t.length(), s.length()));
				//			System.out.println(sub);
				//			System.out.println(a+" "+c+" "+b);
				
				int com = compare(s,sa[c], Math.min(sa[c]+t.length(), s.length()),t);
//				int com = compare(s,sa[c], sa[c]+t.length()< s.length() ? sa[c]+t.length():s.length(),t);
//				if(sub.compareTo(t)<0 != com < 0){
//					System.out.println(sub.compareTo(t)+" "+com);
//					System.out.println(sa[c]+" "+sa[c]+" "+t.length()+" "+s.length());
//					System.out.println(sub+" "+t);
//				}
//				if(sub.compareTo(t)<0){
				if(com<0){
					a=c;
				}
				else{
					b=c;
				}
			}
//			return s.substring(sa[b], Math.min(sa[b]+t.length(), s.length())).compareTo(t)==0;
//			return compare(s,sa[b], sa[b]+t.length()< s.length() ? sa[b]+t.length():s.length(),t)==0;
			return compare(s,sa[b], Math.min(sa[b]+t.length(), s.length()),t)==0;
		}
		/*
		 * s.substring(i1,i2).compare(t)
		 */
		private int compare(String s,int i1,int i2,String t){
//			if(true)
//				return s.substring(i1,i2).compareTo(t);
					
			for(int i=i1;i<i2;i++){
				if(i-i1>=t.length()){
					return 1;
				}
				if(s.charAt(i)!=t.charAt(i-i1)){
					return s.charAt(i)-t.charAt(i-i1);
				}
			}
			return (i2-i1)-t.length();
		}

		/*
		 * s.substring(i1,i2).compare(t.substring(j1,j2)
		 */
		private int compare(String s,int i1,int i2,String t,int j1,int j2){
			int slen=i2-i1;
			int tlen=j2-j1;
			for(int i=0;i<slen;i++){
				if(i>=tlen){
					return 1;
				}
				if(s.charAt(i+i1)!=t.charAt(i+j1)){
					return s.charAt(i+i1)-t.charAt(i+j1);
				}
			}
			return slen-tlen;
		}

		private int compare(Integer o1, Integer o2) {
			int r1=rank[o1];
			int r2=rank[o2];
			if(r1!=r2)return (r1-r2);
			int r11=o1+k <= n ? rank[o1+k] : -1;
			int r22=o2+k <= n ? rank[o2+k] : -1;

			return (r11-r22);
		}

	}

}

</source>
</class>

<class classid="75" nclones="2" nlines="35" similarity="100">
<source file="../hum_codes_raw/s126567478.java" startline="1" endline="48" pcid="4226">
import java.util.*;

public class Main {    
    
  public static void main(String[] args) {              
     Scanner sc = new Scanner(System.in);
     
     String S = sc.next();
     
     int N = S.length();                              
     int current = N;
     
     
     while(current > 0){
         
             if(current >= 7){
                 String sub = S.substring(current-7,current);
                 if(sub.equals("dreamer")){
                     current -= 7;
                     continue;
                 }             
             }
             
             if(current >= 6){
                 String sub = S.substring(current - 6,current);
                 if(sub.equals("eraser")){
                     current -= 6;
                     continue;
                 }
             }
         
             if(current >= 5){
                 String sub = S.substring(current - 5,current);
                 if(sub.equals("dream") || sub.equals("erase")){
                     current -= 5;
                     continue;
                 }                                  
             }
                       
             System.out.println("NO");
             return;                                   
     }
     
     System.out.println("YES");     
     
  }          
}

</source>
<source file="../hum_codes_raw/s420320317.java" startline="1" endline="50" pcid="14125">
import java.util.*;

public class Main {    
    public static void main(String[] args){

       Scanner sc = new Scanner(System.in);
                
        String S = sc.next();
		int N = S.length();
	
		int current = N;
	
		while(current > 0){
			if(current >= 7){
				String sub = S.substring(current-7, current);
				if(sub.equals("dreamer")){
					current -= 7;
					continue;
				}
			}
			
			if(current >= 6){
				String sub = S.substring(current-6, current);
				if(sub.equals("eraser")){
					current -= 6;
					continue;
				}
			}
			
			if(current >= 5){
				String sub = S.substring(current-5, current);
				if(sub.equals("dream") || sub.equals("erase")){
					current -= 5;
					continue;
				}
			}
			
			System.out.println("NO");
                        return;
		}
		
		System.out.println("YES");      
                
      
  }                                      
}
        
        
        

</source>
</class>

<class classid="76" nclones="2" nlines="83" similarity="100">
<source file="../hum_codes_raw/s134378982.java" startline="1" endline="96" pcid="4487">
import java.util.*;
public class Main {
	Scanner in = new Scanner(System.in);
	public static void main(String[] args) {
		new Main();
	}

	public Main(){
		new A().doIt();
	}
	
	class A{
		int n,m;
		int[] result;
		int zero,one;
		boolean calc(int target){
			int index = 0,num = 1;
			int c = ((target>>0)%2);
			for(int i=1;i<n;i++){
				if(c == (target>>i)%2)num++;
				else{
					if(result[m-index-1]!=num)return false;
					index++;
					num = 1;
					c = (target>>i)%2;
				}
			}
			if(result[m-index-1]!=num)return false;
			int z = 0;
			int o = 0;
			for(int i=0;i<n;i++){
				if((target>>i)%2==0)z++;
				else o++;
			}
			if(zero==z&&one==o)return true;
			return false;
		}
		
		int solve(ArrayList<Integer> kouho,char[] to){
			int result = Integer.MAX_VALUE/2;
			ArrayList<String> list = new ArrayList<String>();
			for(int i=0;i<kouho.size();i++){
				String a = "";
				for(int s=n-1;s>=0;s--)a+=((kouho.get(i)>>s)%2);
				list.add(a);
			}
//			System.out.println(list);
			
			for(int i=0;i<list.size();i++){
				int cnt = 0;
				boolean[] sw = new boolean[n];
				String target = list.get(i);
//				System.out.println(target);
				for(int s=0;s<n;s++)if(target.charAt(s)=='1'){
					for(int j=0;j<n;j++){
//						System.out.println(s+" "+j+" "+target.charAt(s)+" "+to[j]);
						if(to[j]==target.charAt(s)&&!sw[j]){
							sw[j] = true;
							cnt += Math.abs(j-s);
							break;
						}
//						System.out.println(Arrays.toString(sw));
					}
				}
				result = Math.min(cnt, result);
			}
			
			return result;
		}
		
		void doIt(){
			n = in.nextInt();
			m = in.nextInt();
			zero = 0;one = 0;
			char[] input = new char[n];
			for(int i=0;i<n;i++)input[i] = in.next().charAt(0);
			String input2 = "";
			for(int i=0;i<n;i++)input2+=input[i];
			result = new int[m];
			for(int i=0;i<m;i++)result[i] = in.nextInt();
			for(int i=0;i<n;i++){
				if(input[i]=='0')zero++;
				else one++;
			}
			ArrayList<Integer> kouho = new ArrayList<Integer>();
			for(int i=0;i<(1<<n);i++){
				if(calc(i))kouho.add(i);
			}
//			System.out.println(kouho);
//			for(int i=0;i<kouho.size();i++)System.out.println(Integer.toBinaryString(kouho.get(i)));
			System.out.println(solve(kouho,input));
		}
	}
	
}

</source>
<source file="../hum_codes_raw/s760553625.java" startline="1" endline="96" pcid="25556">
import java.util.*;
public class Main {
	Scanner in = new Scanner(System.in);
	public static void main(String[] args) {
		new Main();
	}

	public Main(){
		new A().doIt();
	}
	
	class A{
		int n,m;
		int[] result;
		int zero,one;
		boolean calc(int target){
			int index = 0,num = 1;
			int c = ((target>>0)%2);
			for(int i=1;i<n;i++){
				if(c == (target>>i)%2)num++;
				else{
					if(result[m-index-1]!=num)return false;
					index++;
					num = 1;
					c = (target>>i)%2;
				}
			}
			if(result[m-index-1]!=num)return false;
			int z = 0;
			int o = 0;
			for(int i=0;i<n;i++){
				if((target>>i)%2==0)z++;
				else o++;
			}
			if(zero==z&&one==o)return true;
			return false;
		}
		
		int solve(ArrayList<Integer> kouho,char[] to){
			int result = Integer.MAX_VALUE/2;
			ArrayList<String> list = new ArrayList<String>();
			for(int i=0;i<kouho.size();i++){
				String a = "";
				for(int s=n-1;s>=0;s--)a+=((kouho.get(i)>>s)%2);
				list.add(a);
			}
//			System.out.println(list);
			
			for(int i=0;i<list.size();i++){
				int cnt = 0;
				boolean[] sw = new boolean[n];
				String target = list.get(i);
//				System.out.println(target);
				for(int s=0;s<n;s++)if(target.charAt(s)=='1'){
					for(int j=0;j<n;j++){
//						System.out.println(s+" "+j+" "+target.charAt(s)+" "+to[j]);
						if(to[j]==target.charAt(s)&&!sw[j]){
							sw[j] = true;
							cnt += Math.abs(j-s);
							break;
						}
//						System.out.println(Arrays.toString(sw));
					}
				}
				result = Math.min(cnt, result);
			}
			
			return result;
		}
		
		void doIt(){
			n = in.nextInt();
			m = in.nextInt();
			zero = 0;one = 0;
			char[] input = new char[n];
			for(int i=0;i<n;i++)input[i] = in.next().charAt(0);
			String input2 = "";
			for(int i=0;i<n;i++)input2+=input[i];
			result = new int[m];
			for(int i=0;i<m;i++)result[i] = in.nextInt();
			for(int i=0;i<n;i++){
				if(input[i]=='0')zero++;
				else one++;
			}
			ArrayList<Integer> kouho = new ArrayList<Integer>();
			for(int i=0;i<(1<<n);i++){
				if(calc(i))kouho.add(i);
			}
//			System.out.println(kouho);
//			for(int i=0;i<kouho.size();i++)System.out.println(Integer.toBinaryString(kouho.get(i)));
			System.out.println(solve(kouho,input));
		}
	}
	
}

</source>
</class>

<class classid="77" nclones="2" nlines="56" similarity="100">
<source file="../hum_codes_raw/s135223040.java" startline="1" endline="64" pcid="4520">
import java.util.Scanner;

//Smart Calculator
public class Main {

	static char[] s;
	static int id;
	
	static int exp(){
		int r = term();
		while(true){
			char c = s[id++];
			if(c=='+')r+=term();
			else if(c=='-')r-=term();
			else break;
		}
		return r;
	}
	
	static int term(){
		int r = fact();
		while(true){
			char c = s[id++];
			if(c=='*') r*=fact();
			else if(c=='/')r/=fact();
			else break;
		}
		id--;
		return r;
	}
	
	static int fact(){
		char c = s[id++];
		if(c=='(')return exp();
		if(c=='-'){
			return -fact();
		}
		if(c=='+'){
			return fact();
		}
		int x = c-'0';
		while(true){
			c = s[id++];
			if(Character.isDigit(c)){
				x *= 10;
				x += c-'0';
			}
			else break;
		}
		id--;
		return x;
	}
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int t = sc.nextInt();
		while(t--!=0){
			s = sc.next().toCharArray();
			id = 0;
			System.out.println(exp());
		}
	}
}

</source>
<source file="../hum_codes_raw/s943957762.java" startline="1" endline="64" pcid="31732">
import java.util.Scanner;

//Smart Calculator
public class Main {

        static char[] s;
        static int id;

        static int exp(){
                int r = term();
                while(true){
                        char c = s[id++];
                        if(c=='+')r+=term();
                        else if(c=='-')r-=term();
                        else break;
                }
                return r;
        }

        static int term(){
                int r = fact();
                while(true){
                        char c = s[id++];
                        if(c=='*') r*=fact();
                        else if(c=='/')r/=fact();
                        else break;
                }
                id--;
                return r;
        }

        static int fact(){
                char c = s[id++];
                if(c=='(')return exp();
                if(c=='-'){
                        return -fact();
                }
                if(c=='+'){
                        return fact();
                }
                int x = c-'0';
                while(true){
                        c = s[id++];
                        if(Character.isDigit(c)){
                                x *= 10;
                                x += c-'0';
                        }
                        else break;
                }
                id--;
                return x;
        }

        public static void main(String[] args) {
                Scanner sc = new Scanner(System.in);
                int t = sc.nextInt();
                while(t--!=0){
                        s = sc.next().toCharArray();
                        id = 0;
                        System.out.println(exp());
                }
        }
}

</source>
</class>

<class classid="78" nclones="2" nlines="15" similarity="100">
<source file="../hum_codes_raw/s136337930.java" startline="1" endline="18" pcid="4556">
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int a = scan.nextInt();
		int b = scan.nextInt();
		int c = scan.nextInt();
		//????????????????\???
		if(a < b && b < c){ //?????????????????????????
			System.out.println("Yes");
		} else {
			System.out.println("No");
		}
	}
}

</source>
<source file="../hum_codes_raw/s227320733.java" startline="1" endline="15" pcid="7685">
import java.util.Scanner;
public class Main {
	public static void main(String[] args){
		Scanner scan=new Scanner(System.in);
		int a=scan.nextInt();
		int b=scan.nextInt();
		int c=scan.nextInt();
		if(a<b&&b<c){
			System.out.println("Yes");
		}else{
			System.out.println("No");
		}
	}
}

</source>
</class>

<class classid="79" nclones="2" nlines="51" similarity="100">
<source file="../hum_codes_raw/s136786538.java" startline="1" endline="72" pcid="4578">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Collections;
import java.util.InputMismatchException;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.StringTokenizer;

public class Main {
	
	static class Priorityqueue {
		public void priorityqueue (InputReader ir) {
			
			Queue<Integer> pq = new PriorityQueue<> (Collections.reverseOrder());;
			StringBuilder sb = new StringBuilder ();
			
			while (true) {
				
				String ord = ir.nextString();
				
				if (ord.equals("end")) break;
				
				if (ord.equals("insert")) pq.add(ir.nextInt());
				else if (ord.equals("extract")) sb.append(pq.poll()).append("\n"); 
				
			}
			
			System.out.print(sb);
			
		}
	}

	static class InputReader {
		BufferedReader br;
		StringTokenizer st;
		
		public String nextString() {
			
			 while (!st.hasMoreTokens()) {
	                try {
	                    st = new StringTokenizer(br.readLine(), " ");
	                } catch (IOException e) {
	                    throw new InputMismatchException();
	                }
	            }
			return st.nextToken();
		}
		
		public int nextInt() {
			return Integer.parseInt(nextString());
		}
					
		public InputReader (InputStream inputStream) {
			br = new BufferedReader (new InputStreamReader (inputStream));
			st = new StringTokenizer ("");
		}
		
	}
	
	public static void main (String[] args) {
		InputStream inputStream = System.in;
		InputReader in = new InputReader (inputStream);
		Priorityqueue obj = new Priorityqueue ();
		obj.priorityqueue (in);
	}
	
	
}


</source>
<source file="../hum_codes_raw/s589090521.java" startline="1" endline="72" pcid="19776">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Collections;
import java.util.InputMismatchException;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.StringTokenizer;

public class Main {
	
	static class Priorityqueue {
		public void priorityqueue (InputReader ir) {
			
			Queue<Integer> pq = new PriorityQueue<> (Collections.reverseOrder());;
			StringBuilder sb = new StringBuilder ();
			
			while (true) {
				
				String ord = ir.nextString();
				
				if (ord.equals("end")) break;
				
				if (ord.equals("insert")) pq.add(ir.nextInt());
				else if (ord.equals("extract")) sb.append(pq.poll()).append("\n"); 
				
			}
			
			System.out.print(sb);
			
		}
	}

	static class InputReader {
		BufferedReader br;
		StringTokenizer st;
		
		public String nextString() {
			
			 while (!st.hasMoreTokens()) {
	                try {
	                    st = new StringTokenizer(br.readLine(), " ");
	                } catch (IOException e) {
	                    throw new InputMismatchException();
	                }
	            }
			return st.nextToken();
		}
		
		public int nextInt() {
			return Integer.parseInt(nextString());
		}
					
		public InputReader (InputStream inputStream) {
			br = new BufferedReader (new InputStreamReader (inputStream));
			st = new StringTokenizer ("");
		}
		
	}
	
	public static void main (String[] args) {
		InputStream inputStream = System.in;
		InputReader in = new InputReader (inputStream);
		Priorityqueue obj = new Priorityqueue ();
		obj.priorityqueue (in);
	}
	
	
}


</source>
</class>

<class classid="80" nclones="2" nlines="113" similarity="100">
<source file="../hum_codes_raw/s137158279.java" startline="1" endline="151" pcid="4590">
import java.awt.Point;
import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Scanner;
import java.util.Stack;

public class Main {

	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(System.in);
		int INF = 1 << 28;
		while (true) {
			int n = sc.nextInt();
			if (n == 0)
				break;
			// }
			// 1 
			// 2 1 b1 x1 y1
			// b1
			// x1x
			// y1y
			// 3 2 b2 x2 y2
			// 
			// n+1 n bn xn yn
			Point2D.Double[] bs = new Point2D.Double[n + 1];
			for (int i = 1; i <= n; i++) {
				int b = sc.nextInt();
				int x = sc.nextInt();
				int y = sc.nextInt();
				bs[b] = new Point2D.Double(x, y);
			}
			@SuppressWarnings("unchecked")
			ArrayList<Edge> es[] = new ArrayList[n + 1];
			for (int i = 1; i <= n; i++) {
				es[i] = new ArrayList<Edge>();
				for (int j = 1; j <= n; j++) {
					if (i == j)
						continue;
//					int dis = (bs[i].x - bs[j].x) * (bs[i].x - bs[j].x)
//							+ (bs[i].y - bs[j].y) * (bs[i].y - bs[j].y);
					double dis = Math.hypot(bs[i].x-bs[j].x, bs[i].y-bs[j].y);
					if (dis <= 50)
						es[i].add(new Edge(j, dis));
				}
			}
//			for (int i = 1; i <= n; i++) {
//				System.out.print(i + " : ");
//				System.out.println(es[i]);
//			}
			int m = sc.nextInt();
			for (int i = 0; i < m; i++) {
				int prev[] = new int[n + 1];
				double d[] = new double[n + 1];
				Arrays.fill(d, INF);
				Arrays.fill(prev, -1);
				Queue<Pair> q = new PriorityQueue<Pair>();
				int s = sc.nextInt();
				d[s] = 0;
				int g = sc.nextInt();
				q.offer(new Pair(0, s));
				while (!q.isEmpty()) {
					Pair p = q.poll();
					int v = p.v;
					if (d[v] < p.d)
						continue;
					for (int j = 0; j < es[v].size(); j++) {
						Edge e = es[v].get(j);
						if (d[e.to] > d[v] + e.cost) {
							prev[e.to] = v;
							d[e.to] = d[v] + e.cost;
							q.offer(new Pair(d[e.to], e.to));
						}
					}
				}
				if (d[g] == INF) {
					System.out.println("NA");

				} else {
					boolean init = true;
					int j = g;
					Stack<String> ans = new Stack<String>();
					while (true) {
						if (init) {
							init = false;
						} else {
							ans.add(" ");
						}
						ans.add(Integer.toString(j));
						if (j == s) {
							break;
						}
						j = prev[j];
					}
					while (!ans.isEmpty()) {
						System.out.print(ans.pop());
					}
					System.out.println();
				}
			}
			// n+2 m
			// n+3 1  s1 g1
			// s1 
			// g1 
			// n+4 2  s2 g2
			// 
			// n+m+2 m  sm gm
		}
	}
}

class Edge {
	public int to;
	public double cost;

	Edge(int to, double dis) {
		this.to = to;
		this.cost = dis;
	}

	public String toString() {
		return "to: " + to + " cost: " + cost;
	}
}

class Pair implements Comparable<Pair> {
	double d;
	int v;

	Pair(double d2, int v) {
		this.d = d2;
		this.v = v;
	}

	@Override
	public int compareTo(Pair p) {
		if (d - p.d < 0)
			return -1;
		else if (d - p.d > 0)
			return 1;
		else
			return 0;
	}

	public String toString() {
		return "d : " + d + " " + "v : " + v;
	}
}

</source>
<source file="../hum_codes_raw/s723032876.java" startline="1" endline="151" pcid="24309">
import java.awt.Point;
import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Scanner;
import java.util.Stack;

public class Main {

	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(System.in);
		int INF = 1 << 28;
		while (true) {
			int n = sc.nextInt();
			if (n == 0)
				break;
			// }
			// 1 
			// 2 1 b1 x1 y1
			// b1
			// x1x
			// y1y
			// 3 2 b2 x2 y2
			// 
			// n+1 n bn xn yn
			Point2D.Double[] bs = new Point2D.Double[n + 1];
			for (int i = 1; i <= n; i++) {
				int b = sc.nextInt();
				int x = sc.nextInt();
				int y = sc.nextInt();
				bs[b] = new Point2D.Double(x, y);
			}
			@SuppressWarnings("unchecked")
			ArrayList<Edge> es[] = new ArrayList[n + 1];
			for (int i = 1; i <= n; i++) {
				es[i] = new ArrayList<Edge>();
				for (int j = 1; j <= n; j++) {
					if (i == j)
						continue;
//					int dis = (bs[i].x - bs[j].x) * (bs[i].x - bs[j].x)
//							+ (bs[i].y - bs[j].y) * (bs[i].y - bs[j].y);
					double dis = Math.hypot(bs[i].x-bs[j].x, bs[i].y-bs[j].y);
					if (dis <= 50)
						es[i].add(new Edge(j, dis));
				}
			}
//			for (int i = 1; i <= n; i++) {
//				System.out.print(i + " : ");
//				System.out.println(es[i]);
//			}
			int m = sc.nextInt();
			for (int i = 0; i < m; i++) {
				int prev[] = new int[n + 1];
				double d[] = new double[n + 1];
				Arrays.fill(d, INF);
				Arrays.fill(prev, -1);
				Queue<Pair> q = new PriorityQueue<Pair>();
				int s = sc.nextInt();
				d[s] = 0;
				int g = sc.nextInt();
				q.offer(new Pair(0, s));
				while (!q.isEmpty()) {
					Pair p = q.poll();
					int v = p.v;
					if (d[v] < p.d)
						continue;
					for (int j = 0; j < es[v].size(); j++) {
						Edge e = es[v].get(j);
						if (d[e.to] > d[v] + e.cost) {
							prev[e.to] = v;
							d[e.to] = d[v] + e.cost;
							q.offer(new Pair(d[e.to], e.to));
						}
					}
				}
				if (d[g] == INF) {
					System.out.println("NA");

				} else {
					boolean init = true;
					int j = g;
					Stack<String> ans = new Stack<String>();
					while (true) {
						if (init) {
							init = false;
						} else {
							ans.add(" ");
						}
						ans.add(Integer.toString(j));
						if (j == s) {
							break;
						}
						j = prev[j];
					}
					while (!ans.isEmpty()) {
						System.out.print(ans.pop());
					}
					System.out.println();
				}
			}
			// n+2 m
			// n+3 1  s1 g1
			// s1 
			// g1 
			// n+4 2  s2 g2
			// 
			// n+m+2 m  sm gm
		}
	}
}

class Edge {
	public int to;
	public double cost;

	Edge(int to, double dis) {
		this.to = to;
		this.cost = dis;
	}

	public String toString() {
		return "to: " + to + " cost: " + cost;
	}
}

class Pair implements Comparable<Pair> {
	double d;
	int v;

	Pair(double d2, int v) {
		this.d = d2;
		this.v = v;
	}

	@Override
	public int compareTo(Pair p) {
		if (d - p.d < 0)
			return -1;
		else if (d - p.d > 0)
			return 1;
		else
			return 0;
	}

	public String toString() {
		return "d : " + d + " " + "v : " + v;
	}
}

</source>
</class>

<class classid="81" nclones="2" nlines="22" similarity="100">
<source file="../hum_codes_raw/s137266061.java" startline="1" endline="28" pcid="4595">

import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);

		int A = sc.nextInt();
		int B = sc.nextInt();
		int C = sc.nextInt();
		int coin = 0;
		int day = 0;
		while (coin < C) {
			day++;
			coin += A;
			if (day % 7 == 0) {
				coin += B;
			}
			if (coin >= C) {
				break;
			}
		}
		System.out.println(day);
	}

}


</source>
<source file="../hum_codes_raw/s685966054.java" startline="1" endline="27" pcid="23047">
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);

		int A = sc.nextInt();
		int B = sc.nextInt();
		int C = sc.nextInt();
		int coin = 0;
		int day = 0;
		while (coin < C) {
			day++;
			coin += A;
			if (day % 7 == 0) {
				coin += B;
			}
			if (coin >= C) {
				break;
			}
		}
		System.out.println(day);
	}

}


</source>
</class>

<class classid="82" nclones="2" nlines="22" similarity="100">
<source file="../hum_codes_raw/s141112005.java" startline="1" endline="24" pcid="4706">
import java.util.Scanner;
public class Main {
	public static void main(String[] args) {
		 Scanner sc = new Scanner(System.in);
		 while(sc.hasNext()) {
			int a = sc.nextInt();
			int b = sc.nextInt();
			int c = sc.nextInt();
			int d = sc.nextInt();
			int e = sc.nextInt();
			int ans = 0;
			if(a<0) {
				ans = d + Math.abs(a)*c + b*e;
			}
			else {
				if(a==0)
					ans += d;
				ans += (b-a)*e;
			}
			System.out.println(ans);
	  }	 
	}
}

</source>
<source file="../hum_codes_raw/s967294600.java" startline="1" endline="24" pcid="32526">
import java.util.Scanner;
public class Main {
	public static void main(String[] args) {
		 Scanner sc = new Scanner(System.in);
		 while(sc.hasNext()) {
			int a = sc.nextInt();
			int b = sc.nextInt();
			int c = sc.nextInt();
			int d = sc.nextInt();
			int e = sc.nextInt();
			int ans = 0;
			if(a<0) {
				ans = d + Math.abs(a)*c + b*e;
			}
			else {
				if(a==0)
					ans += d;
				ans += (b-a)*e;
			}
			System.out.println(ans);
	  }	 
	}
}

</source>
</class>

<class classid="83" nclones="2" nlines="127" similarity="100">
<source file="../hum_codes_raw/s142354620.java" startline="1" endline="146" pcid="4766">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.Arrays;
import java.util.Scanner;
import java.util.StringTokenizer;

public class Main {

	public static class WeightedUnionFind{
	    int[] par; // 
	    int[] ws;  // 
	    
	    public WeightedUnionFind(int n){
	        par = new int[n];
	        ws  = new int[n];
	        for(int i = 0; i < n; i++){ 
	        	par[i] = -1;
	        }
	    }
	    
	    public int find(int x){
	    	if(par[x] < 0){
	    		return x;
	    	}else{
	    		final int parent = find(par[x]);
	    		ws[x] += ws[par[x]];
	    		par[x] = parent;
	    		return parent;
	    	}
	    }
	    
	    public int weight(int x){
	    	find(x);
	    	return ws[x];
	    }
	    
	    public boolean union(int x, int y, int w){ // x <-(w)- y (x + w = y)
	    	w += weight(x);
	    	w -= weight(y);
	        x = find(x);
	        y = find(y);
	        
	        if(x != y){
	            if(par[y] < par[x]) {  // .
	                int tmp = x; x = y; y = tmp;
	                w = -w;
	            }
	            par[x] += par[y];
	            par[y] = x;
	            ws[y] = w;
	            
	            return true;
	        }else{
	            return false;
	        }
	    }
	    
	    public boolean same(int x, int y){
	        return find(x) == find(y);
	    }
	    
	    public Integer diff(int x, int y){ // x - y . null.
	    	if(!same(x, y)){
	    		return null;
	    	}else{
	    		return this.weight(x) - this.weight(y);
	    	}
	    }
	    
	    public int size(int x){
	        return -par[find(x)];
	    }
	}
	
	public static void main(String[] args) throws IOException {
		Scanner sc = new Scanner(System.in);

		while(true){
			final int n = sc.nextInt();
			final int m = sc.nextInt();
			
			if(n == 0 && m == 0){
				break;
			}
			
			WeightedUnionFind uf = new WeightedUnionFind(n);
			
			for(int i = 0; i < m; i++){
				final String ops = sc.next();
				
				if("?".equals(ops)){
					final int r = sc.nextInt() - 1;
					final int l = sc.nextInt() - 1;
					
					if(!uf.same(r, l)){
						System.out.println("UNKNOWN");
					}else{
						System.out.println(uf.weight(l) - uf.weight(r));
					}
				}else{
					final int r = sc.nextInt() - 1;
					final int l = sc.nextInt() - 1;
					final int w = sc.nextInt();
					
					uf.union(r, l, w);
				}
			}
		}
		
		sc.close();
	}
	
	public static class Scanner {
	    private BufferedReader br;
	    private StringTokenizer tok;

	    public Scanner(InputStream is) throws IOException {
	        br = new BufferedReader(new InputStreamReader(is));
	    }

	    private void getLine() throws IOException {
	        while (!hasNext()) { tok = new StringTokenizer(br.readLine()); }
	    }

	    private boolean hasNext() {
	        return tok != null && tok.hasMoreTokens();
	    }

	    public String next() throws IOException {
	        getLine(); return tok.nextToken();
	    }

	    public int nextInt() throws IOException {
	        return Integer.parseInt(next());
	    }
	    // nextXXXXXX.parseXXX()
	    
	    public void close() throws IOException {
	        br.close();
	    }
	}
}

</source>
<source file="../hum_codes_raw/s519233826.java" startline="1" endline="146" pcid="17448">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.Arrays;
import java.util.Scanner;
import java.util.StringTokenizer;

public class Main {

	public static class WeightedUnionFind{
	    int[] par; // 
	    int[] ws;  // 
	    
	    public WeightedUnionFind(int n){
	        par = new int[n];
	        ws  = new int[n];
	        for(int i = 0; i < n; i++){ 
	        	par[i] = -1;
	        }
	    }
	    
	    public int find(int x){
	    	if(par[x] < 0){
	    		return x;
	    	}else{
	    		final int parent = find(par[x]);
	    		ws[x] += ws[par[x]];
	    		par[x] = parent;
	    		return parent;
	    	}
	    }
	    
	    public int weight(int x){
	    	find(x);
	    	return ws[x];
	    }
	    
	    public boolean union(int x, int y, int w){ // x <-(w)- y (x + w = y)
	    	w += weight(x);
	    	w -= weight(y);
	        x = find(x);
	        y = find(y);
	        
	        if(x != y){
	            if(par[y] < par[x]) {  // .
	                int tmp = x; x = y; y = tmp;
	                w = -w;
	            }
	            par[x] += par[y];
	            par[y] = x;
	            ws[y] = w;
	            
	            return true;
	        }else{
	            return false;
	        }
	    }
	    
	    public boolean same(int x, int y){
	        return find(x) == find(y);
	    }
	    
	    public Integer diff(int x, int y){ // x - y . null.
	    	if(!same(x, y)){
	    		return null;
	    	}else{
	    		return this.weight(x) - this.weight(y);
	    	}
	    }
	    
	    public int size(int x){
	        return -par[find(x)];
	    }
	}
	
	public static void main(String[] args) throws IOException {
		Scanner sc = new Scanner(System.in);

		while(true){
			final int n = sc.nextInt();
			final int m = sc.nextInt();
			
			if(n == 0 && m == 0){
				break;
			}
			
			WeightedUnionFind uf = new WeightedUnionFind(n);
			
			for(int i = 0; i < m; i++){
				final String ops = sc.next();
				
				if("?".equals(ops)){
					final int r = sc.nextInt() - 1;
					final int l = sc.nextInt() - 1;
					
					if(!uf.same(r, l)){
						System.out.println("UNKNOWN");
					}else{
						System.out.println(uf.weight(l) - uf.weight(r));
					}
				}else{
					final int r = sc.nextInt() - 1;
					final int l = sc.nextInt() - 1;
					final int w = sc.nextInt();
					
					uf.union(r, l, w);
				}
			}
		}
		
		sc.close();
	}
	
	public static class Scanner {
	    private BufferedReader br;
	    private StringTokenizer tok;

	    public Scanner(InputStream is) throws IOException {
	        br = new BufferedReader(new InputStreamReader(is));
	    }

	    private void getLine() throws IOException {
	        while (!hasNext()) { tok = new StringTokenizer(br.readLine()); }
	    }

	    private boolean hasNext() {
	        return tok != null && tok.hasMoreTokens();
	    }

	    public String next() throws IOException {
	        getLine(); return tok.nextToken();
	    }

	    public int nextInt() throws IOException {
	        return Integer.parseInt(next());
	    }
	    // nextXXXXXX.parseXXX()
	    
	    public void close() throws IOException {
	        br.close();
	    }
	}
}

</source>
</class>

<class classid="84" nclones="2" nlines="36" similarity="100">
<source file="../hum_codes_raw/s143124304.java" startline="1" endline="40" pcid="4790">
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		ArrayList<List<Integer>> A = new ArrayList<>();
		for (int i = 0; i < n; i++) {
			ArrayList<Integer> B = new ArrayList<>();
			A.add(B);
		}
		int q = sc.nextInt();
		for (int i = 0; i < q; i++) {
			int x = sc.nextInt();
			if (x == 0) {
				int y = sc.nextInt();
				int z = sc.nextInt();
				A.get(y).add(z);
			} else if (x == 1) {
				int y = sc.nextInt();
				if (A.get(y).size() != 0) {
					System.out.println(A.get(y).get(A.get(y).size() - 1));
				}
			} else if (x == 2) {
				int y = sc.nextInt();
				if (A.get(y).size() != 0) {
					A.get(y).remove(A.get(y).size() - 1);
				}
			}
		}
		sc.close();

	}

}



</source>
<source file="../hum_codes_raw/s724292859.java" startline="1" endline="46" pcid="24362">


import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);

		int n = sc.nextInt();
		ArrayList<List<Integer>> A = new ArrayList<>();
		for (int i = 0; i < n; i++) {
			ArrayList<Integer> B = new ArrayList<>();
			A.add(B);
		}
		int q = sc.nextInt();

		for (int i = 0; i < q; i++) {
			int x = sc.nextInt();
			if (x == 0) {
				int y = sc.nextInt();
				int z = sc.nextInt();
				A.get(y).add(z);

			} else if (x == 1) {
				int y = sc.nextInt();
				if (A.get(y).size() != 0) {
					System.out.println(A.get(y).get(A.get(y).size() - 1));
				}

			} else if (x == 2) {
				int y = sc.nextInt();
				if (A.get(y).size() != 0) {
					A.get(y).remove(A.get(y).size() - 1);
				}
			}
		}
		sc.close();

	}

}


</source>
</class>

<class classid="85" nclones="2" nlines="21" similarity="100">
<source file="../hum_codes_raw/s145256498.java" startline="1" endline="26" pcid="4868">
import java.util.Scanner;

class Main {
	public static void main(String[] args) {
		try (Scanner sc = new Scanner (System.in)){
			int n = sc.nextInt();
			long[] array = new long[n];
			for (int i=0; i<n; i++) array[i] = sc.nextLong();
			int times = sc.nextInt();  //query
			for (int i=0; i<times; i++) {
				int start = sc.nextInt();
				int end = sc.nextInt();
				int target = sc.nextInt();
				//count(start,end,target)
				int count = 0;
				for (int j=start; j<end; j++) {
					if (array[j] == target) count++;
				}
				System.out.println(count);
			}
		}
	}
}



</source>
<source file="../hum_codes_raw/s190641646.java" startline="1" endline="25" pcid="6426">
import java.util.Scanner;

class Main {
	public static void main(String[] args) {
		try (Scanner sc = new Scanner (System.in)){
			int n = sc.nextInt();
			long[] array = new long[n];
			for (int i=0; i<n; i++) array[i] = sc.nextLong();
			int times = sc.nextInt();  //query
			for (int i=0; i<times; i++) {
				int start = sc.nextInt();
				int end = sc.nextInt();
				int target = sc.nextInt();
				//count(start,end,target)
				int count = 0;
				for (int j=start; j<end; j++) {
					if (array[j] == target) count++;
				}
				System.out.println(count);
			}
		}
	}
}


</source>
</class>

<class classid="86" nclones="2" nlines="33" similarity="100">
<source file="../hum_codes_raw/s146622168.java" startline="1" endline="40" pcid="4901">
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int N = sc.nextInt();
        int A = sc.nextInt();
        int[] x = new int[N + 1];
        for (int i = 1; i <= N; ++i) {
            x[i] = sc.nextInt();
        }

        long[][][] dp = new long[N + 1][N + 1][N * A + 1];
        for (int i = 0; i < N; ++i) {
            dp[i][0][0] = 1;
        }

        for (int i = 1; i <= N; ++i) {
            for (int j = 1; j <= i; ++j) {
                for (int k = 1; k <= N * A; ++k) {
                    if (k < x[i]) {
                        dp[i][j][k] = dp[i - 1][j][k];
                    } else {
                        dp[i][j][k] = dp[i - 1][j][k] + dp[i - 1][j - 1][k - x[i]];
                    }
                }
            }
        }

        long ans = 0;
        for (int j = 1; j <= N; ++j) {
            ans += dp[N][j][j * A];
        }

        System.out.println(ans);

    }
}

</source>
<source file="../hum_codes_raw/s413840969.java" startline="1" endline="39" pcid="13913">
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int N = sc.nextInt();
        int A = sc.nextInt();
        int[] x = new int[N + 1];
        for (int i = 1; i <= N; ++i) {
            x[i] = sc.nextInt();
        }

        long[][][] dp = new long[N + 1][N + 1][N * A + 1];
        for (int i = 0; i < N; ++i) {
            dp[i][0][0] = 1;
        }

        for (int i = 1; i <= N; ++i) {
            for (int j = 1; j <= i; ++j) {
                for (int k = 1; k <= N * A; ++k) {
                    if (k < x[i]) {
                        dp[i][j][k] = dp[i - 1][j][k];
                    } else {
                        dp[i][j][k] = dp[i - 1][j][k] + dp[i - 1][j - 1][k - x[i]];
                    }
                }
            }
        }

        long ans = 0;
        for (int j = 1; j <= N; ++j) {
            ans += dp[N][j][j * A];
        }

        System.out.println(ans);
    }
}

</source>
</class>

<class classid="87" nclones="3" nlines="52" similarity="100">
<source file="../hum_codes_raw/s147924630.java" startline="1" endline="64" pcid="4943">
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int n = sc.nextInt();
			if(n == 0){
				break;
			}
			int[][] students = new int[n][n];
			int[][] x = new int[n][n];
			for(int i = 0; i < n; i++){
				for(int j = 0; j < n; j++){
					students[i][j] = sc.nextInt();
				}
			}
			
			for(int i = 0; i < n; i++){
				int columnMax = -1;
				for(int j = 0; j < n; j++){
					if(columnMax < students[j][i])
						columnMax = students[j][i];
				}
				for(int j = 0; j < n; j++){
					if(columnMax == students[j][i])
						x[j][i] |= 2;
				}
			}
			for(int i = 0; i < n; i++){
				int rowMin = Integer.MAX_VALUE;
				for(int j = 0; j < n; j++){
					if(rowMin > students[i][j])
						rowMin = students[i][j];
				}
				for(int j = 0; j < n; j++){
					if(rowMin == students[i][j])
						x[i][j] |= 1;
				}
			}
			
			Set<Integer> both = new HashSet<Integer>();
            for(int i = 0;i < n;i++)
                for(int j = 0;j < n;j++)
                    if(x[i][j] == 3)
                        both.add(students[i][j]);
			
            if(both.size() == 1){
            	StringBuilder sb = new StringBuilder();
                for(int v : both){
                    sb.append(v + " ");
                }
                sb.deleteCharAt(sb.length() - 1);
                System.out.println(sb);
            }else{
            	System.out.println(0);
            }
		}
	}
}

</source>
<source file="../hum_codes_raw/s650556080.java" startline="1" endline="64" pcid="21836">
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int n = sc.nextInt();
			if(n == 0){
				break;
			}
			int[][] students = new int[n][n];
			int[][] x = new int[n][n];
			for(int i = 0; i < n; i++){
				for(int j = 0; j < n; j++){
					students[i][j] = sc.nextInt();
				}
			}
			
			for(int i = 0; i < n; i++){
				int columnMax = -1;
				for(int j = 0; j < n; j++){
					if(columnMax < students[j][i])
						columnMax = students[j][i];
				}
				for(int j = 0; j < n; j++){
					if(columnMax == students[j][i])
						x[j][i] |= 2;
				}
			}
			for(int i = 0; i < n; i++){
				int rowMin = Integer.MAX_VALUE;
				for(int j = 0; j < n; j++){
					if(rowMin > students[i][j])
						rowMin = students[i][j];
				}
				for(int j = 0; j < n; j++){
					if(rowMin == students[i][j])
						x[i][j] |= 1;
				}
			}
			
			Set<Integer> both = new HashSet<Integer>();
            for(int i = 0;i < n;i++)
                for(int j = 0;j < n;j++)
                    if(x[i][j] == 3)
                        both.add(students[i][j]);
			
            if(both.size() == 1){
            	StringBuilder sb = new StringBuilder();
                for(int v : both){
                    sb.append(v + " ");
                }
                sb.deleteCharAt(sb.length() - 1);
                System.out.println(sb);
            }else{
            	System.out.println(0);
            }
		}
	}
}

</source>
<source file="../hum_codes_raw/s673267797.java" startline="1" endline="64" pcid="22618">
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int n = sc.nextInt();
			if(n == 0){
				break;
			}
			int[][] students = new int[n][n];
			int[][] x = new int[n][n];
			for(int i = 0; i < n; i++){
				for(int j = 0; j < n; j++){
					students[i][j] = sc.nextInt();
				}
			}
			
			for(int i = 0; i < n; i++){
				int columnMax = -1;
				for(int j = 0; j < n; j++){
					if(columnMax < students[j][i])
						columnMax = students[j][i];
				}
				for(int j = 0; j < n; j++){
					if(columnMax == students[j][i])
						x[j][i] |= 2;
				}
			}
			for(int i = 0; i < n; i++){
				int rowMin = Integer.MAX_VALUE;
				for(int j = 0; j < n; j++){
					if(rowMin > students[i][j])
						rowMin = students[i][j];
				}
				for(int j = 0; j < n; j++){
					if(rowMin == students[i][j])
						x[i][j] |= 1;
				}
			}
			
			Set<Integer> both = new HashSet<Integer>();
            for(int i = 0;i < n;i++)
                for(int j = 0;j < n;j++)
                    if(x[i][j] == 3)
                        both.add(students[i][j]);
			
            if(both.size() == 1){
            	StringBuilder sb = new StringBuilder();
                for(int v : both){
                    sb.append(v + " ");
                }
                sb.deleteCharAt(sb.length() - 1);
                System.out.println(sb);
            }else{
            	System.out.println(0);
            }
		}
	}
}

</source>
</class>

<class classid="88" nclones="3" nlines="121" similarity="100">
<source file="../hum_codes_raw/s148459095.java" startline="1" endline="183" pcid="4956">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

/**
 * 
 * @author DemonSong
 * 
 *         2170.Marked Ancestor
 * 
 *         Problem F: Marked Ancestor You are given a tree T that consists of N
 *         nodes. Each node is numbered from 1 to N, and node 1 is always the
 *         root node of T. Consider the following two operations on T:
 * 
 *         M v: (Mark) Mark node v. Q v: (Query) Print the index of the nearest
 *         marked ancestor of node v which is nearest to it. Initially, only the
 *         root node is marked. Your job is to write a program that performs a
 *         sequence of these operations on a given tree and calculates the value
 *         that each Q operation will print. To avoid too large output file,
 *         your program is requested to print the sum of the outputs of all
 *         query operations. Note that the judges confirmed that it is possible
 *         to calculate every output of query operations in a given sequence.
 * 
 *         Input The input consists of multiple datasets. Each dataset has the
 *         following format:
 * 
 *         The first line of the input contains two integers N and Q, which
 *         denotes the number of nodes in the tree T and the number of
 *         operations, respectively. These numbers meet the following
 *         conditions: 1 ??? N ??? 100000 and 1 ??? Q ??? 100000.
 * 
 *         The following N - 1 lines describe the configuration of the tree T.
 *         Each line contains a single integer pi (i = 2, ... , N), which
 *         represents the index of the parent of i-th node.
 * 
 *         The next Q lines contain operations in order. Each operation is
 *         formatted as "M v" or "Q v", where v is the index of a node.
 * 
 *         The last dataset is followed by a line containing two zeros. This
 *         line is not a part of any dataset and should not be processed.
 * 
 *         Output For each dataset, print the sum of the outputs of all query
 *         operations in one line.
 * 
 *         Sample Input 6 3 1 1 2 3 3 Q 5 M 3 Q 5 0 0 Output for the Sample
 *         Input 4
 *
 */
public class Main{
	
	static class Union{
		int[] id;
		int[] sz;
		
		public Union(int size){
			id = new int[size];
			sz = new int[size];
			for (int i = 0; i < size; ++i){
				id[i] = i;
				sz[i] = 1;
			}
		}
		
		public int find(int i){
			while(id[i] != i){
				i = id[i];
			}
			return i;
		}
		
		public boolean same(int i, int j){
			return find(i) == find(j);
		}
		
		public void union(int i, int j){
			int p = find(i);
			int q = find(j);
			
			if (p == q) return;
			
			if (sz[p] < sz[q]){
				id[p] = q;
				sz[q] += sz[p];
			}
			else{
				id[q] = p;
				sz[p] += sz[q];
			}
		}
	}
	
	public static void main(String[] args) throws IOException {
		Scanner in = new Scanner(System.in);
		while (true){
			int N = in.nextInt();
			int Q = in.nextInt();
			if (N == 0 && Q == 0) break;
			
			int[] id = new int[N];
			for (int i = 1; i < N; ++i){
				int p = in.nextInt() - 1;
				id[i] = p;
			}
			
			long sum = 0;
			for (int i = 0; i < Q; ++i){
				String opera = in.next();
				int c = in.nextInt() - 1;
				if (opera.equals("Q")){
					while (c != id[c]){
						c = id[c];
					}
					sum += (c + 1);
				}
				else{
					id[c] = c;
				}
			}
			System.out.println(sum);
		}
		
	}
	
	static class Scanner {

		private BufferedReader br;
		private StringTokenizer tok;

		public Scanner(InputStream is) throws IOException {
			br = new BufferedReader(new InputStreamReader(is));
			getLine();
		}

		private void getLine() throws IOException {
			while (tok == null || !tok.hasMoreTokens()) {
				tok = new StringTokenizer(br.readLine());
			}
		}

		private boolean hasNext() {
			return tok.hasMoreTokens();
		}

		public String next() throws IOException {
			if (hasNext()) {
				return tok.nextToken();
			} else {
				getLine();
				return tok.nextToken();
			}
		}

		public int nextInt() throws IOException {
			if (hasNext()) {
				return Integer.parseInt(tok.nextToken());
			} else {
				getLine();
				return Integer.parseInt(tok.nextToken());
			}
		}

		public long nextLong() throws IOException {
			if (hasNext()) {
				return Long.parseLong(tok.nextToken());
			} else {
				getLine();
				return Long.parseLong(tok.nextToken());
			}
		}

		public double nextDouble() throws IOException {
			if (hasNext()) {
				return Double.parseDouble(tok.nextToken());
			} else {
				getLine();
				return Double.parseDouble(tok.nextToken());
			}
		}
	}
}

</source>
<source file="../hum_codes_raw/s951882746.java" startline="1" endline="183" pcid="31973">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

/**
 * 
 * @author DemonSong
 * 
 *         2170.Marked Ancestor
 * 
 *         Problem F: Marked Ancestor You are given a tree T that consists of N
 *         nodes. Each node is numbered from 1 to N, and node 1 is always the
 *         root node of T. Consider the following two operations on T:
 * 
 *         M v: (Mark) Mark node v. Q v: (Query) Print the index of the nearest
 *         marked ancestor of node v which is nearest to it. Initially, only the
 *         root node is marked. Your job is to write a program that performs a
 *         sequence of these operations on a given tree and calculates the value
 *         that each Q operation will print. To avoid too large output file,
 *         your program is requested to print the sum of the outputs of all
 *         query operations. Note that the judges confirmed that it is possible
 *         to calculate every output of query operations in a given sequence.
 * 
 *         Input The input consists of multiple datasets. Each dataset has the
 *         following format:
 * 
 *         The first line of the input contains two integers N and Q, which
 *         denotes the number of nodes in the tree T and the number of
 *         operations, respectively. These numbers meet the following
 *         conditions: 1 ??? N ??? 100000 and 1 ??? Q ??? 100000.
 * 
 *         The following N - 1 lines describe the configuration of the tree T.
 *         Each line contains a single integer pi (i = 2, ... , N), which
 *         represents the index of the parent of i-th node.
 * 
 *         The next Q lines contain operations in order. Each operation is
 *         formatted as "M v" or "Q v", where v is the index of a node.
 * 
 *         The last dataset is followed by a line containing two zeros. This
 *         line is not a part of any dataset and should not be processed.
 * 
 *         Output For each dataset, print the sum of the outputs of all query
 *         operations in one line.
 * 
 *         Sample Input 6 3 1 1 2 3 3 Q 5 M 3 Q 5 0 0 Output for the Sample
 *         Input 4
 *
 */
public class Main{
	
	static class Union{
		int[] id;
		int[] sz;
		
		public Union(int size){
			id = new int[size];
			sz = new int[size];
			for (int i = 0; i < size; ++i){
				id[i] = i;
				sz[i] = 1;
			}
		}
		
		public int find(int i){
			while(id[i] != i){
				i = id[i];
			}
			return i;
		}
		
		public boolean same(int i, int j){
			return find(i) == find(j);
		}
		
		public void union(int i, int j){
			int p = find(i);
			int q = find(j);
			
			if (p == q) return;
			
			if (sz[p] < sz[q]){
				id[p] = q;
				sz[q] += sz[p];
			}
			else{
				id[q] = p;
				sz[p] += sz[q];
			}
		}
	}
	
	public static void main(String[] args) throws IOException {
		Scanner in = new Scanner(System.in);
		while (true){
			int N = in.nextInt();
			int Q = in.nextInt();
			if (N == 0 && Q == 0) break;
			
			int[] id = new int[N];
			for (int i = 1; i < N; ++i){
				int p = in.nextInt() - 1;
				id[i] = p;
			}
			
			long sum = 0;
			for (int i = 0; i < Q; ++i){
				String opera = in.next();
				int c = in.nextInt() - 1;
				if (opera.equals("Q")){
					while (c != id[c]){
						c = id[c];
					}
					sum += (c + 1);
				}
				else{
					id[c] = c;
				}
			}
			System.out.println(sum);
		}
		
	}
	
	static class Scanner {

		private BufferedReader br;
		private StringTokenizer tok;

		public Scanner(InputStream is) throws IOException {
			br = new BufferedReader(new InputStreamReader(is));
			getLine();
		}

		private void getLine() throws IOException {
			while (tok == null || !tok.hasMoreTokens()) {
				tok = new StringTokenizer(br.readLine());
			}
		}

		private boolean hasNext() {
			return tok.hasMoreTokens();
		}

		public String next() throws IOException {
			if (hasNext()) {
				return tok.nextToken();
			} else {
				getLine();
				return tok.nextToken();
			}
		}

		public int nextInt() throws IOException {
			if (hasNext()) {
				return Integer.parseInt(tok.nextToken());
			} else {
				getLine();
				return Integer.parseInt(tok.nextToken());
			}
		}

		public long nextLong() throws IOException {
			if (hasNext()) {
				return Long.parseLong(tok.nextToken());
			} else {
				getLine();
				return Long.parseLong(tok.nextToken());
			}
		}

		public double nextDouble() throws IOException {
			if (hasNext()) {
				return Double.parseDouble(tok.nextToken());
			} else {
				getLine();
				return Double.parseDouble(tok.nextToken());
			}
		}
	}
}

</source>
<source file="../hum_codes_raw/s258318295.java" startline="1" endline="184" pcid="8680">

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

/**
 * 
 * @author DemonSong
 * 
 *         2170.Marked Ancestor
 * 
 *         Problem F: Marked Ancestor You are given a tree T that consists of N
 *         nodes. Each node is numbered from 1 to N, and node 1 is always the
 *         root node of T. Consider the following two operations on T:
 * 
 *         M v: (Mark) Mark node v. Q v: (Query) Print the index of the nearest
 *         marked ancestor of node v which is nearest to it. Initially, only the
 *         root node is marked. Your job is to write a program that performs a
 *         sequence of these operations on a given tree and calculates the value
 *         that each Q operation will print. To avoid too large output file,
 *         your program is requested to print the sum of the outputs of all
 *         query operations. Note that the judges confirmed that it is possible
 *         to calculate every output of query operations in a given sequence.
 * 
 *         Input The input consists of multiple datasets. Each dataset has the
 *         following format:
 * 
 *         The first line of the input contains two integers N and Q, which
 *         denotes the number of nodes in the tree T and the number of
 *         operations, respectively. These numbers meet the following
 *         conditions: 1 ??? N ??? 100000 and 1 ??? Q ??? 100000.
 * 
 *         The following N - 1 lines describe the configuration of the tree T.
 *         Each line contains a single integer pi (i = 2, ... , N), which
 *         represents the index of the parent of i-th node.
 * 
 *         The next Q lines contain operations in order. Each operation is
 *         formatted as "M v" or "Q v", where v is the index of a node.
 * 
 *         The last dataset is followed by a line containing two zeros. This
 *         line is not a part of any dataset and should not be processed.
 * 
 *         Output For each dataset, print the sum of the outputs of all query
 *         operations in one line.
 * 
 *         Sample Input 6 3 1 1 2 3 3 Q 5 M 3 Q 5 0 0 Output for the Sample
 *         Input 4
 *
 */
public class Main{
	
	static class Union{
		int[] id;
		int[] sz;
		
		public Union(int size){
			id = new int[size];
			sz = new int[size];
			for (int i = 0; i < size; ++i){
				id[i] = i;
				sz[i] = 1;
			}
		}
		
		public int find(int i){
			while(id[i] != i){
				i = id[i];
			}
			return i;
		}
		
		public boolean same(int i, int j){
			return find(i) == find(j);
		}
		
		public void union(int i, int j){
			int p = find(i);
			int q = find(j);
			
			if (p == q) return;
			
			if (sz[p] < sz[q]){
				id[p] = q;
				sz[q] += sz[p];
			}
			else{
				id[q] = p;
				sz[p] += sz[q];
			}
		}
	}
	
	public static void main(String[] args) throws IOException {
		Scanner in = new Scanner(System.in);
		while (true){
			int N = in.nextInt();
			int Q = in.nextInt();
			if (N == 0 && Q == 0) break;
			
			int[] id = new int[N];
			for (int i = 1; i < N; ++i){
				int p = in.nextInt() - 1;
				id[i] = p;
			}
			
			long sum = 0;
			for (int i = 0; i < Q; ++i){
				String opera = in.next();
				int c = in.nextInt() - 1;
				if (opera.equals("Q")){
					while (c != id[c]){
						c = id[c];
					}
					sum += (c + 1);
				}
				else{
					id[c] = c;
				}
			}
			System.out.println(sum);
		}
		
	}
	
	static class Scanner {

		private BufferedReader br;
		private StringTokenizer tok;

		public Scanner(InputStream is) throws IOException {
			br = new BufferedReader(new InputStreamReader(is));
			getLine();
		}

		private void getLine() throws IOException {
			while (tok == null || !tok.hasMoreTokens()) {
				tok = new StringTokenizer(br.readLine());
			}
		}

		private boolean hasNext() {
			return tok.hasMoreTokens();
		}

		public String next() throws IOException {
			if (hasNext()) {
				return tok.nextToken();
			} else {
				getLine();
				return tok.nextToken();
			}
		}

		public int nextInt() throws IOException {
			if (hasNext()) {
				return Integer.parseInt(tok.nextToken());
			} else {
				getLine();
				return Integer.parseInt(tok.nextToken());
			}
		}

		public long nextLong() throws IOException {
			if (hasNext()) {
				return Long.parseLong(tok.nextToken());
			} else {
				getLine();
				return Long.parseLong(tok.nextToken());
			}
		}

		public double nextDouble() throws IOException {
			if (hasNext()) {
				return Double.parseDouble(tok.nextToken());
			} else {
				getLine();
				return Double.parseDouble(tok.nextToken());
			}
		}
	}
}

</source>
</class>

<class classid="89" nclones="2" nlines="26" similarity="100">
<source file="../hum_codes_raw/s150255228.java" startline="1" endline="33" pcid="5021">
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;

class Main{
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        int n = Integer.parseInt(br.readLine());
        String[] input = br.readLine().split(" ");

        int max = 0;
        boolean onCheck = false;
        int cl = 1; // current length

        for(String x : input){
            if(x.equals("1")){
                cl++;
                onCheck = true;
            }else if(onCheck){
                max = Math.max(cl,max);
                cl = 1;
                onCheck = false;
            }
        }

        max = Math.max(cl,max);

        System.out.println(max);
    }
}


</source>
<source file="../hum_codes_raw/s836953497.java" startline="1" endline="32" pcid="28096">
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;

class Main{
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        int n = Integer.parseInt(br.readLine());
        String[] input = br.readLine().split(" ");

        int max = 0;
        boolean onCheck = false;
        int cl = 1; // current length

        for(String x : input){
            if(x.equals("1")){
                cl++;
                onCheck = true;
            }else if(onCheck){
                max = Math.max(cl,max);
                cl = 1;
                onCheck = false;
            }
        }

        max = Math.max(cl,max);

        System.out.println(max);
    }
}

</source>
</class>

<class classid="90" nclones="2" nlines="113" similarity="100">
<source file="../hum_codes_raw/s153560595.java" startline="1" endline="143" pcid="5149">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.PriorityQueue;
import java.util.Queue;

public class Main {

  public static void main(String[] args) {
    
    new Main().run();
  }

  public void run() {

    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      int n = Integer.parseInt(br.readLine());
      Graph graph = new Graph(n);
      String[] vInfo;
      int id,degree,key,val;
      IntTuple[] ajacent;

      for(int i=0; i<n; i++) {
        vInfo = br.readLine().split(" ");
        id     = Integer.parseInt(vInfo[0]);
        degree = Integer.parseInt(vInfo[1]);
        ajacent = new IntTuple[degree];
        for (int j=0,k=2; j<degree; j++) {
          key = Integer.parseInt(vInfo[k++]);
          val = Integer.parseInt(vInfo[k++]);
          ajacent[j] = new IntTuple(key, val);
        }
        graph.setVertex(id, ajacent);
      }

      graph.calcSSSPWeightSum();

      StringBuilder buf = new StringBuilder();
      for (Vertex v : graph.vertices) {
        buf.append(v.id).append(" ").append(v.minPathCost)
           .append("\n");
      }
      System.out.print(buf);
    }
    catch (IOException e) {
      System.err.println(e);
    }
  }


  class Graph {

    Vertex[] vertices;
    Queue<IntTuple> queue;

    public Graph(int size ) {
      vertices  = new Vertex[size];
      queue = new PriorityQueue<>(size);
    }

    public void setVertex(int id) {
      vertices[id] = new Vertex(id);
    }
    public void setVertex(int id, IntTuple[] ajacent) {
      setVertex(id);
      setAjacent(id, ajacent);
    }
    public void setAjacent(int id, IntTuple[] ajasent) {
      vertices[id].ajacent = ajasent;
    }

    public void calcSSSPWeightSum() {
      algorithmDijkstra(0);
    }

    private void algorithmDijkstra(int s) {
      vertices[s].minPathCost = 0;
      Vertex current,next;
      queue.offer(new IntTuple(vertices[s].id, vertices[s].minPathCost));
      vertices[s].state = Vertex.GRAY;

      IntTuple v;
      while( (v = queue.poll()) != null ) {
        vertices[v.key].state = Vertex.BLACK;

        if(vertices[v.key].minPathCost < v.val) continue;
        
        current = vertices[v.key];
        for (IntTuple w: current.ajacent) {
          next = vertices[w.key];
          if( (next.state != Vertex.BLACK) &&
              (current.minPathCost + w.val < next.minPathCost) ) {
            next.minPathCost = current.minPathCost + w.val;
            queue.offer(new IntTuple(next.id, next.minPathCost));
            next.state = Vertex.GRAY;
          }
        }
        continue;
      }
    }
  }

  class Vertex {

    static final int NILL  =-1;
    static final int WHITE = 0;
    static final int GRAY  = 1;
    static final int BLACK = 2;
    int id;
    int state;
    int minPathCost;
    IntTuple[] ajacent;

    public Vertex(int id) {
      this.id = id;
      state = WHITE;
      minPathCost = Integer.MAX_VALUE;
    }
  }

  class IntTuple implements Comparable<IntTuple> {
    public int key;
    public int val;

    public IntTuple(int key, int val) {
      this.key = key;
      this.val = val;
    }

    @Override
    public String toString() {
      return "[" + key + "," + val + "]";
    }
    @Override
    public int compareTo(IntTuple obj) {
      if(this.val == obj.val) return 0;

      return this.val > obj.val ? 1 : -1;
    }
  }
}

</source>
<source file="../hum_codes_raw/s739900039.java" startline="1" endline="143" pcid="24856">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.PriorityQueue;
import java.util.Queue;

public class Main {

  public static void main(String[] args) {
    
    new Main().run();
  }

  public void run() {

    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      int n = Integer.parseInt(br.readLine());
      Graph graph = new Graph(n);
      String[] vInfo;
      int id,degree,key,val;
      IntTuple[] ajacent;

      for(int i=0; i<n; i++) {
        vInfo = br.readLine().split(" ");
        id     = Integer.parseInt(vInfo[0]);
        degree = Integer.parseInt(vInfo[1]);
        ajacent = new IntTuple[degree];
        for (int j=0,k=2; j<degree; j++) {
          key = Integer.parseInt(vInfo[k++]);
          val = Integer.parseInt(vInfo[k++]);
          ajacent[j] = new IntTuple(key, val);
        }
        graph.setVertex(id, ajacent);
      }

      graph.calcSSSPWeightSum();

      StringBuilder buf = new StringBuilder();
      for (Vertex v : graph.vertices) {
        buf.append(v.id).append(" ").append(v.minPathCost)
           .append("\n");
      }
      System.out.print(buf);
    }
    catch (IOException e) {
      System.err.println(e);
    }
  }


  class Graph {

    Vertex[] vertices;
    Queue<IntTuple> queue;

    public Graph(int size ) {
      vertices  = new Vertex[size];
      queue = new PriorityQueue<>(size);
    }

    public void setVertex(int id) {
      vertices[id] = new Vertex(id);
    }
    public void setVertex(int id, IntTuple[] ajacent) {
      setVertex(id);
      setAjacent(id, ajacent);
    }
    public void setAjacent(int id, IntTuple[] ajasent) {
      vertices[id].ajacent = ajasent;
    }

    public void calcSSSPWeightSum() {
      algorithmDijkstra(0);
    }

    private void algorithmDijkstra(int s) {
      vertices[s].minPathCost = 0;
      Vertex current,next;
      queue.offer(new IntTuple(vertices[s].id, vertices[s].minPathCost));
      vertices[s].state = Vertex.GRAY;

      IntTuple v;
      while( (v = queue.poll()) != null ) {
        vertices[v.key].state = Vertex.BLACK;

        if(vertices[v.key].minPathCost < v.val) continue;
        
        current = vertices[v.key];
        for (IntTuple w: current.ajacent) {
          next = vertices[w.key];
          if( (next.state != Vertex.BLACK) &&
              (current.minPathCost + w.val < next.minPathCost) ) {
            next.minPathCost = current.minPathCost + w.val;
            queue.offer(new IntTuple(next.id, next.minPathCost));
            next.state = Vertex.GRAY;
          }
        }
        continue;
      }
    }
  }

  class Vertex {

    static final int NILL  =-1;
    static final int WHITE = 0;
    static final int GRAY  = 1;
    static final int BLACK = 2;
    int id;
    int state;
    int minPathCost;
    IntTuple[] ajacent;

    public Vertex(int id) {
      this.id = id;
      state = WHITE;
      minPathCost = Integer.MAX_VALUE;
    }
  }

  class IntTuple implements Comparable<IntTuple> {
    public int key;
    public int val;

    public IntTuple(int key, int val) {
      this.key = key;
      this.val = val;
    }

    @Override
    public String toString() {
      return "[" + key + "," + val + "]";
    }
    @Override
    public int compareTo(IntTuple obj) {
      if(this.val == obj.val) return 0;

      return this.val > obj.val ? 1 : -1;
    }
  }
}

</source>
</class>

<class classid="91" nclones="3" nlines="38" similarity="100">
<source file="../hum_codes_raw/s154166749.java" startline="1" endline="41" pcid="5164">
import java.util.Scanner;
 
public class Main {
    public static void main(String[] args) {
        try(Scanner sc = new Scanner(System.in)){
        	while(true) {
        		int m = sc.nextInt();
        		int n = sc.nextInt();
        		if(m==0 && n==0) break;
        		int w [] = new int[n];
        		int sum = 0;
        		int max = 0;
        		for(int i=0;i<n;i++) {
        			w[i] = sc.nextInt();
        			sum += w[i];
        			max = Math.max(w[i], max);
        		}
        		max = Math.max(max, sum/m);
        		
        		for(int i=max;;i++) {
        			sum = 0;
        			int count = 0;
        			for(int j=0;j<n;j++) {
        				sum += w[j];
        				if(sum>i) {
        					j--;
        					count++;
        					sum = 0;
        				}
        				if(count==m) break;
        			}
        			if(count<m) {
        			System.out.println(i);
        			break;
        			}
        		}
        	}	
        }
    }
}

</source>
<source file="../hum_codes_raw/s660414641.java" startline="1" endline="42" pcid="22175">
import java.util.Scanner;
 
public class Main {
    public static void main(String[] args) {
        try(Scanner sc = new Scanner(System.in)){
        	while(true) {
        		int m = sc.nextInt();
        		int n = sc.nextInt();
        		if(m==0 && n==0) break;
        		int w [] = new int[n];
        		int sum = 0;
        		int max = 0;
        		for(int i=0;i<n;i++) {
        			w[i] = sc.nextInt();
        			sum += w[i];
        			max = Math.max(w[i], max);
        		}
        		max = Math.max(max, sum/m);
        		
        		for(int i=max;;i++) {
        			sum = 0;
        			int count = 0;
        			for(int j=0;j<n;j++) {
        				sum += w[j];
        				if(sum>i) {
        					j--;
        					count++;
        					sum = 0;
        				}
        				if(count==m) break;
        			}
        			if(count<m) {
        			System.out.println(i);
        			break;
        			}
        		}
        	}	
        }
    }
}


</source>
<source file="../hum_codes_raw/s766888933.java" startline="1" endline="42" pcid="25755">
import java.util.Scanner;
 
public class Main {
    public static void main(String[] args) {
        try(Scanner sc = new Scanner(System.in)){
        	while(true) {
        		int m = sc.nextInt();
        		int n = sc.nextInt();
        		if(m==0 && n==0) break;
        		int w [] = new int[n];
        		int sum = 0;
        		int max = 0;
        		for(int i=0;i<n;i++) {
        			w[i] = sc.nextInt();
        			sum += w[i];
        			max = Math.max(w[i], max);
        		}
        		max = Math.max(max, sum/m);
        		
        		for(int i=max;;i++) {
        			sum = 0;
        			int count = 0;
        			for(int j=0;j<n;j++) {
        				sum += w[j];
        				if(sum>i) {
        					j--;
        					count++;
        					sum = 0;
        				}
        				if(count==m) break;
        			}
        			if(count<m) {
        			System.out.println(i);
        			break;
        			}
        		}
        	}	
        }
    }
}


</source>
</class>

<class classid="92" nclones="2" nlines="19" similarity="100">
<source file="../hum_codes_raw/s156731543.java" startline="1" endline="23" pcid="5256">
import java.util.Scanner;

//Patrol
public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(sc.hasNext()){
			int[] a = new int[101];
			while(true){
				int s = sc.nextInt();
				int t = sc.nextInt();
				if((s|t)==0)break;
				a[s]++;
				a[t]++;
			}
			int o = 0;
			for(int s:a)if(s%2==1)o++;
			System.out.println(o!=2?"NG":a[1]%2==1&&a[2]%2==1?"OK":"NG");
		}
	}
}

</source>
<source file="../hum_codes_raw/s277078962.java" startline="1" endline="23" pcid="9270">
import java.util.Scanner;

//Patrol
public class Main{

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(sc.hasNext()){
			int[] a = new int[101];
			while(true){
				int s = sc.nextInt();
				int t = sc.nextInt();
				if((s|t)==0)break;
				a[s]++;
				a[t]++;
			}
			int o = 0;
			for(int s:a)if(s%2==1)o++;
			System.out.println(o!=2?"NG":a[1]%2==1&&a[2]%2==1?"OK":"NG");
		}
	}
}

</source>
</class>

<class classid="93" nclones="2" nlines="22" similarity="100">
<source file="../hum_codes_raw/s157691451.java" startline="1" endline="33" pcid="5292">
import java.util.*;
/**
 * @author afterCmidday
 *
 */
class Main {
 
    /**
     * @param args
     */
    public static void main(String[] args) {
        // TODO 
        final double eps = 1e-10;
        int n;
        Scanner scan = new Scanner(System.in);
        n = scan.nextInt();
        for(int i = 0;i < n;i++){
            double x1 = scan.nextDouble(), y1 = scan.nextDouble(), x2 = scan.nextDouble(), y2 = scan.nextDouble();
            double a = x2 - x1, b = y2 - y1;
            double x3 = scan.nextDouble(), y3 = scan.nextDouble(), x4 = scan.nextDouble(), y4 = scan.nextDouble();
            double c = x4 - x3, d = y4 - y3;
            double e = a * d - b * c;
            if(Math.abs(e) < eps){
                System.out.println("YES");
            }else{
                System.out.println("NO");
            }
        }
 
    }
 
}

</source>
<source file="../hum_codes_raw/s790607735.java" startline="1" endline="36" pcid="26559">
/**
 * 
 */
import java.util.*;
/**
 * @author afterCmidday
 *
 */
class Main {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO 
		final double eps = 1e-10;
		int n;
		Scanner scan = new Scanner(System.in);
		n = scan.nextInt();
		for(int i = 0;i < n;i++){
			double x1 = scan.nextDouble(), y1 = scan.nextDouble(), x2 = scan.nextDouble(), y2 = scan.nextDouble();
			double a = x2 - x1, b = y2 - y1;
			double x3 = scan.nextDouble(), y3 = scan.nextDouble(), x4 = scan.nextDouble(), y4 = scan.nextDouble();
			double c = x4 - x3, d = y4 - y3;
			double e = a * d - b * c;
			if(Math.abs(e) < eps){
				System.out.println("YES");
			}else{
				System.out.println("NO");
			}
		}

	}

}

</source>
</class>

<class classid="94" nclones="2" nlines="13" similarity="100">
<source file="../hum_codes_raw/s157938525.java" startline="1" endline="19" pcid="5302">
import java.util.Scanner;

public class Main {
	Scanner sc = new Scanner(System.in);
	
	public static void main(String[] args) {
		Main m = new Main();
		m.run();
	}
	
	void run() {
		int n = sc.nextInt();
		int k = sc.nextInt();
		
		System.out.println(n-k+1);
		
	}
}

</source>
<source file="../hum_codes_raw/s168074770.java" startline="1" endline="19" pcid="5634">
import java.util.Scanner;

public class Main {
	Scanner sc = new Scanner(System.in);
	
	public static void main(String[] args) {
		Main m = new Main();
		m.run();
	}
	
	void run() {
		int n = sc.nextInt();
		int k = sc.nextInt();
		
		System.out.println(n-k+1);
		
	}
}

</source>
</class>

<class classid="95" nclones="2" nlines="44" similarity="100">
<source file="../hum_codes_raw/s160342270.java" startline="1" endline="46" pcid="5380">
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Main main = new Main();
        main.solve();
    }
    public void solve() {
        Scanner scan = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int N = scan.nextInt();
        long C = scan.nextLong();
        long K = scan.nextLong();
        long[] l = new long[N];
        for (int i = 0; i < N; i++) {
            l[i] = scan.nextLong();
        }
        Arrays.sort(l);
        long[] r = new long[N];
        for (int i = 0; i < N; i++) {
            r[i] = l[i] + K;
        }
        int answer = 0;
        long current = Long.MAX_VALUE;
        long number_of_people = 0;
        for (int i = N-1; 0 <= i; i--) {
            if (number_of_people == C) {
                answer += 1;
                number_of_people = 0;
                current = l[i];
            }
            if (r[i] < current) {
                answer += (number_of_people + (C-1))/C;
                number_of_people = 1;
                current = l[i];
                continue;
            }
            number_of_people += 1;
        }
        answer += (number_of_people + (C - 1)) / C;
        System.out.println(answer);
    }
}

</source>
<source file="../hum_codes_raw/s295257878.java" startline="1" endline="46" pcid="9900">
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Main main = new Main();
        main.solve();
    }
    public void solve() {
        Scanner scan = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int N = scan.nextInt();
        long C = scan.nextLong();
        long K = scan.nextLong();
        long[] l = new long[N];
        for (int i = 0; i < N; i++) {
            l[i] = scan.nextLong();
        }
        Arrays.sort(l);
        long[] r = new long[N];
        for (int i = 0; i < N; i++) {
            r[i] = l[i] + K;
        }
        int answer = 0;
        long current = Long.MAX_VALUE;
        long number_of_people = 0;
        for (int i = N-1; 0 <= i; i--) {
            if (number_of_people == C) {
                answer += 1;
                number_of_people = 0;
                current = l[i];
            }
            if (r[i] < current) {
                answer += (number_of_people + (C-1))/C;
                number_of_people = 1;
                current = l[i];
                continue;
            }
            number_of_people += 1;
        }
        answer += (number_of_people + (C - 1)) / C;
        System.out.println(answer);
    }
}

</source>
</class>

<class classid="96" nclones="4" nlines="169" similarity="100">
<source file="../hum_codes_raw/s161310507.java" startline="1" endline="249" pcid="5407">
import java.util.ArrayList;
import java.util.Scanner;
import java.io.PrintWriter;

class Main {
    static Scanner sc = new Scanner(System.in);
    static PrintWriter out = new PrintWriter(System.out);
    static RUQ d = new RUQ(100005, (1 << 31) - 1);
    static int n, q;
    static int com;
    static int indx;
    static int s, t, x;
    
    public static void main(String[] args) {
        n = sc.nextInt();
        q = sc.nextInt();
        
        for (int i = 0; i < q; i++) {

            com = sc.nextInt();
            if (com == 0) {

                s = sc.nextInt();
                t = sc.nextInt();
                x = sc.nextInt();
                d.update(s, t + 1, x);
            }
            else {
                indx = sc.nextInt();
                out.println(d.query(indx, indx + 1));
            }
        }
        
        out.flush();
    }
}

class RUQ extends LazySqrtDecomposition<Integer> {

    public RUQ(int n, int e) {
        super(n, e);
    }
    
    @Override
    protected Integer f(Integer x, Integer y) {
        return y;
    }
    
    @Override
    protected Integer g(Integer x, Integer y, int t) {
        return y;
    }
    
    @Override
    protected Integer h(Integer x, Integer y) {
        return y;
    }

}

/**
 * @author ei1710
 * @version 1.00
 */

//package toyama.ei1710.DataStructures;
/**
 * .<br>
 * operator<br>
 * O(sqrt(N))
 *
 * <br>
 * bucket_ilazy_i<br>
 * bucket_i<br>
 *
 * <br>
 * bucket_ibucket_ilazy_i
 * lazy_ibucket_i
 * 
 *
 */
abstract class LazySqrtDecomposition<T> {
    /**  */
    protected ArrayList<T> raw_data;
    /**  */
    protected ArrayList<T> bucket;
    /**  */
    protected ArrayList<T> lazy;
    
    /** lazy */
    protected boolean[] lazy_flag;
    /**  */
    protected T e;
    /**  */
    protected int N;

    protected int sqrtN;

    /**  */
    protected int K;
    
    /**  */
    abstract protected T f(T x, T y);

    /**  bucketlazy */
    abstract protected T g(T x, T y, int t);

    /**  lazy*/
    abstract protected T h(T x, T y);
    
    /** enmemb */
    public LazySqrtDecomposition(int nmemb, T e) {
        this.e = e;
        N = nmemb;
        sqrtN = 1;
        while (sqrtN * sqrtN < N) sqrtN++;
        
        K = (N + sqrtN - 1) / sqrtN;
        
        raw_data = new ArrayList<T>(N);
        bucket = new ArrayList<T>(K);
        lazy = new ArrayList<T>(K);
        lazy_flag = new boolean[K];
        
        build();
    }
    
    private void build() {

        for (int i = 0; i < N; i++) {
            raw_data.add(e);
        }

        for (int i = 0; i < K; i++) {
            bucket.add(e);
            lazy.add(e);
            lazy_flag[i] = false;
        }
    }
    
    /** bucket[k]lazy[k]bucket[k] */
    protected void eval(int k) {
        
        T x = e;
        for (int i = k * sqrtN; i < Math.min(N, (k + 1) * sqrtN); i++) {
            if (lazy_flag[k]) {
                raw_data.set(i, g(raw_data.get(i), lazy.get(k), 1));
            }
            x = f(x, raw_data.get(i));
        }
        
        lazy_flag[k] = false;
        bucket.set(k, x);
    }

    
    /** [l, r)dat O(sqrt(N)) */
    public void update(int l, int r, T dat) {
        int s = l / sqrtN;
        int t = (r + sqrtN - 1) / sqrtN;

        int bucket_l, bucket_r;
        
        for (int i = s; i < t; i++) {
            bucket_l = i * sqrtN;
            bucket_r = (i + 1) * sqrtN;
            
            if (l <= bucket_l && bucket_r <= r) {
                if (lazy_flag[i]) {
                    lazy.set(i, h(lazy.get(i), dat));
                }
                else {
                    lazy.set(i, dat);
                }
                lazy_flag[i] = true;
            }
            else {
                eval(i);
                for (int j = Math.max(bucket_l, l); j < Math.min(bucket_r, r); j++) {
                    raw_data.set(j, g(raw_data.get(j), dat, 1));
                }
            }
        }
    }

    /** [l, r) O(sqrt(N)) */
    public T query(int l, int r) {
        int s = l / sqrtN;
        int t = (r + sqrtN - 1) / sqrtN;
        int bucket_l, bucket_r;
        T x = e;
        
        for (int i = s; i < t; i++) {
            bucket_l = i * sqrtN;
            bucket_r = (i + 1) * sqrtN;
            if (l <= bucket_l && bucket_r <= r) {
                if (lazy_flag[i]) {
                    x = f(x, g(bucket.get(i), lazy.get(i), 1));
                }
                else {
                    x = f(x, bucket.get(i));
                }
            }
            else {
                eval(i);
                
                for (int j = Math.max(bucket_l, l); j < Math.min(bucket_r, r); j++) {
                    x = f(x, raw_data.get(j));
                }
            }
        }
        return x;
    }
    
    /**  */
    public void debugPrint() {
        
        System.err.println("-lazy-");
        for (int i = 0; i < lazy.size(); i++) {
            if (!lazy_flag[i]) {
                System.err.print(" --  ");
            }
            else {
                System.err.print(lazy.get(i));
                System.err.print(' ');
            }
        }
        System.err.print('\n');
        
        System.err.println("-bucket-");
        for (T p : bucket) {
            System.err.print(p);
            System.err.print(' ');
        }
        System.err.print('\n');

        System.err.println("-raw_data-");
        for (T q : raw_data) {
            System.err.print(q);
            System.err.print(' ');
        }
        System.err.print('\n');

        System.err.println("-other data-");
        System.err.printf("N: %d, sqrtN: %d, K: %d\n", N, sqrtN, K);
    }
}


</source>
<source file="../hum_codes_raw/s220987916.java" startline="1" endline="249" pcid="7473">
import java.util.ArrayList;
import java.util.Scanner;
import java.io.PrintWriter;

class Main {
    static Scanner sc = new Scanner(System.in);
    static PrintWriter out = new PrintWriter(System.out);
    static RUQ d = new RUQ(100005, (1 << 31) - 1);
    static int n, q;
    static int com;
    static int indx;
    static int s, t, x;
    
    public static void main(String[] args) {
        n = sc.nextInt();
        q = sc.nextInt();
        
        for (int i = 0; i < q; i++) {

            com = sc.nextInt();
            if (com == 0) {

                s = sc.nextInt();
                t = sc.nextInt();
                x = sc.nextInt();
                d.update(s, t + 1, x);
            }
            else {
                indx = sc.nextInt();
                out.println(d.query(indx, indx + 1));
            }
        }
        
        out.flush();
    }
}

class RUQ extends LazySqrtDecomposition<Integer> {

    public RUQ(int n, int e) {
        super(n, e);
    }
    
    @Override
    protected Integer f(Integer x, Integer y) {
        return y;
    }
    
    @Override
    protected Integer g(Integer x, Integer y, int t) {
        return y;
    }
    
    @Override
    protected Integer h(Integer x, Integer y) {
        return y;
    }

}

/**
 * @author ei1710
 * @version 1.00
 */

//package toyama.ei1710.DataStructures;
/**
 * .<br>
 * operator<br>
 * O(sqrt(N))
 *
 * <br>
 * bucket_ilazy_i<br>
 * bucket_i<br>
 *
 * <br>
 * bucket_ibucket_ilazy_i
 * lazy_ibucket_i
 * 
 *
 */
abstract class LazySqrtDecomposition<T> {
    /**  */
    protected ArrayList<T> raw_data;
    /**  */
    protected ArrayList<T> bucket;
    /**  */
    protected ArrayList<T> lazy;
    
    /** lazy */
    protected boolean[] lazy_flag;
    /**  */
    protected T e;
    /**  */
    protected int N;

    protected int sqrtN;

    /**  */
    protected int K;
    
    /**  */
    abstract protected T f(T x, T y);

    /**  bucketlazy */
    abstract protected T g(T x, T y, int t);

    /**  lazy*/
    abstract protected T h(T x, T y);
    
    /** enmemb */
    public LazySqrtDecomposition(int nmemb, T e) {
        this.e = e;
        N = nmemb;
        sqrtN = 1;
        while (sqrtN * sqrtN < N) sqrtN++;
        
        K = (N + sqrtN - 1) / sqrtN;
        
        raw_data = new ArrayList<T>(N);
        bucket = new ArrayList<T>(K);
        lazy = new ArrayList<T>(K);
        lazy_flag = new boolean[K];
        
        build();
    }
    
    private void build() {

        for (int i = 0; i < N; i++) {
            raw_data.add(e);
        }

        for (int i = 0; i < K; i++) {
            bucket.add(e);
            lazy.add(e);
            lazy_flag[i] = false;
        }
    }
    
    /** bucket[k]lazy[k]bucket[k] */
    protected void eval(int k) {
        
        T x = e;
        for (int i = k * sqrtN; i < Math.min(N, (k + 1) * sqrtN); i++) {
            if (lazy_flag[k]) {
                raw_data.set(i, g(raw_data.get(i), lazy.get(k), 1));
            }
            x = f(x, raw_data.get(i));
        }
        
        lazy_flag[k] = false;
        bucket.set(k, x);
    }

    
    /** [l, r)dat O(sqrt(N)) */
    public void update(int l, int r, T dat) {
        int s = l / sqrtN;
        int t = (r + sqrtN - 1) / sqrtN;

        int bucket_l, bucket_r;
        
        for (int i = s; i < t; i++) {
            bucket_l = i * sqrtN;
            bucket_r = (i + 1) * sqrtN;
            
            if (l <= bucket_l && bucket_r <= r) {
                if (lazy_flag[i]) {
                    lazy.set(i, h(lazy.get(i), dat));
                }
                else {
                    lazy.set(i, dat);
                }
                lazy_flag[i] = true;
            }
            else {
                eval(i);
                for (int j = Math.max(bucket_l, l); j < Math.min(bucket_r, r); j++) {
                    raw_data.set(j, g(raw_data.get(j), dat, 1));
                }
            }
        }
    }

    /** [l, r) O(sqrt(N)) */
    public T query(int l, int r) {
        int s = l / sqrtN;
        int t = (r + sqrtN - 1) / sqrtN;
        int bucket_l, bucket_r;
        T x = e;
        
        for (int i = s; i < t; i++) {
            bucket_l = i * sqrtN;
            bucket_r = (i + 1) * sqrtN;
            if (l <= bucket_l && bucket_r <= r) {
                if (lazy_flag[i]) {
                    x = f(x, g(bucket.get(i), lazy.get(i), 1));
                }
                else {
                    x = f(x, bucket.get(i));
                }
            }
            else {
                eval(i);
                
                for (int j = Math.max(bucket_l, l); j < Math.min(bucket_r, r); j++) {
                    x = f(x, raw_data.get(j));
                }
            }
        }
        return x;
    }
    
    /**  */
    public void debugPrint() {
        
        System.err.println("-lazy-");
        for (int i = 0; i < lazy.size(); i++) {
            if (!lazy_flag[i]) {
                System.err.print(" --  ");
            }
            else {
                System.err.print(lazy.get(i));
                System.err.print(' ');
            }
        }
        System.err.print('\n');
        
        System.err.println("-bucket-");
        for (T p : bucket) {
            System.err.print(p);
            System.err.print(' ');
        }
        System.err.print('\n');

        System.err.println("-raw_data-");
        for (T q : raw_data) {
            System.err.print(q);
            System.err.print(' ');
        }
        System.err.print('\n');

        System.err.println("-other data-");
        System.err.printf("N: %d, sqrtN: %d, K: %d\n", N, sqrtN, K);
    }
}


</source>
<source file="../hum_codes_raw/s218869781.java" startline="1" endline="249" pcid="7383">
import java.util.ArrayList;
import java.util.Scanner;
import java.io.PrintWriter;

class Main {
    static Scanner sc = new Scanner(System.in);
    static PrintWriter out = new PrintWriter(System.out);
    static RUQ d = new RUQ(100005, (1 << 31) - 1);
    static int n, q;
    static int com;
    static int indx;
    static int s, t, x;
    
    public static void main(String[] args) {
        n = sc.nextInt();
        q = sc.nextInt();
        
        for (int i = 0; i < q; i++) {

            com = sc.nextInt();
            if (com == 0) {

                s = sc.nextInt();
                t = sc.nextInt();
                x = sc.nextInt();
                d.update(s, t + 1, x);
            }
            else {
                indx = sc.nextInt();
                out.println(d.query(indx, indx + 1));
            }
        }
        
        out.flush();
    }
}

class RUQ extends LazySqrtDecomposition<Integer> {

    public RUQ(int n, int e) {
        super(n, e);
    }
    
    @Override
    protected Integer f(Integer x, Integer y) {
        return y;
    }
    
    @Override
    protected Integer g(Integer x, Integer y, int t) {
        return y;
    }
    
    @Override
    protected Integer h(Integer x, Integer y) {
        return y;
    }

}

/**
 * @author ei1710
 * @version 1.00
 */

//package toyama.ei1710.DataStructures;
/**
 * .<br>
 * operator<br>
 * O(sqrt(N))
 *
 * <br>
 * bucket_ilazy_i<br>
 * bucket_i<br>
 *
 * <br>
 * bucket_ibucket_ilazy_i
 * lazy_ibucket_i
 * 
 *
 */
abstract class LazySqrtDecomposition<T> {
    /**  */
    protected ArrayList<T> raw_data;
    /**  */
    protected ArrayList<T> bucket;
    /**  */
    protected ArrayList<T> lazy;
    
    /** lazy */
    protected boolean[] lazy_flag;
    /**  */
    protected T e;
    /**  */
    protected int N;

    protected int sqrtN;

    /**  */
    protected int K;
    
    /**  */
    abstract protected T f(T x, T y);

    /**  bucketlazy */
    abstract protected T g(T x, T y, int t);

    /**  lazy*/
    abstract protected T h(T x, T y);
    
    /** enmemb */
    public LazySqrtDecomposition(int nmemb, T e) {
        this.e = e;
        N = nmemb;
        sqrtN = 1;
        while (sqrtN * sqrtN < N) sqrtN++;
        
        K = (N + sqrtN - 1) / sqrtN;
        
        raw_data = new ArrayList<T>(N);
        bucket = new ArrayList<T>(K);
        lazy = new ArrayList<T>(K);
        lazy_flag = new boolean[K];
        
        build();
    }
    
    private void build() {

        for (int i = 0; i < N; i++) {
            raw_data.add(e);
        }

        for (int i = 0; i < K; i++) {
            bucket.add(e);
            lazy.add(e);
            lazy_flag[i] = false;
        }
    }
    
    /** bucket[k]lazy[k]bucket[k] */
    protected void eval(int k) {
        
        T x = e;
        for (int i = k * sqrtN; i < Math.min(N, (k + 1) * sqrtN); i++) {
            if (lazy_flag[k]) {
                raw_data.set(i, g(raw_data.get(i), lazy.get(k), 1));
            }
            x = f(x, raw_data.get(i));
        }
        
        lazy_flag[k] = false;
        bucket.set(k, x);
    }

    
    /** [l, r)dat O(sqrt(N)) */
    public void update(int l, int r, T dat) {
        int s = l / sqrtN;
        int t = (r + sqrtN - 1) / sqrtN;

        int bucket_l, bucket_r;
        
        for (int i = s; i < t; i++) {
            bucket_l = i * sqrtN;
            bucket_r = (i + 1) * sqrtN;
            
            if (l <= bucket_l && bucket_r <= r) {
                if (lazy_flag[i]) {
                    lazy.set(i, h(lazy.get(i), dat));
                }
                else {
                    lazy.set(i, dat);
                }
                lazy_flag[i] = true;
            }
            else {
                eval(i);
                for (int j = Math.max(bucket_l, l); j < Math.min(bucket_r, r); j++) {
                    raw_data.set(j, g(raw_data.get(j), dat, 1));
                }
            }
        }
    }

    /** [l, r) O(sqrt(N)) */
    public T query(int l, int r) {
        int s = l / sqrtN;
        int t = (r + sqrtN - 1) / sqrtN;
        int bucket_l, bucket_r;
        T x = e;
        
        for (int i = s; i < t; i++) {
            bucket_l = i * sqrtN;
            bucket_r = (i + 1) * sqrtN;
            if (l <= bucket_l && bucket_r <= r) {
                if (lazy_flag[i]) {
                    x = f(x, g(bucket.get(i), lazy.get(i), 1));
                }
                else {
                    x = f(x, bucket.get(i));
                }
            }
            else {
                eval(i);
                
                for (int j = Math.max(bucket_l, l); j < Math.min(bucket_r, r); j++) {
                    x = f(x, raw_data.get(j));
                }
            }
        }
        return x;
    }
    
    /**  */
    public void debugPrint() {
        
        System.err.println("-lazy-");
        for (int i = 0; i < lazy.size(); i++) {
            if (!lazy_flag[i]) {
                System.err.print(" --  ");
            }
            else {
                System.err.print(lazy.get(i));
                System.err.print(' ');
            }
        }
        System.err.print('\n');
        
        System.err.println("-bucket-");
        for (T p : bucket) {
            System.err.print(p);
            System.err.print(' ');
        }
        System.err.print('\n');

        System.err.println("-raw_data-");
        for (T q : raw_data) {
            System.err.print(q);
            System.err.print(' ');
        }
        System.err.print('\n');

        System.err.println("-other data-");
        System.err.printf("N: %d, sqrtN: %d, K: %d\n", N, sqrtN, K);
    }
}


</source>
<source file="../hum_codes_raw/s441715290.java" startline="1" endline="249" pcid="14801">
import java.util.ArrayList;
import java.util.Scanner;
import java.io.PrintWriter;

class Main {
    static Scanner sc = new Scanner(System.in);
    static PrintWriter out = new PrintWriter(System.out);
    static RUQ d = new RUQ(100005, (1 << 31) - 1);
    static int n, q;
    static int com;
    static int indx;
    static int s, t, x;
    
    public static void main(String[] args) {
        n = sc.nextInt();
        q = sc.nextInt();
        
        for (int i = 0; i < q; i++) {

            com = sc.nextInt();
            if (com == 0) {

                s = sc.nextInt();
                t = sc.nextInt();
                x = sc.nextInt();
                d.update(s, t + 1, x);
            }
            else {
                indx = sc.nextInt();
                out.println(d.query(indx, indx + 1));
            }
        }
        
        out.flush();
    }
}

class RUQ extends LazySqrtDecomposition<Integer> {

    public RUQ(int n, int e) {
        super(n, e);
    }
    
    @Override
    protected Integer f(Integer x, Integer y) {
        return y;
    }
    
    @Override
    protected Integer g(Integer x, Integer y, int t) {
        return y;
    }
    
    @Override
    protected Integer h(Integer x, Integer y) {
        return y;
    }

}

/**
 * @author ei1710
 * @version 1.00
 */

//package toyama.ei1710.DataStructures;
/**
 * .<br>
 * operator<br>
 * O(sqrt(N))
 *
 * <br>
 * bucket_ilazy_i<br>
 * bucket_i<br>
 *
 * <br>
 * bucket_ibucket_ilazy_i
 * lazy_ibucket_i
 * 
 *
 */
abstract class LazySqrtDecomposition<T> {
    /**  */
    protected ArrayList<T> raw_data;
    /**  */
    protected ArrayList<T> bucket;
    /**  */
    protected ArrayList<T> lazy;
    
    /** lazy */
    protected boolean[] lazy_flag;
    /**  */
    protected T e;
    /**  */
    protected int N;

    protected int sqrtN;

    /**  */
    protected int K;
    
    /**  */
    abstract protected T f(T x, T y);

    /**  bucketlazy */
    abstract protected T g(T x, T y, int t);

    /**  lazy*/
    abstract protected T h(T x, T y);
    
    /** enmemb */
    public LazySqrtDecomposition(int nmemb, T e) {
        this.e = e;
        N = nmemb;
        sqrtN = 1;
        while (sqrtN * sqrtN < N) sqrtN++;
        
        K = (N + sqrtN - 1) / sqrtN;
        
        raw_data = new ArrayList<T>(N);
        bucket = new ArrayList<T>(K);
        lazy = new ArrayList<T>(K);
        lazy_flag = new boolean[K];
        
        build();
    }
    
    private void build() {

        for (int i = 0; i < N; i++) {
            raw_data.add(e);
        }

        for (int i = 0; i < K; i++) {
            bucket.add(e);
            lazy.add(e);
            lazy_flag[i] = false;
        }
    }
    
    /** bucket[k]lazy[k]bucket[k] */
    protected void eval(int k) {
        
        T x = e;
        for (int i = k * sqrtN; i < Math.min(N, (k + 1) * sqrtN); i++) {
            if (lazy_flag[k]) {
                raw_data.set(i, g(raw_data.get(i), lazy.get(k), 1));
            }
            x = f(x, raw_data.get(i));
        }
        
        lazy_flag[k] = false;
        bucket.set(k, x);
    }

    
    /** [l, r)dat O(sqrt(N)) */
    public void update(int l, int r, T dat) {
        int s = l / sqrtN;
        int t = (r + sqrtN - 1) / sqrtN;

        int bucket_l, bucket_r;
        
        for (int i = s; i < t; i++) {
            bucket_l = i * sqrtN;
            bucket_r = (i + 1) * sqrtN;
            
            if (l <= bucket_l && bucket_r <= r) {
                if (lazy_flag[i]) {
                    lazy.set(i, h(lazy.get(i), dat));
                }
                else {
                    lazy.set(i, dat);
                }
                lazy_flag[i] = true;
            }
            else {
                eval(i);
                for (int j = Math.max(bucket_l, l); j < Math.min(bucket_r, r); j++) {
                    raw_data.set(j, g(raw_data.get(j), dat, 1));
                }
            }
        }
    }

    /** [l, r) O(sqrt(N)) */
    public T query(int l, int r) {
        int s = l / sqrtN;
        int t = (r + sqrtN - 1) / sqrtN;
        int bucket_l, bucket_r;
        T x = e;
        
        for (int i = s; i < t; i++) {
            bucket_l = i * sqrtN;
            bucket_r = (i + 1) * sqrtN;
            if (l <= bucket_l && bucket_r <= r) {
                if (lazy_flag[i]) {
                    x = f(x, g(bucket.get(i), lazy.get(i), 1));
                }
                else {
                    x = f(x, bucket.get(i));
                }
            }
            else {
                eval(i);
                
                for (int j = Math.max(bucket_l, l); j < Math.min(bucket_r, r); j++) {
                    x = f(x, raw_data.get(j));
                }
            }
        }
        return x;
    }
    
    /**  */
    public void debugPrint() {
        
        System.err.println("-lazy-");
        for (int i = 0; i < lazy.size(); i++) {
            if (!lazy_flag[i]) {
                System.err.print(" --  ");
            }
            else {
                System.err.print(lazy.get(i));
                System.err.print(' ');
            }
        }
        System.err.print('\n');
        
        System.err.println("-bucket-");
        for (T p : bucket) {
            System.err.print(p);
            System.err.print(' ');
        }
        System.err.print('\n');

        System.err.println("-raw_data-");
        for (T q : raw_data) {
            System.err.print(q);
            System.err.print(' ');
        }
        System.err.print('\n');

        System.err.println("-other data-");
        System.err.printf("N: %d, sqrtN: %d, K: %d\n", N, sqrtN, K);
    }
}


</source>
</class>

<class classid="97" nclones="2" nlines="46" similarity="100">
<source file="../hum_codes_raw/s165602118.java" startline="1" endline="49" pcid="5545">
import java.util.Scanner;

public class Main {
	static Scanner sc = new Scanner(System.in);
	
	static boolean search(String tar , String str){//
		boolean f = false;
		for(int j=0;j<str.length();j++){
			if(tar.equals(str))return true;
			if(tar.charAt(0)==str.charAt(j)){
				int cnt=0;
				for(int i=j+1;i<str.length();i++){
					cnt++;
					if(str.length()<j+cnt)continue;
					if(tar.charAt(1)==str.charAt(i)){
						if((j+tar.length()-1*cnt)>str.length())break;//
						for(int k=2;k<tar.length();k++){
							if(j+k*cnt>=str.length()){f=false;break;}//
							if(tar.charAt(k)==str.charAt(j+k*cnt))f = true;
							else {
								f = false;
								break;
							}
						}
						if(f==true) return f;
					}
				}
			}
		}		
		return f;
	}
	
	void doIt(){//sc
		int n = sc.nextInt();
		int ans = 0;
		String tar = sc.next();
		for(int i=0;i<n;++i){
			String s = sc.next();
			if(search(tar,s))ans++;
		}
		System.out.println(ans);
	}

	public static void main(String[] args) {
		new Main().doIt();
	}

}

</source>
<source file="../hum_codes_raw/s181026918.java" startline="1" endline="49" pcid="6100">
import java.util.Scanner;
 
public class Main {
    static Scanner sc = new Scanner(System.in);
     
    static boolean search(String tar , String str){//
        boolean f = false;
        for(int j=0;j<str.length();j++){
            if(tar.equals(str))return true;
            if(tar.charAt(0)==str.charAt(j)){
                int cnt=0;
                for(int i=j+1;i<str.length();i++){
                    cnt++;
                    if(str.length()<j+cnt)continue;
                    if(tar.charAt(1)==str.charAt(i)){
                        if((j+tar.length()-1*cnt)>str.length())break;//
                        for(int k=2;k<tar.length();k++){
                            if(j+k*cnt>=str.length()){f=false;break;}//
                            if(tar.charAt(k)==str.charAt(j+k*cnt))f = true;
                            else {
                                f = false;
                                break;
                            }
                        }
                        if(f==true) return f;
                    }
                }
            }
        }       
        return f;
    }
     
    void doIt(){//sc
        int n = sc.nextInt();
        int ans = 0;
        String tar = sc.next();
        for(int i=0;i<n;++i){
            String s = sc.next();
            if(search(tar,s))ans++;
        }
        System.out.println(ans);
    }
 
    public static void main(String[] args) {
        new Main().doIt();
    }
 
}

</source>
</class>

<class classid="98" nclones="2" nlines="165" similarity="100">
<source file="../hum_codes_raw/s165832489.java" startline="1" endline="187" pcid="5556">
import java.io.*;
import java.util.*;

public class Main {
  private static int dropBit(int n, int index) {
    int higher = (n >> (index + 1)) << index;
    int lower = (n & ((1 << index) - 1));
    return higher | lower;
  }
  
  private static int insertBit(int n, int index, int v) {
    int higher = ((n >> index) << (index + 1));
    int lower = (n & ((1 << index) - 1));
    return higher | lower | v;
  }
  
  private static List<Integer> solveSub(int n, int a, int b) {
    if (n == 1) {
      if (a != b) {
        return Arrays.asList(a, b);
      } else {
        return null;
      }
    }
    
    for (int i = 0; i < n; i++) {
      int aBit = (a >> i) & 1;
      int bBit = (b >> i) & 1;
      if (aBit != bBit) {
        int aDash = dropBit(a, i);
        int bDash = dropBit(b, i);
        int c = aDash ^ 1;
        List<Integer> path1 = solveSub(n - 1, aDash, c);
        List<Integer> path2 = solveSub(n - 1, c, bDash);
        if (path1 != null && path2 != null) {
          List<Integer> path = new ArrayList<>();
          for (int v : path1) {
            path.add(insertBit(v, i, aBit << i));
          }
          for (int v : path2) {
            path.add(insertBit(v, i, bBit << i));
          }
          return path;
        }
        return null;
      }
    }
    return null;
  }
  
  private static List<String> solve(int n, int a, int b) {
    List<Integer> path = solveSub(n, a, b);
    if (path == null) {
      return Arrays.asList("NO");
    }
    StringBuffer sb = new StringBuffer();
    sb.append(path.get(0));
    for (int i = 1; i < path.size(); i++) {
      sb.append(" ");
      sb.append(path.get(i));
    }
    return Arrays.asList("YES", sb.toString());
  }
  
  private static void execute(ContestReader reader, PrintWriter out) {
    int n = reader.nextInt();
    int a = reader.nextInt();
    int b = reader.nextInt();
    for (String line : solve(n, a, b)) {
      out.println(line);
    }
  }
  
  public static void main(String[] args) {
    ContestReader reader = new ContestReader(System.in);
    PrintWriter out = new PrintWriter(System.out);
    execute(reader, out);
    out.flush();
  }
}

class ContestReader {
  private BufferedReader reader;
  private StringTokenizer tokenizer;
  
  ContestReader(InputStream in) {
    reader = new BufferedReader(new InputStreamReader(in));
  }
  
  public String next() {
    while (tokenizer == null || !tokenizer.hasMoreTokens()) {
      try {
        tokenizer = new java.util.StringTokenizer(reader.readLine());
      } catch (Exception e) {
        throw new RuntimeException(e);
      }
    }
    return tokenizer.nextToken();
  }
  
  public int nextInt() {
    return Integer.parseInt(next());
  }
  
  public long nextLong() {
    return Long.parseLong(next());
  }
  
  public double nextDouble() {
    return Double.parseDouble(next());
  }
  
  public String[] next(int n) {
    String[] array = new String[n];
    for (int i = 0; i < n; i++) {
      array[i] = next();
    }
    return array;
  }
  
  public int[] nextInt(int n) {
    int[] array = new int[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextInt();
    }
    return array;
  }
  
  public long[] nextLong(int n) {
    long[] array = new long[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextLong();
    }
    return array;
  }
  
  public double[] nextDouble(int n) {
    double[] array = new double[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextDouble();
    }
    return array;
  }
  
  public char[] nextCharArray() {
    return next().toCharArray();
  }
  
  public int[][] nextInt(int n, int m) {
    int[][] matrix = new int[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextInt();
      }
    }
    return matrix;
  }
  
  public long[][] nextLong(int n, int m) {
    long[][] matrix = new long[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextLong();
      }
    }
    return matrix;
  }
  
  public double[][] nextDouble(int n, int m) {
    double[][] matrix = new double[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextDouble();
      }
    }
    return matrix;
  }
  
  public char[][] nextCharArray(int n) {
    char[][] matrix = new char[n][];
    for (int i = 0; i < n; i++) {
      matrix[i] = next().toCharArray();
    }
    return matrix;
  }
}

</source>
<source file="../hum_codes_raw/s569121349.java" startline="1" endline="190" pcid="19140">
import java.io.*;
import java.util.*;

public class Main {
  private static int dropBit(int n, int index) {
    int higher = (n >> (index + 1)) << index;
    int lower = (n & ((1 << index) - 1));
//    System.err.printf("n: %d, index: %d, higher: %d, lower: %d\n", n, index, higher, lower);
    return higher | lower;
  }
  
  private static int insertBit(int n, int index, int v) {
    int higher = ((n >> index) << (index + 1));
    int lower = (n & ((1 << index) - 1));
    return higher | lower | v;
  }
  
  private static List<Integer> solveSub(int n, int a, int b) {
//    System.err.printf("n: %d, a: %d, b: %d\n", n, a, b);
    if (n == 1) {
      if (a != b) {
        return Arrays.asList(a, b);
      } else {
        return null;
      }
    }
    
    for (int i = 0; i < n; i++) {
      int aBit = (a >> i) & 1;
      int bBit = (b >> i) & 1;
      if (aBit != bBit) {
        int aDash = dropBit(a, i);
        int bDash = dropBit(b, i);
//        System.err.printf("i: %d, aDash: %d, bDash: %d\n", i, aDash, bDash);
        int c = aDash ^ 1;
        List<Integer> path1 = solveSub(n - 1, aDash, c);
        List<Integer> path2 = solveSub(n - 1, c, bDash);
        if (path1 != null && path2 != null) {
          List<Integer> path = new ArrayList<>();
          for (int v : path1) {
            path.add(insertBit(v, i, aBit << i));
          }
          for (int v : path2) {
            path.add(insertBit(v, i, bBit << i));
          }
          return path;
        }
        return null;
      }
    }
    return null;
  }
  
  private static List<String> solve(int n, int a, int b) {
    List<Integer> path = solveSub(n, a, b);
    if (path == null) {
      return Arrays.asList("NO");
    }
    StringBuffer sb = new StringBuffer();
    sb.append(path.get(0));
    for (int i = 1; i < path.size(); i++) {
      sb.append(" ");
      sb.append(path.get(i));
    }
    return Arrays.asList("YES", sb.toString());
  }
  
  private static void execute(ContestReader reader, PrintWriter out) {
    int n = reader.nextInt();
    int a = reader.nextInt();
    int b = reader.nextInt();
    for (String line : solve(n, a, b)) {
      out.println(line);
    }
  }
  
  public static void main(String[] args) {
    ContestReader reader = new ContestReader(System.in);
    PrintWriter out = new PrintWriter(System.out);
    execute(reader, out);
    out.flush();
  }
}

class ContestReader {
  private BufferedReader reader;
  private StringTokenizer tokenizer;
  
  ContestReader(InputStream in) {
    reader = new BufferedReader(new InputStreamReader(in));
  }
  
  public String next() {
    while (tokenizer == null || !tokenizer.hasMoreTokens()) {
      try {
        tokenizer = new java.util.StringTokenizer(reader.readLine());
      } catch (Exception e) {
        throw new RuntimeException(e);
      }
    }
    return tokenizer.nextToken();
  }
  
  public int nextInt() {
    return Integer.parseInt(next());
  }
  
  public long nextLong() {
    return Long.parseLong(next());
  }
  
  public double nextDouble() {
    return Double.parseDouble(next());
  }
  
  public String[] next(int n) {
    String[] array = new String[n];
    for (int i = 0; i < n; i++) {
      array[i] = next();
    }
    return array;
  }
  
  public int[] nextInt(int n) {
    int[] array = new int[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextInt();
    }
    return array;
  }
  
  public long[] nextLong(int n) {
    long[] array = new long[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextLong();
    }
    return array;
  }
  
  public double[] nextDouble(int n) {
    double[] array = new double[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextDouble();
    }
    return array;
  }
  
  public char[] nextCharArray() {
    return next().toCharArray();
  }
  
  public int[][] nextInt(int n, int m) {
    int[][] matrix = new int[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextInt();
      }
    }
    return matrix;
  }
  
  public long[][] nextLong(int n, int m) {
    long[][] matrix = new long[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextLong();
      }
    }
    return matrix;
  }
  
  public double[][] nextDouble(int n, int m) {
    double[][] matrix = new double[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextDouble();
      }
    }
    return matrix;
  }
  
  public char[][] nextCharArray(int n) {
    char[][] matrix = new char[n][];
    for (int i = 0; i < n; i++) {
      matrix[i] = next().toCharArray();
    }
    return matrix;
  }
}

</source>
</class>

<class classid="99" nclones="2" nlines="21" similarity="100">
<source file="../hum_codes_raw/s167771213.java" startline="1" endline="24" pcid="5627">
import java.util.*;

class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        Integer a[] = new Integer[N];
        for (int i=0; i<N; i++) {
            a[i] = sc.nextInt();
        }
        Arrays.sort(a, Comparator.reverseOrder());

        int Alice = 0;
        int Bob   = 0;
        for (int i=0; i<N; i+=2) {
            Alice += a[i];
        }
        for (int i=1; i<N; i+=2) {
            Bob += a[i];
        }
        System.out.println(Alice - Bob);
    }
}

</source>
<source file="../hum_codes_raw/s456003682.java" startline="1" endline="24" pcid="15297">
import java.util.*;

class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int N=sc.nextInt();
        Integer a[]=new Integer[N];
        for(int i=0;i<N;i++){
            a[i]=sc.nextInt();
        }
        Arrays.sort(a,Comparator.reverseOrder());

        int Alice=0;
        int Bob=0;
        for(int i=0;i<N;i+=2){
            Alice+=a[i];
        }
        for(int i=1;i<N;i+=2){
            Bob+=a[i];
        }
        System.out.println(Alice-Bob);
    }
}

</source>
</class>

<class classid="100" nclones="2" nlines="25" similarity="100">
<source file="../hum_codes_raw/s170645507.java" startline="1" endline="26" pcid="5735">
import java.util.Scanner;
public class Main {
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		int L=sc.nextInt();
		int A=sc.nextInt();
		int B=sc.nextInt();
		int C=sc.nextInt();
		int D=sc.nextInt();
		int kokugoday=A/C;
		int sansuday=B/D;
		if(A%C!=0){
			kokugoday++;
		}
		if(B%D!=0){
			sansuday++;
		}
		if(kokugoday<sansuday){
			System.out.println(L-sansuday);
		}
		else{
			System.out.println(L-kokugoday);
		}
	}
}

</source>
<source file="../hum_codes_raw/s685662628.java" startline="1" endline="26" pcid="23033">
import java.util.Scanner;
public class Main {
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		int L=sc.nextInt();
		int A=sc.nextInt();
		int B=sc.nextInt();
		int C=sc.nextInt();
		int D=sc.nextInt();
		int kokugoday=A/C;
		int sansuday=B/D;
		if(A%C!=0){
			kokugoday++;
		}
		if(B%D!=0){
			sansuday++;
		}
		if(kokugoday<sansuday){
			System.out.println(L-sansuday);
		}
		else{
			System.out.println(L-kokugoday);
		}
	}
}

</source>
</class>

<class classid="101" nclones="2" nlines="19" similarity="100">
<source file="../hum_codes_raw/s171383036.java" startline="1" endline="25" pcid="5767">
import java.util.Scanner;

//0609
class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(), m = sc.nextInt(), l[] = new int[m], r[] = new int[n];
        for (int i = 0; i < m; i++)
            l[i] = sc.nextInt();
        for (int i = 0; i < m; i++) {
            int s = 0;
            for (int j = 0; j < n; j++) {
                if (sc.nextInt() == l[i]) {
                    r[j]++;
                    s++;
                }
            }
            r[l[i] - 1] += n - s;
        }
        for (int i : r)
            System.out.println(i);
    }
}


</source>
<source file="../hum_codes_raw/s584967724.java" startline="1" endline="24" pcid="19633">
import java.util.Scanner;
 

class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(), m = sc.nextInt(), l[] = new int[m], r[] = new int[n];
        for (int i = 0; i < m; i++)
            l[i] = sc.nextInt();
        for (int i = 0; i < m; i++) {
            int s = 0;
            for (int j = 0; j < n; j++) {
                if (sc.nextInt() == l[i]) {
                    r[j]++;
                    s++;
                }
            }
            r[l[i] - 1] += n - s;
        }
        for (int i : r)
            System.out.println(i);
    }
}

</source>
</class>

<class classid="102" nclones="2" nlines="27" similarity="100">
<source file="../hum_codes_raw/s182127508.java" startline="1" endline="34" pcid="6140">
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		boolean ok = true;
		int a = 0;
		int b = 0;
		int c = 0;
		int d = 0;
		while(sc.hasNext()) {
			int[] list = new int[3];
			for(int i = 0; i < 3; i++) {
				list[i] = sc.nextInt();
			}
			if(!ok) continue;
			Arrays.sort(list);
			if(list[0] + list[1] <= list[2]) ok = false;
			else {
				a++;
				if(list[0]*list[0] + list[1] * list[1] < list[2] * list[2])c++;
				else if(list[0]*list[0] + list[1] * list[1] > list[2] * list[2]) d++;
				else b++;
			}
		}
		System.out.println(a + " " + b + " " + d + " " + c);

	}



}

</source>
<source file="../hum_codes_raw/s398975488.java" startline="1" endline="34" pcid="13415">
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		boolean ok = true;
		int a = 0;
		int b = 0;
		int c = 0;
		int d = 0;
		while(sc.hasNext()) {
			int[] list = new int[3];
			for(int i = 0; i < 3; i++) {
				list[i] = sc.nextInt();
			}
			if(!ok) continue;
			Arrays.sort(list);
			if(list[0] + list[1] <= list[2]) ok = false;
			else {
				a++;
				if(list[0]*list[0] + list[1] * list[1] < list[2] * list[2])c++;
				else if(list[0]*list[0] + list[1] * list[1] > list[2] * list[2]) d++;
				else b++;
			}
		}
		System.out.println(a + " " + b + " " + d + " " + c);

	}



}

</source>
</class>

<class classid="103" nclones="2" nlines="21" similarity="100">
<source file="../hum_codes_raw/s184441056.java" startline="1" endline="23" pcid="6214">
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        for (;;) {
            int n = sc.nextInt();
            if(n==0)break;
            double u=2000001;
            int p=0;
            for(int i=0;i<n;i++) {
                int a=sc.nextInt(),b=sc.nextInt();
                double t=Math.abs(22-(double)sc.nextInt()*10000/b/b);
                if(u>t) {
                    u=t;
                    p=a;
                }
            }
            System.out.println(p);
        }
    }
}

</source>
<source file="../hum_codes_raw/s558855756.java" startline="1" endline="23" pcid="18834">
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        for (;;) {
            int n = sc.nextInt();
            if(n==0)break;
            double u=2000001;
            int p=0;
            for(int i=0;i<n;i++) {
                int a=sc.nextInt(),b=sc.nextInt();
                double t=Math.abs(22-(double)sc.nextInt()*10000/b/b);
                if(u>t) {
                    u=t;
                    p=a;
                }
            }
            System.out.println(p);
        }
    }
}

</source>
</class>

<class classid="104" nclones="2" nlines="29" similarity="100">
<source file="../hum_codes_raw/s187784404.java" startline="1" endline="33" pcid="6320">
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		List<Integer> list = new ArrayList<>();
		for (int i = 0; i < n; i++) {
			list.add(sc.nextInt());
		}
		int q = sc.nextInt();
		for (int i = 0; i < q; i++) {
			switch (sc.nextInt()) {
				case 0:
					int b  = sc.nextInt();
					int e = sc.nextInt();
					System.out.println(Collections.min(list.subList(b, e)));
					break;
				case 1:
					b  = sc.nextInt();
					e = sc.nextInt();
					System.out.println(Collections.max(list.subList(b, e)));
					break;
			}
		}
	}
}



</source>
<source file="../hum_codes_raw/s892475806.java" startline="1" endline="32" pcid="30017">
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		List<Integer> list = new ArrayList<>();
		for (int i = 0; i < n; i++) {
			list.add(sc.nextInt());
		}
		int q = sc.nextInt();
		for (int i = 0; i < q; i++) {
			switch (sc.nextInt()) {
				case 0:
					int b  = sc.nextInt();
					int e = sc.nextInt();
					System.out.println(Collections.min(list.subList(b, e)));
					break;
				case 1:
					b  = sc.nextInt();
					e = sc.nextInt();
					System.out.println(Collections.max(list.subList(b, e)));
					break;
			}
		}
	}
}


</source>
</class>

<class classid="105" nclones="3" nlines="10" similarity="100">
<source file="../hum_codes_raw/s189048146.java" startline="1" endline="16" pcid="6368">
import java.util.*;
public class Main {
	public static void main(String[] args) {
		Scanner sc =new Scanner(System.in);
		
		
		int a=sc.nextInt();
		int b=sc.nextInt();
		int h=sc.nextInt();
		
		
		System.out.println((a+b)*h/2);

}
}

</source>
<source file="../hum_codes_raw/s597822515.java" startline="1" endline="13" pcid="20059">
import java.util.*;

public class Main {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int a = sc.nextInt();
    int b = sc.nextInt();
    int h = sc.nextInt();
    
    System.out.println((a+b)*h/2);
  }
}

</source>
<source file="../hum_codes_raw/s811477541.java" startline="1" endline="11" pcid="27264">
import java.util.*;
public class Main{
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int a = sc.nextInt();
    int b = sc.nextInt();
    int h = sc.nextInt();
    System.out.println((a+b)*h/2);
  }
}

</source>
</class>

<class classid="106" nclones="2" nlines="53" similarity="100">
<source file="../hum_codes_raw/s189078226.java" startline="1" endline="63" pcid="6371">
import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;

public class Main {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		Scanner cin = new Scanner(System.in);
		for(;;){
			int N=Integer.parseInt(cin.nextLine());
			if(N==0)break;
			
			int[][] a = new int[N][2];
			for(int i=0;i<N;i++){
				String[] s =cin.nextLine().split(" ");
				int[] b = new int[s.length-1];
				a[i][0]=Integer.parseInt(s[0]);
				int frame=1;
				for(int j=1;j<s.length;j++){
					b[j-1]=Integer.parseInt(s[j]);
				}
				for(int j=0;j<b.length;){
					if(frame==10){
						a[i][1]+=b[j];
						j++;
						continue;
					}
					a[i][1]+=b[j]+b[j+1];
					if(b[j]==10){
						a[i][1]+=b[j+2];
						j++;
					}
					else{
						if(b[j]+b[j+1]==10){
							a[i][1]+=b[j+2];
						}
						j+=2;

					}
					frame++;
				}
//				System.out.println(a[i][1]);
			}
			Arrays.sort(a,new Comparator<int[]>(){
				public int compare(int[] a,int[] b){
					if(a[1]==b[1]){
						return a[0]-b[0];
					}
					return b[1]-a[1];
				}
			});
			
			for(int i=0;i<N;i++){
				System.out.println(a[i][0]+ " " + a[i][1]);
			}
		}
	}
	
}

</source>
<source file="../hum_codes_raw/s366179451.java" startline="1" endline="63" pcid="12302">
import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;

public class Main {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		Scanner cin = new Scanner(System.in);
		for(;;){
			int N=Integer.parseInt(cin.nextLine());
			if(N==0)break;
			
			int[][] a = new int[N][2];
			for(int i=0;i<N;i++){
				String[] s =cin.nextLine().split(" ");
				int[] b = new int[s.length-1];
				a[i][0]=Integer.parseInt(s[0]);
				int frame=1;
				for(int j=1;j<s.length;j++){
					b[j-1]=Integer.parseInt(s[j]);
				}
				for(int j=0;j<b.length;){
					if(frame==10){
						a[i][1]+=b[j];
						j++;
						continue;
					}
					a[i][1]+=b[j]+b[j+1];
					if(b[j]==10){
						a[i][1]+=b[j+2];
						j++;
					}
					else{
						if(b[j]+b[j+1]==10){
							a[i][1]+=b[j+2];
						}
						j+=2;

					}
					frame++;
				}
//				System.out.println(a[i][1]);
			}
			Arrays.sort(a,new Comparator<int[]>(){
				public int compare(int[] a,int[] b){
					if(a[1]==b[1]){
						return a[0]-b[0];
					}
					return b[1]-a[1];
				}
			});
			
			for(int i=0;i<N;i++){
				System.out.println(a[i][0]+ " " + a[i][1]);
			}
		}
	}
	
}

</source>
</class>

<class classid="107" nclones="2" nlines="36" similarity="100">
<source file="../hum_codes_raw/s190038159.java" startline="1" endline="43" pcid="6407">

import java.util.Scanner;

//Persistence
public class Main {

	static int[] w;
	static int n, m;
	
	static boolean f(int W){
		int need = 1;
		int s = 0;
		for(int i=0;i<n;i++){
			if(w[i]>W)return false;
			if(s+w[i]>W){
				need++;
				s = 0;
			}
			s+=w[i];
		}
		return need <= m;
	}
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			m = sc.nextInt();
			n = sc.nextInt();
			if((m|n)==0)break;
			w = new int[n];
			for(int i=0;i<n;i++)w[i]=sc.nextInt();
			int l = 1;
			int r = 1500000;
			while(r-l>1){
				int mid = (l+r)/2;
				if(f(mid))r = mid;
				else l = mid;
			}
			System.out.println(f(l)?l:r);
		}
	}
}

</source>
<source file="../hum_codes_raw/s227668620.java" startline="1" endline="42" pcid="7702">
import java.util.Scanner;

//Persistence
public class Main {

	static int[] w;
	static int n, m;
	
	static boolean f(int W){
		int need = 1;
		int s = 0;
		for(int i=0;i<n;i++){
			if(w[i]>W)return false;
			if(s+w[i]>W){
				need++;
				s = 0;
			}
			s+=w[i];
		}
		return need <= m;
	}
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			m = sc.nextInt();
			n = sc.nextInt();
			if((m|n)==0)break;
			w = new int[n];
			for(int i=0;i<n;i++)w[i]=sc.nextInt();
			int l = 1;
			int r = 1500000;
			while(r-l>1){
				int mid = (l+r)/2;
				if(f(mid))r = mid;
				else l = mid;
			}
			System.out.println(f(l)?l:r);
		}
	}
}

</source>
</class>

<class classid="108" nclones="3" nlines="133" similarity="100">
<source file="../hum_codes_raw/s192571646.java" startline="1" endline="143" pcid="6480">
import java.util.*;
import java.io.*;

public class Main {
    private static IO io = new IO();
    private static List<ArrayList<int[]>> g = new ArrayList<>();
    private static int cost[] = new int[10001];
    private static int min[] = new int[10001];
    private static int INF = 1145141919;
    private static PriorityQueue<int[]> que = new PriorityQueue<>(10001, new Comparator<int[]>() {
        public int compare (int a[], int b[]) {
            return a[0]-b[0];
        }
    });
    public static void main(String[] args) {
        while (true) {
            int n = io.nextInt();
            int m = io.nextInt();
            if (n==0 && m==0) break;
            g.clear();
            for (int i=0; i<=n; i++) g.add(new ArrayList<>());
            Arrays.fill(min, INF);
            Arrays.fill(cost, INF);
            min[1] = 0;
            cost[1] = 0;
            for (int i = 0; i < m; i++) {
                int ui = io.nextInt();
                int vi = io.nextInt();
                int di = io.nextInt();
                int ci = io.nextInt();
                g.get(ui).add(new int[] {vi, di, ci});
                g.get(vi).add(new int[] {ui, di, ci});
            }
            int ans = 0;
            que.offer(new int[] {0,0,1});
            while (!que.isEmpty()) {
                int poll[] = que.poll();
                int dis = poll[0];
                int cos = poll[1];
                int now = poll[2];
                if (min[now]<dis) continue;
                for (int i = 0; i < g.get(now).size(); i++) {
                    int go = g.get(now).get(i)[0];
                    int god = g.get(now).get(i)[1];
                    int goc = g.get(now).get(i)[2];
                    if (dis+god<min[go]) {
                        cost[go] = cos + goc;
                        min[go] = dis + god;
                        que.offer(new int[] {min[go], 0, go});
                    } else if (dis+god==min[go]) {
                        cost[go] = Math.min(cost[go], cos + goc);
                        que.offer(new int[] {min[go], 0, go});
                    }
                }
            }
            for (int i = 2; i <= n; i++) ans += cost[i];
            System.out.println(ans);
        }
    }

    static class IO extends PrintWriter {
        private final InputStream in;
        private final byte[] buffer = new byte[1024];
        private int ptr = 0;
        private int buflen = 0;

        IO() {
            this(System.in);
        }

        IO(InputStream source) {
            super(System.out);
            this.in = source;
        }

        boolean hasNextByte() {
            if (ptr < buflen) return true;
            else {
                ptr = 0;
                try {
                    buflen = in.read(buffer);
                } catch (IOException e) {
                    e.printStackTrace();
                }
                if (buflen <= 0) return false;
            }
            return true;
        }

        int readByte() {
            if (hasNextByte()) return buffer[ptr++];
            else return -1;
        }

        boolean isPrintableChar(int c) {
            return 33 <= c && c <= 126;
        }

        void skipUnprintable() {
            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        }

        boolean hasNext() {
            skipUnprintable();
            return hasNextByte();
        }

        long nextLong() {
            if (!hasNext()) throw new NoSuchElementException();
            long n = 0;
            boolean minus = false;
            int b = readByte();
            if (b == '-') {
                minus = true;
                b = readByte();
            }
            if (b < '0' || '9' < b) throw new NumberFormatException();
            while (true) {
                if ('0' <= b && b <= '9') {
                    n *= 10;
                    n += b - '0';
                } else if (b == -1 || !isPrintableChar(b)) return minus ? -n : n;
                else throw new NumberFormatException();
                b = readByte();
            }
        }

        int nextInt() {
            long nl = nextLong();
            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
            return (int) nl;
        }

        public void close() {
            super.close();
            try {
                in.close();
            } catch (IOException ignored) {
            }
        }
    }
}

</source>
<source file="../hum_codes_raw/s698904588.java" startline="1" endline="151" pcid="23504">
import java.util.*;
import java.io.*;

public class Main {
    private static IO io = new IO();
    private static List<ArrayList<int[]>> g = new ArrayList<>();
    private static int cost[] = new int[10001]; // ??????????????????????????
    private static int min[] = new int[10001];  // ???1,i?????????????????
    private static int INF = 1145141919;
    // ??????????????????????????
    private static PriorityQueue<int[]> que = new PriorityQueue<>(10001, new Comparator<int[]>() {
        public int compare (int a[], int b[]) {
            return a[0]-b[0];
        }
    });
    public static void main(String[] args) {
        while (true) {

            int n = io.nextInt();
            int m = io.nextInt();
            if (n==0 && m==0) break;
            // ?????????
            g.clear();
            for (int i=0; i<=n; i++) g.add(new ArrayList<>());
            Arrays.fill(min, INF);
            Arrays.fill(cost, INF);
            min[1] = 0;
            cost[1] = 0;
            // ??\???
            for (int i = 0; i < m; i++) {
                int ui = io.nextInt();
                int vi = io.nextInt();
                int di = io.nextInt();
                int ci = io.nextInt();
                g.get(ui).add(new int[] {vi, di, ci});
                g.get(vi).add(new int[] {ui, di, ci});
            }
            // ??????????????????????????????????&??????????????????????????????????
            int ans = 0;
            que.offer(new int[] {0,0,1});
            while (!que.isEmpty()) {
                int poll[] = que.poll();
                int dis = poll[0];
                int cos = poll[1];
                int now = poll[2];
                // ???????????????????????????????????????????
                if (min[now]<dis) continue;
                // ?????????????\??????????????????????????????????????????????????????????????????????????????
                // ??????????????????????????????????????????????????????????????????????????????????2????????????????????????????????????
                for (int i = 0; i < g.get(now).size(); i++) {
                    int go = g.get(now).get(i)[0];
                    int god = g.get(now).get(i)[1];
                    int goc = g.get(now).get(i)[2];
                    if (dis+god<min[go]) {
                        cost[go] = cos + goc;
                        min[go] = dis + god;
                        que.offer(new int[] {min[go], 0, go});
                    } else if (dis+god==min[go]) {
                        cost[go] = Math.min(cost[go], cos + goc);
                        que.offer(new int[] {min[go], 0, go});
                    }
                }
            }
            for (int i = 2; i <= n; i++) ans += cost[i];
            System.out.println(ans);
        }
    }

    static class IO extends PrintWriter {
        private final InputStream in;
        private final byte[] buffer = new byte[1024];
        private int ptr = 0;
        private int buflen = 0;

        IO() {
            this(System.in);
        }

        IO(InputStream source) {
            super(System.out);
            this.in = source;
        }

        boolean hasNextByte() {
            if (ptr < buflen) return true;
            else {
                ptr = 0;
                try {
                    buflen = in.read(buffer);
                } catch (IOException e) {
                    e.printStackTrace();
                }
                if (buflen <= 0) return false;
            }
            return true;
        }

        int readByte() {
            if (hasNextByte()) return buffer[ptr++];
            else return -1;
        }

        boolean isPrintableChar(int c) {
            return 33 <= c && c <= 126;
        }

        void skipUnprintable() {
            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        }

        boolean hasNext() {
            skipUnprintable();
            return hasNextByte();
        }

        long nextLong() {
            if (!hasNext()) throw new NoSuchElementException();
            long n = 0;
            boolean minus = false;
            int b = readByte();
            if (b == '-') {
                minus = true;
                b = readByte();
            }
            if (b < '0' || '9' < b) throw new NumberFormatException();
            while (true) {
                if ('0' <= b && b <= '9') {
                    n *= 10;
                    n += b - '0';
                } else if (b == -1 || !isPrintableChar(b)) return minus ? -n : n;
                else throw new NumberFormatException();
                b = readByte();
            }
        }

        int nextInt() {
            long nl = nextLong();
            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
            return (int) nl;
        }

        public void close() {
            super.close();
            try {
                in.close();
            } catch (IOException ignored) {
            }
        }
    }
}

</source>
<source file="../hum_codes_raw/s708674639.java" startline="1" endline="156" pcid="23826">
import java.util.*;
import java.io.*;

public class Main {
    private static IO io = new IO();
    private static List<ArrayList<int[]>> g = new ArrayList<>();
    private static int cost[] = new int[10001]; // ??????????????????????????
    private static int min[] = new int[10001];  // ???1,i?????????????????
    private static int INF = 1145141919;
    // ??????????????????????????
    private static PriorityQueue<int[]> que = new PriorityQueue<>(10001, new Comparator<int[]>() {
        public int compare (int a[], int b[]) {
            return a[0]-b[0];	// ?1???????????????????????
        }
    });
    public static void main(String[] args) {
        while (true) {

            int n = io.nextInt();
            int m = io.nextInt();
            if (n==0 && m==0) break;
            // ?????????
            g.clear();
            for (int i=0; i<=n; i++) g.add(new ArrayList<>());
            Arrays.fill(min, INF);
            Arrays.fill(cost, INF);
            min[1] = 0;
            cost[1] = 0;
            // input
            for (int i = 0; i < m; i++) {
                int ui = io.nextInt();
                int vi = io.nextInt();
                int di = io.nextInt();
                int ci = io.nextInt();
                g.get(ui).add(new int[] {vi, di, ci});
                g.get(vi).add(new int[] {ui, di, ci});
            }
            // ??????????????????????????????????&??????????????????????????????????
            int ans = 0;
            que.offer(new int[] {0,0,1});
            while (!que.isEmpty()) {
                int poll[] = que.poll();
                int dis = poll[0];
                int cos = poll[1];
                int now = poll[2];
                // ???????????????????????????????????????????
                if (min[now]<dis) continue;
                // ?????????????\??????????????????????????????????????????????????????????????????????????????
                // ??????????????????????????????????????????????????????????????????????????????????2????????????????????????????????????
                for (int i = 0; i < g.get(now).size(); i++) {
                    int go = g.get(now).get(i)[0];
                    int god = g.get(now).get(i)[1];
                    int goc = g.get(now).get(i)[2];
                    if (dis+god<min[go]) {
                        cost[go] = cos + goc;
                        min[go] = dis + god;
                        que.offer(new int[] {min[go], 0, go});
                        //System.out.println(now + "??????" + go + "?????????");
                        //System.out.println("1???" + go + "???????????????" + cost[go] + "?????????????");
                    } else if (dis+god==min[go]) {
                        cost[go] = Math.min(cost[go], cos + goc);
                        que.offer(new int[] {min[go], 0, go});
                        //System.out.println(now + "??????" + go + "?????????");
                        //System.out.println("1???" + go + "???????????????" + cost[go] + "?????????????");
                    }
                }
            }
            for (int i = 2; i <= n; i++) ans += cost[i];
            System.out.println(ans);
            //System.out.println(Arrays.toString(cost));
        }
    }

    static class IO extends PrintWriter {
        private final InputStream in;
        private final byte[] buffer = new byte[1024];
        private int ptr = 0;
        private int buflen = 0;

        IO() {
            this(System.in);
        }

        IO(InputStream source) {
            super(System.out);
            this.in = source;
        }

        boolean hasNextByte() {
            if (ptr < buflen) return true;
            else {
                ptr = 0;
                try {
                    buflen = in.read(buffer);
                } catch (IOException e) {
                    e.printStackTrace();
                }
                if (buflen <= 0) return false;
            }
            return true;
        }

        int readByte() {
            if (hasNextByte()) return buffer[ptr++];
            else return -1;
        }

        boolean isPrintableChar(int c) {
            return 33 <= c && c <= 126;
        }

        void skipUnprintable() {
            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        }

        boolean hasNext() {
            skipUnprintable();
            return hasNextByte();
        }

        long nextLong() {
            if (!hasNext()) throw new NoSuchElementException();
            long n = 0;
            boolean minus = false;
            int b = readByte();
            if (b == '-') {
                minus = true;
                b = readByte();
            }
            if (b < '0' || '9' < b) throw new NumberFormatException();
            while (true) {
                if ('0' <= b && b <= '9') {
                    n *= 10;
                    n += b - '0';
                } else if (b == -1 || !isPrintableChar(b)) return minus ? -n : n;
                else throw new NumberFormatException();
                b = readByte();
            }
        }

        int nextInt() {
            long nl = nextLong();
            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
            return (int) nl;
        }

        public void close() {
            super.close();
            try {
                in.close();
            } catch (IOException ignored) {
            }
        }
    }
}

</source>
</class>

<class classid="109" nclones="2" nlines="14" similarity="100">
<source file="../hum_codes_raw/s192590654.java" startline="1" endline="15" pcid="6481">
import java.util.Scanner;
 
public class Main {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int a = sc.nextInt();
        int b = sc.nextInt();
        if (a%3 == 0 || b%3 == 0 || (a+b) % 3 == 0) {
            System.out.println("Possible");
        } else {
            System.out.println("Impossible");
        }
    }
}

</source>
<source file="../hum_codes_raw/s574808787.java" startline="1" endline="17" pcid="19321">
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int a = sc.nextInt();
        int b = sc.nextInt();

        if (a % 3 == 0 || b % 3 == 0 || (a + b) % 3 == 0) {
            System.out.println("Possible");
        } else {
            System.out.println("Impossible");
        }
    }
}

</source>
</class>

<class classid="110" nclones="2" nlines="45" similarity="100">
<source file="../hum_codes_raw/s194476548.java" startline="1" endline="48" pcid="6548">
import java.util.Scanner;

//Altair and Vega
public class Main{

	public static class Point {
		public double x;
		public double y;
		public Point(double x_, double y_) {
			x = x_; y=y_;
		}
	}
	public static Point sub(Point p1, Point p2) {
		return new Point(p1.x-p2.x, p1.y-p2.y);
	}
	public static double extp(Point p1, Point p2) {
		return p1.x*p2.y - p2.x*p1.y;
	}
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int t = sc.nextInt();
		while(t--!=0){
			Point[] p = new Point[3];
			for(int i=0;i<3;i++)p[i]=new Point(sc.nextDouble(), sc.nextDouble());
			Point p1 = new Point(sc.nextDouble(), sc.nextDouble());
			Point p2 = new Point(sc.nextDouble(), sc.nextDouble());
			boolean in1 = false;
			boolean in2 = false;
			boolean right = true;
			boolean left = true;
			boolean right2 = true;
			boolean left2 = true;
			for(int i=0;i<3;i++){
				Point base = sub(p[(i+1)%3], p[i]);
				Point bec = sub(p1, p[i]);
				Point bec2 = sub(p2, p[i]);
				if(extp(base, bec)<0) left = false;
				else right = false;
				if(extp(base, bec2)<0) left2 = false;
				else right2 = false;
			}
			in1 = left|right;
			in2 = left2|right2;
			System.out.println(in1!=in2?"OK":"NG");
		}
	}
}

</source>
<source file="../hum_codes_raw/s544941511.java" startline="1" endline="48" pcid="18362">
import java.util.Scanner;

//Altair and Vega
public class Main {

	public static class Point {
		public double x;
		public double y;
		public Point(double x_, double y_) {
			x = x_; y=y_;
		}
	}
	public static Point sub(Point p1, Point p2) {
		return new Point(p1.x-p2.x, p1.y-p2.y);
	}
	public static double extp(Point p1, Point p2) {
		return p1.x*p2.y - p2.x*p1.y;
	}
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int t = sc.nextInt();
		while(t--!=0){
			Point[] p = new Point[3];
			for(int i=0;i<3;i++)p[i]=new Point(sc.nextDouble(), sc.nextDouble());
			Point p1 = new Point(sc.nextDouble(), sc.nextDouble());
			Point p2 = new Point(sc.nextDouble(), sc.nextDouble());
			boolean in1 = false;
			boolean in2 = false;
			boolean right = true;
			boolean left = true;
			boolean right2 = true;
			boolean left2 = true;
			for(int i=0;i<3;i++){
				Point base = sub(p[(i+1)%3], p[i]);
				Point bec = sub(p1, p[i]);
				Point bec2 = sub(p2, p[i]);
				if(extp(base, bec)<0) left = false;
				else right = false;
				if(extp(base, bec2)<0) left2 = false;
				else right2 = false;
			}
			in1 = left|right;
			in2 = left2|right2;
			System.out.println(in1!=in2?"OK":"NG");
		}
	}
}

</source>
</class>

<class classid="111" nclones="2" nlines="81" similarity="100">
<source file="../hum_codes_raw/s196089839.java" startline="1" endline="87" pcid="6612">
import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;
 
class Main {
	public static void main(String[] args) {
		new Main().run();
	}
 
	void run() {
		Scanner sc = new Scanner(System.in);
		long[] p1 = { sc.nextLong(), sc.nextLong() };
		long[] p2 = { sc.nextLong(), sc.nextLong() };
		if (p1[0] > p2[0]) {
			long[] tmp = p1;
			p1 = p2;
			p2=tmp;
		}
		int coe = 1;
		if (p1[1] > p2[1]) {
			coe = -1;
			p1[1] *= coe;
			p2[1] *= coe;
		}
		int n = sc.nextInt();
		long[][] p = new long[n][2];
		for (int i = 0; i < n; ++i) {
			p[i][0] = sc.nextLong();
			p[i][1] = sc.nextLong() * coe;
		}
		Arrays.sort(p, new Comparator<long[]>() {
			@Override
			public int compare(long[] o1, long[] o2) {
				return Long.compare(o1[0], o2[0]);
			}
		});
		int sz = 0;
		for (int i = 0; i < n; ++i) {
			if (p1[0] <= p[i][0] && p[i][0] <= p2[0] && p1[1] <= p[i][1] && p[i][1] <= p2[1])
				++sz;
		}
		long[] a = new long[sz];
		sz = 0;
		for (int i = 0; i < n; ++i) {
			if (p1[0] <= p[i][0] && p[i][0] <= p2[0] && p1[1] <= p[i][1] && p[i][1] <= p2[1]) {
				a[sz++] = p[i][1];
			}
		}
		long lis = LIS(a.length, a);
		double ans = (p2[0] - p1[0] + p2[1] - p1[1]) * 100 + (Math.PI * 5 - 20) * lis;
		if (lis == Math.min(p2[0] - p1[0] + 1, p2[1] - p1[1] + 1))
			ans += Math.PI * 5;
		System.out.println(String.format("%.20f", ans));
	}
 
	long LIS(int n, long[] a) {
		long[] f = new long[n];
		int sz = 0;
		for (int i = 0; i < n; ++i) {
			if (sz == 0) {
				f[sz] = a[0];
				++sz;
			} else {
				int ok = -1;
				int ng = sz;
				while (ng - ok > 1) {
					int middle = (ok + ng) / 2;
					if (f[middle] < a[i]) {
						ok = middle;
					} else {
						ng = middle;
					}
				}
 
				f[ok + 1] = a[i];
				if (ok + 1 == sz)
					++sz;
			}
		}
		return sz;
	}
 
	void tr(Object... objects) {
		System.out.println(Arrays.deepToString(objects));
	}
}

</source>
<source file="../hum_codes_raw/s318994732.java" startline="1" endline="87" pcid="10703">
import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;

class Main {
	public static void main(String[] args) {
		new Main().run();
	}

	void run() {
		Scanner sc = new Scanner(System.in);
		long[] p1 = { sc.nextLong(), sc.nextLong() };
		long[] p2 = { sc.nextLong(), sc.nextLong() };
		if (p1[0] > p2[0]) {
			long[] tmp = p1;
			p1 = p2;
			p2=tmp;
		}
		int coe = 1;
		if (p1[1] > p2[1]) {
			coe = -1;
			p1[1] *= coe;
			p2[1] *= coe;
		}
		int n = sc.nextInt();
		long[][] p = new long[n][2];
		for (int i = 0; i < n; ++i) {
			p[i][0] = sc.nextLong();
			p[i][1] = sc.nextLong() * coe;
		}
		Arrays.sort(p, new Comparator<long[]>() {
			@Override
			public int compare(long[] o1, long[] o2) {
				return Long.compare(o1[0], o2[0]);
			}
		});
		int sz = 0;
		for (int i = 0; i < n; ++i) {
			if (p1[0] <= p[i][0] && p[i][0] <= p2[0] && p1[1] <= p[i][1] && p[i][1] <= p2[1])
				++sz;
		}
		long[] a = new long[sz];
		sz = 0;
		for (int i = 0; i < n; ++i) {
			if (p1[0] <= p[i][0] && p[i][0] <= p2[0] && p1[1] <= p[i][1] && p[i][1] <= p2[1]) {
				a[sz++] = p[i][1];
			}
		}
		long lis = LIS(a.length, a);
		double ans = (p2[0] - p1[0] + p2[1] - p1[1]) * 100 + (Math.PI * 5 - 20) * lis;
		if (lis == Math.min(p2[0] - p1[0] + 1, p2[1] - p1[1] + 1))
			ans += Math.PI * 5;
		System.out.println(String.format("%.20f", ans));
	}

	long LIS(int n, long[] a) {
		long[] f = new long[n];
		int sz = 0;
		for (int i = 0; i < n; ++i) {
			if (sz == 0) {
				f[sz] = a[0];
				++sz;
			} else {
				int ok = -1;
				int ng = sz;
				while (ng - ok > 1) {
					int middle = (ok + ng) / 2;
					if (f[middle] < a[i]) {
						ok = middle;
					} else {
						ng = middle;
					}
				}

				f[ok + 1] = a[i];
				if (ok + 1 == sz)
					++sz;
			}
		}
		return sz;
	}

	void tr(Object... objects) {
		System.out.println(Arrays.deepToString(objects));
	}
}

</source>
</class>

<class classid="112" nclones="2" nlines="34" similarity="100">
<source file="../hum_codes_raw/s196107800.java" startline="1" endline="35" pcid="6613">
import java.util.Scanner;
public class Main {
	public static void main(String args[]){
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int m = sc.nextInt();
		int a[] = new int[n];//?????????????
		int b[] = new int[m];//????????????
		int cnt[] = new int[n];//????????????
		int max = 0, idx = 0;//??????????????????????????????????
		for(int i = 0;i < n;i++){
			a[i] = sc.nextInt();
			cnt[i] = 0;//????????????????????????
		}
		for(int i = 0;i < m;i++){
			b[i] = sc.nextInt();
		}
		for(int i = 0;i < m;i++){
			for(int k = 0;k < n;k++){
				if(a[k] <= b[i]){
					cnt[k]++;
					break;
				}
			}
		}
		for(int i = 0;i < n;i++){
			if(max < cnt[i]){
				max = cnt[i];
				idx = i;
			}
		}
		System.out.println(idx + 1);
	}
}

</source>
<source file="../hum_codes_raw/s318845272.java" startline="1" endline="35" pcid="10699">
import java.util.Scanner;
public class Main {
	public static void main(String args[]){
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int m = sc.nextInt();
		int a[] = new int[n];//?????????????
		int b[] = new int[m];//????????????
		int cnt[] = new int[n];//????????????
		int max = 0, idx = 0;//??????????????????????????????????
		for(int i = 0;i < n;i++){
			a[i] = sc.nextInt();
			cnt[i] = 0;//????????????????????????
		}
		for(int i = 0;i < m;i++){
			b[i] = sc.nextInt();
		}
		for(int i = 0;i < m;i++){
			for(int k = 0;k < n;k++){
				if(a[k] <= b[i]){
					cnt[k]++;
					break;
				}
			}
		}
		for(int i = 0;i < n;i++){
			if(max < cnt[i]){
				max = cnt[i];
				idx = i;
			}
		}
		System.out.println(idx + 1);
	}
}

</source>
</class>

<class classid="113" nclones="2" nlines="14" similarity="100">
<source file="../hum_codes_raw/s197501754.java" startline="1" endline="14" pcid="6662">
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
      Scanner sc = new Scanner(System.in);
      int n = sc.nextInt();
      int r = sc.nextInt();
      if(n>=10){
      	System.out.println(r);
      }else{
        System.out.println(r+100*(10-n));
      }
    }
}

</source>
<source file="../hum_codes_raw/s621888968.java" startline="1" endline="18" pcid="20885">
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int r = sc.nextInt();
		if (n >= 10) {
			System.out.println(r);
		} else {
			System.out.println(r + 100 * (10 - n));
		}

	}

}

</source>
</class>

<class classid="114" nclones="2" nlines="32" similarity="100">
<source file="../hum_codes_raw/s198093778.java" startline="1" endline="46" pcid="6669">
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Scanner;

/**
 * Created by shoya on 2017/04/12.
 */
public class Main {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        String str1 = sc.next();
        String str2 = sc.next();
        PrintWriter pwout = new PrintWriter(System.out);
        for(Integer i : rabinKarp(str2, str1))
            pwout.println(i);
        pwout.flush();
        return;
    }

    static ArrayList<Integer> rabinKarp(String str1, String str2){
        ArrayList<Integer> list = new ArrayList<>();
        if (str1.length() > str2.length())
            return list;

        final long RADIX = Long.parseUnsignedLong("100000007");
        long t = 1, str1hash = 0, str2hash = 0;
        for (int i = 0; i < str1.length(); i++) {
            t *= RADIX;
            str1hash = str1hash * RADIX + str1.charAt(i);
            str2hash = str2hash * RADIX + str2.charAt(i);
        }
        for (int i = 0; i + str1.length() <= str2.length(); i++) {
            //System.out.println(Long.toUnsignedString(str1hash));
            //System.out.println(Long.toUnsignedString(str2hash));
            //System.out.println();
            if (str1hash == str2hash)
                list.add(i);
            if (i + str1.length() < str2.length()) {
                str2hash = str2hash * RADIX + str2.charAt(i + str1.length()) - str2.charAt(i) * t;
                //System.out.println(Long.toUnsignedString(str2hash));
            }
        }
        return list;
    }
}

</source>
<source file="../hum_codes_raw/s608386792.java" startline="1" endline="46" pcid="20447">
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Scanner;

/**
 * Created by shoya on 2017/04/12.
 */
public class Main {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        String str1 = sc.next();
        String str2 = sc.next();
        PrintWriter pwout = new PrintWriter(System.out);
        for(Integer i : rabinKarp(str2, str1))
            pwout.println(i);
        pwout.flush();
        return;
    }

    static ArrayList<Integer> rabinKarp(String str1, String str2){
        ArrayList<Integer> list = new ArrayList<>();
        if (str1.length() > str2.length())
            return list;

        final long RADIX = Long.parseUnsignedLong("100000007");
        long t = 1, str1hash = 0, str2hash = 0;
        for (int i = 0; i < str1.length(); i++) {
            t *= RADIX;
            str1hash = str1hash * RADIX + str1.charAt(i);
            str2hash = str2hash * RADIX + str2.charAt(i);
        }
        for (int i = 0; i + str1.length() <= str2.length(); i++) {
            //System.out.println(Long.toUnsignedString(str1hash));
            //System.out.println(Long.toUnsignedString(str2hash));
            //System.out.println();
            if (str1hash == str2hash)
                list.add(i);
            if (i + str1.length() < str2.length()) {
                str2hash = str2hash * RADIX + str2.charAt(i + str1.length()) - str2.charAt(i) * t;
                //System.out.println(Long.toUnsignedString(str2hash));
            }
        }
        return list;
    }
}

</source>
</class>

<class classid="115" nclones="2" nlines="85" similarity="100">
<source file="../hum_codes_raw/s199319317.java" startline="1" endline="106" pcid="6717">
import java.awt.geom.AffineTransform;
import java.awt.geom.Point2D;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] tmpArray = br.readLine().split(" ");
        double px1 = Double.parseDouble(tmpArray[0]);
        double py1 = Double.parseDouble(tmpArray[1]);
        double px2 = Double.parseDouble(tmpArray[2]);
        double py2 = Double.parseDouble(tmpArray[3]);
        
        Point2D p1 = new Point2D.Double(px1, py1);
        Point2D p2 = new Point2D.Double(px2, py2);
        
        int q = Integer.parseInt(br.readLine());
        
        for(int i = 0; i < q; i++) {
            tmpArray = br.readLine().split(" ");
            double x = Double.parseDouble(tmpArray[0]);
            double y = Double.parseDouble(tmpArray[1]);
            
            Point2D p = new Point2D.Double(x, y);
            
            int result = checkClockwise(p, p1, p2);
            
            switch(result) {
                case COUNTER_CLOCKWISE:
                    System.out.println("COUNTER_CLOCKWISE");
                    break;
                
                case CLOCKWISE:
                    System.out.println("CLOCKWISE");
                    break;
                
                case ONLINE_BACK:
                    System.out.println("ONLINE_BACK");
                    break;
                
                case ONLINE_FRONT:
                    System.out.println("ONLINE_FRONT");
                    break;
                
                case ON_SEGMENT:
                    System.out.println("ON_SEGMENT");
                    break;
                    
                default:
                    break;
            }
        }
    }
    
    static final int COUNTER_CLOCKWISE = 1;
    static final int CLOCKWISE         = 2;
    static final int ONLINE_BACK       = 3;
    static final int ONLINE_FRONT      = 4;
    static final int ON_SEGMENT        = 5;
    static final double EPS            = 0.00000001;
    
    //p1, p2p
    static int checkClockwise(Point2D p, Point2D p1, Point2D p2) {
        if(p1.getX() > p2.getX() || (p1.getX() == p2.getX() && p1.getY() > p2.getY())) {
            AffineTransform rotate = AffineTransform.getQuadrantRotateInstance(2);
            Point2D tmp = null;
            p  = rotate.transform(p , tmp);
            p1 = rotate.transform(p1, tmp);
            p2 = rotate.transform(p2, tmp);
        }
        double theta = Math.PI / 2;
        
        //90
        if(p1.getX() != p2.getX()) {
            theta = Math.atan((p1.getY() - p2.getY()) / (p1.getX() - p2.getX()));
        }
        
        AffineTransform affine;
        affine = AffineTransform.getRotateInstance(-theta);
        affine.concatenate(AffineTransform.getTranslateInstance(-p1.getX(), -p1.getY()));
        Point2D pD = new Point2D.Double();
        pD = affine.transform(p, pD);
        Point2D p2D = new Point2D.Double();
        p2D = affine.transform(p2, p2D);
        
        if(pD.getY() > EPS) {
            return COUNTER_CLOCKWISE;
        }
        else if(pD.getY() < -EPS) {
            return CLOCKWISE;
        }
        else if(pD.getX() < 0) {
            return ONLINE_BACK;
        }
        else if(pD.getX() > p2D.getX()) {
            return ONLINE_FRONT;
        }
        else {
            return ON_SEGMENT;
        }
    }   
    
}

</source>
<source file="../hum_codes_raw/s778145644.java" startline="1" endline="119" pcid="26130">

import java.awt.geom.AffineTransform;
import java.awt.geom.Point2D;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

		String[] tmpArray = br.readLine().split(" ");
		double px1 = Double.parseDouble(tmpArray[0]);
		double py1 = Double.parseDouble(tmpArray[1]);
		double px2 = Double.parseDouble(tmpArray[2]);
		double py2 = Double.parseDouble(tmpArray[3]);

		Point2D p1 = new Point2D.Double(px1, py1);
		Point2D p2 = new Point2D.Double(px2, py2);

		int q = Integer.parseInt(br.readLine());

		for(int i = 0; i < q; i++){
			tmpArray = br.readLine().split(" ");
			double x = Double.parseDouble(tmpArray[0]);
			double y = Double.parseDouble(tmpArray[1]);

			Point2D p = new Point2D.Double(x,y);

			int result = checkClockwise(p, p1, p2);

			switch (result) {
			case COUNTER_CLOCKWISE:
				System.out.println("COUNTER_CLOCKWISE");
				break;

			case CLOCKWISE:
				System.out.println("CLOCKWISE");
				break;

			case ONLINE_BACK:
				System.out.println("ONLINE_BACK");
				break;

			case ONLINE_FRONT:
				System.out.println("ONLINE_FRONT");
				break;

			case ON_SEGMENT:
				System.out.println("ON_SEGMENT");
				break;

			default:
				break;
			}
		}

	}

	static final int COUNTER_CLOCKWISE = 1;
	static final int CLOCKWISE = 2;
	static final int ONLINE_BACK = 3;
	static final int ONLINE_FRONT = 4;
	static final int ON_SEGMENT = 5;
	static final double EPS = 0.00000001;

	//p1,p2p
	static int checkClockwise(Point2D p, Point2D p1, Point2D p2){
		if(p1.getX() > p2.getX() || (p1.getX() == p2.getX() && p1.getY() > p2.getY())){
			AffineTransform rotate = AffineTransform.getQuadrantRotateInstance(2);
			Point2D tmp = null;
			p = rotate.transform(p, tmp);
			p1 = rotate.transform(p1, tmp);
			p2 = rotate.transform(p2, tmp);

//			System.out.println(p);
		}

		double theta = Math.PI/2;

		//90
		if(p1.getX() != p2.getX()){
			theta = Math.atan((p1.getY() - p2.getY()) / (p1.getX() - p2.getX()));
		}


		AffineTransform affine;// = AffineTransform.getTranslateInstance(p1.getX(), p1.getY());
//		affine.concatenate(AffineTransform.getRotateInstance(theta));
//		affine.concatenate(new AffineTransform(1, 0, 0, -1, 0, 0));
		affine = AffineTransform.getRotateInstance(-theta);
		affine.concatenate(AffineTransform.getTranslateInstance(-p1.getX(), -p1.getY()));

		Point2D pD = new Point2D.Double();
		pD = affine.transform(p, pD);
		Point2D p2D = new Point2D.Double();
		p2D = affine.transform(p2, p2D);

		if(pD.getY() > EPS){
			return COUNTER_CLOCKWISE;
		}
		else if(pD.getY() < -EPS){
			return CLOCKWISE;
		}
		else if(pD.getX() < 0){
			return ONLINE_BACK;
		}
		else if(pD.getX() > p2D.getX()){
			return ONLINE_FRONT;
		}
		else {
			return ON_SEGMENT;
		}

	}

}


</source>
</class>

<class classid="116" nclones="2" nlines="32" similarity="100">
<source file="../hum_codes_raw/s199979698.java" startline="1" endline="39" pcid="6739">
import java.util.Scanner;

//Search
public class Main{

	static int c;
	static int[] a;

	static int comp(int k, int x){
		c++;
		return a[k]-x;
	}

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int n = sc.nextInt();
			if(n==0)break;
			a = new int[n];
			for(int i=0;i<n;i++)a[i]=sc.nextInt();
			int x = sc.nextInt();
			c = 0;
			int l = 0;
			int r = n-1;
			int k = (l+r)/2;
			while(l<=r){
//				System.out.println("K: " + k + " L:" + l + " R:" + r);
				int com = comp(k, x);
				if(r<=l)break;
				if(com<0)l=k+1;
				else if(com>0)r=k-1;
				else break;
				k=(l+r)/2;
			}
			System.out.println(c);
		}
	}
}

</source>
<source file="../hum_codes_raw/s289066775.java" startline="1" endline="38" pcid="9678">
import java.util.Scanner;

//Search
public class Main {

	static int c;
	static int[] a;

	static int comp(int k, int x){
		c++;
		return a[k]-x;
	}

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int n = sc.nextInt();
			if(n==0)break;
			a = new int[n];
			for(int i=0;i<n;i++)a[i]=sc.nextInt();
			int x = sc.nextInt();
			c = 0;
			int l = 0;
			int r = n-1;
			int k = (l+r)/2;
			while(l<=r){
				int com = comp(k, x);
				if(r<=l)break;
				if(com<0)l=k+1;
				else if(com>0)r=k-1;
				else break;
				k=(l+r)/2;
			}
			System.out.println(c);
		}
	}
}

</source>
</class>

<class classid="117" nclones="2" nlines="44" similarity="100">
<source file="../hum_codes_raw/s200353596.java" startline="1" endline="58" pcid="6754">
import java.util.*;
import java.util.regex.*;

class Main{
	private final static Pattern addsubmuldiv = Pattern.compile("^(.*?)(-?\\d+)([+Z*/])(-?\\d+)(.*)$");
	private final static Pattern addsub = Pattern.compile("^(.*?)(-?\\d+)([+Z])(-?\\d+)(.*)$");
	private final static Pattern muldiv = Pattern.compile("^(.*?)(-?\\d+)([*/])(-?\\d+)(.*)$");

	private static String process(String s){
		Matcher m=muldiv.matcher(s);
		while(m.find()){
			if(m.group(3).equals("*"))
				s=m.group(1)+(Integer.parseInt(m.group(2))*Integer.parseInt(m.group(4)))+m.group(5);
			else
				s=m.group(1)+(Integer.parseInt(m.group(2))/Integer.parseInt(m.group(4)))+m.group(5);
			m=muldiv.matcher(s);
		}

		m=addsub.matcher(s);
		while(m.find()){
			if(m.group(3).equals("+"))
				s=m.group(1)+(Integer.parseInt(m.group(2))+Integer.parseInt(m.group(4)))+m.group(5);
			else
				s=m.group(1)+(Integer.parseInt(m.group(2))-Integer.parseInt(m.group(4)))+m.group(5);
			m=addsub.matcher(s);
		}
		return s;
	}

	private static String process2(String s){
		Matcher m=addsubmuldiv.matcher(s);
		while(m.find()){
			if(m.group(3).equals("*"))
				s=m.group(1)+(Integer.parseInt(m.group(2))*Integer.parseInt(m.group(4)))+m.group(5);
			else if(m.group(3).equals("/"))
				s=m.group(1)+(Integer.parseInt(m.group(2))/Integer.parseInt(m.group(4)))+m.group(5);
			else if(m.group(3).equals("+"))
				s=m.group(1)+(Integer.parseInt(m.group(2))+Integer.parseInt(m.group(4)))+m.group(5);
			else
				s=m.group(1)+(Integer.parseInt(m.group(2))-Integer.parseInt(m.group(4)))+m.group(5);
			m=addsubmuldiv.matcher(s);
		}
		return s;
	}

	public static void main(String[]z){
		Scanner x=new Scanner(System.in);
		String s=x.next().replaceAll("-","Z");
		String ans=x.next();
		boolean a=process(s).equals(ans);
		boolean b=process2(s).equals(ans);
		if(a&&b)System.out.println("U");
		if(a&&!b)System.out.println("M");
		if(!a&&b)System.out.println("L");
		if(!a&&!b)System.out.println("I");
	}
}

</source>
<source file="../hum_codes_raw/s771420354.java" startline="1" endline="58" pcid="25897">
import java.util.*;
import java.util.regex.*;

class Main{
	private final static Pattern addsubmuldiv = Pattern.compile("^(.*?)(-?\\d+)([+Z*/])(-?\\d+)(.*)$");
	private final static Pattern addsub = Pattern.compile("^(.*?)(-?\\d+)([+Z])(-?\\d+)(.*)$");
	private final static Pattern muldiv = Pattern.compile("^(.*?)(-?\\d+)([*/])(-?\\d+)(.*)$");

	private static String process(String s){
		Matcher m=muldiv.matcher(s);
		while(m.find()){
			if(m.group(3).equals("*"))
				s=m.group(1)+(Integer.parseInt(m.group(2))*Integer.parseInt(m.group(4)))+m.group(5);
			else
				s=m.group(1)+(Integer.parseInt(m.group(2))/Integer.parseInt(m.group(4)))+m.group(5);
			m=muldiv.matcher(s);
		}

		m=addsub.matcher(s);
		while(m.find()){
			if(m.group(3).equals("+"))
				s=m.group(1)+(Integer.parseInt(m.group(2))+Integer.parseInt(m.group(4)))+m.group(5);
			else
				s=m.group(1)+(Integer.parseInt(m.group(2))-Integer.parseInt(m.group(4)))+m.group(5);
			m=addsub.matcher(s);
		}
		return s;
	}

	private static String process2(String s){
		Matcher m=addsubmuldiv.matcher(s);
		while(m.find()){
			if(m.group(3).equals("*"))
				s=m.group(1)+(Integer.parseInt(m.group(2))*Integer.parseInt(m.group(4)))+m.group(5);
			else if(m.group(3).equals("/"))
				s=m.group(1)+(Integer.parseInt(m.group(2))/Integer.parseInt(m.group(4)))+m.group(5);
			else if(m.group(3).equals("+"))
				s=m.group(1)+(Integer.parseInt(m.group(2))+Integer.parseInt(m.group(4)))+m.group(5);
			else
				s=m.group(1)+(Integer.parseInt(m.group(2))-Integer.parseInt(m.group(4)))+m.group(5);
			m=addsubmuldiv.matcher(s);
		}
		return s;
	}

	public static void main(String[]z){
		Scanner x=new Scanner(System.in);
		String s=x.next().replaceAll("-","Z");
		String ans=x.next();
		boolean a=process(s).equals(ans);
		boolean b=process2(s).equals(ans);
		if(a&&b)System.out.println("U");
		if(a&&!b)System.out.println("M");
		if(!a&&b)System.out.println("L");
		if(!a&&!b)System.out.println("I");
	}
}

</source>
</class>

<class classid="118" nclones="2" nlines="186" similarity="100">
<source file="../hum_codes_raw/s200363083.java" startline="1" endline="201" pcid="6755">
import java.io.*;
import java.util.*;
import java.util.Map.Entry;
import java.util.stream.Collectors;

@SuppressWarnings("unused")
public class Main {
	
	//final boolean isDebug = true;
	final boolean isDebug = false;
	String fileName = "input.txt";
	FastScanner sc;
	PrintWriter out;
	final int MOD = (int)1e9+7;
	//final int INF = Integer.MAX_VALUE / 2;
	final long INF = Long.MAX_VALUE / 2;
	
	void solve() throws Exception{
		Scanner scanner = new Scanner(System.in);
		while(scanner.hasNext()){
			String S = scanner.next();
			if(S == null) break;
			int[] num = new int[10];
			for(int i = 0; i < S.length(); i++) num[S.charAt(i) - '0']++;
			
			ArrayList<Integer> ans = new ArrayList<>();
			for(int i = 1; i <= 9; i++){
				int[] tehai = Arrays.copyOf(num, num.length);
				tehai[i]++;
				if(tehai[i] == 5) continue;
				if(canTitoi(Arrays.copyOf(tehai, tehai.length)) || can1(Arrays.copyOf(tehai, tehai.length))) ans.add(i);
			}
			
			if(ans.isEmpty()) System.out.println(0);
			else{
				for(int i = 0; i < ans.size(); i++){
					System.out.print(ans.get(i) + (i == ans.size()-1 ? "\n" : " "));
				}
			}
		}
		scanner.close();
 	}
	
	
	
	boolean canTitoi(int[] tehai){
		int sum = 0;
		for(int i = 1; i <= 9; i++){
			if(tehai[i] == 2) sum++;
			else if(tehai[i] != 0) return false;
		}
		return sum == 7;
	}
	
	boolean can1(int[] tehai){
		for(int i = 1; i <= 9; i++){
			if(tehai[i] < 2) continue;
			int[] t = Arrays.copyOf(tehai, tehai.length);
			t[i] -= 2;
			if(can4(t)) return true;
		}
		return false;
	}
	
	boolean can4(int[] tehai){
		int sumAll = 0;
		for(int i = 1; i <= 9; i++){
			sumAll += tehai[i];
			if(tehai[i] >= 3){
				int[] t = Arrays.copyOf(tehai, tehai.length);
				t[i] -= 3;
				if(can4(t)) return true;
			}
			if(i <= 7 && tehai[i] >= 1 && tehai[i+1] >= 1 && tehai[i+2] >= 1){
				int[] t = Arrays.copyOf(tehai, tehai.length);
				t[i]--; t[i+1]--; t[i+2]--;
				if(can4(t)) return true;
			}
		}
		return sumAll == 0;
	}
	
	/* end solve */
	
	/* main */
	public static void main(String[] args) throws Exception {
		new Main().m();
	}
	
	void m() throws Exception {
		long S = System.currentTimeMillis();
		sc = (isDebug) ? new FastScanner(new FileInputStream(fileName)) : new FastScanner(System.in);
		out = new PrintWriter(System.out);
		solve();
		out.flush();
		long G = System.currentTimeMillis();
		if(isDebug){
			System.out.println("---Debug---");
			System.out.printf("%8d ms\n", (G-S));
		}
	}
	/* end main */
}
/* end Main */

class Pair{
	int x;
	long d;
	public Pair(int x, long d){this.x = x; this.d = d;}
}

class FastScanner {
    private InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;
    public FastScanner(InputStream in) {
		this.in = in;
	}
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() {
    	if (hasNextByte()) return buffer[ptr++];
    	else return -1;
    }
    private static boolean isPrintableChar(int c){
    	return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
    	while(hasNextByte() && !isPrintableChar(buffer[ptr]))
    		ptr++; return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
    public String nextLine() {
        if (!hasNext()) throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(b != 10) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
    public long nextLong() {
        if (!hasNext()) throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while(true){
            if ('0' <= b && b <= '9') {
                n *= 10;
                n += b - '0';
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
    	return Double.parseDouble(next());
    }
}


</source>
<source file="../hum_codes_raw/s749602919.java" startline="1" endline="201" pcid="25183">
import java.io.*;
import java.util.*;
import java.util.Map.Entry;
import java.util.stream.Collectors;

@SuppressWarnings("unused")
public class Main {
	
	//final boolean isDebug = true;
	final boolean isDebug = false;
	String fileName = "input.txt";
	FastScanner sc;
	PrintWriter out;
	final int MOD = (int)1e9+7;
	//final int INF = Integer.MAX_VALUE / 2;
	final long INF = Long.MAX_VALUE / 2;
	
	void solve() throws Exception{
		Scanner scanner = new Scanner(System.in);
		while(scanner.hasNext()){
			String S = scanner.next();
			if(S == null) break;
			int[] num = new int[10];
			for(int i = 0; i < S.length(); i++) num[S.charAt(i) - '0']++;
			
			ArrayList<Integer> ans = new ArrayList<>();
			for(int i = 1; i <= 9; i++){
				int[] tehai = Arrays.copyOf(num, num.length);
				tehai[i]++;
				if(tehai[i] == 5) continue;
				if(canTitoi(Arrays.copyOf(tehai, tehai.length)) || can1(Arrays.copyOf(tehai, tehai.length))) ans.add(i);
			}
			
			if(ans.isEmpty()) System.out.println(0);
			else{
				for(int i = 0; i < ans.size(); i++){
					System.out.print(ans.get(i) + (i == ans.size()-1 ? "\n" : " "));
				}
			}
		}
		scanner.close();
 	}
	
	
	
	boolean canTitoi(int[] tehai){
		int sum = 0;
		for(int i = 1; i <= 9; i++){
			if(tehai[i] == 2) sum++;
			else if(tehai[i] != 0) return false;
		}
		return sum == 7;
	}
	
	boolean can1(int[] tehai){
		for(int i = 1; i <= 9; i++){
			if(tehai[i] < 2) continue;
			int[] t = Arrays.copyOf(tehai, tehai.length);
			t[i] -= 2;
			if(can4(t)) return true;
		}
		return false;
	}
	
	boolean can4(int[] tehai){
		int sumAll = 0;
		for(int i = 1; i <= 9; i++){
			sumAll += tehai[i];
			if(tehai[i] >= 3){
				int[] t = Arrays.copyOf(tehai, tehai.length);
				t[i] -= 3;
				if(can4(t)) return true;
			}
			if(i <= 7 && tehai[i] >= 1 && tehai[i+1] >= 1 && tehai[i+2] >= 1){
				int[] t = Arrays.copyOf(tehai, tehai.length);
				t[i]--; t[i+1]--; t[i+2]--;
				if(can4(t)) return true;
			}
		}
		return sumAll == 0;
	}
	
	/* end solve */
	
	/* main */
	public static void main(String[] args) throws Exception {
		new Main().m();
	}
	
	void m() throws Exception {
		long S = System.currentTimeMillis();
		sc = (isDebug) ? new FastScanner(new FileInputStream(fileName)) : new FastScanner(System.in);
		out = new PrintWriter(System.out);
		solve();
		out.flush();
		long G = System.currentTimeMillis();
		if(isDebug){
			System.out.println("---Debug---");
			System.out.printf("%8d ms\n", (G-S));
		}
	}
	/* end main */
}
/* end Main */

class Pair{
	int x;
	long d;
	public Pair(int x, long d){this.x = x; this.d = d;}
}

class FastScanner {
    private InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;
    public FastScanner(InputStream in) {
		this.in = in;
	}
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() {
    	if (hasNextByte()) return buffer[ptr++];
    	else return -1;
    }
    private static boolean isPrintableChar(int c){
    	return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
    	while(hasNextByte() && !isPrintableChar(buffer[ptr]))
    		ptr++; return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
    public String nextLine() {
        if (!hasNext()) throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(b != 10) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
    public long nextLong() {
        if (!hasNext()) throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while(true){
            if ('0' <= b && b <= '9') {
                n *= 10;
                n += b - '0';
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
    	return Double.parseDouble(next());
    }
}


</source>
</class>

<class classid="119" nclones="2" nlines="39" similarity="100">
<source file="../hum_codes_raw/s210510115.java" startline="1" endline="36" pcid="7101">
import java.util.Scanner;
public class Main {
	public static void main(String[] args){
		Scanner stdIn=new Scanner(System.in);
		int N=stdIn.nextInt();
		int X=stdIn.nextInt();
		int A[]=new int[N];
		int B[]=new int[N-1];
		int z=0,y=0,x=0;
		long ans=0;
		while(z<N){
			A[z]=stdIn.nextInt();
			z++;
		}z=0;
		while(z<N-1){
			B[z]=A[z]+A[z+1];
			z++;
		}z=0;
		while(z<N-1){
			if(B[z]>X){
				y=B[z]-X;
				if(y>A[z+1]){
					x=y-A[z+1];y=A[z+1];
				}
				A[z]-=x;
				A[z+1]-=y;
				if(z!=N-2)
					B[z+1]-=y;
				ans+=x+y;
			}
			x=0;y=0;z++;
		}
		System.out.println(ans);
	}
}

</source>
<source file="../hum_codes_raw/s379237304.java" startline="1" endline="36" pcid="12754">
import java.util.Scanner;
public class Main {
	public static void main(String[] args){
		Scanner stdIn=new Scanner(System.in);
		int N=stdIn.nextInt();
		int X=stdIn.nextInt();
		int A[]=new int[N];
		int B[]=new int[N-1];
		int z=0,y=0,x=0;
		long ans=0;
		while(z<N){
			A[z]=stdIn.nextInt();
			z++;
		}z=0;
		while(z<N-1){
			B[z]=A[z]+A[z+1];
			z++;
		}z=0;
		while(z<N-1){
			if(B[z]>X){
				y=B[z]-X;
				if(y>A[z+1]){
					x=y-A[z+1];y=A[z+1];
				}
				A[z]-=x;
				A[z+1]-=y;
				if(z!=N-2)
					B[z+1]-=y;
				ans+=x+y;
			}
			x=0;y=0;z++;
		}
		System.out.println(ans);
	}
}

</source>
</class>

<class classid="120" nclones="2" nlines="21" similarity="100">
<source file="../hum_codes_raw/s215591855.java" startline="1" endline="54" pcid="7278">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.function.Function;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class Main {

  public static void main(String[] args) throws IOException {
    
    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      int n = Integer.parseInt(br.readLine());

      Function<String,double[]> lineSpliteThenArray =
        s -> Stream.of(s.split(" "))
          .mapToDouble(Double::parseDouble)
          .toArray();

      double[][] vecter =
        br.lines()
          .limit(2)
          .map( lineSpliteThenArray )
          .toArray(double[][]::new);

      double p1 =
        IntStream.range(0, n)
          .mapToDouble(i -> Math.abs(vecter[0][i] - vecter[1][i]) )
          .sum();

      double p2 = Math.sqrt(
        IntStream.range(0, n)
          .mapToDouble(i -> Math.pow( vecter[0][i] - vecter[1][i], 2))
          .sum() );

      double p3 = Math.pow(
        IntStream.range(0, n)
        .mapToDouble(i -> Math.pow( Math.abs(vecter[0][i] - vecter[1][i]), 3d))
        .sum() , 1d/3d );

      double p00 =
        IntStream.range(0, n)
          .mapToDouble(i -> Math.abs(vecter[0][i] - vecter[1][i]))
          .max()
          .getAsDouble();

      System.out.printf("%.8f\n%.8f\n%.8f\n%.8f\n", p1,p2,p3,p00);
    }
  }

}

</source>
<source file="../hum_codes_raw/s855876782.java" startline="1" endline="54" pcid="28772">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.function.Function;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class Main {

  public static void main(String[] args) throws IOException {
    
    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      int n = Integer.parseInt(br.readLine());

      Function<String,double[]> lineSpliteThenArray =
        s -> Stream.of(s.split(" "))
          .mapToDouble(Double::parseDouble)
          .toArray();

      double[][] vecter =
        br.lines()
          .limit(2)
          .map( lineSpliteThenArray )
          .toArray(double[][]::new);

      double p1 =
        IntStream.range(0, n)
          .mapToDouble(i -> Math.abs(vecter[0][i] - vecter[1][i]) )
          .sum();

      double p2 = Math.sqrt(
        IntStream.range(0, n)
          .mapToDouble(i -> Math.pow( vecter[0][i] - vecter[1][i], 2))
          .sum() );

      double p3 = Math.pow(
        IntStream.range(0, n)
        .mapToDouble(i -> Math.pow( Math.abs(vecter[0][i] - vecter[1][i]), 3d))
        .sum() , 1d/3d );

      double p00 =
        IntStream.range(0, n)
          .mapToDouble(i -> Math.abs(vecter[0][i] - vecter[1][i]))
          .max()
          .getAsDouble();

      System.out.printf("%.8f\n%.8f\n%.8f\n%.8f\n", p1,p2,p3,p00);
    }
  }

}

</source>
</class>

<class classid="121" nclones="2" nlines="41" similarity="100">
<source file="../hum_codes_raw/s217045508.java" startline="1" endline="44" pcid="7328">
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc = new Scanner(System.in);
		int h = sc.nextInt();
		int w = sc.nextInt();
		char[][] weather = new char[h][w + 1];
		int[][] result = new int[h][w + 1];
		for (int i = 0; i < h; i++) {
			weather[i] = sc.next().toCharArray();
		}
		int cnt;
		for(int i = 0; i < h; i++) {
			cnt = -1;
			for(int k = 0; k < w; k++) {
				if(weather[i][k] == 'c') {
					cnt = 0;
					result[i][k] = cnt;
					cnt = cnt + 1;
				} else if(cnt >= 0) {
					result[i][k] = cnt;
					cnt = cnt + 1;
				} else {
					result[i][k] = cnt;
				}
				
			}
		}
		for(int i = 0; i < h; i++) {
			for(int k = 0; k < w; k++) {
				if(k == w - 1) {
					System.out.println(result[i][k]);
				} else {
					System.out.print(result[i][k] + " ");
				}
			}
		}
	}

}

</source>
<source file="../hum_codes_raw/s381324116.java" startline="1" endline="44" pcid="12815">
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc = new Scanner(System.in);
		int h = sc.nextInt();
		int w = sc.nextInt();
		char[][] weather = new char[h][w + 1];
		int[][] result = new int[h][w + 1];
		for (int i = 0; i < h; i++) {
			weather[i] = sc.next().toCharArray();
		}
		int cnt;
		for(int i = 0; i < h; i++) {
			cnt = -1;
			for(int k = 0; k < w; k++) {
				if(weather[i][k] == 'c') {
					cnt = 0;
					result[i][k] = cnt;
					cnt = cnt + 1;
				} else if(cnt >= 0) {
					result[i][k] = cnt;
					cnt = cnt + 1;
				} else {
					result[i][k] = cnt;
				}
				
			}
		}
		for(int i = 0; i < h; i++) {
			for(int k = 0; k < w; k++) {
				if(k == w - 1) {
					System.out.println(result[i][k]);
				} else {
					System.out.print(result[i][k] + " ");
				}
			}
		}
	}

}

</source>
</class>

<class classid="122" nclones="3" nlines="38" similarity="100">
<source file="../hum_codes_raw/s223434161.java" startline="1" endline="49" pcid="7548">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Main {

  public static void main(String[] args) throws IOException {
    
    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      int q = Integer.parseInt(br.readLine());
      String[] s = new String[q+q];
      Arrays.fill(s, "");
      List<String> list  = Arrays.asList(s);
      int head = q;
      int tail = q;

      String[] query;
      int op;
      for ( int i=0; i<q; i++ ){
        query = br.readLine().split(" ");
        op  = Integer.parseInt(query[0]);

        switch( op ) {
          case 0 :
            if ( Integer.parseInt(query[1]) == 0 )
              list.set(head--,query[2]);
            else
              list.set(++tail,query[2]);
            break;
          case 1 :
            System.out.println( list.get(head+1 + Integer.parseInt(query[1])) );
            break;
          case 2 :
            if ( Integer.parseInt(query[1]) == 0 )
              head++; // list.set(head++,"");
            else
              tail--; // list.set(tail--,"");
            break;
          default:
        }
      }
    }
  }
}

</source>
<source file="../hum_codes_raw/s730888198.java" startline="1" endline="49" pcid="24568">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Main {

  public static void main(String[] args) throws IOException {
    
    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      int q = Integer.parseInt(br.readLine());
      String[] s = new String[q+q];
      Arrays.fill(s, "");
      List<String> list  = Arrays.asList(s);
      int head = q;
      int tail = q;

      String[] query;
      int op;
      for ( int i=0; i<q; i++ ){
        query = br.readLine().split(" ");
        op  = Integer.parseInt(query[0]);

        switch( op ) {
          case 0 :
            if ( Integer.parseInt(query[1]) == 0 )
              list.set(head--,query[2]);
            else
              list.set(++tail,query[2]);
            break;
          case 1 :
            System.out.println( list.get(head+1 + Integer.parseInt(query[1])) );
            break;
          case 2 :
            if ( Integer.parseInt(query[1]) == 0 )
              head++; // list.set(head++,"");
            else
              tail--; // list.set(tail--,"");
            break;
          default:
        }
      }
    }
  }
}

</source>
<source file="../hum_codes_raw/s280856904.java" startline="1" endline="49" pcid="9399">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Main {

  public static void main(String[] args) throws IOException {
    
    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      int q = Integer.parseInt(br.readLine());
      String[] s = new String[q+q];
      Arrays.fill(s, "");
      List<String> list  = Arrays.asList(s);
      int head = q;
      int tail = q;

      String[] query;
      int op;
      for ( int i=0; i<q; i++ ){
        query = br.readLine().split(" ");
        op  = Integer.parseInt(query[0]);

        switch( op ) {
          case 0 :
            if ( Integer.parseInt(query[1]) == 0 )
              list.set(head--,query[2]);
            else
              list.set(++tail,query[2]);
            break;
          case 1 :
            System.out.println( list.get(head+1 + Integer.parseInt(query[1])) );
            break;
          case 2 :
            if ( Integer.parseInt(query[1]) == 0 )
              head++; // list.set(head++,"");
            else
              tail--; // list.set(tail--,"");
            break;
          default:
        }
      }
    }
  }
}

</source>
</class>

<class classid="123" nclones="2" nlines="73" similarity="100">
<source file="../hum_codes_raw/s224294059.java" startline="1" endline="93" pcid="7576">

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.*;


public class Main {

    public static void main(String[] args) throws IOException {
        Scanner s = new Scanner(System.in);
        int n = s.nextInt(),x=s.nextInt();
        long total=0;
        int arr[] = new int[n];
        for(int i=0;i<n;i++)arr[i]=s.nextInt();
        for(int i=1;i<n;i++){
            int sum = arr[i]+arr[i-1];
            if(sum>x){
                int diff = sum-x;
                total+=diff;

                if(arr[i]-diff>=0){
                    arr[i]-=diff;
                }
                else{
                    arr[i]=0;
                }
            }
        }
        System.out.println(total);
    }


}




class Scanner
{
    StringTokenizer st;
    BufferedReader br;

    public Scanner(InputStream s){	br = new BufferedReader(new InputStreamReader(s));}

    public String next() throws IOException
    {
        while (st == null || !st.hasMoreTokens())
            st = new StringTokenizer(br.readLine());
        return st.nextToken();
    }

    public int nextInt() throws IOException {return Integer.parseInt(next());}

    public long nextLong() throws IOException {return Long.parseLong(next());}

    public String nextLine() throws IOException {return br.readLine();}

    public double nextDouble() throws IOException
    {
        String x = next();
        StringBuilder sb = new StringBuilder("0");
        double res = 0, f = 1;
        boolean dec = false, neg = false;
        int start = 0;
        if(x.charAt(0) == '-')
        {
            neg = true;
            start++;
        }
        for(int i = start; i < x.length(); i++)
            if(x.charAt(i) == '.')
            {
                res = Long.parseLong(sb.toString());
                sb = new StringBuilder("0");
                dec = true;
            }
            else
            {
                sb.append(x.charAt(i));
                if(dec)
                    f *= 10;
            }
        res += Long.parseLong(sb.toString()) / f;
        return res * (neg?-1:1);
    }

    public boolean ready() throws IOException {return br.ready();}


}

</source>
<source file="../hum_codes_raw/s225899038.java" startline="1" endline="93" pcid="7638">

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.*;


public class Main {

    public static void main(String[] args) throws IOException {
        Scanner s = new Scanner(System.in);
        int n = s.nextInt(),x=s.nextInt();
        long total=0;
        int arr[] = new int[n];
        for(int i=0;i<n;i++)arr[i]=s.nextInt();
        for(int i=1;i<n;i++){
            int sum = arr[i]+arr[i-1];
            if(sum>x){
                int diff = sum-x;
                total+=diff;

                if(arr[i]-diff>=0){
                    arr[i]-=diff;
                }
                else{
                    arr[i]=0;
                }
            }
        }
        System.out.println(total);
    }


}




class Scanner
{
    StringTokenizer st;
    BufferedReader br;

    public Scanner(InputStream s){	br = new BufferedReader(new InputStreamReader(s));}

    public String next() throws IOException
    {
        while (st == null || !st.hasMoreTokens())
            st = new StringTokenizer(br.readLine());
        return st.nextToken();
    }

    public int nextInt() throws IOException {return Integer.parseInt(next());}

    public long nextLong() throws IOException {return Long.parseLong(next());}

    public String nextLine() throws IOException {return br.readLine();}

    public double nextDouble() throws IOException
    {
        String x = next();
        StringBuilder sb = new StringBuilder("0");
        double res = 0, f = 1;
        boolean dec = false, neg = false;
        int start = 0;
        if(x.charAt(0) == '-')
        {
            neg = true;
            start++;
        }
        for(int i = start; i < x.length(); i++)
            if(x.charAt(i) == '.')
            {
                res = Long.parseLong(sb.toString());
                sb = new StringBuilder("0");
                dec = true;
            }
            else
            {
                sb.append(x.charAt(i));
                if(dec)
                    f *= 10;
            }
        res += Long.parseLong(sb.toString()) / f;
        return res * (neg?-1:1);
    }

    public boolean ready() throws IOException {return br.ready();}


}

</source>
</class>

<class classid="124" nclones="2" nlines="58" similarity="100">
<source file="../hum_codes_raw/s225400136.java" startline="1" endline="64" pcid="7629">
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

//Wrought Gold Master
public class Main {

	public static int[] price;
	public static int[] opt;
	public static Map<String, Integer> ref;
	public static int[][] list;

	public static int get(int k){
		if(opt[k]!=Integer.MAX_VALUE){
			return opt[k];
		}
		if(list[k].length==0){
			return opt[k] = price[k];
		}
		int p = 0;
		for(int i=0;i<list[k].length;i++){
			p += get(list[k][i]);
		}
		return opt[k] = Math.min(p, price[k]);
	}

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int n = sc.nextInt();
			if(n==0)break;
			price = new int[300];
			opt = new int[300];
			list = new int[300][0];
			Arrays.fill(opt, Integer.MAX_VALUE);
			int id = 0;
			ref = new HashMap<String, Integer>();
			for(int i=0;i<n;i++){
				ref.put(sc.next(), id);
				price[id++] = sc.nextInt();
			}
			int m = sc.nextInt();
			while(m--!=0){
				String s = sc.next();
				if(!ref.containsKey(s)){
					ref.put(s, id++);
				}
				int i = ref.get(s);
				int k = sc.nextInt();
				list[i] = new int[k];
				for(int j=0;j<k;j++){
					s = sc.next();
					if(!ref.containsKey(s)){
						ref.put(s, id++);
					}
					list[i][j] = ref.get(s);
				}
			}
			System.out.println(get(ref.get(sc.next())));
		}
	}
}

</source>
<source file="../hum_codes_raw/s934297997.java" startline="1" endline="64" pcid="31419">
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

//Wrought Gold Master
public class Main{

	public static int[] price;
	public static int[] opt;
	public static Map<String, Integer> ref;
	public static int[][] list;

	public static int get(int k){
		if(opt[k]!=Integer.MAX_VALUE){
			return opt[k];
		}
		if(list[k].length==0){
			return opt[k] = price[k];
		}
		int p = 0;
		for(int i=0;i<list[k].length;i++){
			p += get(list[k][i]);
		}
		return opt[k] = Math.min(p, price[k]);
	}

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int n = sc.nextInt();
			if(n==0)break;
			price = new int[300];
			opt = new int[300];
			list = new int[300][0];
			Arrays.fill(opt, Integer.MAX_VALUE);
			int id = 0;
			ref = new HashMap<String, Integer>();
			for(int i=0;i<n;i++){
				ref.put(sc.next(), id);
				price[id++] = sc.nextInt();
			}
			int m = sc.nextInt();
			while(m--!=0){
				String s = sc.next();
				if(!ref.containsKey(s)){
					ref.put(s, id++);
				}
				int i = ref.get(s);
				int k = sc.nextInt();
				list[i] = new int[k];
				for(int j=0;j<k;j++){
					s = sc.next();
					if(!ref.containsKey(s)){
						ref.put(s, id++);
					}
					list[i][j] = ref.get(s);
				}
			}
			System.out.println(get(ref.get(sc.next())));
		}
	}
}

</source>
</class>

<class classid="125" nclones="2" nlines="18" similarity="100">
<source file="../hum_codes_raw/s226358701.java" startline="1" endline="21" pcid="7652">
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int a = scan.nextInt();
        int b = scan.nextInt();
        int c = scan.nextInt();

        if (a == b) {
            System.out.println(c);
        } else if(b == c) {
            System.out.println(a);
        } else {
            System.out.println(b);
        }
    }
}


</source>
<source file="../hum_codes_raw/s565471129.java" startline="1" endline="19" pcid="19026">
import java.util.Scanner;
public class Main{
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		int a=scan.nextInt();
		int b=scan.nextInt();
		int c=scan.nextInt();
if(a==b) {
	System.out.println(c);
}
else if(b==c){
	System.out.println(a);
}
else {
	System.out.println(b);
}
	}
}

</source>
</class>

<class classid="126" nclones="2" nlines="36" similarity="100">
<source file="../hum_codes_raw/s226968743.java" startline="1" endline="42" pcid="7677">
import java.util.ArrayList;
import java.util.Collections;
import java.util.PriorityQueue;
import java.util.Scanner;

class Main{
	public static void main(String[] args) {
		ArrayList <PriorityQueue<Integer>> queues = new ArrayList <PriorityQueue<Integer>>();  //PriorityQueueArrayList
		try (Scanner sc = new Scanner (System.in)){
			int n = sc.nextInt();
			for (int i=0; i<n; i++) {
				queues.add(new PriorityQueue<Integer>(Collections.reverseOrder()));

			}
			int times = sc.nextInt();
			for (int i=0; i<times; i++) {
				int query = sc.nextInt();
				int que = sc.nextInt();
				switch (query) {
				//insert(t,x)
				case 0:
					int x = sc.nextInt();
					queues.get(que).add(x);
					break;
				case 1:
					if (queues.get(que).size() != 0) {
						System.out.println(queues.get(que).peek());
					}
					break;
				case 2:
					if (queues.get(que).size() != 0) {
						queues.get(que).poll();
					}
					break;

				}
			}
		}
	}
}


</source>
<source file="../hum_codes_raw/s607330585.java" startline="1" endline="46" pcid="20406">
import java.util.ArrayList;
import java.util.Collections;
import java.util.PriorityQueue;
import java.util.Scanner;

class Main {

	public static void main(String[] args) {
		ArrayList <PriorityQueue<Integer>> queues = new ArrayList <PriorityQueue<Integer>>();  //PriorityQueueArrayList
		try (Scanner sc = new Scanner (System.in)){
			int n = sc.nextInt();
			for (int i=0; i<n; i++) {
				queues.add(new PriorityQueue<Integer>(Collections.reverseOrder()));  //nPriorityQueue
																					//Collectionshttps://qiita.com/p_shiki37/items/3902f4e3adc3aeb382f1
			}
			int times = sc.nextInt();
			for (int i=0; i<times; i++) {
				int query = sc.nextInt();  // 0 insert 1 getMax 2 deleteMax
				int que = sc.nextInt();  //queue
				switch (query) {
				//insert(t,x)
				case 0:
					int x = sc.nextInt();
					queues.get(que).add(x);
					break;

				//getMax(t)
				case 1:
					if (queues.get(que).size() != 0) { //
						System.out.println(queues.get(que).peek());
					}
					break;

				//deleteMax(t)
				case 2:
					if (queues.get(que).size() != 0) { //
						queues.get(que).poll();
					}
					break;

				}
			}
		}
	}
}

</source>
</class>

<class classid="127" nclones="2" nlines="39" similarity="100">
<source file="../hum_codes_raw/s228857483.java" startline="1" endline="45" pcid="7726">
import java.util.Arrays;
import java.util.Scanner;

public class Main {
	Scanner sc = new Scanner(System.in);
	int N, M;
	int INF = Integer.MAX_VALUE / 2;
	int[][] graph, memo;

	void run() {
		N = sc.nextInt(); // edge number
		M = sc.nextInt(); // vertex number
		graph = new int[N][N];
		memo = new int[N][1 << N];
		for (int i = 0; i < N; i++) {
			Arrays.fill(graph[i], INF);
			Arrays.fill(memo[i], -1);
		}
		for (int i = 0; i < M; i++) {
			int s = sc.nextInt();
			int t = sc.nextInt();
			int cost = sc.nextInt();
			graph[s][t] = cost;
		}
		int res = tsp(0, 1);
		System.out.println(res == INF ? -1 : res);
	}

	int tsp(int v, int mask) {
		if (memo[v][mask] != -1)  return memo[v][mask];
		if (mask == (1 << N) - 1) return graph[v][0];

		int res = INF;
		for (int i = 0; i < N; i++) {
			if ((mask & (1 << i)) != 0) continue;
			res = Math.min(res, graph[v][i] + tsp(i, mask | (1 << i)));
		}
		return memo[v][mask] = res;
	}

	public static void main(String[] args) {
		new Main().run();
	}
}

</source>
<source file="../hum_codes_raw/s507253512.java" startline="1" endline="45" pcid="16995">
import java.util.Arrays;
import java.util.Scanner;

public class Main {
	Scanner sc = new Scanner(System.in);
	int N, M;
	int INF = Integer.MAX_VALUE / 2;
	int[][] graph, memo;

	void run() {
		N = sc.nextInt(); // edge number
		M = sc.nextInt(); // vertex number
		graph = new int[N][N];
		memo = new int[N][1 << N];
		for (int i = 0; i < N; i++) {
			Arrays.fill(graph[i], INF);
			Arrays.fill(memo[i], -1);
		}
		for (int i = 0; i < M; i++) {
			int s = sc.nextInt();
			int t = sc.nextInt();
			int cost = sc.nextInt();
			graph[s][t] = cost;
		}
		int res = tsp(0, 1);
		System.out.println(res == INF ? -1 : res);
	}

	int tsp(int v, int mask) {
		if (memo[v][mask] != -1)  return memo[v][mask];
		if (mask == (1 << N) - 1) return graph[v][0];

		int res = INF;
		for (int i = 0; i < N; i++) {
			if ((mask & (1 << i)) != 0) continue;
			res = Math.min(res, graph[v][i] + tsp(i, mask | (1 << i)));
		}
		return memo[v][mask] = res;
	}

	public static void main(String[] args) {
		new Main().run();
	}
}

</source>
</class>

<class classid="128" nclones="2" nlines="19" similarity="100">
<source file="../hum_codes_raw/s229096843.java" startline="1" endline="32" pcid="7736">
import java.util.Scanner;
public class Main{
    int high;
		int low;
		int sa;
		
    public void solve(){
		Scanner sc=new Scanner(System.in);
		
		
    
		for(int i=0;i<7;i++){
			
        high=sc.nextInt();
        low=sc.nextInt();
		sa=high-low;
   
	System.out.println(sa);
    
    }
	
    }

        
    public static void main(String[]args){
		
        Main obj =new Main();
        obj.solve();
    
    }
}

</source>
<source file="../hum_codes_raw/s259696948.java" startline="1" endline="21" pcid="8724">
import java.util.Scanner;
public class Main{
    int high;
    int low;
    int sa;
    
    public void solve(){
       Scanner sc = new Scanner(System.in);
	   for(int i=0;i<7;i++){
        high=sc.nextInt();
		low=sc.nextInt();
		sa=high-low;
		System.out.println(sa);
	   }
    }
    public static void main(String[]args){
        Main obj = new Main();
        obj.solve();
    }
}

</source>
</class>

<class classid="129" nclones="2" nlines="27" similarity="100">
<source file="../hum_codes_raw/s232142104.java" startline="1" endline="30" pcid="7836">

import java.util.*;
import java.lang.*;
import java.math.*;

public class Main {
	Scanner sc = new Scanner(System.in);
	void run(){
		int[] dp = new int[51];
		Arrays.fill(dp, Integer.MAX_VALUE - 3000);
		dp[0] = 0;
		int price[] ={380,550,850,380*4,(int)(550*4*0.85 + 0.4),(int)(850*3*0.88 + 0.4)} ;
		int weigh[] ={  2,  3,  5, 10,12,15} ;
		for(int i = 0;i < 6;i++){
			for(int j=0;weigh[i]+j < 51;j++){
				dp[j+weigh[i]] = Math.min(dp[j] + price[i],dp[j+weigh[i]]);
			}
		}
		for(;;){
			int n = sc.nextInt()/100;
			if(n==0) break;
			System.out.println(dp[n]);
		}
	}
	public static void main(String[] args){
		Main m = new Main();
		m.run();
	}
}

</source>
<source file="../hum_codes_raw/s610653046.java" startline="1" endline="58" pcid="20511">


import java.util.*;

import java.lang.*;

import java.math.*;



public class Main {

	Scanner sc = new Scanner(System.in);

	void run(){

		int[] dp = new int[51];

		Arrays.fill(dp, Integer.MAX_VALUE - 3000);

		dp[0] = 0;

		int price[] ={380,550,850,380*4,(int)(550*4*0.85 + 0.4),(int)(850*3*0.88 + 0.4)} ;

		int weigh[] ={  2,  3,  5, 10,12,15} ;

		for(int i = 0;i < 6;i++){

			for(int j=0;weigh[i]+j < 51;j++){

				dp[j+weigh[i]] = Math.min(dp[j] + price[i],dp[j+weigh[i]]);

			}

		}

		for(;;){

			int n = sc.nextInt()/100;

			if(n==0) break;

			System.out.println(dp[n]);

		}

	}

	public static void main(String[] args){

		Main m = new Main();

		m.run();

	}

}

</source>
</class>

<class classid="130" nclones="2" nlines="20" similarity="100">
<source file="../hum_codes_raw/s233405311.java" startline="1" endline="22" pcid="7882">
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        while (true) {
            int H = sc.nextInt();
            int W = sc.nextInt();
            if (H == 0 && W == 0) {
                break;
            }
            for (int i = 0; i < H; i++) {
                for (int j = 0; j < W; j++) {
                    System.out.printf("#");
                }
                System.out.printf("\n");
            }
            System.out.printf("\n");
        }
    }
}

</source>
<source file="../hum_codes_raw/s450531715.java" startline="1" endline="22" pcid="15104">
import java.util.Scanner;

public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        while(true){
            int H = sc.nextInt();
            int W = sc.nextInt();
            if(H == 0 && W == 0){
                break;
            }
            for(int i=0;i<H;i++){
                for(int j=0;j<W;j++){
                    System.out.printf("#");
                }
                System.out.printf("\n");
        }
        System.out.printf("\n");
    }
}
}

</source>
</class>

<class classid="131" nclones="2" nlines="161" similarity="100">
<source file="../hum_codes_raw/s234525574.java" startline="1" endline="220" pcid="7926">
import java.io.IOException;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Scanner;

public class Main {
	// static int time = 0;

	public static void main(String[] args) throws IOException {

		Scanner scan = new Scanner(System.in);
		// Scanner scan = new Scanner(new
		// File("D:\\UserArea\\J0124567\\Downloads\\ALDS1_6_A-in9.txt"));

		HS hs = new HS();

		for (int y = 0; y < 4; y++)
			for (int x = 0; x < 4; x++)
				hs.SetIni(x, y, scan.nextInt());

		System.out.println(hs.solve());

		scan.close();
		System.exit(0);
	}
}

class HS {
	class Bd {
		byte[][] pn = new byte[4][4];
		int oper = 0;
		int diff = 0;

		public long getKey() {
			long key = 0;
			for (int x = 0; x < 4; x++)
				for (int y = 0; y < 4; y++) {
					key *= 10;
					key += pn[x][y];
				}
			return key;
		}

		public int eval() {
			int ret = 0;
			for (int x = 0; x < 4; x++)
				for (int y = 0; y < 4; y++) {
					int p = pn[x][y];
					if (p != 0)
						ret += Math.abs(x - gx[p]) + Math.abs(y - gy[p]);
				}
			diff = ret;
			return ret;
		}

		public void copy(Bd b) {
			for (int x = 0; x < 4; x++)
				for (int y = 0; y < 4; y++)
					pn[x][y] = b.pn[x][y];
			diff = b.diff;
			oper = b.oper;
		}

		private boolean up() {
			for (int x = 0; x < 4; x++)
				for (int y = 0; y < 3; y++)
					if (pn[x][y] == 0) {
						pn[x][y] = pn[x][y + 1];
						pn[x][y + 1] = 0;
						oper++;
						eval();
						return true;
					}
			return false;
		}

		private boolean down() {
			for (int x = 0; x < 4; x++)
				for (int y = 1; y < 4; y++)
					if (pn[x][y] == 0) {
						pn[x][y] = pn[x][y - 1];
						pn[x][y - 1] = 0;
						oper++;
						eval();
						return true;
					}
			return false;
		}

		private boolean right() {
			for (int x = 1; x < 4; x++)
				for (int y = 0; y < 4; y++)
					if (pn[x][y] == 0) {
						pn[x][y] = pn[x - 1][y];
						pn[x - 1][y] = 0;
						oper++;
						eval();
						return true;
					}
			return false;
		}

		private boolean left() {
			for (int x = 0; x < 3; x++)
				for (int y = 0; y < 4; y++)
					if (pn[x][y] == 0) {
						pn[x][y] = pn[x + 1][y];
						pn[x + 1][y] = 0;
						oper++;
						eval();
						return true;
					}
			return false;
		}

		public boolean move(int op) {
			switch (op) {
			case (0):
				return up();
			case (1):
				return down();
			case (2):
				return right();
			case (3):
				return left();
			}
			return false;
		}

		public boolean isSame(Bd b) {
			for (int x = 0; x < 4; x++)
				for (int y = 0; y < 4; y++)
					if (b.pn[x][y] != pn[x][y])
						return false;
			return true;
		}
	}

	private Bd bd = new Bd();
	private int[] gx = { 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2 };
	private int[] gy = { 3, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3 };
	// private ArrayList<Bd> hist = new ArrayList<Bd>();
	private Map<Long, Integer> hist = new HashMap<>();
	private PriorityQueue<Bd> pqueue = new PriorityQueue<Bd>(3, new Qcomparator());

	class Qcomparator implements Comparator<Bd> {
		@Override
		public int compare(Bd b1, Bd b2) {
			if (b1.diff + b1.oper > b2.diff + b2.oper)
				return 1;
			else if (b1.diff + b1.oper == b2.diff + b2.oper)
				return 0;
			else
				return -1;
		}
	}

	public void SetIni(int x, int y, int a) {
		bd.pn[x][y] = (byte) a;
	}

	public int solve() {
		Bd b = new Bd();
		b.copy(bd);
		b.eval();
		pqueue.add(b);
		hist.put(b.getKey(), 0);
		return search();
	}

	private int search() {
		while (true) {
			Bd b = pqueue.poll();
			if (b == null)
				return -1;

			// printBd(b);

			if (b.diff == 0)
				return b.oper;

			for (int i = 0; i < 4; i++) {
				Bd nb = new Bd();
				nb.copy(b);
				if (nb.move(i))
					addQueue(nb);
			}
		}
	}

	private boolean addQueue(Bd b) {
		long k = b.getKey();
		if (hist.containsKey(k)) {
			int oper = hist.get(k);
			if (oper > b.oper) {
				hist.put(k, b.oper);
				pqueue.add(b);
				return true;
			} else
				return false;
		}
		hist.put(k, b.oper);
		pqueue.add(b);
		return true;
	}

	private void printBd(Bd b) {
		System.out.println("----------------");
		for (int y = 0; y < 3; y++)
			System.out.println("- " + b.pn[0][y] + " " + b.pn[1][y] + " " + b.pn[2][y] + " -");
		System.out.println("------- diff " + b.diff + " oper " + b.oper + " queue " + pqueue.size());
		if (pqueue.size() > 100000)
			System.exit(0);
	}
}

</source>
<source file="../hum_codes_raw/s872592449.java" startline="1" endline="220" pcid="29334">
import java.io.IOException;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Scanner;
 
public class Main {
    // static int time = 0;
 
    public static void main(String[] args) throws IOException {
 
        Scanner scan = new Scanner(System.in);
        // Scanner scan = new Scanner(new
        // File("D:\\UserArea\\J0124567\\Downloads\\ALDS1_6_A-in9.txt"));
 
        HS hs = new HS();
 
        for (int y = 0; y < 4; y++)
            for (int x = 0; x < 4; x++)
                hs.SetIni(x, y, scan.nextInt());
 
        System.out.println(hs.solve());
 
        scan.close();
        System.exit(0);
    }
}
 
class HS {
    class Bd {
        byte[][] pn = new byte[4][4];
        int oper = 0;
        int diff = 0;
 
        public long getKey() {
            long key = 0;
            for (int x = 0; x < 4; x++)
                for (int y = 0; y < 4; y++) {
                    key *= 10;
                    key += pn[x][y];
                }
            return key;
        }
 
        public int eval() {
            int ret = 0;
            for (int x = 0; x < 4; x++)
                for (int y = 0; y < 4; y++) {
                    int p = pn[x][y];
                    if (p != 0)
                        ret += Math.abs(x - gx[p]) + Math.abs(y - gy[p]);
                }
            diff = ret;
            return ret;
        }
 
        public void copy(Bd b) {
            for (int x = 0; x < 4; x++)
                for (int y = 0; y < 4; y++)
                    pn[x][y] = b.pn[x][y];
            diff = b.diff;
            oper = b.oper;
        }
 
        private boolean up() {
            for (int x = 0; x < 4; x++)
                for (int y = 0; y < 3; y++)
                    if (pn[x][y] == 0) {
                        pn[x][y] = pn[x][y + 1];
                        pn[x][y + 1] = 0;
                        oper++;
                        eval();
                        return true;
                    }
            return false;
        }
 
        private boolean down() {
            for (int x = 0; x < 4; x++)
                for (int y = 1; y < 4; y++)
                    if (pn[x][y] == 0) {
                        pn[x][y] = pn[x][y - 1];
                        pn[x][y - 1] = 0;
                        oper++;
                        eval();
                        return true;
                    }
            return false;
        }
 
        private boolean right() {
            for (int x = 1; x < 4; x++)
                for (int y = 0; y < 4; y++)
                    if (pn[x][y] == 0) {
                        pn[x][y] = pn[x - 1][y];
                        pn[x - 1][y] = 0;
                        oper++;
                        eval();
                        return true;
                    }
            return false;
        }
 
        private boolean left() {
            for (int x = 0; x < 3; x++)
                for (int y = 0; y < 4; y++)
                    if (pn[x][y] == 0) {
                        pn[x][y] = pn[x + 1][y];
                        pn[x + 1][y] = 0;
                        oper++;
                        eval();
                        return true;
                    }
            return false;
        }
 
        public boolean move(int op) {
            switch (op) {
            case (0):
                return up();
            case (1):
                return down();
            case (2):
                return right();
            case (3):
                return left();
            }
            return false;
        }
 
        public boolean isSame(Bd b) {
            for (int x = 0; x < 4; x++)
                for (int y = 0; y < 4; y++)
                    if (b.pn[x][y] != pn[x][y])
                        return false;
            return true;
        }
    }
 
    private Bd bd = new Bd();
    private int[] gx = { 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2 };
    private int[] gy = { 3, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3 };
    // private ArrayList<Bd> hist = new ArrayList<Bd>();
    private Map<Long, Integer> hist = new HashMap<>();
    private PriorityQueue<Bd> pqueue = new PriorityQueue<Bd>(3, new Qcomparator());
 
    class Qcomparator implements Comparator<Bd> {
        @Override
        public int compare(Bd b1, Bd b2) {
            if (b1.diff + b1.oper > b2.diff + b2.oper)
                return 1;
            else if (b1.diff + b1.oper == b2.diff + b2.oper)
                return 0;
            else
                return -1;
        }
    }
 
    public void SetIni(int x, int y, int a) {
        bd.pn[x][y] = (byte) a;
    }
 
    public int solve() {
        Bd b = new Bd();
        b.copy(bd);
        b.eval();
        pqueue.add(b);
        hist.put(b.getKey(), 0);
        return search();
    }
 
    private int search() {
        while (true) {
            Bd b = pqueue.poll();
            if (b == null)
                return -1;
 
            // printBd(b);
 
            if (b.diff == 0)
                return b.oper;
 
            for (int i = 0; i < 4; i++) {
                Bd nb = new Bd();
                nb.copy(b);
                if (nb.move(i))
                    addQueue(nb);
            }
        }
    }
 
    private boolean addQueue(Bd b) {
        long k = b.getKey();
        if (hist.containsKey(k)) {
            int oper = hist.get(k);
            if (oper > b.oper) {
                hist.put(k, b.oper);
                pqueue.add(b);
                return true;
            } else
                return false;
        }
        hist.put(k, b.oper);
        pqueue.add(b);
        return true;
    }
 
    private void printBd(Bd b) {
        System.out.println("----------------");
        for (int y = 0; y < 3; y++)
            System.out.println("- " + b.pn[0][y] + " " + b.pn[1][y] + " " + b.pn[2][y] + " -");
        System.out.println("------- diff " + b.diff + " oper " + b.oper + " queue " + pqueue.size());
        if (pqueue.size() > 100000)
            System.exit(0);
    }
}

</source>
</class>

<class classid="132" nclones="2" nlines="91" similarity="100">
<source file="../hum_codes_raw/s234632500.java" startline="1" endline="196" pcid="7929">
import java.util.*;
// import java.io.*;
import java.io.PrintWriter;

public class Main {
    public static void main(String[] args) throws Exception {
        // Your code here!
        Scanner sc = new Scanner(System.in);
        // FastScanner sc = new FastScanner(System.in);
        int n = sc.nextInt();
        int[][] array = new int[n][3];
        for (int i = 0; i < n; i++) {
            array[i][0] = Integer.parseInt(sc.next())-1;   // x[i]
            array[i][1] = Integer.parseInt(sc.next())-1;   // y[i]
            array[i][2] = i;
        }
        
        // ans[i]:
        // 
        // ans[i] = ()
        // ex. (2,2) -> (4,5) -> (1,3)
        
        // how:
        // Union-Find
        // 1. higher(y)
        // 2. lower(x)
        // ()
        
        // a: x
        int[][] a = new int[n][3];
        for (int i = 0; i < n; i++) {
            a[i][0] = array[i][0];
            a[i][1] = array[i][1];
            a[i][2] = array[i][2];
        }
        Arrays.sort(a, (ax, bx) -> Integer.compare(ax[0], bx[0]));
        
        // b: y
        int[][] b = new int[n][3];
        for (int i = 0; i < n; i++) {
            b[i][0] = array[i][0];
            b[i][1] = array[i][1];
            b[i][2] = array[i][2];
        }
        Arrays.sort(b, (ax, bx) -> Integer.compare(ax[1], bx[1]));
        
        UnionFind uf = new UnionFind(n);
        
        // 
        TreeMap<Integer, Integer> map = new TreeMap<Integer, Integer>();
        for (int i = n-1; i >= 0; i--) {
            int nowy = a[i][1];
            int idx = a[i][2];
            
            if (map.higherKey(nowy) != null) {
                int key = map.higherKey(nowy);
                int val = map.get(key);
                uf.unite(idx, val);
                // System.out.println(i + " " + idx + " " + val);
            }
            map.put(nowy, idx);
        }
        // System.out.println(map.toString());
        
        // 
        map = new TreeMap<Integer, Integer>();
        for (int i = 0; i < n; i++) {
            int nowx = b[i][0];
            int idx = b[i][2];
            
            if (map.lowerKey(nowx) != null) {
                int key = map.lowerKey(nowx);
                int val = map.get(key);
                uf.unite(idx, val);
                // System.out.println(i + " " + idx + " " + val);
            }
            map.put(nowx, idx);
        }
        // System.out.println(map.toString());
        
        // ans: 
        PrintWriter out = new PrintWriter(System.out);
        for (int i = 0; i < n; i++) {
            int res = uf.size[uf.root(i)];
            out.println(res);
        }    
        out.flush();
    }
    
    // static class FastScanner {
    //     private BufferedReader reader = null;
    //     private StringTokenizer tokenizer = null;
        
    //     public FastScanner(InputStream in) {
    //         reader = new BufferedReader(new InputStreamReader(in));
    //         tokenizer = null;
    //     }
        
    //     public String next() {
    //         if (tokenizer == null || !tokenizer.hasMoreTokens()) {
    //             try {
    //                 tokenizer = new StringTokenizer(reader.readLine());
    //             } catch (IOException e) {
    //                 throw new RuntimeException(e);
    //             }
    //         }
    //         return tokenizer.nextToken();
    //     }
        
    //     public String nextLine() {
    //         if (tokenizer == null || !tokenizer.hasMoreTokens()) {
    //             try {
    //                 return reader.readLine();
    //             } catch (IOException e) {
    //                 throw new RuntimeException(e);
    //             }
    //         }
        
    //         return tokenizer.nextToken("\n");
    //     }
        
    //     public long nextLong() {
    //         return Long.parseLong(next());
    //     }
        
    //     public int nextInt() {
    //         return Integer.parseInt(next());
    //     }
        
    //     public double nextDouble() {
    //          return Double.parseDouble(next());
    //     }
        
    //     public int[] nextIntArray(int n) {
    //         int[] a = new int[n];
    //         for (int i = 0; i < n; i++)
    //             a[i] = nextInt();
    //         return a;
    //     }
        
    //     public long[] nextLongArray(int n) {
    //         long[] a = new long[n];
    //         for (int i = 0; i < n; i++)
    //             a[i] = nextLong();
    //         return a;
    //     } 
    // }
}

class UnionFind {
    int[] par;  // 
    int[] size; // (size[uf.root(i)])
                // ([i])
    int connectedComponent;

    UnionFind(int n) {
        par = new int[n];
        for (int i = 0; i < n; i++) {
            par[i] = i;
        }
        
        size = new int[n];
        Arrays.fill(size, 1);
        connectedComponent = n;
    }

    int root(int x) {
        if (par[x] == x) return x;
        return par[x] = root(par[x]);
        // 1-2-44=24=1
        // ()
        // return a = b;aba
    }
    
    // x, y=
    void unite(int x, int y) {
        int rx = root(x);
        int ry = root(y);
        if (rx != ry) {
            par[ry] = rx;
            
            int resize = size[rx] + size[ry];
            size[rx] = resize;
            size[ry] = resize;
            connectedComponent--;
        }
    }
    
    // 
    boolean same(int x, int y) {
        int rx = root(x);
        int ry = root(y);
        return rx == ry;
    }
}

</source>
<source file="../hum_codes_raw/s373167882.java" startline="1" endline="196" pcid="12550">
import java.util.*;
// import java.io.*;
import java.io.PrintWriter;

public class Main {
    public static void main(String[] args) throws Exception {
        // Your code here!
        Scanner sc = new Scanner(System.in);
        // FastScanner sc = new FastScanner(System.in);
        int n = sc.nextInt();
        int[][] array = new int[n][3];
        for (int i = 0; i < n; i++) {
            array[i][0] = Integer.parseInt(sc.next())-1;   // x[i]
            array[i][1] = Integer.parseInt(sc.next())-1;   // y[i]
            array[i][2] = i;
        }
        
        // ans[i]:
        // 
        // ans[i] = ()
        // ex. (2,2) -> (4,5) -> (1,3)
        
        // how:
        // Union-Find
        // 1. higher(y)
        // 2. lower(x)
        // ()
        
        // a: x
        int[][] a = new int[n][3];
        for (int i = 0; i < n; i++) {
            a[i][0] = array[i][0];
            a[i][1] = array[i][1];
            a[i][2] = array[i][2];
        }
        Arrays.sort(a, (ax, bx) -> Integer.compare(ax[0], bx[0]));
        
        // b: y
        int[][] b = new int[n][3];
        for (int i = 0; i < n; i++) {
            b[i][0] = array[i][0];
            b[i][1] = array[i][1];
            b[i][2] = array[i][2];
        }
        Arrays.sort(b, (ax, bx) -> Integer.compare(ax[1], bx[1]));
        
        UnionFind uf = new UnionFind(n);
        
        // 
        TreeMap<Integer, Integer> map = new TreeMap<Integer, Integer>();
        for (int i = n-1; i >= 0; i--) {
            int nowy = a[i][1];
            int idx = a[i][2];
            
            if (map.higherKey(nowy) != null) {
                int key = map.higherKey(nowy);
                int val = map.get(key);
                uf.unite(idx, val);
                // System.out.println(i + " " + idx + " " + val);
            }
            map.put(nowy, idx);
        }
        // System.out.println(map.toString());
        
        // 
        map = new TreeMap<Integer, Integer>();
        for (int i = 0; i < n; i++) {
            int nowx = b[i][0];
            int idx = b[i][2];
            
            if (map.lowerKey(nowx) != null) {
                int key = map.lowerKey(nowx);
                int val = map.get(key);
                uf.unite(idx, val);
                // System.out.println(i + " " + idx + " " + val);
            }
            map.put(nowx, idx);
        }
        // System.out.println(map.toString());
        
        // ans: 
        PrintWriter out = new PrintWriter(System.out);
        for (int i = 0; i < n; i++) {
            int res = uf.size[uf.root(i)];
            out.println(res);
        }    
        out.flush();
    }
    
    // static class FastScanner {
    //     private BufferedReader reader = null;
    //     private StringTokenizer tokenizer = null;
        
    //     public FastScanner(InputStream in) {
    //         reader = new BufferedReader(new InputStreamReader(in));
    //         tokenizer = null;
    //     }
        
    //     public String next() {
    //         if (tokenizer == null || !tokenizer.hasMoreTokens()) {
    //             try {
    //                 tokenizer = new StringTokenizer(reader.readLine());
    //             } catch (IOException e) {
    //                 throw new RuntimeException(e);
    //             }
    //         }
    //         return tokenizer.nextToken();
    //     }
        
    //     public String nextLine() {
    //         if (tokenizer == null || !tokenizer.hasMoreTokens()) {
    //             try {
    //                 return reader.readLine();
    //             } catch (IOException e) {
    //                 throw new RuntimeException(e);
    //             }
    //         }
        
    //         return tokenizer.nextToken("\n");
    //     }
        
    //     public long nextLong() {
    //         return Long.parseLong(next());
    //     }
        
    //     public int nextInt() {
    //         return Integer.parseInt(next());
    //     }
        
    //     public double nextDouble() {
    //          return Double.parseDouble(next());
    //     }
        
    //     public int[] nextIntArray(int n) {
    //         int[] a = new int[n];
    //         for (int i = 0; i < n; i++)
    //             a[i] = nextInt();
    //         return a;
    //     }
        
    //     public long[] nextLongArray(int n) {
    //         long[] a = new long[n];
    //         for (int i = 0; i < n; i++)
    //             a[i] = nextLong();
    //         return a;
    //     } 
    // }
}

class UnionFind {
    int[] par;  // 
    int[] size; // (size[uf.root(i)])
                // ([i])
    int connectedComponent;

    UnionFind(int n) {
        par = new int[n];
        for (int i = 0; i < n; i++) {
            par[i] = i;
        }
        
        size = new int[n];
        Arrays.fill(size, 1);
        connectedComponent = n;
    }

    int root(int x) {
        if (par[x] == x) return x;
        return par[x] = root(par[x]);
        // 1-2-44=24=1
        // ()
        // return a = b;aba
    }
    
    // x, y=
    void unite(int x, int y) {
        int rx = root(x);
        int ry = root(y);
        if (rx != ry) {
            par[ry] = rx;
            
            int resize = size[rx] + size[ry];
            size[rx] = resize;
            size[ry] = resize;
            connectedComponent--;
        }
    }
    
    // 
    boolean same(int x, int y) {
        int rx = root(x);
        int ry = root(y);
        return rx == ry;
    }
}

</source>
</class>

<class classid="133" nclones="2" nlines="25" similarity="100">
<source file="../hum_codes_raw/s235438384.java" startline="1" endline="28" pcid="7948">
import java.util.*;
import java.util.stream.*;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int K = in.nextInt();
        long num = 0, d = 1;
        for(int i = 0; i < K; i++)  {
            num += d;
            if(calc(num + 2 * d) < calc(num + d)) {
                d *= 10L;
            }
            System.out.println(num);
        }
    }

    public static double calc(long num) {
        double n = (double) num;
        double sum = 0;
        while(num != 0L) {
            sum += num % 10;
            num /= 10;
        }
        return n / sum;
    }
}

</source>
<source file="../hum_codes_raw/s660376524.java" startline="1" endline="28" pcid="22171">
import java.util.*;
import java.util.stream.*;
 
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int K = in.nextInt();
        long num = 0, d = 1;
        for(int i = 0; i < K; i++)  {
            num += d;
            if(calc(num + 2 * d) < calc(num + d)) {
                d *= 10L;
            }
            System.out.println(num);
        }
    }
 
    public static double calc(long num) {
        double n = (double) num;
        double sum = 0;
        while(num != 0L) {
            sum += num % 10;
            num /= 10;
        }
        return n / sum;
    }
}

</source>
</class>

<class classid="134" nclones="2" nlines="11" similarity="100">
<source file="../hum_codes_raw/s239362552.java" startline="1" endline="15" pcid="8085">
import java.util.*;

public class Main{
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);

		while(true){
			int x = sc.nextInt();
			if(x == -1) break;

			System.out.println(Integer.toString(x,4));
		}
	}
}

</source>
<source file="../hum_codes_raw/s764964207.java" startline="1" endline="14" pcid="25689">
import java.util.*;

public class Main{
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);

		while(true){
			int x = sc.nextInt();
			if(x == -1) break;
			System.out.println(Integer.toString(x,4));
		}
	}
}

</source>
</class>

<class classid="135" nclones="2" nlines="17" similarity="100">
<source file="../hum_codes_raw/s241036746.java" startline="1" endline="21" pcid="8127">
import java.util.Scanner;
 class Main{
	int high,low,sa;
	
	public void solve(){
		Scanner sc =new Scanner(System.in);
		
		for(int i=0;i<7;i++){
			high = sc.nextInt();
			low = sc.nextInt();
			sa = high-low;
			System.out.println(sa);
		}
	}
	public static void main(String[] args){
		Main obj = new Main();
		obj.solve();
	}
 }
	

</source>
<source file="../hum_codes_raw/s746654939.java" startline="1" endline="21" pcid="25068">
import java.util.Scanner;
 
class Main{
        int high,low,sa;
     
    public void solve(){
        Scanner sc=new Scanner(System.in);
         
        for(int i=0;i<7;i++){
        high=sc.nextInt();
        low=sc.nextInt();
        sa=high-low;
        System.out.println(sa);
        }
    }
    public static void main(String[]args){
        Main obj=new Main();
        obj.solve();
    }
}

</source>
</class>

<class classid="136" nclones="2" nlines="86" similarity="100">
<source file="../hum_codes_raw/s247757307.java" startline="1" endline="96" pcid="8339">
import java.util.Scanner;
import java.util.PriorityQueue;
import java.util.Comparator;

public class Main {
	class Edge{
		int p, q;
		double cost;
		Edge(int p, int q, double cost){
			this.p = p; this.q = q;
			this.cost = cost;
		}
	}
	int[] par;
//	union-find
	void unionfindInit(int n){
		for(int i = 0;i < n;i++) {
			par[i] = i;
		}
	}
//	
	int unionfindRoot(int x) {
		if(par[x]==x) {
			return x;
		}
		else {
			return par[x] = unionfindRoot(par[x]);
		}
	}
//	xy
	boolean unionfindSame(int x, int y) {
		return unionfindRoot(x) == unionfindRoot(y);
	}
	
//	xy
	void unionfinUnite(int x, int y) {
		x = unionfindRoot(x);
		y = unionfindRoot(y);
		if (x == y) return;
		par[x]=y;
	}
	void run(){
		Scanner scan = new Scanner(System.in);
		int N = scan.nextInt();
		par = new int[N+1];
		int M = scan.nextInt();
		int coordinate[][] = new int[N+1][2];
		int p, q;
		double hen1, hen2;
		double[] hypotenuse = new double[M]; //
		PriorityQueue<Edge> edge = new PriorityQueue<Edge>(new Comparator<Edge>() {
			@Override
			public int compare(Edge e1, Edge e2) {
				if(e2.cost > e1.cost) {
					return 1;
				}
				else if(e2.cost < e1.cost){
					return -1;
				}
				return 0;
			}
		});
		Edge tmp = new Edge(0,0,0);
//		
		for(int i=1; i< N+1;i++) {
			coordinate[i][0] = scan.nextInt();;
			coordinate[i][1] = scan.nextInt();;
		}
//		
		unionfindInit(N+1);
		for(int i=0; i < M; i++) {
			p = scan.nextInt();
			q = scan.nextInt();
			hen1 = Math.abs(coordinate[p][0] - coordinate[q][0]);
			hen2 = Math.abs(coordinate[p][1] - coordinate[q][1]);
			hypotenuse[i] = Math.sqrt(hen1*hen1+hen2*hen2);
			edge.offer(new Edge(p, q, hypotenuse[i]));
		}
//		System.out.println("mainasu: " + mainasu_sum);
		double sum=0;
		for(int i = 0; i < M; i++) {
			tmp = edge.poll();
			if(!unionfindSame(tmp.p, tmp.q)) unionfinUnite(tmp.p, tmp.q);
			else {
				sum += tmp.cost;
//				System.out.println("tmp: " + tmp.cost);
			}
		}
		System.out.println(sum);
	}
	public static void main(String[] args) {
		new Main().run();
	}
}


</source>
<source file="../hum_codes_raw/s643937992.java" startline="1" endline="96" pcid="21607">
import java.util.Scanner;
import java.util.PriorityQueue;
import java.util.Comparator;

public class Main {
	class Edge{
		int p, q;
		double cost;
		Edge(int p, int q, double cost){
			this.p = p; this.q = q;
			this.cost = cost;
		}
	}
	int[] par;
//	union-find
	void unionfindInit(int n){
		for(int i = 0;i < n;i++) {
			par[i] = i;
		}
	}
//	
	int unionfindRoot(int x) {
		if(par[x]==x) {
			return x;
		}
		else {
			return par[x] = unionfindRoot(par[x]);
		}
	}
//	xy
	boolean unionfindSame(int x, int y) {
		return unionfindRoot(x) == unionfindRoot(y);
	}
	
//	xy
	void unionfinUnite(int x, int y) {
		x = unionfindRoot(x);
		y = unionfindRoot(y);
		if (x == y) return;
		par[x]=y;
	}
	void run(){
		Scanner scan = new Scanner(System.in);
		int N = scan.nextInt();
		par = new int[N+1];
		int M = scan.nextInt();
		int coordinate[][] = new int[N+1][2];
		int p, q;
		double hen1, hen2;
		double[] hypotenuse = new double[M]; //
		PriorityQueue<Edge> edge = new PriorityQueue<Edge>(new Comparator<Edge>() {
			@Override
			public int compare(Edge e1, Edge e2) {
				if(e2.cost > e1.cost) {
					return 1;
				}
				else if(e2.cost < e1.cost){
					return -1;
				}
				return 0;
			}
		});
		Edge tmp = new Edge(0,0,0);
//		
		for(int i=1; i< N+1;i++) {
			coordinate[i][0] = scan.nextInt();;
			coordinate[i][1] = scan.nextInt();;
		}
//		
		unionfindInit(N+1);
		for(int i=0; i < M; i++) {
			p = scan.nextInt();
			q = scan.nextInt();
			hen1 = Math.abs(coordinate[p][0] - coordinate[q][0]);
			hen2 = Math.abs(coordinate[p][1] - coordinate[q][1]);
			hypotenuse[i] = Math.sqrt(hen1*hen1+hen2*hen2);
			edge.offer(new Edge(p, q, hypotenuse[i]));
		}
//		System.out.println("mainasu: " + mainasu_sum);
		double sum=0;
		for(int i = 0; i < M; i++) {
			tmp = edge.poll();
			if(!unionfindSame(tmp.p, tmp.q)) unionfinUnite(tmp.p, tmp.q);
			else {
				sum += tmp.cost;
//				System.out.println("tmp: " + tmp.cost);
			}
		}
		System.out.println(sum);
	}
	public static void main(String[] args) {
		new Main().run();
	}
}


</source>
</class>

<class classid="137" nclones="2" nlines="154" similarity="100">
<source file="../hum_codes_raw/s249685457.java" startline="1" endline="157" pcid="8404">
import java.io.InputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.BitSet;
import java.util.Collections;
import java.util.Comparator;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;
import java.math.BigInteger;

public class Main{

static PrintWriter out;
static InputReader ir;

static void solve(){
 ArrayList<Integer> buf=new ArrayList<>();
 boolean[] prime=sieveOfEratosthenes(100350);
 int n,p;
 for(;;){
  ArrayList<Integer> al=new ArrayList<>();
  n=ir.nextInt();
  p=ir.nextInt();
  if(n<0&&p<0) return;
  for(int i=n+1;i<=n+350;i++){
   if(prime[i]) al.add(i);
  }
  for(int i=0;i<al.size();i++){
   for(int j=i;j<al.size();j++){
    int sum=al.get(i)+al.get(j);
    buf.add(sum);
   }
  }
  Collections.sort(buf);
  out.println(buf.get(p-1));
  buf.clear();
 }
}

public static boolean[] sieveOfEratosthenes(int a){
 boolean[] ret=new boolean[a+1];
 Arrays.fill(ret,true);
 ret[0]=ret[1]=false;
 for(int i=2;i<=Math.sqrt(a);i++){
  if(!ret[i]) continue;
  for(int j=i+i;j<=a;j+=i) ret[j]=false;
 }
 return ret;
}

public static void main(String[] args) throws Exception{
 ir=new InputReader(System.in);
 out=new PrintWriter(System.out);
 solve();
 out.flush();
}

static class InputReader {
 private InputStream in;
 private byte[] buffer=new byte[1024];
 private int curbuf;
 private int lenbuf;

 public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}
 
 public boolean hasNextByte() {
  if(curbuf>=lenbuf){
   curbuf= 0;
   try{
    lenbuf=in.read(buffer);
   }catch(IOException e) {
    throw new InputMismatchException();
   }
   if(lenbuf<=0) return false;
  }
  return true;
 }

 private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}
 
 private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}
 
 private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}
 
 public boolean hasNext(){skip(); return hasNextByte();}
 
 public String next(){
  if(!hasNext()) throw new NoSuchElementException();
  StringBuilder sb=new StringBuilder();
  int b=readByte();
  while(!isSpaceChar(b)){
   sb.appendCodePoint(b);
   b=readByte();
  }
  return sb.toString();
 }
 
 public int nextInt() {
  if(!hasNext()) throw new NoSuchElementException();
  int c=readByte();
  while (isSpaceChar(c)) c=readByte();
  boolean minus=false;
  if (c=='-') {
   minus=true;
   c=readByte();
  }
  int res=0;
  do{
   if(c<'0'||c>'9') throw new InputMismatchException();
   res=res*10+c-'0';
   c=readByte();
  }while(!isSpaceChar(c));
  return (minus)?-res:res;
 }
 
 public long nextLong() {
  if(!hasNext()) throw new NoSuchElementException();
  int c=readByte();
  while (isSpaceChar(c)) c=readByte();
  boolean minus=false;
  if (c=='-') {
   minus=true;
   c=readByte();
  }
  long res = 0;
  do{
   if(c<'0'||c>'9') throw new InputMismatchException();
   res=res*10+c-'0';
   c=readByte();
  }while(!isSpaceChar(c));
  return (minus)?-res:res;
 }

 public double nextDouble(){return Double.parseDouble(next());}

 public int[] nextIntArray(int n){
  int[] a=new int[n];
  for(int i=0;i<n;i++) a[i]=nextInt();
  return a;
 }

 public long[] nextLongArray(int n){
  long[] a=new long[n];
  for(int i=0;i<n;i++) a[i]=nextLong();
  return a;
 }

 public char[][] nextCharMap(int n,int m){
  char[][] map=new char[n][m];
  for(int i=0;i<n;i++) map[i]=next().toCharArray();
  return map;
 }
}
}

</source>
<source file="../hum_codes_raw/s804874321.java" startline="1" endline="157" pcid="27036">
import java.io.InputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.BitSet;
import java.util.Collections;
import java.util.Comparator;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;
import java.math.BigInteger;

public class Main{

static PrintWriter out;
static InputReader ir;

static void solve(){
 ArrayList<Integer> buf=new ArrayList<>();
 boolean[] prime=sieveOfEratosthenes(100350);
 int n,p;
 for(;;){
  ArrayList<Integer> al=new ArrayList<>();
  n=ir.nextInt();
  p=ir.nextInt();
  if(n<0&&p<0) return;
  for(int i=n+1;i<=n+350;i++){
   if(prime[i]) al.add(i);
  }
  for(int i=0;i<al.size();i++){
   for(int j=i;j<al.size();j++){
    int sum=al.get(i)+al.get(j);
    buf.add(sum);
   }
  }
  Collections.sort(buf);
  out.println(buf.get(p-1));
  buf.clear();
 }
}

public static boolean[] sieveOfEratosthenes(int a){
 boolean[] ret=new boolean[a+1];
 Arrays.fill(ret,true);
 ret[0]=ret[1]=false;
 for(int i=2;i<=Math.sqrt(a);i++){
  if(!ret[i]) continue;
  for(int j=i+i;j<=a;j+=i) ret[j]=false;
 }
 return ret;
}

public static void main(String[] args) throws Exception{
 ir=new InputReader(System.in);
 out=new PrintWriter(System.out);
 solve();
 out.flush();
}

static class InputReader {
 private InputStream in;
 private byte[] buffer=new byte[1024];
 private int curbuf;
 private int lenbuf;

 public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}
 
 public boolean hasNextByte() {
  if(curbuf>=lenbuf){
   curbuf= 0;
   try{
    lenbuf=in.read(buffer);
   }catch(IOException e) {
    throw new InputMismatchException();
   }
   if(lenbuf<=0) return false;
  }
  return true;
 }

 private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}
 
 private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}
 
 private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}
 
 public boolean hasNext(){skip(); return hasNextByte();}
 
 public String next(){
  if(!hasNext()) throw new NoSuchElementException();
  StringBuilder sb=new StringBuilder();
  int b=readByte();
  while(!isSpaceChar(b)){
   sb.appendCodePoint(b);
   b=readByte();
  }
  return sb.toString();
 }
 
 public int nextInt() {
  if(!hasNext()) throw new NoSuchElementException();
  int c=readByte();
  while (isSpaceChar(c)) c=readByte();
  boolean minus=false;
  if (c=='-') {
   minus=true;
   c=readByte();
  }
  int res=0;
  do{
   if(c<'0'||c>'9') throw new InputMismatchException();
   res=res*10+c-'0';
   c=readByte();
  }while(!isSpaceChar(c));
  return (minus)?-res:res;
 }
 
 public long nextLong() {
  if(!hasNext()) throw new NoSuchElementException();
  int c=readByte();
  while (isSpaceChar(c)) c=readByte();
  boolean minus=false;
  if (c=='-') {
   minus=true;
   c=readByte();
  }
  long res = 0;
  do{
   if(c<'0'||c>'9') throw new InputMismatchException();
   res=res*10+c-'0';
   c=readByte();
  }while(!isSpaceChar(c));
  return (minus)?-res:res;
 }

 public double nextDouble(){return Double.parseDouble(next());}

 public int[] nextIntArray(int n){
  int[] a=new int[n];
  for(int i=0;i<n;i++) a[i]=nextInt();
  return a;
 }

 public long[] nextLongArray(int n){
  long[] a=new long[n];
  for(int i=0;i<n;i++) a[i]=nextLong();
  return a;
 }

 public char[][] nextCharMap(int n,int m){
  char[][] map=new char[n][m];
  for(int i=0;i<n;i++) map[i]=next().toCharArray();
  return map;
 }
}
}

</source>
</class>

<class classid="138" nclones="2" nlines="118" similarity="100">
<source file="../hum_codes_raw/s250783456.java" startline="1" endline="153" pcid="8447">
import java.util.*;

public class Main {
    static long INF = 1001001001001001018L;
    
    public static void main(String[] args) throws Exception {
        // Your code here!
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        
        while (t--> 0) {
            long n = sc.nextLong();
            long a = sc.nextLong();
            long b = sc.nextLong();
            long c = sc.nextLong();
            long d = sc.nextLong();
            
            long start = n;
            long goal = 1;
            
            // to: ()
            
            // dist: start
            // map
            // <- 10^18
            // <- ()
            Map<Long, Long> dist = new HashMap<Long, Long>();
            dist.put(start, 0L);
            
            // : BFS
            // ()
            PriorityQueue<Point> que = new PriorityQueue<>();
            que.add(new Point(start, 0));
            while (!que.isEmpty()) {
                Point cur = que.poll();
                long p = cur.name;
                long dis = cur.dist;
                
                // System.out.println(p + " " + dis);
                
                // distdis
                if (dis > dist.getOrDefault(p, INF)) continue;
                
                if (p <= 1) continue;
                
                long q;
                long PtoQ;
                
                // -1
                q = 1;
                PtoQ = dis + (p-1) * d;
                // if (PtoQ < dist.getOrDefault(q, INF)) {
                if (dis / d + (p-1) < dist.getOrDefault(q, INF) / d) {
                    dist.put(q, PtoQ);
                    que.add(new Point(q, PtoQ));
                }
                
                // /2
                if (p % 2 == 0) {
                    q = p / 2;
                    PtoQ = dis + a;
                    if (PtoQ < dist.getOrDefault(q, INF)) {
                        dist.put(q, PtoQ);
                        que.add(new Point(q, PtoQ));
                    }
                } else {
                    q = p / 2;
                    PtoQ = dis + d * (p % 2) + a;
                    if (PtoQ < dist.getOrDefault(q, INF)) {
                        dist.put(q, PtoQ);
                        que.add(new Point(q, PtoQ));
                    }
                    
                    q = (p+1) / 2;
                    PtoQ = dis + d * (2 - (p % 2)) + a;
                    if (PtoQ < dist.getOrDefault(q, INF)) {
                        dist.put(q, PtoQ);
                        que.add(new Point(q, PtoQ));
                    }
                }
                
                // /3
                if (p % 3 == 0) {
                    q = p / 3;
                    PtoQ = dis + b;
                    if (PtoQ < dist.getOrDefault(q, INF)) {
                        dist.put(q, PtoQ);
                        que.add(new Point(q, PtoQ));
                    }
                } else {
                    q = p / 3;
                    PtoQ = dis + d * (p % 3) + b;
                    if (PtoQ < dist.getOrDefault(q, INF)) {
                        dist.put(q, PtoQ);
                        que.add(new Point(q, PtoQ));
                    }
                    
                    q = (p+2) / 3;
                    PtoQ = dis + d * (3 - (p % 3)) + b;
                    if (PtoQ < dist.getOrDefault(q, INF)) {
                        dist.put(q, PtoQ);
                        que.add(new Point(q, PtoQ));
                    }
                }
                
                // /5
                if (p % 5 == 0) {
                    q = p / 5;
                    PtoQ = dis + c;
                    if (PtoQ < dist.getOrDefault(q, INF)) {
                        dist.put(q, PtoQ);
                        que.add(new Point(q, PtoQ));
                    }
                } else {
                    q = p / 5;
                    PtoQ = dis + d * (p % 5) + c;
                    if (PtoQ < dist.getOrDefault(q, INF)) {
                        dist.put(q, PtoQ);
                        que.add(new Point(q, PtoQ));
                    }
                    
                    q = (p+4) / 5;
                    PtoQ = dis + d * (5 - (p % 5)) + c;
                    if (PtoQ < dist.getOrDefault(q, INF)) {
                        dist.put(q, PtoQ);
                        que.add(new Point(q, PtoQ));
                    }
                }
            }
            System.out.println(dist.get(goal) + d);
        }
    }
}
    
class Point implements Comparable<Point> {
    long name;
    long dist;
     
    Point(long name, long dist) {
        this.name = name;
        this.dist = dist;
    }
    
    @Override
    public int compareTo(Point o) {
        //
        if (this.dist < o.dist) {
            return -1;
        } 
        return 1;
    }
}

</source>
<source file="../hum_codes_raw/s809415687.java" startline="1" endline="174" pcid="27193">
import java.util.*;

public class Main {
    static long INF = 1001001001001001018L;
    
    public static void main(String[] args) throws Exception {
        // Your code here!
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        
        // ans: n0 (N <= 10^18)
        // : p -> q ()
        // 1. n -> n/2 (a) ( n%2 = 0)
        // 2. n -> n/3 (b) ( n%3 = 0)
        // 3. n -> n/5 (c) ( n%5 = 0)
        // 4. n -> n-1 (d)
        // 5. n -> n+1 (d)
        
        while (t--> 0) {
            long n = sc.nextLong();
            long a = sc.nextLong();
            long b = sc.nextLong();
            long c = sc.nextLong();
            long d = sc.nextLong();
            
            long start = n;
            long goal = 1;
            
            // to: ()
            
            // dist: start
            // map
            // <- 10^18
            // <- ()
            Map<Long, Long> dist = new HashMap<Long, Long>();
            dist.put(start, 0L);
            
            // : BFS
            // ()
            PriorityQueue<Point> que = new PriorityQueue<>();
            que.add(new Point(start, 0));
            while (!que.isEmpty()) {
                Point cur = que.poll();
                long p = cur.name;
                long dis = cur.dist;
                
                // distdis
                if (dis > dist.getOrDefault(p, INF)) continue;
                
                if (p <= 1) continue;
                
                // // pdis
                // System.out.println(p + " " + dis);
                
                //  + pq
                long q;
                long PtoQ;
                
                // : ex. 11 -> q ()
                // ()
                // 1. 1-1
                // -> 11->1                     ((p-1)*d)
                // 2. 2()/2
                // -> 11(->10)->5, 11(->12)->6  (2*d + a)
                // 3. 3()/3
                // -> 11(->9)->3, 11(->12)->4   (3*d + b)
                // 4. 5()/5
                // -> 11(->10)->2, 11(->15)->3  (5*d + c)
                
                // -1
                q = 1;
                PtoQ = dis + (p-1) * d;
                // if (PtoQ < dist.getOrDefault(q, INF)) {
                if (dis / d + (p-1) < dist.getOrDefault(q, INF) / d) {  // 
                    dist.put(q, PtoQ);
                    que.add(new Point(q, PtoQ));
                }
                
                // /2
                if (p % 2 == 0) {
                    q = p / 2;
                    PtoQ = dis + a;
                    if (PtoQ < dist.getOrDefault(q, INF)) {
                        dist.put(q, PtoQ);
                        que.add(new Point(q, PtoQ));
                    }
                } else {
                    q = p / 2;
                    PtoQ = dis + d * (p % 2) + a;
                    if (PtoQ < dist.getOrDefault(q, INF)) {
                        dist.put(q, PtoQ);
                        que.add(new Point(q, PtoQ));
                    }
                    
                    q = (p+1) / 2;
                    PtoQ = dis + d * (2 - (p % 2)) + a;
                    if (PtoQ < dist.getOrDefault(q, INF)) {
                        dist.put(q, PtoQ);
                        que.add(new Point(q, PtoQ));
                    }
                }
                
                // /3
                if (p % 3 == 0) {
                    q = p / 3;
                    PtoQ = dis + b;
                    if (PtoQ < dist.getOrDefault(q, INF)) {
                        dist.put(q, PtoQ);
                        que.add(new Point(q, PtoQ));
                    }
                } else {
                    q = p / 3;
                    PtoQ = dis + d * (p % 3) + b;
                    if (PtoQ < dist.getOrDefault(q, INF)) {
                        dist.put(q, PtoQ);
                        que.add(new Point(q, PtoQ));
                    }
                    
                    q = (p+2) / 3;
                    PtoQ = dis + d * (3 - (p % 3)) + b;
                    if (PtoQ < dist.getOrDefault(q, INF)) {
                        dist.put(q, PtoQ);
                        que.add(new Point(q, PtoQ));
                    }
                }
                
                // /5
                if (p % 5 == 0) {
                    q = p / 5;
                    PtoQ = dis + c;
                    if (PtoQ < dist.getOrDefault(q, INF)) {
                        dist.put(q, PtoQ);
                        que.add(new Point(q, PtoQ));
                    }
                } else {
                    q = p / 5;
                    PtoQ = dis + d * (p % 5) + c;
                    if (PtoQ < dist.getOrDefault(q, INF)) {
                        dist.put(q, PtoQ);
                        que.add(new Point(q, PtoQ));
                    }
                    
                    q = (p+4) / 5;
                    PtoQ = dis + d * (5 - (p % 5)) + c;
                    if (PtoQ < dist.getOrDefault(q, INF)) {
                        dist.put(q, PtoQ);
                        que.add(new Point(q, PtoQ));
                    }
                }
            }
            System.out.println(dist.get(goal) + d);
        }
    }
}
    
class Point implements Comparable<Point> {
    long name;
    long dist;
     
    Point(long name, long dist) {
        this.name = name;
        this.dist = dist;
    }
    
    @Override
    public int compareTo(Point o) {
        //
        if (this.dist < o.dist) {
            return -1;
        } 
        return 1;
    }
}

</source>
</class>

<class classid="139" nclones="2" nlines="86" similarity="100">
<source file="../hum_codes_raw/s250879105.java" startline="1" endline="99" pcid="8449">
import java.util.Scanner;

public class Main {
	final int N = 4;
	final int N2 = 16;
	final int LIMIT = 45;

	class Puzzle {
		int[] board = new int[N2];
		int space, md;
		Puzzle() {}
		Puzzle(Puzzle p) {
			space = p.space;
			md = p.md;
			for (int i = 0; i < N2; i++)
				board[i] = p.board[i];
		}
		int getAllMD() {
			int sum = 0;
			for (int i = 0; i < N2; i++) {
				if (board[i] == N2) continue;
				sum += mdt[i][board[i] - 1];
			}
			return sum;
		}
		void swap(int next, int cur) {
			int tmp = this.board[cur];
			this.board[cur] = this.board[next];
			this.board[next] = tmp;
		}
	}

	int limit = 0;
	int[] path = new int[LIMIT];
	int[][] mdt = new int[N2][N2];
	Puzzle state = null;
	char[] dir = {'r', 'u', 'l', 'd'};
	int[] dx = { 0, -1, 0, 1 };
	int[] dy = { 1, 0, -1, 0 };

	void run() {
		Scanner scan = new Scanner(System.in);
		
		for (int i = 0; i < N2; i++)
			for (int j = 0; j < N2; j++)
				mdt[i][j] = Math.abs(i / N - j / N) + Math.abs(i % N - j % N);

		Puzzle p = new Puzzle();
		
		for (int i = 0; i < N2; i++) {
			p.board[i] = scan.nextInt();
			if (p.board[i] == 0) {
				p.board[i] = N2;
				p.space = i;
			}
		}
		iterative_deepening(p);
	}
	boolean dfs(int depth, int prev) {
		if (state.md == 0) return true;
		if (depth + state.md > limit) return false;

		int sx = state.space / N;
		int sy = state.space % N;
		for (int i = 0; i < 4; i++) {
			int tx = sx + dx[i];
			int ty = sy + dy[i];
			if (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;
			if (Math.max(prev, i) - Math.min(prev, i) == 2) continue;
			Puzzle p = new Puzzle(state);
			state.md -= mdt[tx * N + ty][state.board[tx * N + ty] - 1];
			state.md += mdt[sx * N + sy][state.board[tx * N + ty] - 1];
			state.swap(tx * N + ty, sx * N + sy);
			state.space = tx * N + ty;
			if (dfs(depth + 1, i)) {
				path[depth] = i;
				return true;
			}
			state = p;
		}
		return false;
	}
	void iterative_deepening(Puzzle p) {
		p.md = p.getAllMD();
		
		for (limit = p.md; limit <= LIMIT; limit++) {
			state = new Puzzle(p);
			if (dfs(0, -100)) {
				System.out.println(limit);
				return;
			}
		}
	}
	public static void main(String[] args) {
		new Main().run();
	}
}


</source>
<source file="../hum_codes_raw/s563038916.java" startline="1" endline="100" pcid="18952">
import java.util.Scanner;

public class Main {
	final int N = 4;
	final int N2 = 16;
	final int LIMIT = 45;

	class Puzzle {
		int[] board = new int[N2];
		int space, md;
		Puzzle() {}
		Puzzle(Puzzle p) {
			space = p.space;
			md = p.md;
			for (int i = 0; i < N2; i++)
				board[i] = p.board[i];
		}
		int getAllMD() {
			int sum = 0;
			for (int i = 0; i < N2; i++) {
				if (board[i] == N2) continue;
				sum += mdt[i][board[i] - 1];
			}
			return sum;
		}
		void swap(int next, int cur) {
			int tmp = this.board[cur];
			this.board[cur] = this.board[next];
			this.board[next] = tmp;
		}
	}

	int limit = 0;
	int[] path = new int[LIMIT];
	int[][] mdt = new int[N2][N2];
	Puzzle state = null;
	char[] dir = {'r', 'u', 'l', 'd'};
	int[] dx = { 0, -1, 0, 1 };
	int[] dy = { 1, 0, -1, 0 };

	void run() {
		Scanner scan = new Scanner(System.in);
		
		for (int i = 0; i < N2; i++)
			for (int j = 0; j < N2; j++)
				mdt[i][j] = Math.abs(i / N - j / N) + Math.abs(i % N - j % N);

		Puzzle p = new Puzzle();
		
		for (int i = 0; i < N2; i++) {
			p.board[i] = scan.nextInt();
			if (p.board[i] == 0) {
				p.board[i] = N2;
				p.space = i;
			}
		}
		iterative_deepening(p);
	}
	boolean dfs(int depth, int prev) {
		if (state.md == 0) return true;
		if (depth + state.md > limit) return false;

		int sx = state.space / N;
		int sy = state.space % N;
		for (int i = 0; i < 4; i++) {
			int tx = sx + dx[i];
			int ty = sy + dy[i];
			if (tx < 0 || ty < 0 || tx >= N || ty >= N) continue;
			if (Math.max(prev, i) - Math.min(prev, i) == 2) continue;
			Puzzle p = new Puzzle(state);
			state.md -= mdt[tx * N + ty][state.board[tx * N + ty] - 1];
			state.md += mdt[sx * N + sy][state.board[tx * N + ty] - 1];
			state.swap(tx * N + ty, sx * N + sy);
			state.space = tx * N + ty;
			if (dfs(depth + 1, i)) {
				path[depth] = i;
				return true;
			}
			state = p;
		}
		return false;
	}
	void iterative_deepening(Puzzle p) {
		p.md = p.getAllMD();
		
		for (limit = p.md; limit <= LIMIT; limit++) {
			state = new Puzzle(p);
			if (dfs(0, -100)) {
				System.out.println(limit);
				return;
			}
		}
	}
	public static void main(String[] args) {
		new Main().run();
	}
}



</source>
</class>

<class classid="140" nclones="2" nlines="16" similarity="100">
<source file="../hum_codes_raw/s251188564.java" startline="1" endline="21" pcid="8457">
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		int n = sc.nextInt();
		long cnt = 0;
		for(int i=0;i<n;i++){
			sc.next();
			char c = sc.next().charAt(0);
			if(c=='(') cnt += sc.nextInt();
			else cnt -= sc.nextInt();
			if(cnt==0) System.out.println("Yes");
			else System.out.println("No");
		}
	}

}

</source>
<source file="../hum_codes_raw/s459257377.java" startline="1" endline="21" pcid="15409">
import java.util.*;
 
public class Main {
 
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
         
        int n = sc.nextInt();
        long cnt = 0;
        for(int i=0;i<n;i++){
            sc.next();
            char c = sc.next().charAt(0);
            if(c=='(') cnt += sc.nextInt();
            else cnt -= sc.nextInt();
            if(cnt==0) System.out.println("Yes");
            else System.out.println("No");
        }
    }
 
}

</source>
</class>

<class classid="141" nclones="2" nlines="103" similarity="100">
<source file="../hum_codes_raw/s253685459.java" startline="1" endline="129" pcid="8533">
import java.io.*;
import java.util.*;
 
public class Main {
 
	BufferedReader br;
	PrintWriter out;
	StringTokenizer st;
	boolean eof;
	
	List<Integer>[] g;
	int[] b;
	int k;
	
	int dfs(int v, int p) {
		int depth = 0;
		for (int u : g[v]) {
			if (u == p) {
				continue;
			}
			depth = Math.max(depth, dfs(u, v) + 1);
		}
		
		if (depth == k - 1) {
			b[v] = 0;
			return -1;
		}
		return depth;
	}
 
	void solve() throws IOException {
		int n = nextInt();
		k = nextInt();
		int[] a = new int[n];
		
		for (int i = 0; i < n; i++) {
			a[i] = nextInt() - 1;
		}
		
		b = a.clone();
		b[0] = 0;
		
		g = new List[n];
		for (int i = 0; i < n; i++) {
			g[i] = new ArrayList<>();
		}
		
		for (int i = 1; i < n; i++) {
			g[b[i]].add(i);
		}
		
		dfs(0, -1);
		
		int ret = 0;
		for (int i = 0; i < n; i++) {
			if (a[i] != b[i]) {
				ret++;
			}
		}
		
		out.println(ret);
	}
 
	Main() throws IOException {
		br = new BufferedReader(new InputStreamReader(System.in));
		out = new PrintWriter(System.out);
		
		Thread t = new Thread(null, new Runnable() {
 
			@Override
			public void run() {
				try {
					solve();
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
			
		}, "lul", 1 << 26);
		
		t.start();
		try {
			t.join();
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		out.close();
	}
 
	public static void main(String[] args) throws IOException {
		new Main();
	}
 
	String nextToken() {
		while (st == null || !st.hasMoreTokens()) {
			try {
				st = new StringTokenizer(br.readLine());
			} catch (Exception e) {
				eof = true;
				return null;
			}
		}
		return st.nextToken();
	}
 
	String nextString() {
		try {
			return br.readLine();
		} catch (IOException e) {
			eof = true;
			return null;
		}
	}
 
	int nextInt() throws IOException {
		return Integer.parseInt(nextToken());
	}
 
	long nextLong() throws IOException {
		return Long.parseLong(nextToken());
	}
 
	double nextDouble() throws IOException {
		return Double.parseDouble(nextToken());
	}
}

</source>
<source file="../hum_codes_raw/s532315066.java" startline="1" endline="129" pcid="17922">
import java.io.*;
import java.util.*;

public class Main {

	BufferedReader br;
	PrintWriter out;
	StringTokenizer st;
	boolean eof;
	
	List<Integer>[] g;
	int[] b;
	int k;
	
	int dfs(int v, int p) {
		int depth = 0;
		for (int u : g[v]) {
			if (u == p) {
				continue;
			}
			depth = Math.max(depth, dfs(u, v) + 1);
		}
		
		if (depth == k - 1) {
			b[v] = 0;
			return -1;
		}
		return depth;
	}

	void solve() throws IOException {
		int n = nextInt();
		k = nextInt();
		int[] a = new int[n];
		
		for (int i = 0; i < n; i++) {
			a[i] = nextInt() - 1;
		}
		
		b = a.clone();
		b[0] = 0;
		
		g = new List[n];
		for (int i = 0; i < n; i++) {
			g[i] = new ArrayList<>();
		}
		
		for (int i = 1; i < n; i++) {
			g[b[i]].add(i);
		}
		
		dfs(0, -1);
		
		int ret = 0;
		for (int i = 0; i < n; i++) {
			if (a[i] != b[i]) {
				ret++;
			}
		}
		
		out.println(ret);
	}

	Main() throws IOException {
		br = new BufferedReader(new InputStreamReader(System.in));
		out = new PrintWriter(System.out);
		
		Thread t = new Thread(null, new Runnable() {

			@Override
			public void run() {
				try {
					solve();
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
			
		}, "lul", 1 << 26);
		
		t.start();
		try {
			t.join();
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		out.close();
	}

	public static void main(String[] args) throws IOException {
		new Main();
	}

	String nextToken() {
		while (st == null || !st.hasMoreTokens()) {
			try {
				st = new StringTokenizer(br.readLine());
			} catch (Exception e) {
				eof = true;
				return null;
			}
		}
		return st.nextToken();
	}

	String nextString() {
		try {
			return br.readLine();
		} catch (IOException e) {
			eof = true;
			return null;
		}
	}

	int nextInt() throws IOException {
		return Integer.parseInt(nextToken());
	}

	long nextLong() throws IOException {
		return Long.parseLong(nextToken());
	}

	double nextDouble() throws IOException {
		return Double.parseDouble(nextToken());
	}
}

</source>
</class>

<class classid="142" nclones="2" nlines="163" similarity="100">
<source file="../hum_codes_raw/s254255566.java" startline="1" endline="203" pcid="8554">
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.util.List;

public class Main{
	static StringBuilder out = new StringBuilder();
	static final String OK = "OK";
	static final String NG = "NG";
	static final String Possible = "Possible";
	static final String Impossible = "Impossible";
	static FastReader in = new FastReader();
	static final int HEADS = 1;
	static final int TAILS = 0;

	// static final int INF = Integer.MAX_VALUE - 300000000;

	public static void main(String[] args) {
		while (upsideDown())
			;
	}

	private static boolean upsideDown() {
		int h = in.nextInt();
		int w = in.nextInt();
		if (h == 0 && w == 0) return false;

		int[][] senbei = in.nextIntArray2D(h, w);

		System.out.println(solve(senbei));
		return true;
	}

	private static int solve(int[][] senbei) {
		int row = senbei.length;
		int line = senbei[0].length;
		int ex = (int) Math.pow(2, row);

		int[] score = new int[ex];

		for (int i = 0; i < line; i++) {
			for (int j = 0; j < ex; j++) {
				int tempScore = 0;
				int[] filter = makeFilter(row, j);
				for (int k = 0; k < row; k++) {
					tempScore += (senbei[k][i] + filter[k]) % 2;
					// System.out.print((senbei[i][k] +
					// filter[base + k]) % 2);
				}
				// System.out.print("  ");
				score[j] += Math.max(tempScore, row - tempScore);
			}
			// System.out.println();
		}

		int maxScore = 0;
		for (int i = 0; i < ex; i++) {
			maxScore = Math.max(maxScore, score[i]);
			// System.err.println(score[i]);
		}
		return maxScore;
	}

	private static int[] makeFilter(int row, int i) {
		int[] filter = new int[row];
		int temp = i;
		for (int j = 0; j < row; j++) {
			filter[j] = temp % 2;
			temp /= 2;
		}
		return filter;
	}

	static void printExit(Object msg) {
		System.out.println(msg);
		System.exit(0);
	}
}

class FastReader{
	private InputStream in = System.in;
	private byte[] buf = new byte[1024];
	private int charNum;
	private int charLen;
	private StringBuilder sb = new StringBuilder();

	public int read() {
		if (charLen == -1) throw new InputMismatchException();
		if (charNum >= charLen) {
			charNum = 0;
			try {
				charLen = in.read(buf);
			} catch (IOException e) {
				throw new InputMismatchException();
			}
			if (charLen <= 0) return -1;
		}
		return buf[charNum++];
	}

	public String next() {
		int c = read();
		while (isWhitespace(c)) {
			c = read();
		}
		sb.setLength(0);
		do {
			sb.appendCodePoint(c);
			c = read();
		} while (!isWhitespace(c));
		return sb.toString();
	}

	public char[] nextCharArray() {
		return next().toCharArray();
	}

	public char[][] nextCharArray2d(int lines) {
		char[] first = nextCharArray();
		char[][] array = new char[lines][first.length];
		array[0] = first;
		for (int i = 1; i < lines; i++)
			array[i] = nextCharArray();
		return array;
	}

	public char[][] nextCharArray2d(int lines, int rows) {
		char[][] array = new char[lines][rows];
		for (int i = 0; i < lines; i++)
			array[i] = nextCharArray();
		return array;
	}

	public int nextInt() {
		return (int) nextLong();
	}

	public int[] nextIntArray(int n) {
		int[] array = new int[n];
		for (int i = 0; i < n; i++)
			array[i] = nextInt();
		return array;
	}

	public List<Integer> nextIntList(int n) {
		Integer[] array = new Integer[n];
		for (int i = 0; i < n; i++)
			array[i] = nextInt();
		return Arrays.asList(array);
	}

	public int[][] nextIntArray2D(int n, int m) {
		int[][] array = new int[n][m];
		for (int i = 0; i < n; i++)
			array[i] = nextIntArray(m);
		return array;
	}

	public List<int[]> nextIntsList(int n, int m) {
		List<int[]> list = new ArrayList<int[]>(n);
		for (int i = 0; i < n; i++)
			list.add(nextIntArray(m));
		return list;
	}

	public long nextLong() {
		int c = read();
		while (isWhitespace(c)) {
			c = read();
		}
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		long res = 0;
		do {
			if (c < '0' || c > '9') throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isWhitespace(c));
		return res * sgn;
	}

	public double nextDouble() {
		return Double.parseDouble(next());
	}

	public double[] nextDoubleArray(int n) {
		double[] array = new double[n];
		for (int i = 0; i < n; i++)
			array[i] = nextDouble();
		return array;
	}

	public boolean isWhitespace(int c) {
		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
	}
}

</source>
<source file="../hum_codes_raw/s647109273.java" startline="1" endline="198" pcid="21720">
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.util.List;

public class Main{
	static StringBuilder out = new StringBuilder();
	static final String OK = "OK";
	static final String NG = "NG";
	static final String Possible = "Possible";
	static final String Impossible = "Impossible";
	static FastReader in = new FastReader();
	static final int HEADS = 1;
	static final int TAILS = 0;

	// static final int INF = Integer.MAX_VALUE - 300000000;

	public static void main(String[] args) {
		while (upsideDown())
			;
	}

	private static boolean upsideDown() {
		int h = in.nextInt();
		int w = in.nextInt();
		if (h == 0 && w == 0) return false;

		int[][] senbei = in.nextIntArray2D(h, w);

		System.out.println(solve(senbei));
		return true;
	}

	private static int solve(int[][] senbei) {
		int row = senbei.length;
		int line = senbei[0].length;
		int ex = (int) Math.pow(2, row);

		int[] score = new int[ex];

		for (int i = 0; i < line; i++) {
			for (int j = 0; j < ex; j++) {
				int tempScore = 0;
				int[] filter = makeFilter(row, j);
				for (int k = 0; k < row; k++) {
					tempScore += (senbei[k][i] + filter[k]) % 2;
				}
				score[j] += Math.max(tempScore, row - tempScore);
			}
		}

		int maxScore = 0;
		for (int i = 0; i < ex; i++) {
			maxScore = Math.max(maxScore, score[i]);
		}
		return maxScore;
	}

	private static int[] makeFilter(int row, int i) {
		int[] filter = new int[row];
		int temp = i;
		for (int j = 0; j < row; j++) {
			filter[j] = temp % 2;
			temp /= 2;
		}
		return filter;
	}

	static void printExit(Object msg) {
		System.out.println(msg);
		System.exit(0);
	}
}

class FastReader{
	private InputStream in = System.in;
	private byte[] buf = new byte[1024];
	private int charNum;
	private int charLen;
	private StringBuilder sb = new StringBuilder();

	public int read() {
		if (charLen == -1) throw new InputMismatchException();
		if (charNum >= charLen) {
			charNum = 0;
			try {
				charLen = in.read(buf);
			} catch (IOException e) {
				throw new InputMismatchException();
			}
			if (charLen <= 0) return -1;
		}
		return buf[charNum++];
	}

	public String next() {
		int c = read();
		while (isWhitespace(c)) {
			c = read();
		}
		sb.setLength(0);
		do {
			sb.appendCodePoint(c);
			c = read();
		} while (!isWhitespace(c));
		return sb.toString();
	}

	public char[] nextCharArray() {
		return next().toCharArray();
	}

	public char[][] nextCharArray2d(int lines) {
		char[] first = nextCharArray();
		char[][] array = new char[lines][first.length];
		array[0] = first;
		for (int i = 1; i < lines; i++)
			array[i] = nextCharArray();
		return array;
	}

	public char[][] nextCharArray2d(int lines, int rows) {
		char[][] array = new char[lines][rows];
		for (int i = 0; i < lines; i++)
			array[i] = nextCharArray();
		return array;
	}

	public int nextInt() {
		return (int) nextLong();
	}

	public int[] nextIntArray(int n) {
		int[] array = new int[n];
		for (int i = 0; i < n; i++)
			array[i] = nextInt();
		return array;
	}

	public List<Integer> nextIntList(int n) {
		Integer[] array = new Integer[n];
		for (int i = 0; i < n; i++)
			array[i] = nextInt();
		return Arrays.asList(array);
	}

	public int[][] nextIntArray2D(int n, int m) {
		int[][] array = new int[n][m];
		for (int i = 0; i < n; i++)
			array[i] = nextIntArray(m);
		return array;
	}

	public List<int[]> nextIntsList(int n, int m) {
		List<int[]> list = new ArrayList<int[]>(n);
		for (int i = 0; i < n; i++)
			list.add(nextIntArray(m));
		return list;
	}

	public long nextLong() {
		int c = read();
		while (isWhitespace(c)) {
			c = read();
		}
		int sgn = 1;
		if (c == '-') {
			sgn = -1;
			c = read();
		}
		long res = 0;
		do {
			if (c < '0' || c > '9') throw new InputMismatchException();
			res *= 10;
			res += c - '0';
			c = read();
		} while (!isWhitespace(c));
		return res * sgn;
	}

	public double nextDouble() {
		return Double.parseDouble(next());
	}

	public double[] nextDoubleArray(int n) {
		double[] array = new double[n];
		for (int i = 0; i < n; i++)
			array[i] = nextDouble();
		return array;
	}

	public boolean isWhitespace(int c) {
		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
	}
}

</source>
</class>

<class classid="143" nclones="2" nlines="39" similarity="100">
<source file="../hum_codes_raw/s260575609.java" startline="1" endline="50" pcid="8751">
import java.util.Scanner;

public class Main{
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		
		while(true){
			String str = sc.nextLine();
			String[] nums = str.split(" ");
			int[] a = new int[nums.length];
			int ace=0, score=0;
			boolean flag = true;
			
			if(nums[0].equals("0")) break;
			
			for(int i=0; i<nums.length; i++) {
				a[i] = Integer.parseInt(nums[i]);
				if(a[i] == 1) ace++;
				else if(a[i]>9 && a[i]<14) score+=10;
				else score+=a[i];
				
				if(score>21) {
					score=0;
					flag = false;
					break;
				}
			}
			
			if(score +1*ace > 21) {
				flag = false;
				score=0;
			}
			
			int tt = score;
					
			if(flag){
				for(int i=0; i<=ace; i++){
					if(tt + 1*i + 11*(ace-i) <= 21) {
						score = tt + 1*i + 11*(ace-i);
						break;
					} 	
				}
			}
		
			System.out.println(score);
		}	

	}
}

</source>
<source file="../hum_codes_raw/s982251484.java" startline="1" endline="50" pcid="33031">
import java.util.Scanner;

public class Main{
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		
		while(true){
			String str = sc.nextLine();
			String[] nums = str.split(" ");
			int[] a = new int[nums.length];
			int ace=0, score=0;
			boolean flag = true;
			
			if(nums[0].equals("0")) break;
			
			for(int i=0; i<nums.length; i++) {
				a[i] = Integer.parseInt(nums[i]);
				if(a[i] == 1) ace++;
				else if(a[i]>9 && a[i]<14) score+=10;
				else score+=a[i];
				
				if(score>21) {
					score=0;
					flag = false;
					break;
				}
			}
			
			if(score +1*ace > 21) {
				flag = false;
				score=0;
			}
			
			int tt = score;
					
			if(flag){
				for(int i=0; i<=ace; i++){
					if(tt + 1*i + 11*(ace-i) <= 21) {
						score = tt + 1*i + 11*(ace-i);
						break;
					} 	
				}
			}
		
			System.out.println(score);
		}	

	}
}

</source>
</class>

<class classid="144" nclones="2" nlines="111" similarity="100">
<source file="../hum_codes_raw/s263937011.java" startline="1" endline="153" pcid="8869">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;


public class Main {
	static final int N = 4;
	static final int N2 = 16;
	static final int LIMIT = 100;
	
	static final int[] dx = {0, -1, 0, 1};
	static final int[] dy = {1, 0, -1, 0};
	static final char[] dir = {'r','u','l','d'};
	static int[][] MDT = new int[N2][N2];
	
	static Puzzle state;
	static int limit;
	static int[] path = new int[LIMIT];
	/**
	 * @param args
	 * @throws IOException 
	 */
	public static void main(String[] args) throws IOException {
		// TODO Auto-generated method stub
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		for(int i = 0; i < N2 ;i++){
			for(int j = 0; j < N2 ; j++){
				MDT[i][j] = Math.abs(i/N - j/N) + Math.abs(i%N - j%N);
			}
		}
		
		Puzzle in = new Puzzle();
		
		
		for(int i = 0; i < N ; i++){
			String[] tmpArray = br.readLine().split(" ");
			
			for(int j = 0; j < N; j++){
				in.f[i*N + j] = Integer.parseInt(tmpArray[j]);
				if(in.f[i*N + j] == 0 ){
					in.f[i*N + j] = N2;
					in.space = i*N + j;
				}
			}
		}
//		
//		for(int i = 0; i < N2; i++){
//			System.out.print(in.f[i]+" ");
//		}
//		
		String ans = ID(in);
		//System.out.println(ans);
		System.out.println(ans.length());
	}
	
	static int getAllMD(Puzzle pz){
		int sum = 0;
		for(int i = 0; i < N2 ;i++){
			if(pz.f[i] == N2) continue;
			sum += MDT[i][pz.f[i] - 1];
			//System.out.println("index = "+(i + 1)+" MD += "+ MDT[i][pz.f[i] - 1]);
		}
		return sum;
	}
	
	static boolean isSolved() {
		for(int i = 0; i < N2; i++){
			if(state.f[i] != i + 1){
				return false;
			}
		}
		return true;
	}
	
	static boolean dfs(int depth, int prev){
		if(state.MD == 0){
			return true;
		}
		
		if( depth + state.MD > limit){
			return false;
		}
		
		int sx = state.space/N;
		int sy = state.space%N;
		Puzzle tmp;
		
		//System.out.println("sx "+sx+" sy "+sy);
		
		for(int r = 0; r < 4; r++){
			int tx = sx + dx[r];
			int ty = sy + dy[r];
			if(tx < 0 || ty < 0 || tx >= N || ty >= N){
				continue;
			}
			if(Math.max(prev, r) - Math.min(prev, r) == 2){
				continue;
			}
			//C++?????????????????????????????????????????????????????????
			tmp = new Puzzle();
			tmp.MD = state.MD;
			tmp.space = state.space;
			tmp.f = Arrays.copyOf(state.f, N2);
//			tmp = state;
			state.MD -= MDT[tx*N + ty][state.f[tx*N + ty] - 1];
			state.MD += MDT[sx*N + sy][state.f[tx*N + ty] - 1];
			int tmpf = state.f[tx*N + ty];
			state.f[tx*N + ty] = state.f[sx*N + sy];
			state.f[sx*N + sy] = tmpf;
			state.space = tx*N + ty;
			if(dfs(depth + 1, r)) {
				path[depth] = r;
				return true;
			}
//			state = tmp;
			state.MD = tmp.MD;
			state.space = tmp.space;
			state.f = Arrays.copyOf(tmp.f, N2);
		}
		
		return false;
			
	}
	
	static String ID(Puzzle in){
		in.MD = getAllMD(in);
		//System.out.println("MD = "+in.MD);
		
		for(limit = in.MD ; limit <= LIMIT ; limit++){
			state = in;
			if(dfs(0,-100)){
				String ans = "";
				for(int i = 0; i < limit ; i++){
					ans += dir[path[i]];
				}
				return ans;
			}
		}
		
		return "unsolvable";
	}

}

class Puzzle {
	int[] f = new int[Main.N2];
	int space;
	int MD;
}


</source>
<source file="../hum_codes_raw/s977055145.java" startline="1" endline="152" pcid="32875">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;


public class Main {
	static final int N = 4;
	static final int N2 = 16;
	static final int LIMIT = 100;
	
	static final int[] dx = {0, -1, 0, 1};
	static final int[] dy = {1, 0, -1, 0};
	static final char[] dir = {'r','u','l','d'};
	static int[][] MDT = new int[N2][N2];
	
	static Puzzle state;
	static int limit;
	static int[] path = new int[LIMIT];
	/**
	 * @param args
	 * @throws IOException 
	 */
	public static void main(String[] args) throws IOException {
		// TODO Auto-generated method stub
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		for(int i = 0; i < N2 ;i++){
			for(int j = 0; j < N2 ; j++){
				MDT[i][j] = Math.abs(i/N - j/N) + Math.abs(i%N - j%N);
			}
		}
		
		Puzzle in = new Puzzle();
		
		
		for(int i = 0; i < N ; i++){
			String[] tmpArray = br.readLine().split(" ");
			
			for(int j = 0; j < N; j++){
				in.f[i*N + j] = Integer.parseInt(tmpArray[j]);
				if(in.f[i*N + j] == 0 ){
					in.f[i*N + j] = N2;
					in.space = i*N + j;
				}
			}
		}
//		
//		for(int i = 0; i < N2; i++){
//			System.out.print(in.f[i]+" ");
//		}
//		
		String ans = ID(in);
		//System.out.println(ans);
		System.out.println(ans.length());
	}
	
	static int getAllMD(Puzzle pz){
		int sum = 0;
		for(int i = 0; i < N2 ;i++){
			if(pz.f[i] == N2) continue;
			sum += MDT[i][pz.f[i] - 1];
			//System.out.println("index = "+(i + 1)+" MD += "+ MDT[i][pz.f[i] - 1]);
		}
		return sum;
	}
	
	static boolean isSolved() {
		for(int i = 0; i < N2; i++){
			if(state.f[i] != i + 1){
				return false;
			}
		}
		return true;
	}
	
	static boolean dfs(int depth, int prev){
		if(state.MD == 0){
			return true;
		}
		
		if( depth + state.MD > limit){
			return false;
		}
		
		int sx = state.space/N;
		int sy = state.space%N;
		Puzzle tmp;
		
		//System.out.println("sx "+sx+" sy "+sy);
		
		for(int r = 0; r < 4; r++){
			int tx = sx + dx[r];
			int ty = sy + dy[r];
			if(tx < 0 || ty < 0 || tx >= N || ty >= N){
				continue;
			}
			if(Math.max(prev, r) - Math.min(prev, r) == 2){
				continue;
			}
			//C++?????????????????????????????????????????????????????????
			tmp = new Puzzle();
			tmp.MD = state.MD;
			tmp.space = state.space;
			tmp.f = Arrays.copyOf(state.f, N2);
//			tmp = state;
			state.MD -= MDT[tx*N + ty][state.f[tx*N + ty] - 1];
			state.MD += MDT[sx*N + sy][state.f[tx*N + ty] - 1];
			int tmpf = state.f[tx*N + ty];
			state.f[tx*N + ty] = state.f[sx*N + sy];
			state.f[sx*N + sy] = tmpf;
			state.space = tx*N + ty;
			if(dfs(depth + 1, r)) {
				path[depth] = r;
				return true;
			}
//			state = tmp;
			state.MD = tmp.MD;
			state.space = tmp.space;
			state.f = Arrays.copyOf(tmp.f, N2);
		}
		
		return false;
			
	}
	
	static String ID(Puzzle in){
		in.MD = getAllMD(in);
		//System.out.println("MD = "+in.MD);
		
		for(limit = in.MD ; limit <= LIMIT ; limit++){
			state = in;
			if(dfs(0,-100)){
				String ans = "";
				for(int i = 0; i < limit ; i++){
					ans += dir[path[i]];
				}
				return ans;
			}
		}
		
		return "unsolvable";
	}

}

class Puzzle {
	int[] f = new int[Main.N2];
	int space;
	int MD;
}

</source>
</class>

<class classid="145" nclones="2" nlines="42" similarity="100">
<source file="../hum_codes_raw/s264763781.java" startline="1" endline="52" pcid="8888">
import java.util.*;

public class Main {
	static int goal;

	static ArrayList<Integer> list = new ArrayList<>();
	static int[] cache;

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		goal = sc.nextInt();

		int c = sc.nextInt();
		for (int i = 0; i < c; i++) {
			list.add(sc.nextInt());
		}
		cache = new int[goal + 1];
		Collections.sort(list, Collections.reverseOrder());
		System.out.println(compute(goal));

	}

	public static int compute(int value) {
		if (cache[value] != 0) {
			return cache[value];
		}
		HashSet<Integer> set = new HashSet<Integer>();
		for (int e : list) {
			if (e == value) {
				cache[value] = 1;
				return 1;
			}
			if (e < value) {
				int coins = 1;
				coins += compute(value - e);
				set.add(coins);

			}
		}
		int result = Integer.MAX_VALUE;
		for (int e : set) {
			if (e < result) {
				result = e;
			}
		}
		cache[value] = result;
		return result;

	}

}

</source>
<source file="../hum_codes_raw/s370099020.java" startline="1" endline="55" pcid="12442">
import java.util.*;

public class Main {
	static int goal;

	static ArrayList<Integer> list = new ArrayList<>();
	static int[] cache;

	// static int[] result;

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		goal = sc.nextInt();
		// result = new int[goal + 1];
		// Arrays.fill(result, -1);
		int c = sc.nextInt();
		for (int i = 0; i < c; i++) {
			list.add(sc.nextInt());
		}
		cache = new int[goal + 1];
		Collections.sort(list, Collections.reverseOrder());
		System.out.println(compute(goal));

	}

	public static int compute(int value) {
		if (cache[value] != 0) {
			return cache[value];
		}
		HashSet<Integer> set = new HashSet<Integer>();
		for (int e : list) {
			if (e == value) {
				cache[value] = 1;
				return 1;
			}
			if (e < value) {
				int coins = 1;
				coins += compute(value - e);
				set.add(coins);

			}
		}
		int result = Integer.MAX_VALUE;
		for (int e : set) {
			if (e < result) {
				result = e;
			}
		}
		cache[value] = result;
		return result;

	}

}

</source>
</class>

<class classid="146" nclones="2" nlines="123" similarity="100">
<source file="../hum_codes_raw/s268173447.java" startline="1" endline="145" pcid="8973">
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.*;

public class Main {
    public static void main(String[] args) throws Exception {
        // Your code here!
        String[] inputPlane = new String[8];
        
        //int
        List<int[][]> planeList = new ArrayList<int[][]>();
        Scanner scan = new Scanner(System.in);
        int row = 0;
        while(scan.hasNext()){
            String str = scan.next();
            if(str.length() != 0){
                if(row == 8){
                    row = 0;
                    int[][] plane = new int[8][8];
                    for(int i = 0;i < inputPlane.length;i++){
                        for(int j = 0;j < inputPlane[i].length();j++){
                            plane[i][j] = Integer.parseInt(inputPlane[i].substring(j,j+1));
                        }
                    }
                    planeList.add(plane);
                }
                inputPlane[row++] = str;
            }
        }
        
        //if(planeList.size()==0){return;}
        if(!scan.hasNext()){
            int[][] planes = new int[8][8];
            for(int i = 0;i < inputPlane.length;i++){
                for(int j = 0;j < inputPlane[i].length();j++){
                    planes[i][j] = Integer.parseInt(inputPlane[i].substring(j,j+1));
                }
            }
            planeList.add(planes);
        }
        //debug
        /*for(int i = 0;i < planeList.size();i++){
            int[][] debug = planeList.get(i);
            for(int k = 0;k < debug.length;k++){
                for(int j = 0;j < debug[k].length;j++){
                    System.out.print(debug[k][j]);
                }
                System.out.println();
            }
            System.out.println();
        }*/
        for(int i = 0;i < planeList.size();i++){
            //System.out.print(i);
            int[][] plane = planeList.get(i);
            if(blockJudgeD(plane))continue;
            if(blockJudgeG(plane))continue;
            if(blockJudgeE(plane))continue;
            if(blockJudgeF(plane))continue;
            if(blockJudgeA(plane))continue;
            if(blockJudgeB(plane))continue;
            if(blockJudgeC(plane))continue;
        }
    }
    //
    static boolean blockJudgeA(int[][] plane){
        for(int i = 0;i < plane.length;i++){
            for(int j = 0;j < plane[i].length;j++){
                if(i <= 6 && j <= 6 && plane[i][j] == 1 && plane[i][j+1] == 1 && plane[i+1][j] == 1){
                    System.out.println("A");
                    return true;
                }
            }
        }
        return false;
    }
    static boolean blockJudgeB(int[][] plane){
        for(int i = 0;i < plane.length;i++){
            for(int j = 0;j < plane[i].length;j++){
                if(i <= 4 && plane[i][j] == 1 && plane[i+1][j] == 1 && plane[i+2][j] == 1){
                    System.out.println("B");
                    return true;
                }
            }
        }
        return false;
    }
    static boolean blockJudgeC(int[][] plane){
        for(int i = 0;i < plane.length;i++){
            for(int j = 0;j < plane[i].length;j++){
                if(j <= 4 && plane[i][j] == 1 && plane[i][j+1] == 1 && plane[i][j+2] == 1){
                    System.out.println("C");
                    return true;
                }
            }
        }
        return false;
    }
    static boolean blockJudgeD(int[][] plane){
        for(int i = 0;i < plane.length;i++){
            for(int j = 0;j < plane[i].length;j++){
                if(i <= 5 && j <= 7 && j - 1>= 0 && plane[i][j] == 1 && plane[i+1][j-1] == 1 && plane[i+2][j-1] == 1){
                    System.out.println("D");
                    return true;
                }
            }
        }
        return false;
    }
    static boolean blockJudgeE(int[][] plane){
        for(int i = 0;i < plane.length;i++){
            for(int j = 0;j < plane[i].length;j++){
                if(i <= 6 && j <= 5 && plane[i][j] == 1 && plane[i][j+1] == 1 && plane[i+1][j+2] == 1){
                    System.out.println("E");
                    return true;
                }
            }
        }
        return false;
    }
    
    static boolean blockJudgeF(int[][] plane){
        for(int i = 0;i < plane.length;i++){
            for(int j = 0;j < plane[i].length;j++){
                if(i <= 5 && j <= 6 && plane[i][j] == 1 && plane[i+1][j] == 1 && plane[i+2][j+1] == 1){
                    System.out.println("F");
                    return true;
                }
            }
        }
        return false;
    }
    static boolean blockJudgeG(int[][] plane){
        for(int i = 0;i < plane.length;i++){
            for(int j = 0;j < plane[i].length;j++){
                if(j - 1 >= 0 && i <= 6 && j <= 6 && plane[i][j] == 1 && plane[i][j+1] == 1 && plane[i+1][j-1] == 1){
                    System.out.println("G");
                    return true;
                }
            }
        }
        return false;
    }
}


</source>
<source file="../hum_codes_raw/s988324026.java" startline="1" endline="145" pcid="33241">
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.*;

public class Main {
    public static void main(String[] args) throws Exception {
        // Your code here!
        String[] inputPlane = new String[8];
        
        //int
        List<int[][]> planeList = new ArrayList<int[][]>();
        Scanner scan = new Scanner(System.in);
        int row = 0;
        while(scan.hasNext()){
            String str = scan.next();
            if(str.length() != 0){
                if(row == 8){
                    row = 0;
                    int[][] plane = new int[8][8];
                    for(int i = 0;i < inputPlane.length;i++){
                        for(int j = 0;j < inputPlane[i].length();j++){
                            plane[i][j] = Integer.parseInt(inputPlane[i].substring(j,j+1));
                        }
                    }
                    planeList.add(plane);
                }
                inputPlane[row++] = str;
            }
        }
        
        //if(planeList.size()==0){return;}
        if(!scan.hasNext()){
            int[][] planes = new int[8][8];
            for(int i = 0;i < inputPlane.length;i++){
                for(int j = 0;j < inputPlane[i].length();j++){
                    planes[i][j] = Integer.parseInt(inputPlane[i].substring(j,j+1));
                }
            }
            planeList.add(planes);
        }
        //debug
        /*for(int i = 0;i < planeList.size();i++){
            int[][] debug = planeList.get(i);
            for(int k = 0;k < debug.length;k++){
                for(int j = 0;j < debug[k].length;j++){
                    System.out.print(debug[k][j]);
                }
                System.out.println();
            }
            System.out.println();
        }*/
        for(int i = 0;i < planeList.size();i++){
            //System.out.print(i);
            int[][] plane = planeList.get(i);
            if(blockJudgeD(plane))continue;
            if(blockJudgeG(plane))continue;
            if(blockJudgeE(plane))continue;
            if(blockJudgeF(plane))continue;
            if(blockJudgeA(plane))continue;
            if(blockJudgeB(plane))continue;
            if(blockJudgeC(plane))continue;
        }
    }
    //
    static boolean blockJudgeA(int[][] plane){
        for(int i = 0;i < plane.length;i++){
            for(int j = 0;j < plane[i].length;j++){
                if(i <= 6 && j <= 6 && plane[i][j] == 1 && plane[i][j+1] == 1 && plane[i+1][j] == 1){
                    System.out.println("A");
                    return true;
                }
            }
        }
        return false;
    }
    static boolean blockJudgeB(int[][] plane){
        for(int i = 0;i < plane.length;i++){
            for(int j = 0;j < plane[i].length;j++){
                if(i <= 4 && plane[i][j] == 1 && plane[i+1][j] == 1 && plane[i+2][j] == 1){
                    System.out.println("B");
                    return true;
                }
            }
        }
        return false;
    }
    static boolean blockJudgeC(int[][] plane){
        for(int i = 0;i < plane.length;i++){
            for(int j = 0;j < plane[i].length;j++){
                if(j <= 4 && plane[i][j] == 1 && plane[i][j+1] == 1 && plane[i][j+2] == 1){
                    System.out.println("C");
                    return true;
                }
            }
        }
        return false;
    }
    static boolean blockJudgeD(int[][] plane){
        for(int i = 0;i < plane.length;i++){
            for(int j = 0;j < plane[i].length;j++){
                if(i <= 5 && j <= 7 && j - 1>= 0 && plane[i][j] == 1 && plane[i+1][j-1] == 1 && plane[i+2][j-1] == 1){
                    System.out.println("D");
                    return true;
                }
            }
        }
        return false;
    }
    static boolean blockJudgeE(int[][] plane){
        for(int i = 0;i < plane.length;i++){
            for(int j = 0;j < plane[i].length;j++){
                if(i <= 6 && j <= 5 && plane[i][j] == 1 && plane[i][j+1] == 1 && plane[i+1][j+2] == 1){
                    System.out.println("E");
                    return true;
                }
            }
        }
        return false;
    }
    
    static boolean blockJudgeF(int[][] plane){
        for(int i = 0;i < plane.length;i++){
            for(int j = 0;j < plane[i].length;j++){
                if(i <= 5 && j <= 6 && plane[i][j] == 1 && plane[i+1][j] == 1 && plane[i+2][j+1] == 1){
                    System.out.println("F");
                    return true;
                }
            }
        }
        return false;
    }
    static boolean blockJudgeG(int[][] plane){
        for(int i = 0;i < plane.length;i++){
            for(int j = 0;j < plane[i].length;j++){
                if(j - 1 >= 0 && i <= 6 && j <= 6 && plane[i][j] == 1 && plane[i][j+1] == 1 && plane[i+1][j-1] == 1){
                    System.out.println("G");
                    return true;
                }
            }
        }
        return false;
    }
}


</source>
</class>

<class classid="147" nclones="2" nlines="21" similarity="100">
<source file="../hum_codes_raw/s268738325.java" startline="1" endline="25" pcid="8999">
import java.awt.Point;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

class Main{
	public static void main(String[] args) {
		try(Scanner sc = new Scanner(System.in)) {
			int n = sc.nextInt();
			List<Point> points = new ArrayList<Point>();
			for(int i=0;i<n;i++) {
				points.add(new Point(sc.nextInt(), sc.nextInt()));
			}
			points.sort((p1, p2) -> {
				int result = p1.x - p2.x;
				if(result == 0)
					result = p1.y - p2.y;
				return result;
			});
			points.forEach(point -> System.out.println(point.x + " " + point.y));
		}
	}
}


</source>
<source file="../hum_codes_raw/s512387774.java" startline="1" endline="23" pcid="17193">
import java.awt.Point;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
class Main{
	public static void main(String[] args) {
		try(Scanner sc = new Scanner(System.in)) {
			int n = sc.nextInt();
			List<Point> points = new ArrayList<Point>();
			for(int i=0;i<n;i++) {
				points.add(new Point(sc.nextInt(), sc.nextInt()));
			}
			points.sort((p1, p2) -> {
				int result = p1.x - p2.x;
				if(result == 0)
					result = p1.y - p2.y;
				return result;
			});
			points.forEach(point -> System.out.println(point.x + " " + point.y));
		}
	}
}

</source>
</class>

<class classid="148" nclones="2" nlines="14" similarity="100">
<source file="../hum_codes_raw/s269532901.java" startline="1" endline="17" pcid="9022">
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int a = sc.nextInt();
        int b = sc.nextInt();

        if((a * b) % 2 == 0) {
            System.out.println("Even");
        } else {
            System.out.println("Odd");
        }
    }
}

</source>
<source file="../hum_codes_raw/s458628710.java" startline="1" endline="17" pcid="15382">
import java.util.Scanner;

public class Main{
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);

		int a=sc.nextInt();
		int b=sc.nextInt();

		if((a*b)%2==0) {
			System.out.println("Even");
		}else {
			System.out.println("Odd");
		}
	}
}

</source>
</class>

<class classid="149" nclones="3" nlines="24" similarity="100">
<source file="../hum_codes_raw/s270545487.java" startline="1" endline="27" pcid="9050">
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int n = sc.nextInt();
			if(n==0)break;
			int[] a = new int[n];
			for(int i=0;i<n;i++)a[i]=sc.nextInt();
			int s = 0;
			for(int j=n-1;j>=1;j--){
				for(int i=0;i<j;i++){
					if(a[i+1]<a[i]){
						int t = a[i];
						a[i]=a[i+1];
						a[i+1]=t;
						s++;
					}
				}
			}
			System.out.println(s);
		}
	}
}

</source>
<source file="../hum_codes_raw/s743508109.java" startline="1" endline="28" pcid="24978">
import java.util.Scanner;

//Bubble Sort
public class Main{

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int n = sc.nextInt();
			if(n==0)break;
			int[] a = new int[n];
			for(int i=0;i<n;i++)a[i]=sc.nextInt();
			int s = 0;
			for(int j=n-1;j>=1;j--){
				for(int i=0;i<j;i++){
					if(a[i+1]<a[i]){
						int t = a[i];
						a[i]=a[i+1];
						a[i+1]=t;
						s++;
					}
				}
			}
			System.out.println(s);
		}
	}
}

</source>
<source file="../hum_codes_raw/s588971163.java" startline="1" endline="28" pcid="19770">
import java.util.Scanner;

//Bubble Sort
public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int n = sc.nextInt();
			if(n==0)break;
			int[] a = new int[n];
			for(int i=0;i<n;i++)a[i]=sc.nextInt();
			int s = 0;
			for(int j=n-1;j>=1;j--){
				for(int i=0;i<j;i++){
					if(a[i+1]<a[i]){
						int t = a[i];
						a[i]=a[i+1];
						a[i+1]=t;
						s++;
					}
				}
			}
			System.out.println(s);
		}
	}
}

</source>
</class>

<class classid="150" nclones="2" nlines="247" similarity="100">
<source file="../hum_codes_raw/s271055260.java" startline="1" endline="296" pcid="9063">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            EWeightsOnVerticesAndEdges solver = new EWeightsOnVerticesAndEdges();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class EWeightsOnVerticesAndEdges {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            int m = in.readInt();
            int[] vertex = new int[n];
            in.populate(vertex);
            Edge[] edges = new Edge[m];
            for (int i = 0; i < m; i++) {
                edges[i] = new Edge();
                edges[i].a = in.readInt() - 1;
                edges[i].b = in.readInt() - 1;
                edges[i].w = in.readInt();
            }

            DSU dsu = new DSU(n);
            for (int i = 0; i < n; i++) {
                dsu.sum[i] = vertex[i];
            }

            Arrays.sort(edges, (a, b) -> Integer.compare(a.w, b.w));
            for (int i = 0; i < m; i++) {
                int r = i;
                while (r + 1 < m && edges[r + 1].w == edges[i].w) {
                    r++;
                }
                for (int j = i; j <= r; j++) {
                    Edge e = edges[j];
                    if (dsu.prev[dsu.find(e.a)] != null) {
                        dsu.prev[dsu.find(e.a)].next = e;
                        dsu.prev[dsu.find(e.a)] = null;
                    }
                    if (dsu.prev[dsu.find(e.b)] != null) {
                        dsu.prev[dsu.find(e.b)].next = e;
                        dsu.prev[dsu.find(e.b)] = null;
                    }
                    dsu.merge(e.a, e.b);
                    dsu.prev[dsu.find(e.b)] = e;
                }

                for (int j = i; j <= r; j++) {
                    Edge e = edges[j];
                    e.sum = dsu.sum[dsu.find(e.a)];
                }

                i = r;
            }

            for (int i = m - 1; i >= 0; i--) {
                Edge e = edges[i];
                if ((e.next == null || e.next.deleted) && e.sum < e.w) {
                    e.deleted = true;
                }
            }

            int ans = 0;
            for (Edge e : edges) {
                if (e.deleted) {
                    ans++;
                }
            }

            out.println(ans);
        }

    }

    static class Edge {
        int a;
        int b;
        int w;
        long sum;
        boolean deleted;
        Edge next;

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        public void populate(int[] data) {
            for (int i = 0; i < data.length; i++) {
                data[i] = readInt();
            }
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class DSU {
        protected int[] p;
        protected int[] rank;
        protected Edge[] prev;
        protected long[] sum;

        public DSU(int n) {
            p = new int[n];
            rank = new int[n];
            prev = new Edge[n];
            sum = new long[n];
            reset();
        }

        public final void reset() {
            for (int i = 0; i < p.length; i++) {
                p[i] = i;
                rank[i] = 0;
            }
        }

        public final int find(int a) {
            if (p[a] == p[p[a]]) {
                return p[a];
            }
            return p[a] = find(p[a]);
        }

        public final void merge(int a, int b) {
            a = find(a);
            b = find(b);
            if (a == b) {
                return;
            }
            if (rank[a] == rank[b]) {
                rank[a]++;
            }

            if (rank[a] < rank[b]) {
                int tmp = a;
                a = b;
                b = tmp;
            }

            p[b] = a;
            sum[a] += sum[b];
        }

    }
}


</source>
<source file="../hum_codes_raw/s323487421.java" startline="1" endline="296" pcid="10845">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            EWeightsOnVerticesAndEdges solver = new EWeightsOnVerticesAndEdges();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class EWeightsOnVerticesAndEdges {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            int m = in.readInt();
            int[] vertex = new int[n];
            in.populate(vertex);
            Edge[] edges = new Edge[m];
            for (int i = 0; i < m; i++) {
                edges[i] = new Edge();
                edges[i].a = in.readInt() - 1;
                edges[i].b = in.readInt() - 1;
                edges[i].w = in.readInt();
            }

            DSU dsu = new DSU(n);
            for (int i = 0; i < n; i++) {
                dsu.sum[i] = vertex[i];
            }

            Arrays.sort(edges, (a, b) -> Integer.compare(a.w, b.w));
            for (int i = 0; i < m; i++) {
                int r = i;
                while (r + 1 < m && edges[r + 1].w == edges[i].w) {
                    r++;
                }
                for (int j = i; j <= r; j++) {
                    Edge e = edges[j];
                    if (dsu.prev[dsu.find(e.a)] != null) {
                        dsu.prev[dsu.find(e.a)].next = e;
                        dsu.prev[dsu.find(e.a)] = null;
                    }
                    if (dsu.prev[dsu.find(e.b)] != null) {
                        dsu.prev[dsu.find(e.b)].next = e;
                        dsu.prev[dsu.find(e.b)] = null;
                    }
                    dsu.merge(e.a, e.b);
                    dsu.prev[dsu.find(e.b)] = e;
                }

                for (int j = i; j <= r; j++) {
                    Edge e = edges[j];
                    e.sum = dsu.sum[dsu.find(e.a)];
                }

                i = r;
            }

            for (int i = m - 1; i >= 0; i--) {
                Edge e = edges[i];
                if ((e.next == null || e.next.deleted) && e.sum < e.w) {
                    e.deleted = true;
                }
            }

            int ans = 0;
            for (Edge e : edges) {
                if (e.deleted) {
                    ans++;
                }
            }

            out.println(ans);
        }

    }

    static class Edge {
        int a;
        int b;
        int w;
        long sum;
        boolean deleted;
        Edge next;

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        public void populate(int[] data) {
            for (int i = 0; i < data.length; i++) {
                data[i] = readInt();
            }
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class DSU {
        protected int[] p;
        protected int[] rank;
        protected Edge[] prev;
        protected long[] sum;

        public DSU(int n) {
            p = new int[n];
            rank = new int[n];
            prev = new Edge[n];
            sum = new long[n];
            reset();
        }

        public final void reset() {
            for (int i = 0; i < p.length; i++) {
                p[i] = i;
                rank[i] = 0;
            }
        }

        public final int find(int a) {
            if (p[a] == p[p[a]]) {
                return p[a];
            }
            return p[a] = find(p[a]);
        }

        public final void merge(int a, int b) {
            a = find(a);
            b = find(b);
            if (a == b) {
                return;
            }
            if (rank[a] == rank[b]) {
                rank[a]++;
            }

            if (rank[a] < rank[b]) {
                int tmp = a;
                a = b;
                b = tmp;
            }

            p[b] = a;
            sum[a] += sum[b];
        }

    }
}


</source>
</class>

<class classid="151" nclones="2" nlines="39" similarity="100">
<source file="../hum_codes_raw/s272561156.java" startline="1" endline="44" pcid="9115">
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		try(Scanner sc = new Scanner(System.in)){
			while(sc.hasNext()) {
				int m=sc.nextInt();
				int n=sc.nextInt();
				if(m+n==0) break;
				int[] w=new int[n+1];
				int max=0;
				int sum=0;
				for(int i=0; i<n; i++) {
					w[i]=sc.nextInt();
					max=Math.max(w[i], max);
					sum+=w[i];
				}
				int mini=0;
				for(int i=max; i<=sum; i++) {
					int h=1;
					int[] book=new int[n+1];
					int end=0;
					for(int j=0; j<n; j++) {
						if(book[h]+w[j]>i) {
							h++;
							if(h>m) {
								end=1;
								break;
							}
						}
						book[h]+=w[j];
					}
					mini=i;
					if(end==0) break;
				}
				System.out.println(mini);

			}
		}
	}
}



</source>
<source file="../hum_codes_raw/s744183787.java" startline="1" endline="44" pcid="24997">
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		try(Scanner sc = new Scanner(System.in)){
			while(sc.hasNext()) {
				int m=sc.nextInt();
				int n=sc.nextInt();
				if(m+n==0) break;
				int[] w=new int[n+1];
				int max=0;
				int sum=0;
				for(int i=0; i<n; i++) {
					w[i]=sc.nextInt();
					max=Math.max(w[i], max);
					sum+=w[i];
				}
				int mini=0;
				for(int i=max; i<=sum; i++) {
					int h=1;
					int[] book=new int[n+1];
					int end=0;
					for(int j=0; j<n; j++) {
						if(book[h]+w[j]>i) {
							h++;
							if(h>m) {
								end=1;
								break;
							}
						}
						book[h]+=w[j];
					}
					mini=i;
					if(end==0) break;
				}
				System.out.println(mini);

			}
		}
	}
}



</source>
</class>

<class classid="152" nclones="2" nlines="75" similarity="100">
<source file="../hum_codes_raw/s273328080.java" startline="1" endline="92" pcid="9141">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.List;
import java.util.Scanner;
import java.util.Comparator;
import java.util.ArrayList;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        Scanner in = new Scanner(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskC solver = new TaskC();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskC {
        public void solve(int testNumber, Scanner in, PrintWriter out) {
            final int n = in.nextInt();
            List<TaskC.Point> pointA = new ArrayList<>();
            List<TaskC.Point> pointB = new ArrayList<>();
            Comparator<TaskC.Point> min = Comparator.comparing(TaskC.Point::getMin);
            Comparator<TaskC.Point> max = Comparator.comparing(TaskC.Point::getMax);

            for (int i = 0; i < n; i++) {
                pointA.add(new TaskC.Point(in.nextInt(), in.nextInt()));
            }
            for (int i = 0; i < n; i++) {
                pointB.add(new TaskC.Point(in.nextInt(), in.nextInt()));
            }

            pointA.sort(max);
            pointB.sort(min);
            int ans = 0;
            int index = pointA.size() - 1;
            while (index >= 0) {
                TaskC.Point ca = pointA.get(index);
                for (int i = 0; i < pointB.size(); i++) {
                    TaskC.Point cb = pointB.get(i);
                    if (ca.getX() < cb.getX() && ca.getY() < cb.getY()) {
                        pointA.remove(ca);
                        pointB.remove(cb);
                        ans++;
                        index--;
                        break;
                    } else if (i == pointB.size() - 1) {
                        index--;
                    }
                }
            }
            out.println(ans);
        }

        static class Point {
            private int x;
            private int y;

            public Point(int x, int y) {
                this.x = x;
                this.y = y;
            }

            public int getX() {
                return this.x;
            }

            public int getY() {
                return this.y;
            }

            public int getMax() {
                return Math.max(x, y);
            }

            public int getMin() {
                return Math.min(x, y);
            }

        }

    }
}


</source>
<source file="../hum_codes_raw/s668721837.java" startline="1" endline="91" pcid="22472">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.List;
import java.util.Scanner;
import java.util.Comparator;
import java.util.ArrayList;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        Scanner in = new Scanner(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskC solver = new TaskC();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskC {
        public void solve(int testNumber, Scanner in, PrintWriter out) {
            final int n = in.nextInt();
            List<TaskC.Point> pointA = new ArrayList<>();
            List<TaskC.Point> pointB = new ArrayList<>();
            Comparator<TaskC.Point> min = Comparator.comparing(TaskC.Point::getMin);
            Comparator<TaskC.Point> max = Comparator.comparing(TaskC.Point::getMax);

            for (int i = 0; i < n; i++) {
                pointA.add(new TaskC.Point(in.nextInt(), in.nextInt()));
            }
            for (int i = 0; i < n; i++) {
                pointB.add(new TaskC.Point(in.nextInt(), in.nextInt()));
            }

            pointA.sort(max);
            pointB.sort(min);
            int ans = 0;
            int index = pointA.size() - 1;
            while (index >= 0) {
                TaskC.Point ca = pointA.get(index);
                for (int i = 0; i < pointB.size(); i++) {
                    TaskC.Point cb = pointB.get(i);
                    if (ca.getX() < cb.getX() && ca.getY() < cb.getY()) {
                        pointA.remove(ca);
                        pointB.remove(cb);
                        ans++;
                        index--;
                        break;
                    } else if (i == pointB.size() - 1) {
                        index--;
                    }
                }
            }
            out.println(ans);
        }

        static class Point {
            private int x;
            private int y;

            public Point(int x, int y) {
                this.x = x;
                this.y = y;
            }

            public int getX() {
                return this.x;
            }

            public int getY() {
                return this.y;
            }

            public int getMax() {
                return Math.max(x, y);
            }

            public int getMin() {
                return Math.min(x, y);
            }

        }

    }
}

</source>
</class>

<class classid="153" nclones="2" nlines="324" similarity="100">
<source file="../hum_codes_raw/s274100373.java" startline="1" endline="408" pcid="9166">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            FPass solver = new FPass();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class FPass {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            Modular mod = new Modular(998244353);
            char[] s = in.readString().toCharArray();
            int n = s.length;

            int[][] dp = new int[n + 1][n + 1];
            dp[0][0] = 1;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j <= i; j++) {
                    int b = j;
                    int r = i - j;
                    int way = dp[i][j];
                    if (way == 0) {
                        continue;
                    }
                    if (s[i] == '0') {
                        //two blue
                        //this is blue
                        dp[i + 1][j + 1] = mod.plus(dp[i + 1][j + 1], way);
                        //this is red
                        if (r > 0) {
                            dp[i + 1][j + 2] = mod.plus(dp[i + 1][j + 2], way);
                        }
                    } else if (s[i] == '1') {
                        //one blue one red
                        //this is blue
                        dp[i + 1][j] = mod.plus(dp[i + 1][j], way);
                        //this is red
                        dp[i + 1][j + 1] = mod.plus(dp[i + 1][j + 1], way);
                    } else {
                        //two red
                        //this is blue
                        if (j > 0) {
                            dp[i + 1][j - 1] = mod.plus(dp[i + 1][j - 1], way);
                        }
                        //this is red
                        dp[i + 1][j] = mod.plus(dp[i + 1][j], way);
                    }
                }
            }

            int ans = 0;
            Combination comb = new Combination(n, new Power(mod));
            for (int i = 0; i <= n; i++) {
                int way = dp[n][i];
                way = mod.mul(way, comb.combination(n, i));
                ans = mod.plus(ans, way);
            }
            out.println(ans);
        }

    }

    static class Power implements InverseNumber {
        static IntExtGCDObject extGCD = new IntExtGCDObject();
        final Modular modular;

        public Modular getModular() {
            return modular;
        }

        public Power(Modular modular) {
            this.modular = modular;
        }

        public int inverse(int x) {
            int ans = inverseExtGCD(x);
//        if(modular.mul(ans, x) != 1){
//            throw new IllegalStateException();
//        }
            return ans;
        }

        public int inverseExtGCD(int x) {
            if (extGCD.extgcd(x, modular.getMod()) != 1) {
                throw new IllegalArgumentException();
            }
            return modular.valueOf(extGCD.getX());
        }

    }

    static class ExtGCD {
        public static int extGCD(int a, int b, int[] xy) {
            if (a >= b) {
                return extGCD0(a, b, xy);
            }
            int ans = extGCD0(b, a, xy);
            SequenceUtils.swap(xy, 0, 1);
            return ans;
        }

        private static int extGCD0(int a, int b, int[] xy) {
            if (b == 0) {
                xy[0] = 1;
                xy[1] = 0;
                return a;
            }
            int ans = extGCD0(b, a % b, xy);
            int x = xy[0];
            int y = xy[1];
            xy[0] = y;
            xy[1] = x - a / b * y;
            return ans;
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class Modular {
        int m;

        public int getMod() {
            return m;
        }

        public Modular(int m) {
            this.m = m;
        }

        public Modular(long m) {
            this.m = (int) m;
            if (this.m != m) {
                throw new IllegalArgumentException();
            }
        }

        public Modular(double m) {
            this.m = (int) m;
            if (this.m != m) {
                throw new IllegalArgumentException();
            }
        }

        public int valueOf(int x) {
            x %= m;
            if (x < 0) {
                x += m;
            }
            return x;
        }

        public int valueOf(long x) {
            x %= m;
            if (x < 0) {
                x += m;
            }
            return (int) x;
        }

        public int mul(int x, int y) {
            return valueOf((long) x * y);
        }

        public int plus(int x, int y) {
            return valueOf(x + y);
        }

        public String toString() {
            return "mod " + m;
        }

    }

    static class SequenceUtils {
        public static void swap(int[] data, int i, int j) {
            int tmp = data[i];
            data[i] = data[j];
            data[j] = tmp;
        }

    }

    static interface InverseNumber {
    }

    static interface IntCombination {
    }

    static class Combination implements IntCombination {
        final Factorial factorial;
        final Modular modular;

        public Combination(Factorial factorial) {
            this.factorial = factorial;
            this.modular = factorial.getMod();
        }

        public Combination(int limit, Power pow) {
            this(new Factorial(limit, pow));
        }

        public int combination(int m, int n) {
            if (n > m || n < 0) {
                return 0;
            }
            return modular.mul(modular.mul(factorial.fact(m), factorial.invFact(n)), factorial.invFact(m - n));
        }

    }

    static class Factorial {
        int[] fact;
        int[] inv;
        Modular mod;

        public Modular getMod() {
            return mod;
        }

        public Factorial(int[] fact, int[] inv, Power pow) {
            this.mod = pow.getModular();
            this.fact = fact;
            this.inv = inv;
            fact[0] = inv[0] = 1;
            int n = Math.min(fact.length, pow.getModular().getMod());
            for (int i = 1; i < n; i++) {
                fact[i] = i;
                fact[i] = mod.mul(fact[i], fact[i - 1]);
            }
            inv[n - 1] = pow.inverse(fact[n - 1]);
            for (int i = n - 2; i >= 1; i--) {
                inv[i] = mod.mul(inv[i + 1], i + 1);
            }
        }

        public Factorial(int limit, Power pow) {
            this(new int[limit + 1], new int[limit + 1], pow);
        }

        public int fact(int n) {
            return fact[n];
        }

        public int invFact(int n) {
            return inv[n];
        }

    }

    static class FastInput {
        private final InputStream is;
        private StringBuilder defaultStringBuf = new StringBuilder(1 << 13);
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public String readString(StringBuilder builder) {
            skipBlank();

            while (next > 32) {
                builder.append((char) next);
                next = read();
            }

            return builder.toString();
        }

        public String readString() {
            defaultStringBuf.setLength(0);
            return readString(defaultStringBuf);
        }

    }

    static class IntExtGCDObject {
        private int[] xy = new int[2];

        public int extgcd(int a, int b) {
            return ExtGCD.extGCD(a, b, xy);
        }

        public int getX() {
            return xy[0];
        }

    }
}


</source>
<source file="../hum_codes_raw/s765718955.java" startline="1" endline="408" pcid="25717">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            FPass solver = new FPass();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class FPass {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            Modular mod = new Modular(998244353);
            char[] s = in.readString().toCharArray();
            int n = s.length;

            int[][] dp = new int[n + 1][n + 1];
            dp[0][0] = 1;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j <= i; j++) {
                    int b = j;
                    int r = i - j;
                    int way = dp[i][j];
                    if (way == 0) {
                        continue;
                    }
                    if (s[i] == '0') {
                        //two blue
                        //this is blue
                        dp[i + 1][j + 1] = mod.plus(dp[i + 1][j + 1], way);
                        //this is red
                        if (r > 0) {
                            dp[i + 1][j + 2] = mod.plus(dp[i + 1][j + 2], way);
                        }
                    } else if (s[i] == '1') {
                        //one blue one red
                        //this is blue
                        dp[i + 1][j] = mod.plus(dp[i + 1][j], way);
                        //this is red
                        dp[i + 1][j + 1] = mod.plus(dp[i + 1][j + 1], way);
                    } else {
                        //two red
                        //this is blue
                        if (j > 0) {
                            dp[i + 1][j - 1] = mod.plus(dp[i + 1][j - 1], way);
                        }
                        //this is red
                        dp[i + 1][j] = mod.plus(dp[i + 1][j], way);
                    }
                }
            }

            int ans = 0;
            Combination comb = new Combination(n, new Power(mod));
            for (int i = 0; i <= n; i++) {
                int way = dp[n][i];
                way = mod.mul(way, comb.combination(n, i));
                ans = mod.plus(ans, way);
            }
            out.println(ans);
        }

    }

    static class Power implements InverseNumber {
        static IntExtGCDObject extGCD = new IntExtGCDObject();
        final Modular modular;

        public Modular getModular() {
            return modular;
        }

        public Power(Modular modular) {
            this.modular = modular;
        }

        public int inverse(int x) {
            int ans = inverseExtGCD(x);
//        if(modular.mul(ans, x) != 1){
//            throw new IllegalStateException();
//        }
            return ans;
        }

        public int inverseExtGCD(int x) {
            if (extGCD.extgcd(x, modular.getMod()) != 1) {
                throw new IllegalArgumentException();
            }
            return modular.valueOf(extGCD.getX());
        }

    }

    static class ExtGCD {
        public static int extGCD(int a, int b, int[] xy) {
            if (a >= b) {
                return extGCD0(a, b, xy);
            }
            int ans = extGCD0(b, a, xy);
            SequenceUtils.swap(xy, 0, 1);
            return ans;
        }

        private static int extGCD0(int a, int b, int[] xy) {
            if (b == 0) {
                xy[0] = 1;
                xy[1] = 0;
                return a;
            }
            int ans = extGCD0(b, a % b, xy);
            int x = xy[0];
            int y = xy[1];
            xy[0] = y;
            xy[1] = x - a / b * y;
            return ans;
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class Modular {
        int m;

        public int getMod() {
            return m;
        }

        public Modular(int m) {
            this.m = m;
        }

        public Modular(long m) {
            this.m = (int) m;
            if (this.m != m) {
                throw new IllegalArgumentException();
            }
        }

        public Modular(double m) {
            this.m = (int) m;
            if (this.m != m) {
                throw new IllegalArgumentException();
            }
        }

        public int valueOf(int x) {
            x %= m;
            if (x < 0) {
                x += m;
            }
            return x;
        }

        public int valueOf(long x) {
            x %= m;
            if (x < 0) {
                x += m;
            }
            return (int) x;
        }

        public int mul(int x, int y) {
            return valueOf((long) x * y);
        }

        public int plus(int x, int y) {
            return valueOf(x + y);
        }

        public String toString() {
            return "mod " + m;
        }

    }

    static class SequenceUtils {
        public static void swap(int[] data, int i, int j) {
            int tmp = data[i];
            data[i] = data[j];
            data[j] = tmp;
        }

    }

    static interface InverseNumber {
    }

    static interface IntCombination {
    }

    static class Combination implements IntCombination {
        final Factorial factorial;
        final Modular modular;

        public Combination(Factorial factorial) {
            this.factorial = factorial;
            this.modular = factorial.getMod();
        }

        public Combination(int limit, Power pow) {
            this(new Factorial(limit, pow));
        }

        public int combination(int m, int n) {
            if (n > m || n < 0) {
                return 0;
            }
            return modular.mul(modular.mul(factorial.fact(m), factorial.invFact(n)), factorial.invFact(m - n));
        }

    }

    static class Factorial {
        int[] fact;
        int[] inv;
        Modular mod;

        public Modular getMod() {
            return mod;
        }

        public Factorial(int[] fact, int[] inv, Power pow) {
            this.mod = pow.getModular();
            this.fact = fact;
            this.inv = inv;
            fact[0] = inv[0] = 1;
            int n = Math.min(fact.length, pow.getModular().getMod());
            for (int i = 1; i < n; i++) {
                fact[i] = i;
                fact[i] = mod.mul(fact[i], fact[i - 1]);
            }
            inv[n - 1] = pow.inverse(fact[n - 1]);
            for (int i = n - 2; i >= 1; i--) {
                inv[i] = mod.mul(inv[i + 1], i + 1);
            }
        }

        public Factorial(int limit, Power pow) {
            this(new int[limit + 1], new int[limit + 1], pow);
        }

        public int fact(int n) {
            return fact[n];
        }

        public int invFact(int n) {
            return inv[n];
        }

    }

    static class FastInput {
        private final InputStream is;
        private StringBuilder defaultStringBuf = new StringBuilder(1 << 13);
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public String readString(StringBuilder builder) {
            skipBlank();

            while (next > 32) {
                builder.append((char) next);
                next = read();
            }

            return builder.toString();
        }

        public String readString() {
            defaultStringBuf.setLength(0);
            return readString(defaultStringBuf);
        }

    }

    static class IntExtGCDObject {
        private int[] xy = new int[2];

        public int extgcd(int a, int b) {
            return ExtGCD.extGCD(a, b, xy);
        }

        public int getX() {
            return xy[0];
        }

    }
}


</source>
</class>

<class classid="154" nclones="2" nlines="10" similarity="100">
<source file="../hum_codes_raw/s274344490.java" startline="1" endline="14" pcid="9175">
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		int W = s.nextInt();
		int res = W*32;
		System.out.println(res);

		s.close();

	}
}

</source>
<source file="../hum_codes_raw/s933072200.java" startline="1" endline="14" pcid="31376">
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		int W = s.nextInt();
		int res = W*32;
		System.out.println(res);

		s.close();

	}
}

</source>
</class>

<class classid="155" nclones="2" nlines="34" similarity="100">
<source file="../hum_codes_raw/s275165787.java" startline="1" endline="40" pcid="9200">
import java.util.BitSet;
import java.util.Scanner;
 
public class Main {
 
    static Scanner sc = new Scanner(System.in);
 
    static BitSet primes() {
        int SIZE = 1 << 15;
        BitSet ret = new BitSet(SIZE);
        ret.set(2, SIZE);
        for (int i = 2; i < SIZE; ++i) {
            if (!ret.get(i)) continue;
            for (int j = i * i; j < SIZE; j += i) {
                ret.clear(j);
            }
        }
        return ret;
    }
 
    public static void main(String[] args) {
        BitSet psset = primes();
        int[] ps = new int[psset.cardinality()];
        int idx = 0;
        for (int i = 0; i < psset.size(); ++i) {
            if (psset.get(i)) ps[idx++] = i;
        }
        while (true) {
            int N = sc.nextInt();
            if (N == 0) break;
            int ans = 0;
            for (int i = 0; i < ps.length && ps[i] <= N / 2; ++i) {
                if (psset.get(N - ps[i])) ++ans;
            }
            System.out.println(ans);
        }
    }
 
}

</source>
<source file="../hum_codes_raw/s777160410.java" startline="1" endline="40" pcid="26091">
import java.util.BitSet;
import java.util.Scanner;

public class Main {

	static Scanner sc = new Scanner(System.in);

	static BitSet primes() {
		int SIZE = 1 << 15;
		BitSet ret = new BitSet(SIZE);
		ret.set(2, SIZE);
		for (int i = 2; i < SIZE; ++i) {
			if (!ret.get(i)) continue;
			for (int j = i * i; j < SIZE; j += i) {
				ret.clear(j);
			}
		}
		return ret;
	}

	public static void main(String[] args) {
		BitSet psset = primes();
		int[] ps = new int[psset.cardinality()];
		int idx = 0;
		for (int i = 0; i < psset.size(); ++i) {
			if (psset.get(i)) ps[idx++] = i;
		}
		while (true) {
			int N = sc.nextInt();
			if (N == 0) break;
			int ans = 0;
			for (int i = 0; i < ps.length && ps[i] <= N / 2; ++i) {
				if (psset.get(N - ps[i])) ++ans;
			}
			System.out.println(ans);
		}
	}

}

</source>
</class>

<class classid="156" nclones="2" nlines="105" similarity="100">
<source file="../hum_codes_raw/s275374216.java" startline="1" endline="127" pcid="9203">

import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Deque;
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

public class Main {
	static int N = 3;
	static int N2 = 9;

	public static void main(String[] args) {
		new Main().run();
	}

	private void run() {
		Scanner scanner = new Scanner(System.in);
		Puzzle puzzle = new Puzzle();
		for (int i = 0; i < N2; i++) {
			int v = scanner.nextInt();
			puzzle.map[i] = v;
			if (v == 0) {
				puzzle.space = i;
			}
		}
		System.out.println(slove(puzzle));
	}

	int[][] dxy = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };

	private int slove(Puzzle in) {
		Puzzle u = new Puzzle();
		Puzzle v = new Puzzle();
		Deque<Puzzle> deque = new ArrayDeque<Puzzle>();
		Set<Puzzle> set = new HashSet<Main.Puzzle>();
		set.add(in);
		deque.offer(in);
		while (!deque.isEmpty()) {
			u = deque.poll();
			if (isTrue(u)) {
				return u.count;
			}
			int y = u.space / N;
			int x = u.space % N;
			for (int[] a : dxy) {
				int dy = y + a[0];
				int dx = x + a[1];
				if (dy < 0 || dx < 0 || N <= dy || N <= dx)
					continue;
				v = u.clone();
				swap(v, u.space, dy * N + dx);
				v.space = dy * N + dx;
				if (!set.contains(v)) {
					set.add(v);
					v.count++;
					deque.offer(v);
				}
			}
		}
		return -1;
	}

	private boolean isTrue(Puzzle u) {
		for (int i = 0; i < N2 - 1; i++) {
			if (u.map[i] != i + 1) {
				return false;
			}
		}
		return true;
	}

	private void swap(Puzzle v, int space, int i) {
		int t = v.map[i];
		v.map[i] = v.map[space];
		v.map[space] = t;

	}
	class Puzzle implements Cloneable {
		int[] map = new int[N2];
		int space;
		int count = 0;

		@Override
		public Puzzle clone() {
			try {
				Puzzle clonePuzzle = (Puzzle) super.clone();
				clonePuzzle.map = Arrays.copyOf(map, N2);
				return clonePuzzle;
			} catch (CloneNotSupportedException e) {
				throw new InternalError();
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + getOuterType().hashCode();
			result = prime * result + Arrays.hashCode(map);
			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			Puzzle other = (Puzzle) obj;
			if (!getOuterType().equals(other.getOuterType()))
				return false;
			if (!Arrays.equals(map, other.map))
				return false;
			return true;
		}

		private Main getOuterType() {
			return Main.this;
		}

	}
}


</source>
<source file="../hum_codes_raw/s908069064.java" startline="1" endline="126" pcid="30554">

import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Deque;
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

public class Main {
	static int N = 3;
	static int N2 = 9;

	public static void main(String[] args) {
		new Main().run();
	}

	private void run() {
		Scanner scanner = new Scanner(System.in);
		Puzzle puzzle = new Puzzle();
		for (int i = 0; i < N2; i++) {
			int v = scanner.nextInt();
			puzzle.map[i] = v;
			if (v == 0) {
				puzzle.space = i;
			}
		}
		System.out.println(slove(puzzle));
	}

	int[][] dxy = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };

	private int slove(Puzzle in) {
		Puzzle u = new Puzzle();
		Puzzle v = new Puzzle();
		Deque<Puzzle> deque = new ArrayDeque<Puzzle>();
		Set<Puzzle> set = new HashSet<Main.Puzzle>();
		set.add(in);
		deque.offer(in);
		while (!deque.isEmpty()) {
			u = deque.poll();
			if (isTrue(u)) {
				return u.count;
			}
			int y = u.space / N;
			int x = u.space % N;
			for (int[] a : dxy) {
				int dy = y + a[0];
				int dx = x + a[1];
				if (dy < 0 || dx < 0 || N <= dy || N <= dx)
					continue;
				v = u.clone();
				swap(v, u.space, dy * N + dx);
				v.space = dy * N + dx;
				if (!set.contains(v)) {
					set.add(v);
					v.count++;
					deque.offer(v);
				}
			}
		}
		return -1;
	}

	private boolean isTrue(Puzzle u) {
		for (int i = 0; i < N2 - 1; i++) {
			if (u.map[i] != i + 1) {
				return false;
			}
		}
		return true;
	}

	private void swap(Puzzle v, int space, int i) {
		int t = v.map[i];
		v.map[i] = v.map[space];
		v.map[space] = t;

	}
	class Puzzle implements Cloneable {
		int[] map = new int[N2];
		int space;
		int count = 0;

		@Override
		public Puzzle clone() {
			try {
				Puzzle clonePuzzle = (Puzzle) super.clone();
				clonePuzzle.map = Arrays.copyOf(map, N2);
				return clonePuzzle;
			} catch (CloneNotSupportedException e) {
				throw new InternalError();
			}
		}

		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + getOuterType().hashCode();
			result = prime * result + Arrays.hashCode(map);
			return result;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			Puzzle other = (Puzzle) obj;
			if (!getOuterType().equals(other.getOuterType()))
				return false;
			if (!Arrays.equals(map, other.map))
				return false;
			return true;
		}

		private Main getOuterType() {
			return Main.this;
		}

	}
}

</source>
</class>

<class classid="157" nclones="2" nlines="24" similarity="100">
<source file="../hum_codes_raw/s275725695.java" startline="1" endline="25" pcid="9219">
import java.util.*;
import java.text.*;

class Main {
    public static void main(String[]args)throws Exception {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        for(int i = 1; i <= n; i++) {
            int x = i;
            if((x % 3) == 0) {
                System.out.print(" " + i);
            } else {
                while(x != 0) {
                    if((x % 10) == 3) {
                        System.out.print(" " + i);
                        x = 0;
                    }
                    x = x / 10;
                }
            }
        }
        System.out.println();
    }
}

</source>
<source file="../hum_codes_raw/s848354165.java" startline="1" endline="26" pcid="28498">
import java.util.*;
import java.text.*;

class Main {
    public static void main(String[]args)throws Exception {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        for(int i = 1; i <= n; i++) {
            int x = i;
            if((x % 3) == 0) {
                System.out.print(" " + i);
            } else {
                while(x != 0) {
                    if((x % 10) == 3) {
                        System.out.print(" " + i);
                        x = 0;
                    }
                    x = x / 10;
                }
            }
        }
        System.out.println();
    }
}


</source>
</class>

<class classid="158" nclones="2" nlines="51" similarity="100">
<source file="../hum_codes_raw/s276733936.java" startline="1" endline="59" pcid="9254">
import java.util.*;
public class Main{
    static Scanner kbd = new Scanner(System.in);
    public static void main(String[] args){
	int[] p = new int[10000];
	putN(p);
	while(kbd.hasNext()){
	    int n = kbd.nextInt();
	    if(n!=0){
		int i=0;
		int s=0;  //??????
		int l=0;  //????????
		int c = 0;  //???
		while(p[i]!=0){
		    if(s < n) {
			s += p[i];
			i++;
		    }
		    else if(s>n){
			s -= p[l];
			l++;
		    }
		    else;

		    if(s==n) {
			c++;
			s += p[i];
			i++;
		    }
		}	 
		System.out.println(c);
	    }
	}
    }

    
    
    
    static void putN(int[] p){
	int i=0, k;
	for(k=2; k<10000; k++){
	    if(check(k)) {
		p[i] = k;
		//System.out.print(p[i]+" ");
		i++;
	    }
	}

    }
    static boolean check(int n){
	int a, c=0;
	for(a=1; a<=n; a++){
	    if(n%a==0) c++;
	}
	if(c>2) return false;
	return true;
    }    
}

</source>
<source file="../hum_codes_raw/s352963618.java" startline="1" endline="59" pcid="11850">
import java.util.*;
public class Main{
    static Scanner kbd = new Scanner(System.in);
    public static void main(String[] args){
	int[] p = new int[10000];
	putN(p);
	while(kbd.hasNext()){
	    int n = kbd.nextInt();
	    if(n!=0){
		int i=0;
		int s=0;  //
		int l=0;  //
		int c = 0;  //
		while(p[i]!=0){
		    if(s < n) {
			s += p[i];
			i++;
		    }
		    else if(s>n){
			s -= p[l];
			l++;
		    }
		    else;

		    if(s==n) {
			c++;
			s += p[i];
			i++;
		    }
		}	 
		System.out.println(c);
	    }
	}
    }

    
    
    
    static void putN(int[] p){
	int i=0, k;
	for(k=2; k<10000; k++){
	    if(check(k)) {
		p[i] = k;
		//System.out.print(p[i]+" ");
		i++;
	    }
	}

    }
    static boolean check(int n){
	int a, c=0;
	for(a=1; a<=n; a++){
	    if(n%a==0) c++;
	}
	if(c>2) return false;
	return true;
    }    
}

</source>
</class>

<class classid="159" nclones="3" nlines="31" similarity="100">
<source file="../hum_codes_raw/s277064174.java" startline="1" endline="49" pcid="9269">
import java.util.Arrays;
import java.util.Scanner;

public class Main 
{
	public static void main(String arg[])
	{
		Scanner sc=new Scanner(System.in);
		boolean a[] =new boolean[10001];
		Arrays.fill(a, true);
		a[0]=a[1]=false;
		for(int i=2; i*i<=10000; i++)
		{
			if(!a[i])
				continue;
			for(int j=i*2; j<=10000; j+=i)
				a[j]=false;
		}


		while(sc.hasNext())
		{
			int n=sc.nextInt();
			if(n==0)
				return;
			int sum=0;
			int ans=0;

			for(int i=2; i<=n; i++)
			{
				sum =0;
				if(a[i])
					for(int j=i; j<=n; j++)
					{
						if(a[j])
						{
							sum+=j;
							if(n==sum)
								ans++;
						}
						if(sum>=n)
							break;
					}
			}
			System.out.println(ans);
		}
	}
}

</source>
<source file="../hum_codes_raw/s866706293.java" startline="1" endline="46" pcid="29152">
import java.util.Arrays;
import java.util.Scanner;

public class Main
{
	public static void main(String arg[])
	{
		Scanner sc=new Scanner(System.in);
		boolean a[] =new boolean[10001];
		Arrays.fill(a, true);
		a[0]=a[1]=false;
		for(int i=2; i*i<=10000; i++)
		{
			if(!a[i])
				continue;
			for(int j=i*2; j<=10000; j+=i)
				a[j]=false;
		}
		while(sc.hasNext())
		{
			int n=sc.nextInt();
			if(n==0)
				return;
			int sum=0;
			int ans=0;
			for(int i=2; i<=n; i++)
			{
				sum =0;
				if(a[i])
					for(int j=i; j<=n; j++)
					{
						if(a[j])
						{
							sum+=j;
							if(n==sum)
								ans++;
						}
						if(sum>=n)
							break;
					}
			}
			System.out.println(ans);
		}
	}
}

</source>
<source file="../hum_codes_raw/s586575169.java" startline="1" endline="46" pcid="19689">
import java.util.Arrays;
import java.util.Scanner;

public class Main
{
	public static void main(String arg[])
	{
		Scanner sc=new Scanner(System.in);
		boolean a[] =new boolean[10001];
		Arrays.fill(a, true);
		a[0]=a[1]=false;
		for(int i=2; i*i<=10000; i++)
		{
			if(!a[i])
				continue;
			for(int j=i*2; j<=10000; j+=i)
				a[j]=false;
		}
		while(sc.hasNext())
		{
			int n=sc.nextInt();
			if(n==0)
				return;
			int sum=0;
			int ans=0;
			for(int i=2; i<=n; i++)
			{
				sum =0;
				if(a[i])
					for(int j=i; j<=n; j++)
					{
						if(a[j])
						{
							sum+=j;
							if(n==sum)
								ans++;
						}
						if(sum>=n)
							break;
					}
			}
			System.out.println(ans);
		}
	}
}

</source>
</class>

<class classid="160" nclones="2" nlines="58" similarity="100">
<source file="../hum_codes_raw/s277875295.java" startline="1" endline="75" pcid="9301">
import java.util.Scanner;
 
class Bot{
    int x = 1, y = 1 , dir = 0;
    private int width, height;
     
    private int[][] xy = {
            {0,1},{1,0},{0,-1},{-1,0}
    };
     
    public Bot(int w, int h) {
        width = w;
        height = h;
    }
     
     
    public void  forward(int step){
        x += xy[dir][0]*step;
        y += xy[dir][1]*step;
        beProperly();
    }
     
    public void backward(int step){
        x -= xy[dir][0]*step;
        y -= xy[dir][1]*step;
        beProperly();
    }
     
    public void right(){
        dir = (dir+1)%4;
    }
     
    public void left(){
        if(--dir == -1) dir = 3;
    }
     
    private void beProperly(){
        if(x > width) x = width;
        if(y > height) y = height;
        if(x < 1) x = 1;
        if(y < 1) y = 1;
    }
}
 
 
public class Main {
    public static void main(String[] args){
        Scanner sn = new Scanner(System.in);
 
        while(true){
            int w = sn.nextInt(), h = sn.nextInt();
            if(w == 0 && h == 0) break;
            Bot bot = new Bot(w, h);
            while(true){
 
                String cmd = sn.nextLine();
                String[] go = cmd.split(" ");
                String dir;
                 
                if(go.length == 2){
                    int step = new Integer(go[1]);
                    if(go[0].equals("FORWARD")) bot.forward(step);
                    else if(go[0].equals("BACKWARD")) bot.backward(step);
                } else{
                     
                    if(go[0].equals("RIGHT")) bot.right();
                    else if(go[0].equals("LEFT")) bot.left();
                    else if(go[0].equals("STOP")) break;
                }
            }
            System.out.println(bot.x+" "+bot.y);
        }      
    }
}

</source>
<source file="../hum_codes_raw/s462178555.java" startline="1" endline="75" pcid="15515">
import java.util.Scanner;

class Bot{
	int x = 1, y = 1 , dir = 0;
	private int width, height;
	
	private int[][] xy = {
			{0,1},{1,0},{0,-1},{-1,0}
	};
	
	public Bot(int w, int h) {
		width = w;
		height = h;
	}
	
	
	public void  forward(int step){
		x += xy[dir][0]*step;
		y += xy[dir][1]*step;
		beProperly();
	}
	
	public void backward(int step){
		x -= xy[dir][0]*step;
		y -= xy[dir][1]*step;
		beProperly();
	}
	
	public void right(){
		dir = (dir+1)%4;
	}
	
	public void left(){
		if(--dir == -1) dir = 3;
	}
	
	private void beProperly(){
		if(x > width) x = width;
		if(y > height) y = height;
		if(x < 1) x = 1;
		if(y < 1) y = 1;
	}
}


public class Main {
	public static void main(String[] args){
		Scanner sn = new Scanner(System.in);

		while(true){
			int w = sn.nextInt(), h = sn.nextInt();
			if(w == 0 && h == 0) break;
			Bot bot = new Bot(w, h);
			while(true){

				String cmd = sn.nextLine();
				String[] go = cmd.split(" ");
				String dir;
				
				if(go.length == 2){
					int step = new Integer(go[1]);
					if(go[0].equals("FORWARD")) bot.forward(step);
					else if(go[0].equals("BACKWARD")) bot.backward(step);
				} else{
					
					if(go[0].equals("RIGHT")) bot.right();
					else if(go[0].equals("LEFT")) bot.left();
					else if(go[0].equals("STOP")) break;
				}
			}
			System.out.println(bot.x+" "+bot.y);
		}		
	}
}

</source>
</class>

<class classid="161" nclones="2" nlines="180" similarity="100">
<source file="../hum_codes_raw/s280908225.java" startline="1" endline="218" pcid="9404">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 27);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            BRowToColumn solver = new BRowToColumn();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class BRowToColumn {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            int[][] mat = new int[n][n];
            int sum = 0;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    mat[i][j] = in.readChar() == '#' ? 1 : 0;
                    sum += mat[i][j];
                }
            }

            if (sum == 0) {
                out.println(-1);
                return;
            }

            int ans = (int) 1e9;
            for (int i = 0; i < n; i++) {
                int cnt = 0;
                for (int j = 0; j < n; j++) {
                    cnt += mat[j][i];
                }

                int row = 0;
                for (int j = 0; j < n; j++) {
                    row += mat[i][j];
                }

                int req = n - row;
                ans = Math.min(ans, req + (cnt == 0 ? 1 : 0));
            }

            for (int i = 0; i < n; i++) {
                int cnt = 0;
                for (int j = 0; j < n; j++) {
                    cnt += mat[j][i];
                }
                if (cnt < n) {
                    ans++;
                }
            }

            out.println(ans);
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

        public char readChar() {
            skipBlank();
            char c = (char) next;
            next = read();
            return c;
        }

    }
}


</source>
<source file="../hum_codes_raw/s851321599.java" startline="1" endline="218" pcid="28601">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 27);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            BRowToColumn solver = new BRowToColumn();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class BRowToColumn {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            int[][] mat = new int[n][n];
            int sum = 0;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    mat[i][j] = in.readChar() == '#' ? 1 : 0;
                    sum += mat[i][j];
                }
            }

            if (sum == 0) {
                out.println(-1);
                return;
            }

            int ans = (int) 1e9;
            for (int i = 0; i < n; i++) {
                int cnt = 0;
                for (int j = 0; j < n; j++) {
                    cnt += mat[j][i];
                }

                int row = 0;
                for (int j = 0; j < n; j++) {
                    row += mat[i][j];
                }

                int req = n - row;
                ans = Math.min(ans, req + (cnt == 0 ? 1 : 0));
            }

            for (int i = 0; i < n; i++) {
                int cnt = 0;
                for (int j = 0; j < n; j++) {
                    cnt += mat[j][i];
                }
                if (cnt < n) {
                    ans++;
                }
            }

            out.println(ans);
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

        public char readChar() {
            skipBlank();
            char c = (char) next;
            next = read();
            return c;
        }

    }
}


</source>
</class>

<class classid="162" nclones="2" nlines="32" similarity="100">
<source file="../hum_codes_raw/s283215821.java" startline="1" endline="43" pcid="9489">
import java.util.Arrays;
import java.util.Scanner;

class Main{
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		while(sc.hasNextInt()){
			int N = sc.nextInt();
			int[] n = new int[N];

			for(int i = 0; i < N; i++)
				n[i] = sc.nextInt()*60 + sc.nextInt();

			int M = sc.nextInt();
			int[] m = new int[M];

			for(int i = 0; i < M; i++)
				m[i] = sc.nextInt()*60 + sc.nextInt();

			int[] nm = new int[N+M];
			for(int i = 0; i < N; i++)
				nm[i] = n[i];
			for(int i = 0 ; i < M; i++)
				nm[N+i] = m[i];
			Arrays.sort(nm);
			int count=0;
			for(int i=1;i<nm.length;i++){
				if((nm[i]==nm[i-1])){
					nm[i-1]=0;count++;
				}

			}
			Arrays.sort(nm);
			for(;count < N+M; count++){
				System.out.printf("%d:%02d",nm[count]/60, nm[count]%60);
			if(!(count == N+M-1))
				System.out.print(" ");
			}
			System.out.println();
		}
	}
}

</source>
<source file="../hum_codes_raw/s994582133.java" startline="1" endline="43" pcid="33470">
import java.util.Arrays;
import java.util.Scanner;

class Main{
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		while(sc.hasNextInt()){
			int N = sc.nextInt();
			int[] n = new int[N];

			for(int i = 0; i < N; i++)
				n[i] = sc.nextInt()*60 + sc.nextInt();

			int M = sc.nextInt();
			int[] m = new int[M];

			for(int i = 0; i < M; i++)
				m[i] = sc.nextInt()*60 + sc.nextInt();

			int[] nm = new int[N+M];
			for(int i = 0; i < N; i++)
				nm[i] = n[i];
			for(int i = 0 ; i < M; i++)
				nm[N+i] = m[i];
			Arrays.sort(nm);
			int count=0;
			for(int i=1;i<nm.length;i++){
				if((nm[i]==nm[i-1])){
					nm[i-1]=0;count++;
				}

			}
			Arrays.sort(nm);
			for(;count < N+M; count++){
				System.out.printf("%d:%02d",nm[count]/60, nm[count]%60);
			if(!(count == N+M-1))
				System.out.print(" ");
			}
			System.out.println();
		}
	}
}

</source>
</class>

<class classid="163" nclones="2" nlines="37" similarity="100">
<source file="../hum_codes_raw/s286777872.java" startline="1" endline="50" pcid="9615">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Stack;

public class Main {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String[] tmpArray = br.readLine().split(" ");
		int n = Integer.parseInt(tmpArray[0]);
		int q = Integer.parseInt(tmpArray[1]);

		@SuppressWarnings("unchecked")
		Stack<Integer>[] stackArray = new Stack[n];
		for(int i = 0; i < n; i++){
			stackArray[i] = new Stack<Integer>();
		}

		for(int i = 0; i < q; i++){
			tmpArray = br.readLine().split(" ");

			//push
			if(tmpArray[0].equals("0")){
				int t = Integer.parseInt(tmpArray[1]);
				int x = Integer.parseInt(tmpArray[2]);

				stackArray[t].push(x);
			}
			//top
			else if(tmpArray[0].equals("1")){
				int t = Integer.parseInt(tmpArray[1]);

				if(!stackArray[t].isEmpty()){
					System.out.println(stackArray[t].peek());
				}
			}
			//pop
			else {
				int t = Integer.parseInt(tmpArray[1]);

				if(!stackArray[t].isEmpty()){
					stackArray[t].pop();
				}
			}
		}

	}
}

</source>
<source file="../hum_codes_raw/s608277077.java" startline="1" endline="51" pcid="20442">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Stack;

public class Main{

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String[] tmpArray = br.readLine().split(" ");
		int n = Integer.parseInt(tmpArray[0]);
		int q = Integer.parseInt(tmpArray[1]);

		@SuppressWarnings("unchecked")
		Stack<Integer>[] stackArray = new Stack[n];
		for(int i = 0; i < n; i++){
			stackArray[i] = new Stack<Integer>();
		}

		for(int i = 0; i < q; i++){
			tmpArray = br.readLine().split(" ");

			//push
			if(tmpArray[0].equals("0")){
				int t = Integer.parseInt(tmpArray[1]);
				int x = Integer.parseInt(tmpArray[2]);

				stackArray[t].push(x);
			}
			//top
			else if(tmpArray[0].equals("1")){
				int t = Integer.parseInt(tmpArray[1]);

				if(!stackArray[t].isEmpty()){
					System.out.println(stackArray[t].peek());
				}
			}
			//pop
			else {
				int t = Integer.parseInt(tmpArray[1]);

				if(!stackArray[t].isEmpty()){
					stackArray[t].pop();
				}
			}
		}

	}
}


</source>
</class>

<class classid="164" nclones="2" nlines="186" similarity="100">
<source file="../hum_codes_raw/s289533688.java" startline="1" endline="222" pcid="9691">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.io.UncheckedIOException;
import java.util.List;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            BSplatterPainting solver = new BSplatterPainting();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class BSplatterPainting {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            int m = in.readInt();
            Node[] nodes = new Node[n];
            for (int i = 0; i < n; i++) {
                nodes[i] = new Node();
            }
            for (int j = 0; j < m; j++) {
                Node a = nodes[in.readInt() - 1];
                Node b = nodes[in.readInt() - 1];
                a.adj.add(b);
                b.adj.add(a);
            }
            int q = in.readInt();
            int[][] qs = new int[3][q];
            for (int i = 0; i < q; i++) {
                for (int j = 0; j < 3; j++) {
                    qs[j][i] = in.readInt();
                }
            }

            for (int i = q - 1; i >= 0; i--) {
                Node v = nodes[qs[0][i] - 1];
                int d = qs[1][i];
                int c = qs[2][i];
                paint(v, c, d);
            }

            for (Node node : nodes) {
                int c = node.color == -1 ? 0 : node.color;
                out.println(c);
            }
        }

        public void paint(Node root, int c, int power) {
            if (power < 0 || root.used[power]) {
                return;
            }
            root.used[power] = true;
            if (root.color == -1) {
                root.color = c;
            }
            for (Node node : root.adj) {
                paint(node, c, power - 1);
            }
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class Node {
        List<Node> adj = new ArrayList<>();
        boolean[] used = new boolean[11];
        int color = -1;

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }
}


</source>
<source file="../hum_codes_raw/s825806369.java" startline="1" endline="222" pcid="27702">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.io.UncheckedIOException;
import java.util.List;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            BSplatterPainting solver = new BSplatterPainting();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class BSplatterPainting {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            int m = in.readInt();
            Node[] nodes = new Node[n];
            for (int i = 0; i < n; i++) {
                nodes[i] = new Node();
            }
            for (int j = 0; j < m; j++) {
                Node a = nodes[in.readInt() - 1];
                Node b = nodes[in.readInt() - 1];
                a.adj.add(b);
                b.adj.add(a);
            }
            int q = in.readInt();
            int[][] qs = new int[3][q];
            for (int i = 0; i < q; i++) {
                for (int j = 0; j < 3; j++) {
                    qs[j][i] = in.readInt();
                }
            }

            for (int i = q - 1; i >= 0; i--) {
                Node v = nodes[qs[0][i] - 1];
                int d = qs[1][i];
                int c = qs[2][i];
                paint(v, c, d);
            }

            for (Node node : nodes) {
                int c = node.color == -1 ? 0 : node.color;
                out.println(c);
            }
        }

        public void paint(Node root, int c, int power) {
            if (power < 0 || root.used[power]) {
                return;
            }
            root.used[power] = true;
            if (root.color == -1) {
                root.color = c;
            }
            for (Node node : root.adj) {
                paint(node, c, power - 1);
            }
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class Node {
        List<Node> adj = new ArrayList<>();
        boolean[] used = new boolean[11];
        int color = -1;

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }
}


</source>
</class>

<class classid="165" nclones="2" nlines="475" similarity="100">
<source file="../hum_codes_raw/s297470456.java" startline="1" endline="548" pcid="9996">
import java.io.*;
import java.util.*;

class P{
	long x, y;
	public P(int x, int y) {
		super();
		this.x = x;
		this.y = y;
	}
}

public class Main {
	static InputStream is;
	static PrintWriter out;
	static String INPUT = "";

	static final long mod = (long) 1e9 + 7;
	static final int dx[] = { -1, 0, 1, 0 }, dy[] = { 0, -1, 0, 1 };
	static final int[] dx8 = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy8 = { -1, 0, 1, -1, 1, -1, 0, 1 };
	static final int inf = Integer.MAX_VALUE / 3;
	static final long linf = Long.MAX_VALUE / 3;
	static final double dinf = Double.MAX_VALUE / 3;
	static final double eps = 1e-10;
	static final double pi = Math.PI;

	static void solve() {
		int n = ni();
		P p[] = new P[n];
		for(int i=0;i<n;i++) {
			p[i] = new P(ni(),ni());
		}
		//
		int check = (int)Math.abs(p[0].x-p[0].y)%2;
		for(int i=0;i<n;i++) {
			if(check != Math.abs(p[i].x - p[i].y)%2) {
				out.println(-1);
				return;
			}
		}
		
		
		int m = 0;
		long d[];
		if(check==1) {
			m = 33;
			d = new long[m];
			for(int i=0;i<m;i++) {
				d[i] = 1L<<i;
			}
		}
		else {
			m = 34;
			d = new long[m];
			for(int i=0;i<m-1;i++) {
				d[i+1] = 1L<<i;
				d[0] = 1;
			}
		}
		
		out.println(m);
		for(int i=0;i<m;i++) {
			out.print(d[m-1-i] + " ");
		}
		out.println();
		
		for(int i=0;i<n;i++) {
			String s = "";
			long x = p[i].x, y = p[i].y;
			for(int j=m-1;j>=0;j--) {
				if(abs(x)-abs(y)>0) {
					if(x<0) {
						s += "L";
						x += d[j];
					}
					else {
						s += "R";
						x -= d[j];
					}
				}
				else {
					if(y<0) {
						s += "D";
						y += d[j];
					}
					else {
						s += "U";
						y -= d[j];
					}
				}					
			}
			out.println(s);
		}
		

	}

	static int abs(int x) {
		return Math.abs(x);
	}	
	static long abs(long x) {
		return Math.abs(x);
	}
	static double abs(double x) {
		return Math.abs(x);
	}
	
	//libraries		
	static int lowerBound(int[] a, int x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] < x) {//
				//if (a[c] > x) {//
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static int upperBound(int[] a, int x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] <= x) {
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static int lowerBound(long[] a, long x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] < x) {
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static int upperBound(long[] a, long x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] <= x) {
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static int lowerBound(double[] a, double x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] < x) {
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static int upperBound(double[] a, double x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] <= x) {
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static <T> int lowerBound(List<T> ls, T x) throws RuntimeException {
		if (ls.size() == 0)
			return -1;
		if (ls.get(0) instanceof Integer) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) >= 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Long) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) >= 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Double) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) >= 0 ? 1 : -1);
		} else {
			System.err.println(
					String.format("%s:", Thread.currentThread().getStackTrace()[1].getMethodName()));
			throw new RuntimeException();
		}
	}

	static <T> int upperBound(List<T> ls, T x) throws RuntimeException {
		if (ls.size() == 0)
			return -1;
		if (ls.get(0) instanceof Integer) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) > 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Long) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) > 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Double) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) > 0 ? 1 : -1);
		} else {
			System.err.println(
					String.format("%s:", Thread.currentThread().getStackTrace()[1].getMethodName()));
			throw new RuntimeException();
		}
	}

	static <T> int rupperBound(List<T> ls, T x) throws RuntimeException {
		if (ls.size() == 0)
			return -1;
		if (ls.get(0) instanceof Integer) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) < 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Long) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) < 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Double) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) < 0 ? 1 : -1);
		} else {
			System.err.println(
					String.format("%s:", Thread.currentThread().getStackTrace()[1].getMethodName()));
			throw new RuntimeException();
		}
	}

	static <T> int rlowerBound(List<T> ls, T x) {
		if (ls.size() == 0)
			return -1;
		if (ls.get(0) instanceof Integer) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) <= 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Long) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) <= 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Double) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) <= 0 ? 1 : -1);
		} else {
			System.err.println(
					String.format("%s:", Thread.currentThread().getStackTrace()[1].getMethodName()));
			throw new RuntimeException();
		}
	}

	static int[] concat(int x, int arr[]) {
		int ret[] = new int[arr.length + 1];
		System.arraycopy(arr, 0, ret, 1, ret.length - 1);
		ret[0] = x;
		return ret;
	}

	static int[] concat(int arr[], int x) {
		int ret[] = new int[arr.length + 1];
		System.arraycopy(arr, 0, ret, 0, ret.length - 1);
		ret[ret.length - 1] = x;
		return ret;
	}

	static long[] concat(long x, long arr[]) {
		long ret[] = new long[arr.length + 1];
		System.arraycopy(arr, 0, ret, 1, ret.length - 1);
		ret[0] = x;
		return ret;
	}

	static long[] concat(long arr[], long x) {
		long ret[] = new long[arr.length + 1];
		System.arraycopy(arr, 0, ret, 0, ret.length - 1);
		ret[ret.length - 1] = x;
		return ret;
	}

	static long max(long x, long y) {
		return Math.max(x, y);
	}

	static long min(long x, long y) {
		return Math.min(x, y);
	}

	static long max(long x, long y, long z) {
		x = Math.max(x, y);
		x = Math.max(x, z);
		return x;
	}

	static long min(long x, long y, long z) {
		x = Math.min(x, y);
		x = Math.min(x, z);
		return x;
	}

	static double max(double x, double y) {
		return Math.max(x, y);
	}

	static double min(double x, double y) {
		return Math.min(x, y);
	}

	static double max(double x, double y, double z) {
		x = Math.max(x, y);
		x = Math.max(x, z);
		return x;
	}

	static double min(double x, double y, double z) {
		x = Math.min(x, y);
		x = Math.min(x, z);
		return x;
	}

	static void sort(int[] ar) {
		Arrays.sort(ar);
	}

	static void sort(long[] ar) {
		Arrays.sort(ar);
	}

	static void sort(double[] ar) {
		Arrays.sort(ar);
	}

	static void rsort(int[] ar) {
		Arrays.sort(ar);
		int len = ar.length;
		for (int i = 0; i < len / 2; i++) {
			int tmp = ar[i];
			ar[i] = ar[len - 1 - i];
			ar[len - 1 - i] = tmp;
		}
	}

	static void rsort(long[] ar) {
		Arrays.sort(ar);
		int len = ar.length;
		for (int i = 0; i < len / 2; i++) {
			long tmp = ar[i];
			ar[i] = ar[len - 1 - i];
			ar[len - 1 - i] = tmp;
		}
	}

	static void rsort(double[] ar) {
		Arrays.sort(ar);
		int len = ar.length;
		for (int i = 0; i < len / 2; i++) {
			double tmp = ar[i];
			ar[i] = ar[len - 1 - i];
			ar[len - 1 - i] = tmp;
		}
	}

	static void fill(int arr[], int x) {
		Arrays.fill(arr, x);
	}

	static void fill(long arr[], long x) {
		Arrays.fill(arr, x);
	}

	static void fill(double arr[], double x) {
		Arrays.fill(arr, x);
	}

	static void fill(int arr[][], int x) {
		for (int i = 0; i < arr.length; i++)
			Arrays.fill(arr[i], x);
	}

	static void fill(long arr[][], long x) {
		for (int i = 0; i < arr.length; i++)
			Arrays.fill(arr[i], x);
	}

	static void fill(double arr[][], double x) {
		for (int i = 0; i < arr.length; i++)
			Arrays.fill(arr[i], x);
	}

	//MOD culc
	static long plus(long x, long y) {
		long res = (x + y) % mod;
		return res < 0 ? res + mod : res;
	}

	static long sub(long x, long y) {
		long res = (x - y) % mod;
		return res < 0 ? res + mod : res;
	}

	static long mul(long x, long y) {
		long res = (x * y) % mod;
		return res < 0 ? res + mod : res;
	}

	static long div(long x, long y) {
		long res = x * pow(y, mod - 2) % mod;
		return res < 0 ? res + mod : res;
	}

	static long pow(long x, long y) {
		if (y < 0)
			return 0;
		if (y == 0)
			return 1;
		if (y % 2 == 1)
			return (x * pow(x, y - 1)) % mod;
		long root = pow(x, y / 2);
		return root * root % mod;
	}

	public static void main(String[] args) throws Exception {
		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		solve();
		out.flush();
	}

	//input
	private static byte[] inbuf = new byte[1024];
	static int lenbuf = 0, ptrbuf = 0;

	private static int readByte() {
		if (lenbuf == -1)
			throw new InputMismatchException();
		if (ptrbuf >= lenbuf) {
			ptrbuf = 0;
			try {
				lenbuf = is.read(inbuf);
			} catch (IOException e) {
				throw new InputMismatchException();
			}
			if (lenbuf <= 0)
				return -1;
		}
		return inbuf[ptrbuf++];
	}

	private static boolean isSpaceChar(int c) {
		return !(c >= 33 && c <= 126);
	}

	private static int skip() {
		int b;
		while ((b = readByte()) != -1 && isSpaceChar(b))
			;
		return b;
	}

	@SuppressWarnings("unused")
	private static double nd() {
		return Double.parseDouble(ns());
	}

	@SuppressWarnings("unused")
	private static char nc() {
		return (char) skip();
	}

	private static String ns() {
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while (!(isSpaceChar(b))) {
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}

	private static char[] ns(int n) {
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while (p < n && !(isSpaceChar(b))) {
			buf[p++] = (char) b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}

	@SuppressWarnings("unused")
	private static char[][] nm(int n, int m) {
		char[][] map = new char[n][];
		for (int i = 0; i < n; i++)
			map[i] = ns(m);
		return map;
	}

	@SuppressWarnings("unused")
	private static int[] na(int n) {
		int[] a = new int[n];
		for (int i = 0; i < n; i++)
			a[i] = ni();
		return a;
	}

	private static int ni() {
		int num = 0, b;
		boolean minus = false;
		while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))
			;
		if (b == '-') {
			minus = true;
			b = readByte();
		}

		while (true) {
			if (b >= '0' && b <= '9') {
				num = num * 10 + (b - '0');
			} else {
				return minus ? -num : num;
			}
			b = readByte();
		}
	}

	@SuppressWarnings("unused")
	private static long nl() {
		long num = 0;
		int b;
		boolean minus = false;
		while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))
			;
		if (b == '-') {
			minus = true;
			b = readByte();
		}

		while (true) {
			if (b >= '0' && b <= '9') {
				num = num * 10 + (b - '0');
			} else {
				return minus ? -num : num;
			}
			b = readByte();
		}
	}

}

</source>
<source file="../hum_codes_raw/s898792213.java" startline="1" endline="548" pcid="30243">
import java.io.*;
import java.util.*;

class P{
	long x, y;
	public P(int x, int y) {
		super();
		this.x = x;
		this.y = y;
	}
}

public class Main {
	static InputStream is;
	static PrintWriter out;
	static String INPUT = "";

	static final long mod = (long) 1e9 + 7;
	static final int dx[] = { -1, 0, 1, 0 }, dy[] = { 0, -1, 0, 1 };
	static final int[] dx8 = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy8 = { -1, 0, 1, -1, 1, -1, 0, 1 };
	static final int inf = Integer.MAX_VALUE / 3;
	static final long linf = Long.MAX_VALUE / 3;
	static final double dinf = Double.MAX_VALUE / 3;
	static final double eps = 1e-10;
	static final double pi = Math.PI;

	static void solve() {
		int n = ni();
		P p[] = new P[n];
		for(int i=0;i<n;i++) {
			p[i] = new P(ni(),ni());
		}
		//
		int check = (int)Math.abs(p[0].x-p[0].y)%2;
		for(int i=0;i<n;i++) {
			if(check != Math.abs(p[i].x - p[i].y)%2) {
				out.println(-1);
				return;
			}
		}
		
		
		int m = 0;
		long d[];
		if(check==1) {
			m = 33;
			d = new long[m];
			for(int i=0;i<m;i++) {
				d[i] = 1L<<i;
			}
		}
		else {
			m = 34;
			d = new long[m];
			for(int i=0;i<m-1;i++) {
				d[i+1] = 1L<<i;
				d[0] = 1;
			}
		}
		
		out.println(m);
		for(int i=0;i<m;i++) {
			out.print(d[m-1-i] + " ");
		}
		out.println();
		
		for(int i=0;i<n;i++) {
			String s = "";
			long x = p[i].x, y = p[i].y;
			for(int j=m-1;j>=0;j--) {
				if(abs(x)-abs(y)>0) {
					if(x<0) {
						s += "L";
						x += d[j];
					}
					else {
						s += "R";
						x -= d[j];
					}
				}
				else {
					if(y<0) {
						s += "D";
						y += d[j];
					}
					else {
						s += "U";
						y -= d[j];
					}
				}					
			}
			out.println(s);
		}
		

	}

	static int abs(int x) {
		return Math.abs(x);
	}	
	static long abs(long x) {
		return Math.abs(x);
	}
	static double abs(double x) {
		return Math.abs(x);
	}
	
	//libraries		
	static int lowerBound(int[] a, int x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] < x) {//
				//if (a[c] > x) {//
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static int upperBound(int[] a, int x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] <= x) {
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static int lowerBound(long[] a, long x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] < x) {
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static int upperBound(long[] a, long x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] <= x) {
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static int lowerBound(double[] a, double x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] < x) {
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static int upperBound(double[] a, double x) {
		int l = -1, r = a.length;
		while (r - l > 1) {
			int c = (l + r) / 2;
			if (a[c] <= x) {
				l = c;
			} else {
				r = c;
			}
		}
		return r;
	}

	static <T> int lowerBound(List<T> ls, T x) throws RuntimeException {
		if (ls.size() == 0)
			return -1;
		if (ls.get(0) instanceof Integer) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) >= 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Long) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) >= 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Double) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) >= 0 ? 1 : -1);
		} else {
			System.err.println(
					String.format("%s:", Thread.currentThread().getStackTrace()[1].getMethodName()));
			throw new RuntimeException();
		}
	}

	static <T> int upperBound(List<T> ls, T x) throws RuntimeException {
		if (ls.size() == 0)
			return -1;
		if (ls.get(0) instanceof Integer) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) > 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Long) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) > 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Double) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) > 0 ? 1 : -1);
		} else {
			System.err.println(
					String.format("%s:", Thread.currentThread().getStackTrace()[1].getMethodName()));
			throw new RuntimeException();
		}
	}

	static <T> int rupperBound(List<T> ls, T x) throws RuntimeException {
		if (ls.size() == 0)
			return -1;
		if (ls.get(0) instanceof Integer) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) < 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Long) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) < 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Double) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) < 0 ? 1 : -1);
		} else {
			System.err.println(
					String.format("%s:", Thread.currentThread().getStackTrace()[1].getMethodName()));
			throw new RuntimeException();
		}
	}

	static <T> int rlowerBound(List<T> ls, T x) {
		if (ls.size() == 0)
			return -1;
		if (ls.get(0) instanceof Integer) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) <= 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Long) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) <= 0 ? 1 : -1);
		} else if (ls.get(0) instanceof Double) {
			return ~Collections.binarySearch(ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) <= 0 ? 1 : -1);
		} else {
			System.err.println(
					String.format("%s:", Thread.currentThread().getStackTrace()[1].getMethodName()));
			throw new RuntimeException();
		}
	}

	static int[] concat(int x, int arr[]) {
		int ret[] = new int[arr.length + 1];
		System.arraycopy(arr, 0, ret, 1, ret.length - 1);
		ret[0] = x;
		return ret;
	}

	static int[] concat(int arr[], int x) {
		int ret[] = new int[arr.length + 1];
		System.arraycopy(arr, 0, ret, 0, ret.length - 1);
		ret[ret.length - 1] = x;
		return ret;
	}

	static long[] concat(long x, long arr[]) {
		long ret[] = new long[arr.length + 1];
		System.arraycopy(arr, 0, ret, 1, ret.length - 1);
		ret[0] = x;
		return ret;
	}

	static long[] concat(long arr[], long x) {
		long ret[] = new long[arr.length + 1];
		System.arraycopy(arr, 0, ret, 0, ret.length - 1);
		ret[ret.length - 1] = x;
		return ret;
	}

	static long max(long x, long y) {
		return Math.max(x, y);
	}

	static long min(long x, long y) {
		return Math.min(x, y);
	}

	static long max(long x, long y, long z) {
		x = Math.max(x, y);
		x = Math.max(x, z);
		return x;
	}

	static long min(long x, long y, long z) {
		x = Math.min(x, y);
		x = Math.min(x, z);
		return x;
	}

	static double max(double x, double y) {
		return Math.max(x, y);
	}

	static double min(double x, double y) {
		return Math.min(x, y);
	}

	static double max(double x, double y, double z) {
		x = Math.max(x, y);
		x = Math.max(x, z);
		return x;
	}

	static double min(double x, double y, double z) {
		x = Math.min(x, y);
		x = Math.min(x, z);
		return x;
	}

	static void sort(int[] ar) {
		Arrays.sort(ar);
	}

	static void sort(long[] ar) {
		Arrays.sort(ar);
	}

	static void sort(double[] ar) {
		Arrays.sort(ar);
	}

	static void rsort(int[] ar) {
		Arrays.sort(ar);
		int len = ar.length;
		for (int i = 0; i < len / 2; i++) {
			int tmp = ar[i];
			ar[i] = ar[len - 1 - i];
			ar[len - 1 - i] = tmp;
		}
	}

	static void rsort(long[] ar) {
		Arrays.sort(ar);
		int len = ar.length;
		for (int i = 0; i < len / 2; i++) {
			long tmp = ar[i];
			ar[i] = ar[len - 1 - i];
			ar[len - 1 - i] = tmp;
		}
	}

	static void rsort(double[] ar) {
		Arrays.sort(ar);
		int len = ar.length;
		for (int i = 0; i < len / 2; i++) {
			double tmp = ar[i];
			ar[i] = ar[len - 1 - i];
			ar[len - 1 - i] = tmp;
		}
	}

	static void fill(int arr[], int x) {
		Arrays.fill(arr, x);
	}

	static void fill(long arr[], long x) {
		Arrays.fill(arr, x);
	}

	static void fill(double arr[], double x) {
		Arrays.fill(arr, x);
	}

	static void fill(int arr[][], int x) {
		for (int i = 0; i < arr.length; i++)
			Arrays.fill(arr[i], x);
	}

	static void fill(long arr[][], long x) {
		for (int i = 0; i < arr.length; i++)
			Arrays.fill(arr[i], x);
	}

	static void fill(double arr[][], double x) {
		for (int i = 0; i < arr.length; i++)
			Arrays.fill(arr[i], x);
	}

	//MOD culc
	static long plus(long x, long y) {
		long res = (x + y) % mod;
		return res < 0 ? res + mod : res;
	}

	static long sub(long x, long y) {
		long res = (x - y) % mod;
		return res < 0 ? res + mod : res;
	}

	static long mul(long x, long y) {
		long res = (x * y) % mod;
		return res < 0 ? res + mod : res;
	}

	static long div(long x, long y) {
		long res = x * pow(y, mod - 2) % mod;
		return res < 0 ? res + mod : res;
	}

	static long pow(long x, long y) {
		if (y < 0)
			return 0;
		if (y == 0)
			return 1;
		if (y % 2 == 1)
			return (x * pow(x, y - 1)) % mod;
		long root = pow(x, y / 2);
		return root * root % mod;
	}

	public static void main(String[] args) throws Exception {
		is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());
		out = new PrintWriter(System.out);
		solve();
		out.flush();
	}

	//input
	private static byte[] inbuf = new byte[1024];
	static int lenbuf = 0, ptrbuf = 0;

	private static int readByte() {
		if (lenbuf == -1)
			throw new InputMismatchException();
		if (ptrbuf >= lenbuf) {
			ptrbuf = 0;
			try {
				lenbuf = is.read(inbuf);
			} catch (IOException e) {
				throw new InputMismatchException();
			}
			if (lenbuf <= 0)
				return -1;
		}
		return inbuf[ptrbuf++];
	}

	private static boolean isSpaceChar(int c) {
		return !(c >= 33 && c <= 126);
	}

	private static int skip() {
		int b;
		while ((b = readByte()) != -1 && isSpaceChar(b))
			;
		return b;
	}

	@SuppressWarnings("unused")
	private static double nd() {
		return Double.parseDouble(ns());
	}

	@SuppressWarnings("unused")
	private static char nc() {
		return (char) skip();
	}

	private static String ns() {
		int b = skip();
		StringBuilder sb = new StringBuilder();
		while (!(isSpaceChar(b))) {
			sb.appendCodePoint(b);
			b = readByte();
		}
		return sb.toString();
	}

	private static char[] ns(int n) {
		char[] buf = new char[n];
		int b = skip(), p = 0;
		while (p < n && !(isSpaceChar(b))) {
			buf[p++] = (char) b;
			b = readByte();
		}
		return n == p ? buf : Arrays.copyOf(buf, p);
	}

	@SuppressWarnings("unused")
	private static char[][] nm(int n, int m) {
		char[][] map = new char[n][];
		for (int i = 0; i < n; i++)
			map[i] = ns(m);
		return map;
	}

	@SuppressWarnings("unused")
	private static int[] na(int n) {
		int[] a = new int[n];
		for (int i = 0; i < n; i++)
			a[i] = ni();
		return a;
	}

	private static int ni() {
		int num = 0, b;
		boolean minus = false;
		while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))
			;
		if (b == '-') {
			minus = true;
			b = readByte();
		}

		while (true) {
			if (b >= '0' && b <= '9') {
				num = num * 10 + (b - '0');
			} else {
				return minus ? -num : num;
			}
			b = readByte();
		}
	}

	@SuppressWarnings("unused")
	private static long nl() {
		long num = 0;
		int b;
		boolean minus = false;
		while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))
			;
		if (b == '-') {
			minus = true;
			b = readByte();
		}

		while (true) {
			if (b >= '0' && b <= '9') {
				num = num * 10 + (b - '0');
			} else {
				return minus ? -num : num;
			}
			b = readByte();
		}
	}

}

</source>
</class>

<class classid="166" nclones="2" nlines="10" similarity="100">
<source file="../hum_codes_raw/s300046550.java" startline="1" endline="16" pcid="10105">
import java.util.Scanner;

public class Main {

  public static void main(String[] args) {

    Scanner sc = new Scanner(System.in);
    int a = sc.nextInt();
    int b = sc.nextInt();
    int h = sc.nextInt();

    System.out.println((a + b) * h / 2);

  }
}

</source>
<source file="../hum_codes_raw/s734792783.java" startline="1" endline="14" pcid="24696">
import java.util.Scanner;

public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        
        int a = sc.nextInt();
        int b = sc.nextInt();
        int h = sc.nextInt();
        
        System.out.println((a + b) * h / 2);
    }
}

</source>
</class>

<class classid="167" nclones="2" nlines="26" similarity="100">
<source file="../hum_codes_raw/s302989808.java" startline="1" endline="26" pcid="10203">
import java.util.*; 
class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int q = sc.nextInt();
        Queue<String> qProcess = new LinkedList<String>();
        Queue<Integer> qTime = new LinkedList<Integer>();        
        int totalTime = 0;
        for (int i = 0; i < n; i++) {
            qProcess.add(sc.next());
            qTime.add(sc.nextInt());
        }         
        while (qProcess.size()>0) {
            if (qTime.peek() - q > 0) {
                qProcess.add(qProcess.poll());
                qTime.add(qTime.poll()-q);
                totalTime = totalTime + q;
            } else {
                totalTime = totalTime + qTime.poll();
                System.out.println(qProcess.poll() + ' ' + totalTime);
            }
        }
    }
}

</source>
<source file="../hum_codes_raw/s544542918.java" startline="1" endline="26" pcid="18345">
import java.util.*; 
class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int q = sc.nextInt();
        Queue<String> qProcess = new LinkedList<String>();
        Queue<Integer> qTime = new LinkedList<Integer>();        
        int totalTime = 0;
        for (int i = 0; i < n; i++) {
            qProcess.add(sc.next());
            qTime.add(sc.nextInt());
        }         
        while (qProcess.size()>0) {
            if (qTime.peek() - q > 0) {
                qProcess.add(qProcess.poll());
                qTime.add(qTime.poll()-q);
                totalTime = totalTime + q;
            } else {
                totalTime = totalTime + qTime.poll();
                System.out.println(qProcess.poll() + ' ' + totalTime);
            }
        }
    }
}

</source>
</class>

<class classid="168" nclones="2" nlines="162" similarity="100">
<source file="../hum_codes_raw/s306147031.java" startline="1" endline="180" pcid="10309">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

class Node {
	int key, priority;
	Node parent, left, right;

	public Node(int key, int priority) {
		super();
		this.key = key;
		this.priority = priority;
	}

}

class Tree {
	Node root;

	Node rightRotate(Node t) {
		Node s = t.left;
		t.left = s.right;
		s.right = t;
		if (t == this.root) {
			this.root = s;
		}
		return s;
	}

	Node leftRotate(Node t) {
		Node s = t.right;
		t.right = s.left;
		s.left = t;
		if (t == this.root) {
			this.root = s;
		}
		return s;
	}

	Node insert(Node t, int key, int priority) {
		if (this.root == null) {
			this.root = new Node(key, priority);
			return t;
		}
		if (t == null) {
			return new Node(key, priority);
		}
		if (key == t.key) {
			return t;
		}

		if (key < t.key) {
			t.left = insert(t.left, key, priority);
			if (t.priority < t.left.priority) {
				t = rightRotate(t);
			}
		} else {
			t.right = insert(t.right, key, priority);
			if (t.priority < t.right.priority) {
				t = leftRotate(t);
			}
		}
		return t;

	}


	Node delete(Node t, int key) {
		if (t == null) {
			return null;
		}
		if (key < t.key) {
			t.left = delete(t.left, key);
		} else if(key > t.key) {
			 t.right = delete(t.right, key);
		} else {
			return _delete(t, key);
		}

		return t;
	}

	Node _delete(Node t, int key) {
		if (t.left == null && t.right == null) {
			return null;
		} else if (t.left == null) {
			t = leftRotate(t);
		} else if (t.right == null) {
			t = rightRotate(t);
		} else {
			if (t.left.priority > t.right.priority) {
				t = rightRotate(t);
			} else {
				t = leftRotate(t);
			}
		}

		return delete(t, key);
	}

	boolean find(Node t, int key) {
		if (t == null) {
			return false;
		}
		if (key < t.key) {
			return find(t.left, key);
		} else if (key > t.key) {
			return find(t.right, key);
		} else {
			return true;
		}
	}



}

public class Main {

	static StringBuilder sb;

	public static void printPreOrder(Node node) {
		if (node == null) {
			return;
		}

		sb.append(" " + node.key);
		printPreOrder(node.left);
		printPreOrder(node.right);
	}

	public static void printInOrder(Node node) {
		if (node == null) {
			return;
		}

		printInOrder(node.left);
		sb.append(" " + node.key);
		printInOrder(node.right);
	}



	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

		int m = Integer.parseInt(br.readLine());
		String[] operation;
		int key, priority;
		Tree tree = new Tree();
		sb = new StringBuilder();

		for (int i = 0; i < m; i++) {
			operation = br.readLine().split(" ");
			if (operation[0].equals("insert")) {
				key = Integer.parseInt(operation[1]);
				priority = Integer.parseInt(operation[2]);
				tree.insert(tree.root, key, priority);
			} else if (operation[0].equals("find")) {
				key = Integer.parseInt(operation[1]);
				if (tree.find(tree.root, key)) {
					System.out.println("yes");
				} else {
					System.out.println("no");
				}
			} else if (operation[0].equals("delete")) {
				key = Integer.parseInt(operation[1]);
				tree.delete(tree.root, key);
			} else {
				printInOrder(tree.root);
				sb.append("\n");
				printPreOrder(tree.root);
				System.out.println(sb.toString());
				sb.setLength(0);
			}
		}

	}
}

</source>
<source file="../hum_codes_raw/s723913417.java" startline="1" endline="202" pcid="24348">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

class Node {
	int key, priority;
	Node parent, left, right;

	public Node(int key, int priority) {
		super();
		this.key = key;
		this.priority = priority;
	}

}

class Tree {
	Node root;

	Node rightRotate(Node t) {
		Node s = t.left;
		t.left = s.right;
		s.right = t;
		if (t == this.root) {
			this.root = s;
		}
		return s;
	}

	Node leftRotate(Node t) {
		Node s = t.right;
		t.right = s.left;
		s.left = t;
		if (t == this.root) {
			this.root = s;
		}
		return s;
	}

//	void insert(Node z) {
//		Node y = null;
//		Node x = this.root;
//		while (x != null) {
//			y = x;
//			if (z.key < x.key) {
//				x = y.left;
//			} else {
//				x = y.right;
//			}
//		}
//		z.parent = y;
//
//		if (y == null) {
//			this.root = z;
//		} else if (z.key < y.key) {
//			y.left = z;
//		} else {
//			y.right = z;
//		}
//	}

	Node insert(Node t, int key, int priority) {
		if (this.root == null) {
			this.root = new Node(key, priority);
			return t;
		}
		if (t == null) {
			return new Node(key, priority);
		}
		if (key == t.key) {
			return t;
		}

		if (key < t.key) {
			t.left = insert(t.left, key, priority);
			if (t.priority < t.left.priority) {
				t = rightRotate(t);
			}
		} else {
			t.right = insert(t.right, key, priority);
			if (t.priority < t.right.priority) {
				t = leftRotate(t);
			}
		}
		return t;

	}


	Node delete(Node t, int key) {
		if (t == null) {
			return null;
		}
		if (key < t.key) {
			t.left = delete(t.left, key);
		} else if(key > t.key) {
			 t.right = delete(t.right, key);
		} else {
			return _delete(t, key);
		}

		return t;
	}

	Node _delete(Node t, int key) {
		if (t.left == null && t.right == null) {
			return null;
		} else if (t.left == null) {
			t = leftRotate(t);
		} else if (t.right == null) {
			t = rightRotate(t);
		} else {
			if (t.left.priority > t.right.priority) {
				t = rightRotate(t);
			} else {
				t = leftRotate(t);
			}
		}

		return delete(t, key);
	}

	boolean find(Node t, int key) {
		if (t == null) {
			return false;
		}
		if (key < t.key) {
			return find(t.left, key);
		} else if (key > t.key) {
			return find(t.right, key);
		} else {
			return true;
		}
	}



}

public class Main {

	static StringBuilder sb;

	public static void printPreOrder(Node node) {
		if (node == null) {
			return;
		}

		sb.append(" " + node.key);
		printPreOrder(node.left);
		printPreOrder(node.right);
	}

	public static void printInOrder(Node node) {
		if (node == null) {
			return;
		}

		printInOrder(node.left);
		sb.append(" " + node.key);
		printInOrder(node.right);
	}



	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

		int m = Integer.parseInt(br.readLine());
		String[] operation;
		int key, priority;
		Tree tree = new Tree();
		sb = new StringBuilder();

		for (int i = 0; i < m; i++) {
			operation = br.readLine().split(" ");
			if (operation[0].equals("insert")) {
				key = Integer.parseInt(operation[1]);
				priority = Integer.parseInt(operation[2]);
				tree.insert(tree.root, key, priority);
			} else if (operation[0].equals("find")) {
				key = Integer.parseInt(operation[1]);
				if (tree.find(tree.root, key)) {
					System.out.println("yes");
				} else {
					System.out.println("no");
				}
			} else if (operation[0].equals("delete")) {
				key = Integer.parseInt(operation[1]);
				tree.delete(tree.root, key);
			} else {
				printInOrder(tree.root);
				sb.append("\n");
				printPreOrder(tree.root);
				System.out.println(sb.toString());
				sb.setLength(0);
			}
		}

	}
}

</source>
</class>

<class classid="169" nclones="2" nlines="34" similarity="100">
<source file="../hum_codes_raw/s306713968.java" startline="1" endline="37" pcid="10327">
import java.util.Scanner;

public class Main{
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		double x_p1 = scan.nextDouble();
		double y_p1 = scan.nextDouble();
		double x_p2 = scan.nextDouble();
		double y_p2 = scan.nextDouble();
		double vx = x_p2 - x_p1;
		double vy = y_p2 - y_p1;
		int q = scan.nextInt();
		double l = norm(x_p1, y_p1, x_p2, y_p2);
		StringBuilder sb = new StringBuilder();
		for(int i = 0; i < q; i++) {
			double x = scan.nextDouble();
			double y = scan.nextDouble();
			double ux = x - x_p1;
			double uy = y - y_p1;
			double t = dot(ux, uy, vx, vy);
			double k = t / l;
			double a = k * vx + x_p1;
			double b = k * vy + y_p1;
			//System.out.println(a + " " + b);
			sb.append(a).append(" ").append(b).append("\n");
		}
		scan.close();
		System.out.print(sb.toString());
	}
	static double dot(double x1, double y1, double x2, double y2) {
		return x1 * x2 + y1 * y2;
	}
	static double norm(double x1, double y1, double x2, double y2) {
		return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
	}
}

</source>
<source file="../hum_codes_raw/s525519255.java" startline="1" endline="45" pcid="17671">
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        
        double x_p1 = scan.nextDouble();
        double y_p1 = scan.nextDouble();
        double x_p2 = scan.nextDouble();
        double y_p2 = scan.nextDouble();
        
        double vx = x_p2 - x_p1;
        double vy = y_p2 - y_p1;
        
        int q = scan.nextInt();
        double l = norm(x_p1, y_p1, x_p2, y_p2);
        
        StringBuilder sb = new StringBuilder();
        
        for(int i = 0; i < q; i++) {
            double x = scan.nextDouble();
            double y = scan.nextDouble();
            double ux = x - x_p1;
            double uy = y - y_p1;
            double t = dot(ux, uy, vx, vy);
            double k = t / l;
            double a = k * vx + x_p1;
            double b = k * vy + y_p1;
            
            //System.out.println(a + " " + b);
            sb.append(a).append(" ").append(b).append("\n");
        }
        scan.close();
        System.out.print(sb.toString());
    }
    
    static double dot(double x1, double y1, double x2, double y2) {
        return x1 * x2 + y1 * y2;
    }
    
    static double norm(double x1, double y1, double x2, double y2) {
        return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
    }
}

</source>
</class>

<class classid="170" nclones="2" nlines="120" similarity="100">
<source file="../hum_codes_raw/s308183422.java" startline="1" endline="135" pcid="10382">
import java.util.LinkedList;
import java.util.PriorityQueue;
import java.util.Scanner;

public class Main {
	static final int INF = 1000000000;
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc = new Scanner(System.in);
		Node[] inn = new Node[101];
		int[][] dp = new int[101][101];
		while(true){
			int n = sc.nextInt();
			int m = sc.nextInt();
			int l = sc.nextInt();
			if(n == 0 && m == 0 & l == 0){
				break;
			}
			for(int i = 1; i <= n; i++){
				inn[i] = new Node(i);
			}
			Node start = inn[1];
			Node goal = inn[n];
			for(int i = 0; i < m; i++){
				int a = sc.nextInt();
				int b = sc.nextInt();
				int d = sc.nextInt();
				int e = sc.nextInt();
				
				inn[a].edges.add(new Edge(e, d, inn[b]));
				inn[b].edges.add(new Edge(e, d, inn[a]));
			}
			boolean[] flg = new boolean[n + 1];
			for(int i = 0; i <= n; i++){
				flg[i] = false;
			}
			for(int i = 1; i <= n; i++){
				for(int j = 0; j <= l; j++){
					dp[i][j] = INF;
				}
			}
			PriorityQueue<Node> q = new PriorityQueue<Node>();
			int len = 0;
			dp[1][0] = 0;
			q.add(inn[1]);
			while(!q.isEmpty()){
				Node node = q.poll();
				len = node.c;
				for(Edge e : node.edges){
					// ???????????????????????
					if(len + e.d <= l){ // ???????????????????????
						// ??????????????????????\??????????????????????????????????????
						if(dp[e.t.n][len + e.d] > dp[node.n][len]){
							Node nnode = new Node(e.t.n);
							nnode.edges = e.t.edges;
							nnode.c = len + e.d;
							q.add(nnode);
							dp[e.t.n][len + e.d] = dp[node.n][len] ;
						}
					}
					// ???????????????????????
					// ??????????????????????????\???????????????????????????
					if(dp[e.t.n][len] > dp[node.n][len] + e.e){
						Node nnode = new Node(e.t.n);
						nnode.edges = e.t.edges;
						nnode.c = len;
						q.add(nnode);
						dp[e.t.n][len] = dp[node.n][len] + e.e;
					}
				}
			}
			
			int min = INF;
			for(int i = 0; i <= l; i++){
				min = Math.min(min, dp[n][i]);
			}
			System.out.println(min);
//			System.out.println(func(start, l, goal, flg));
			
		}
		
		
		sc.close();
	}
	static int func(Node node, int cap, Node goal, boolean[] flg){
		int res = 1000000000;
		if(node.equals(goal)){
			return 0;
		}
		for(Edge e : node.edges){
			if(!flg[e.t.n]){
				if(e.d > cap){
					flg[node.n] = true;
					res = Math.min(res, func(e.t, cap, goal, flg) + e.e);
					flg[node.n] = false;
				}else{
					flg[node.n] = true;
					res = Math.min(res, Math.min(func(e.t, cap - e.d, goal, flg), func(e.t, cap, goal, flg) + e.e));
					flg[node.n] = false;
				}
			}
		}
		
		return res;
	}

}
class Node implements Comparable<Node>{
	int n;
	int c;
	LinkedList<Edge> edges;
	Node(int number){
		edges = new LinkedList<Edge>();
		n = number;
		c = 0;
	}
	@Override
	public int compareTo(Node o) {
		// TODO Auto-generated method stub
		return n - o.n;
	}
}
class Edge{
	boolean flg;
	int e;
	int d;
	Node t;
	Edge(int enemy, int dist, Node to){
		e = enemy;
		d = dist;
		t = to;
		flg = false;
	}
}

</source>
<source file="../hum_codes_raw/s623980376.java" startline="1" endline="135" pcid="20945">
import java.util.LinkedList;
import java.util.PriorityQueue;
import java.util.Scanner;

public class Main {
	static final int INF = 1000000000;
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc = new Scanner(System.in);
		Node[] inn = new Node[101];
		int[][] dp = new int[101][101];
		while(true){
			int n = sc.nextInt();
			int m = sc.nextInt();
			int l = sc.nextInt();
			if(n == 0 && m == 0 & l == 0){
				break;
			}
			for(int i = 1; i <= n; i++){
				inn[i] = new Node(i);
			}
			Node start = inn[1];
			Node goal = inn[n];
			for(int i = 0; i < m; i++){
				int a = sc.nextInt();
				int b = sc.nextInt();
				int d = sc.nextInt();
				int e = sc.nextInt();
				
				inn[a].edges.add(new Edge(e, d, inn[b]));
				inn[b].edges.add(new Edge(e, d, inn[a]));
			}
			boolean[] flg = new boolean[n + 1];
			for(int i = 0; i <= n; i++){
				flg[i] = false;
			}
			for(int i = 1; i <= n; i++){
				for(int j = 0; j <= l; j++){
					dp[i][j] = INF;
				}
			}
			PriorityQueue<Node> q = new PriorityQueue<Node>();
			int len = 0;
			dp[1][0] = 0;
			q.add(inn[1]);
			while(!q.isEmpty()){
				Node node = q.poll();
				len = node.c;
				for(Edge e : node.edges){
					// ???????????????????????
					if(len + e.d <= l){ // ???????????????????????
						// ??????????????????????\??????????????????????????????????????
						if(dp[e.t.n][len + e.d] > dp[node.n][len]){
							Node nnode = new Node(e.t.n);
							nnode.edges = e.t.edges;
							nnode.c = len + e.d;
							q.add(nnode);
							dp[e.t.n][len + e.d] = dp[node.n][len] ;
						}
					}
					// ???????????????????????
					// ??????????????????????????\???????????????????????????
					if(dp[e.t.n][len] > dp[node.n][len] + e.e){
						Node nnode = new Node(e.t.n);
						nnode.edges = e.t.edges;
						nnode.c = len;
						q.add(nnode);
						dp[e.t.n][len] = dp[node.n][len] + e.e;
					}
				}
			}
			
			int min = INF;
			for(int i = 0; i <= l; i++){
				min = Math.min(min, dp[n][i]);
			}
			System.out.println(min);
//			System.out.println(func(start, l, goal, flg));
			
		}
		
		
		sc.close();
	}
	static int func(Node node, int cap, Node goal, boolean[] flg){
		int res = 1000000000;
		if(node.equals(goal)){
			return 0;
		}
		for(Edge e : node.edges){
			if(!flg[e.t.n]){
				if(e.d > cap){
					flg[node.n] = true;
					res = Math.min(res, func(e.t, cap, goal, flg) + e.e);
					flg[node.n] = false;
				}else{
					flg[node.n] = true;
					res = Math.min(res, Math.min(func(e.t, cap - e.d, goal, flg), func(e.t, cap, goal, flg) + e.e));
					flg[node.n] = false;
				}
			}
		}
		
		return res;
	}

}
class Node implements Comparable<Node>{
	int n;
	int c;
	LinkedList<Edge> edges;
	Node(int number){
		edges = new LinkedList<Edge>();
		n = number;
		c = 0;
	}
	@Override
	public int compareTo(Node o) {
		// TODO Auto-generated method stub
		return n - o.n;
	}
}
class Edge{
	boolean flg;
	int e;
	int d;
	Node t;
	Edge(int enemy, int dist, Node to){
		e = enemy;
		d = dist;
		t = to;
		flg = false;
	}
}

</source>
</class>

<class classid="171" nclones="2" nlines="35" similarity="100">
<source file="../hum_codes_raw/s309722984.java" startline="1" endline="38" pcid="10426">
import java.util.Scanner;
 
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int[] p = new int[2];
        for (int i = 0; i < 2; i++) {
            int a1, a2, a3;
            p[i] += a1 = in.nextInt();
            p[i] += a2 = in.nextInt();
            p[i] += a3 = in.nextInt();
            for (int j = 4; j <= 10; j++) {
                int aj = in.nextInt();
                if (aj > a1) {
                    p[i] += (aj - a1);
                    int c = a1;
                    a1 = aj;
                    aj = c;
                }
                if (aj > a2) {
                    p[i] += (aj - a2);
                    int c = a2;
                    a2 = aj;
                    aj = c;
                }
                if (aj > a3) {
                    p[i] += (aj - a3);
                    int c = a3;
                    a3 = aj;
                    aj = c;
                }
            }
        }
        System.out.println(new StringBuilder().append(p[0]).append(' ')
                .append(p[1]));
    }
}

</source>
<source file="../hum_codes_raw/s821004732.java" startline="1" endline="38" pcid="27555">
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		int[] p = new int[2];
		for (int i = 0; i < 2; i++) {
			int a1, a2, a3;
			p[i] += a1 = in.nextInt();
			p[i] += a2 = in.nextInt();
			p[i] += a3 = in.nextInt();
			for (int j = 4; j <= 10; j++) {
				int aj = in.nextInt();
				if (aj > a1) {
					p[i] += (aj - a1);
					int c = a1;
					a1 = aj;
					aj = c;
				}
				if (aj > a2) {
					p[i] += (aj - a2);
					int c = a2;
					a2 = aj;
					aj = c;
				}
				if (aj > a3) {
					p[i] += (aj - a3);
					int c = a3;
					a3 = aj;
					aj = c;
				}
			}
		}
		System.out.println(new StringBuilder().append(p[0]).append(' ')
				.append(p[1]));
	}
}

</source>
</class>

<class classid="172" nclones="2" nlines="37" similarity="100">
<source file="../hum_codes_raw/s314955233.java" startline="1" endline="50" pcid="10595">
import java.util.Scanner;

class Main{
    final static int LEN = 105;
    public static void main(String args[]){
	int[][] graph = new int[LEN][LEN];
	int[] minCost = new int[LEN];
	int count=0;
	int v;
	boolean[] used = new boolean[LEN];

	Scanner in = new Scanner(System.in);

	//read
	int n = in.nextInt();
	for(int i=0; i<n; i++){
	    for(int j=0; j<n; j++){
		int k = in.nextInt();
		graph[i][j]=(k==-1? Integer.MAX_VALUE : k);
	    }
	}

	//make prim
	for(int i=0; i<n; i++){
	    minCost[i]=Integer.MAX_VALUE;
	    used[i]=false;
	}

	minCost[0]=0;

	while(true){
	    v = -1;
	    for(int i=0; i<n; i++){
		if(!used[i] && (v==-1 || minCost[i] < minCost[v]))v=i;
	    }

	    if(v==-1)break;
	    used[v]=true;
	    count+=minCost[v];

	    for(int i=0; i<n; i++){
		minCost[i]=Math.min(minCost[i], graph[v][i]);
	    }
	}

	//print
	System.out.println(count);
    }
}

</source>
<source file="../hum_codes_raw/s490587696.java" startline="1" endline="50" pcid="16477">
import java.util.Scanner;

class Main{
    final static int LEN = 105;
    public static void main(String args[]){
	int[][] graph = new int[LEN][LEN];
	int[] minCost = new int[LEN];
	int count=0;
	int v;
	boolean[] used = new boolean[LEN];

	Scanner in = new Scanner(System.in);

	//read
	int n = in.nextInt();
	for(int i=0; i<n; i++){
	    for(int j=0; j<n; j++){
		int k = in.nextInt();
		graph[i][j]=(k==-1? Integer.MAX_VALUE : k);
	    }
	}

	//make prim
	for(int i=0; i<n; i++){
	    minCost[i]=Integer.MAX_VALUE;
	    used[i]=false;
	}

	minCost[0]=0;

	while(true){
	    v = -1;
	    for(int i=0; i<n; i++){
		if(!used[i] && (v==-1 || minCost[i] < minCost[v]))v=i;
	    }

	    if(v==-1)break;
	    used[v]=true;
	    count+=minCost[v];

	    for(int i=0; i<n; i++){
		minCost[i]=Math.min(minCost[i], graph[v][i]);
	    }
	}

	//print
	System.out.println(count);
    }
}

</source>
</class>

<class classid="173" nclones="2" nlines="52" similarity="100">
<source file="../hum_codes_raw/s318955333.java" startline="1" endline="58" pcid="10702">
import java.util.Scanner;

//Lunch
public class Main {

	static int[] ans;
	static String[] name;
	static int n;
	static int[] w;
	static int[] s;
	static int[] order;
	static boolean[] used;
	static double best;
	
	static void dfs(int k, int num, int total){
		if(k==0){
			double g = num*1.0/total;
			if(g<best){
				best = g;
				for(int i=1;i<=n;i++)ans[i-1]=order[i];
			}
			return;
		}
		for(int i=0;i<n;i++){
			if(!used[i]&&total<=s[i]){
				used[i] = true;
				order[k] = i;
				dfs(k-1, num+k*w[i], total+w[i]);
				used[i] = false;
			}
		}
	}
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			n = sc.nextInt();
			if(n==0)break;
			name = new String[n];
			w = new int[n];
			s = new int[n];
			order = new int[n+1];
			best = Integer.MAX_VALUE;
			for(int i=0;i<n;i++){
				name[i] = sc.next();
				w[i] = sc.nextInt();
				s[i] = sc.nextInt();
			}
			used = new boolean[n];
			ans = new int[n];
			dfs(n, 0, 0);
			for(int i=0;i<n;i++){
				System.out.println(name[ans[i]]);
			}
		}
	}
}

</source>
<source file="../hum_codes_raw/s584602577.java" startline="1" endline="58" pcid="19615">
import java.util.Scanner;

//Lunch
public class Main{

	static int[] ans;
	static String[] name;
	static int n;
	static int[] w;
	static int[] s;
	static int[] order;
	static boolean[] used;
	static double best;
	
	static void dfs(int k, int num, int total){
		if(k==0){
			double g = num*1.0/total;
			if(g<best){
				best = g;
				for(int i=1;i<=n;i++)ans[i-1]=order[i];
			}
			return;
		}
		for(int i=0;i<n;i++){
			if(!used[i]&&total<=s[i]){
				used[i] = true;
				order[k] = i;
				dfs(k-1, num+k*w[i], total+w[i]);
				used[i] = false;
			}
		}
	}
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			n = sc.nextInt();
			if(n==0)break;
			name = new String[n];
			w = new int[n];
			s = new int[n];
			order = new int[n+1];
			best = Integer.MAX_VALUE;
			for(int i=0;i<n;i++){
				name[i] = sc.next();
				w[i] = sc.nextInt();
				s[i] = sc.nextInt();
			}
			used = new boolean[n];
			ans = new int[n];
			dfs(n, 0, 0);
			for(int i=0;i<n;i++){
				System.out.println(name[ans[i]]);
			}
		}
	}
}

</source>
</class>

<class classid="174" nclones="3" nlines="185" similarity="100">
<source file="../hum_codes_raw/s322188556.java" startline="1" endline="230" pcid="10799">
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

public class Main {

	static PrintWriter out;
	static InputReader ir;
	static boolean debug = false;
	static int s;

	static void solve() {
		for (;;) {
			int h = ir.nextInt();
			int w = ir.nextInt();
			s = ir.nextInt();
			if (h == 0 && w == 0)
				return;
			int[][] a = new int[h][];
			for (int i = 0; i < h; i++)
				a[i] = ir.nextIntArray(w);
			int[][] sum = getSumArray(a);
			int[][][][][] dp = new int[h + 1][w + 1][h + 1][w + 1][];
			int[] ret = dfs(0, 0, h, w, sum, dp);
			out.println(ret[0] + " " + (s - ret[1]));
		}
	}

	static int[] dfs(int lh, int lw, int rh, int rw, int[][] sum, int[][][][][] dp) {
		if (dp[lh][lw][rh][rw] != null)
			return dp[lh][lw][rh][rw];
		int[] ret = new int[] { -1, -1 };
		int t = sum[sum.length - 1][sum[0].length - 1] - sum(lh, lw, rh, rw, sum);
		if (sum[sum.length - 1][sum[0].length - 1] - sum(lh, lw, rh, rw, sum) <= s) {
			ret[0] = 1;
			ret[1] = t;
		} else
			return dp[lh][lw][rh][rw] = ret;
		for (int i = lh + 1; i < rh; i++) {
			int[] p = dfs(i, lw, rh, rw, sum, dp);
			int[] q = dfs(lh, lw, i, rw, sum, dp);
			if (p[0] > 0 && q[0] > 0 && p[0] + q[0] >= ret[0]) {
				if (p[0] + q[0] > ret[0]) {
					ret[0] = p[0] + q[0];
					ret[1] = Math.max(p[1], q[1]);
				} else if (ret[1] > Math.max(p[1], q[1])) {
					ret[0] = p[0] + q[0];
					ret[1] = Math.max(p[1], q[1]);
				}
			}
		}
		for (int i = lw + 1; i < rw; i++) {
			int[] p = dfs(lh, lw, rh, i, sum, dp);
			int[] q = dfs(lh, i, rh, rw, sum, dp);
			if (p[0] > 0 && q[0] > 0 && p[0] + q[0] >= ret[0]) {
				if (p[0] + q[0] > ret[0]) {
					ret[0] = p[0] + q[0];
					ret[1] = Math.max(p[1], q[1]);
				} else if (ret[1] > Math.max(p[1], q[1])) {
					ret[0] = p[0] + q[0];
					ret[1] = Math.max(p[1], q[1]);
				}
			}
		}
		return dp[lh][lw][rh][rw] = ret;
	}

	static int sum(int a, int b, int c, int d, int[][] s) {
		return s[c][d] - s[c][b] - s[a][d] + s[a][b];
	}

	public static int[][] getSumArray(int[][] a) {
		int h = a.length, w = a[0].length;
		int[][] ret = new int[h + 1][w + 1];
		for (int i = 0; i < h; i++)
			for (int j = 0; j < w; j++)
				ret[i + 1][j + 1] = a[i][j];
		for (int i = 0; i <= h; i++)
			for (int j = 0; j < w; j++)
				ret[i][j + 1] += ret[i][j];
		for (int i = 0; i < h; i++)
			for (int j = 0; j <= w; j++)
				ret[i + 1][j] += ret[i][j];
		return ret;
	}

	public static void main(String[] args) throws Exception {
		ir = new InputReader(System.in);
		out = new PrintWriter(System.out);
		solve();
		out.flush();
	}

	static class InputReader {

		private InputStream in;
		private byte[] buffer = new byte[1024];
		private int curbuf;
		private int lenbuf;

		public InputReader(InputStream in) {
			this.in = in;
			this.curbuf = this.lenbuf = 0;
		}

		public boolean hasNextByte() {
			if (curbuf >= lenbuf) {
				curbuf = 0;
				try {
					lenbuf = in.read(buffer);
				} catch (IOException e) {
					throw new InputMismatchException();
				}
				if (lenbuf <= 0)
					return false;
			}
			return true;
		}

		private int readByte() {
			if (hasNextByte())
				return buffer[curbuf++];
			else
				return -1;
		}

		private boolean isSpaceChar(int c) {
			return !(c >= 33 && c <= 126);
		}

		private void skip() {
			while (hasNextByte() && isSpaceChar(buffer[curbuf]))
				curbuf++;
		}

		public boolean hasNext() {
			skip();
			return hasNextByte();
		}

		public String next() {
			if (!hasNext())
				throw new NoSuchElementException();
			StringBuilder sb = new StringBuilder();
			int b = readByte();
			while (!isSpaceChar(b)) {
				sb.appendCodePoint(b);
				b = readByte();
			}
			return sb.toString();
		}

		public int nextInt() {
			if (!hasNext())
				throw new NoSuchElementException();
			int c = readByte();
			while (isSpaceChar(c))
				c = readByte();
			boolean minus = false;
			if (c == '-') {
				minus = true;
				c = readByte();
			}
			int res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res = res * 10 + c - '0';
				c = readByte();
			} while (!isSpaceChar(c));
			return (minus) ? -res : res;
		}

		public long nextLong() {
			if (!hasNext())
				throw new NoSuchElementException();
			int c = readByte();
			while (isSpaceChar(c))
				c = readByte();
			boolean minus = false;
			if (c == '-') {
				minus = true;
				c = readByte();
			}
			long res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res = res * 10 + c - '0';
				c = readByte();
			} while (!isSpaceChar(c));
			return (minus) ? -res : res;
		}

		public double nextDouble() {
			return Double.parseDouble(next());
		}

		public int[] nextIntArray(int n) {
			int[] a = new int[n];
			for (int i = 0; i < n; i++)
				a[i] = nextInt();
			return a;
		}

		public long[] nextLongArray(int n) {
			long[] a = new long[n];
			for (int i = 0; i < n; i++)
				a[i] = nextLong();
			return a;
		}

		public char[][] nextCharMap(int n, int m) {
			char[][] map = new char[n][m];
			for (int i = 0; i < n; i++)
				map[i] = next().toCharArray();
			return map;
		}
	}

	static void tr(Object... o) {
		if (debug)
			out.println(Arrays.deepToString(o));
	}
}


</source>
<source file="../hum_codes_raw/s365157941.java" startline="1" endline="230" pcid="12263">
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

public class Main {

	static PrintWriter out;
	static InputReader ir;
	static boolean debug = false;
	static int s;

	static void solve() {
		for (;;) {
			int h = ir.nextInt();
			int w = ir.nextInt();
			s = ir.nextInt();
			if (h == 0 && w == 0)
				return;
			int[][] a = new int[h][];
			for (int i = 0; i < h; i++)
				a[i] = ir.nextIntArray(w);
			int[][] sum = getSumArray(a);
			int[][][][][] dp = new int[h + 1][w + 1][h + 1][w + 1][];
			int[] ret = dfs(0, 0, h, w, sum, dp);
			out.println(ret[0] + " " + (s - ret[1]));
		}
	}

	static int[] dfs(int lh, int lw, int rh, int rw, int[][] sum, int[][][][][] dp) {
		if (dp[lh][lw][rh][rw] != null)
			return dp[lh][lw][rh][rw];
		int[] ret = new int[] { -1, -1 };
		int t = sum[sum.length - 1][sum[0].length - 1] - sum(lh, lw, rh, rw, sum);
		if (sum[sum.length - 1][sum[0].length - 1] - sum(lh, lw, rh, rw, sum) <= s) {
			ret[0] = 1;
			ret[1] = t;
		} else
			return dp[lh][lw][rh][rw] = ret;
		for (int i = lh + 1; i < rh; i++) {
			int[] p = dfs(i, lw, rh, rw, sum, dp);
			int[] q = dfs(lh, lw, i, rw, sum, dp);
			if (p[0] > 0 && q[0] > 0 && p[0] + q[0] >= ret[0]) {
				if (p[0] + q[0] > ret[0]) {
					ret[0] = p[0] + q[0];
					ret[1] = Math.max(p[1], q[1]);
				} else if (ret[1] > Math.max(p[1], q[1])) {
					ret[0] = p[0] + q[0];
					ret[1] = Math.max(p[1], q[1]);
				}
			}
		}
		for (int i = lw + 1; i < rw; i++) {
			int[] p = dfs(lh, lw, rh, i, sum, dp);
			int[] q = dfs(lh, i, rh, rw, sum, dp);
			if (p[0] > 0 && q[0] > 0 && p[0] + q[0] >= ret[0]) {
				if (p[0] + q[0] > ret[0]) {
					ret[0] = p[0] + q[0];
					ret[1] = Math.max(p[1], q[1]);
				} else if (ret[1] > Math.max(p[1], q[1])) {
					ret[0] = p[0] + q[0];
					ret[1] = Math.max(p[1], q[1]);
				}
			}
		}
		return dp[lh][lw][rh][rw] = ret;
	}

	static int sum(int a, int b, int c, int d, int[][] s) {
		return s[c][d] - s[c][b] - s[a][d] + s[a][b];
	}

	public static int[][] getSumArray(int[][] a) {
		int h = a.length, w = a[0].length;
		int[][] ret = new int[h + 1][w + 1];
		for (int i = 0; i < h; i++)
			for (int j = 0; j < w; j++)
				ret[i + 1][j + 1] = a[i][j];
		for (int i = 0; i <= h; i++)
			for (int j = 0; j < w; j++)
				ret[i][j + 1] += ret[i][j];
		for (int i = 0; i < h; i++)
			for (int j = 0; j <= w; j++)
				ret[i + 1][j] += ret[i][j];
		return ret;
	}

	public static void main(String[] args) throws Exception {
		ir = new InputReader(System.in);
		out = new PrintWriter(System.out);
		solve();
		out.flush();
	}

	static class InputReader {

		private InputStream in;
		private byte[] buffer = new byte[1024];
		private int curbuf;
		private int lenbuf;

		public InputReader(InputStream in) {
			this.in = in;
			this.curbuf = this.lenbuf = 0;
		}

		public boolean hasNextByte() {
			if (curbuf >= lenbuf) {
				curbuf = 0;
				try {
					lenbuf = in.read(buffer);
				} catch (IOException e) {
					throw new InputMismatchException();
				}
				if (lenbuf <= 0)
					return false;
			}
			return true;
		}

		private int readByte() {
			if (hasNextByte())
				return buffer[curbuf++];
			else
				return -1;
		}

		private boolean isSpaceChar(int c) {
			return !(c >= 33 && c <= 126);
		}

		private void skip() {
			while (hasNextByte() && isSpaceChar(buffer[curbuf]))
				curbuf++;
		}

		public boolean hasNext() {
			skip();
			return hasNextByte();
		}

		public String next() {
			if (!hasNext())
				throw new NoSuchElementException();
			StringBuilder sb = new StringBuilder();
			int b = readByte();
			while (!isSpaceChar(b)) {
				sb.appendCodePoint(b);
				b = readByte();
			}
			return sb.toString();
		}

		public int nextInt() {
			if (!hasNext())
				throw new NoSuchElementException();
			int c = readByte();
			while (isSpaceChar(c))
				c = readByte();
			boolean minus = false;
			if (c == '-') {
				minus = true;
				c = readByte();
			}
			int res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res = res * 10 + c - '0';
				c = readByte();
			} while (!isSpaceChar(c));
			return (minus) ? -res : res;
		}

		public long nextLong() {
			if (!hasNext())
				throw new NoSuchElementException();
			int c = readByte();
			while (isSpaceChar(c))
				c = readByte();
			boolean minus = false;
			if (c == '-') {
				minus = true;
				c = readByte();
			}
			long res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res = res * 10 + c - '0';
				c = readByte();
			} while (!isSpaceChar(c));
			return (minus) ? -res : res;
		}

		public double nextDouble() {
			return Double.parseDouble(next());
		}

		public int[] nextIntArray(int n) {
			int[] a = new int[n];
			for (int i = 0; i < n; i++)
				a[i] = nextInt();
			return a;
		}

		public long[] nextLongArray(int n) {
			long[] a = new long[n];
			for (int i = 0; i < n; i++)
				a[i] = nextLong();
			return a;
		}

		public char[][] nextCharMap(int n, int m) {
			char[][] map = new char[n][m];
			for (int i = 0; i < n; i++)
				map[i] = next().toCharArray();
			return map;
		}
	}

	static void tr(Object... o) {
		if (debug)
			out.println(Arrays.deepToString(o));
	}
}


</source>
<source file="../hum_codes_raw/s888621240.java" startline="1" endline="230" pcid="29881">
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

public class Main {

	static PrintWriter out;
	static InputReader ir;
	static boolean debug = false;
	static int s;

	static void solve() {
		for (;;) {
			int h = ir.nextInt();
			int w = ir.nextInt();
			s = ir.nextInt();
			if (h == 0 && w == 0)
				return;
			int[][] a = new int[h][];
			for (int i = 0; i < h; i++)
				a[i] = ir.nextIntArray(w);
			int[][] sum = getSumArray(a);
			int[][][][][] dp = new int[h + 1][w + 1][h + 1][w + 1][];
			int[] ret = dfs(0, 0, h, w, sum, dp);
			out.println(ret[0] + " " + (s - ret[1]));
		}
	}

	static int[] dfs(int lh, int lw, int rh, int rw, int[][] sum, int[][][][][] dp) {
		if (dp[lh][lw][rh][rw] != null)
			return dp[lh][lw][rh][rw];
		int[] ret = new int[] { -1, -1 };
		int t = sum[sum.length - 1][sum[0].length - 1] - sum(lh, lw, rh, rw, sum);
		if (sum[sum.length - 1][sum[0].length - 1] - sum(lh, lw, rh, rw, sum) <= s) {
			ret[0] = 1;
			ret[1] = t;
		} else
			return dp[lh][lw][rh][rw] = ret;
		for (int i = lh + 1; i < rh; i++) {
			int[] p = dfs(i, lw, rh, rw, sum, dp);
			int[] q = dfs(lh, lw, i, rw, sum, dp);
			if (p[0] > 0 && q[0] > 0 && p[0] + q[0] >= ret[0]) {
				if (p[0] + q[0] > ret[0]) {
					ret[0] = p[0] + q[0];
					ret[1] = Math.max(p[1], q[1]);
				} else if (ret[1] > Math.max(p[1], q[1])) {
					ret[0] = p[0] + q[0];
					ret[1] = Math.max(p[1], q[1]);
				}
			}
		}
		for (int i = lw + 1; i < rw; i++) {
			int[] p = dfs(lh, lw, rh, i, sum, dp);
			int[] q = dfs(lh, i, rh, rw, sum, dp);
			if (p[0] > 0 && q[0] > 0 && p[0] + q[0] >= ret[0]) {
				if (p[0] + q[0] > ret[0]) {
					ret[0] = p[0] + q[0];
					ret[1] = Math.max(p[1], q[1]);
				} else if (ret[1] > Math.max(p[1], q[1])) {
					ret[0] = p[0] + q[0];
					ret[1] = Math.max(p[1], q[1]);
				}
			}
		}
		return dp[lh][lw][rh][rw] = ret;
	}

	static int sum(int a, int b, int c, int d, int[][] s) {
		return s[c][d] - s[c][b] - s[a][d] + s[a][b];
	}

	public static int[][] getSumArray(int[][] a) {
		int h = a.length, w = a[0].length;
		int[][] ret = new int[h + 1][w + 1];
		for (int i = 0; i < h; i++)
			for (int j = 0; j < w; j++)
				ret[i + 1][j + 1] = a[i][j];
		for (int i = 0; i <= h; i++)
			for (int j = 0; j < w; j++)
				ret[i][j + 1] += ret[i][j];
		for (int i = 0; i < h; i++)
			for (int j = 0; j <= w; j++)
				ret[i + 1][j] += ret[i][j];
		return ret;
	}

	public static void main(String[] args) throws Exception {
		ir = new InputReader(System.in);
		out = new PrintWriter(System.out);
		solve();
		out.flush();
	}

	static class InputReader {

		private InputStream in;
		private byte[] buffer = new byte[1024];
		private int curbuf;
		private int lenbuf;

		public InputReader(InputStream in) {
			this.in = in;
			this.curbuf = this.lenbuf = 0;
		}

		public boolean hasNextByte() {
			if (curbuf >= lenbuf) {
				curbuf = 0;
				try {
					lenbuf = in.read(buffer);
				} catch (IOException e) {
					throw new InputMismatchException();
				}
				if (lenbuf <= 0)
					return false;
			}
			return true;
		}

		private int readByte() {
			if (hasNextByte())
				return buffer[curbuf++];
			else
				return -1;
		}

		private boolean isSpaceChar(int c) {
			return !(c >= 33 && c <= 126);
		}

		private void skip() {
			while (hasNextByte() && isSpaceChar(buffer[curbuf]))
				curbuf++;
		}

		public boolean hasNext() {
			skip();
			return hasNextByte();
		}

		public String next() {
			if (!hasNext())
				throw new NoSuchElementException();
			StringBuilder sb = new StringBuilder();
			int b = readByte();
			while (!isSpaceChar(b)) {
				sb.appendCodePoint(b);
				b = readByte();
			}
			return sb.toString();
		}

		public int nextInt() {
			if (!hasNext())
				throw new NoSuchElementException();
			int c = readByte();
			while (isSpaceChar(c))
				c = readByte();
			boolean minus = false;
			if (c == '-') {
				minus = true;
				c = readByte();
			}
			int res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res = res * 10 + c - '0';
				c = readByte();
			} while (!isSpaceChar(c));
			return (minus) ? -res : res;
		}

		public long nextLong() {
			if (!hasNext())
				throw new NoSuchElementException();
			int c = readByte();
			while (isSpaceChar(c))
				c = readByte();
			boolean minus = false;
			if (c == '-') {
				minus = true;
				c = readByte();
			}
			long res = 0;
			do {
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res = res * 10 + c - '0';
				c = readByte();
			} while (!isSpaceChar(c));
			return (minus) ? -res : res;
		}

		public double nextDouble() {
			return Double.parseDouble(next());
		}

		public int[] nextIntArray(int n) {
			int[] a = new int[n];
			for (int i = 0; i < n; i++)
				a[i] = nextInt();
			return a;
		}

		public long[] nextLongArray(int n) {
			long[] a = new long[n];
			for (int i = 0; i < n; i++)
				a[i] = nextLong();
			return a;
		}

		public char[][] nextCharMap(int n, int m) {
			char[][] map = new char[n][m];
			for (int i = 0; i < n; i++)
				map[i] = next().toCharArray();
			return map;
		}
	}

	static void tr(Object... o) {
		if (debug)
			out.println(Arrays.deepToString(o));
	}
}


</source>
</class>

<class classid="175" nclones="2" nlines="46" similarity="100">
<source file="../hum_codes_raw/s323090943.java" startline="1" endline="58" pcid="10837">

import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int   n = sc.nextInt();
        
        // 
        int[] h = new int[n+1];
        
        h[0] = Integer.MIN_VALUE;
        for (int i = 1; i <= n; i++) {
            h[i] = sc.nextInt();
        }
        
        // 
        for (int i = n/2; i >= 1; i--) {
            maxHeapify(h, i);
        }
        for (int i = 1; i <= n; i++) {
            System.out.print(" " + h[i]);
        }
        System.out.println();
    }
    
    static void maxHeapify(int[] h, int idx) {
        int n = h.length - 1;
        int l = l(idx);
        int r = r(idx);
        // 
        int maxNodeIdx = 0;
        if (l <= n && h[l] > h[idx]) {
            maxNodeIdx = l;
        } else {
            maxNodeIdx = idx;
        }
        if (r <= n && h[r] > h[maxNodeIdx]) {
            maxNodeIdx = r;
        }
        // 
        if (maxNodeIdx != idx) {
            int temp = h[idx];
            h[idx]        = h[maxNodeIdx];
            h[maxNodeIdx] = temp;
            maxHeapify(h, maxNodeIdx);
        }
    }
    
    static int l(int i) {
        return 2*i;
    }
    static int r(int i) {
        return 2*i + 1;
    }
}


</source>
<source file="../hum_codes_raw/s973271954.java" startline="1" endline="52" pcid="32754">
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int   n = sc.nextInt();
        
        int[] h = new int[n+1];
        
        h[0] = Integer.MIN_VALUE;
        for (int i = 1; i <= n; i++) {
            h[i] = sc.nextInt();
        }
        
        for (int i = n/2; i >= 1; i--) {
            maxHeapify(h, i);
        }
        for (int i = 1; i <= n; i++) {
            System.out.print(" " + h[i]);
        }
        System.out.println();
    }
    
    static void maxHeapify(int[] h, int idx) {
        int n = h.length - 1;
        int l = l(idx);
        int r = r(idx);
        int maxNodeIdx = 0;
        if (l <= n && h[l] > h[idx]) {
            maxNodeIdx = l;
        } else {
            maxNodeIdx = idx;
        }
        if (r <= n && h[r] > h[maxNodeIdx]) {
            maxNodeIdx = r;
        }
        if (maxNodeIdx != idx) {
            int temp = h[idx];
            h[idx]        = h[maxNodeIdx];
            h[maxNodeIdx] = temp;
            maxHeapify(h, maxNodeIdx);
        }
    }
    
    static int l(int i) {
        return 2*i;
    }
    static int r(int i) {
        return 2*i + 1;
    }
}

</source>
</class>

<class classid="176" nclones="2" nlines="42" similarity="100">
<source file="../hum_codes_raw/s325955835.java" startline="1" endline="40" pcid="10919">

import java.util.*;
public class Main {
    static Scanner sc = new Scanner(System.in);//XLip
    static double time_of_500m, time_of_1000m;//^Ci[
    public static void main(String[] args) {
        while(sc.hasNextDouble()){//ss
            read();//
            slove();//
        }
    }
    static boolean read(){
        time_of_500m = sc.nextDouble();//
        time_of_1000m = sc.nextDouble();//
        return true;
    }
    static void slove(){
        //System.out.println(time_of_500m);fobOpC
        //System.out.println(time_of_1000m);fobOpC
        //ifB
        if(time_of_500m < 35.5 && time_of_1000m < 71.0){
            System.out.println("AAA");
        }else if(time_of_500m < 37.5 && time_of_1000m < 77.0){
            System.out.println("AA");
        }else if(time_of_500m < 40.0 && time_of_1000m < 83.0){
            System.out.println("A");
        }else if(time_of_500m < 43.0 && time_of_1000m < 89.0){
            System.out.println("B");
        }else if(time_of_500m < 50.0 && time_of_1000m < 105.0){
            System.out.println("C");
        }else if(time_of_500m < 55.0 && time_of_1000m < 116.0){
            System.out.println("D");
        }else if(time_of_500m < 70.0 && time_of_1000m < 148.0){
            System.out.println("E");
        }else{
            System.out.println("NA");
        }
    }
}

</source>
<source file="../hum_codes_raw/s666083294.java" startline="1" endline="40" pcid="22366">
import java.util.*;
public class Main {
	static Scanner sc = new Scanner(System.in);//XLip
	static double time_of_500m, time_of_1000m;//^Ci[
	public static void main(String[] args) {
		while(sc.hasNextDouble()){//ss
			read();//
			slove();//
		}
		
	}
	static boolean read(){
		time_of_500m = sc.nextDouble();//
		time_of_1000m = sc.nextDouble();//
		return true;
	}
	static void slove(){
		//System.out.println(time_of_500m);fobOpC
		//System.out.println(time_of_1000m);fobOpC
		//ifB
		if(time_of_500m < 35.5 && time_of_1000m < 71.0){
			System.out.println("AAA");
		}else if(time_of_500m < 37.5 && time_of_1000m < 77.0){
			System.out.println("AA");
		}else if(time_of_500m < 40.0 && time_of_1000m < 83.0){
			System.out.println("A");
		}else if(time_of_500m < 43.0 && time_of_1000m < 89.0){
			System.out.println("B");
		}else if(time_of_500m < 50.0 && time_of_1000m < 105.0){
			System.out.println("C");
		}else if(time_of_500m < 55.0 && time_of_1000m < 116.0){
			System.out.println("D");
		}else if(time_of_500m < 70.0 && time_of_1000m < 148.0){
			System.out.println("E");
		}else{
			System.out.println("NA");
		}
	}
}

</source>
</class>

<class classid="177" nclones="2" nlines="40" similarity="100">
<source file="../hum_codes_raw/s330022854.java" startline="1" endline="46" pcid="11042">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.MathContext;
import java.text.BreakIterator;
import java.util.Arrays;
import java.util.StringTokenizer;

public class Main{

	static int n, m;
	static char[][] a;
	static boolean[][] ok;
	static int[] dx = new int[] { -1, 0, 1, 0, -1, -1, 1, 1 };
	static int[] dy = new int[] { 0, 1, 0, -1, -1, 1, -1, 1 };
	static int A, B, C;

	public static void main(String[] args) throws IOException {

		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		PrintWriter pw = new PrintWriter(System.out);
		StringTokenizer st = new StringTokenizer(br.readLine());
		int n = Integer.parseInt(st.nextToken());
		int m = Integer.parseInt(st.nextToken());
		if (n % 2 == 1) {
			for (int i = 1; i <= m; i++) {
				pw.println(i + " " + (n - i + 1));
			}
		} else {
			int odd = (m + 1) / 2;
			for (int i = 1; i <= odd ; i++) {
				pw.println(i + " " + (n - i + 1));
			}
			for (int i = odd+1; i <= m; i++) {
				pw.println(i + " " + (n - i));
			}
		}

		pw.flush();
	}

}

</source>
<source file="../hum_codes_raw/s769338576.java" startline="1" endline="46" pcid="25831">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.MathContext;
import java.text.BreakIterator;
import java.util.Arrays;
import java.util.StringTokenizer;

public class Main {

	static int n, m;
	static char[][] a;
	static boolean[][] ok;
	static int[] dx = new int[] { -1, 0, 1, 0, -1, -1, 1, 1 };
	static int[] dy = new int[] { 0, 1, 0, -1, -1, 1, -1, 1 };
	static int A, B, C;

	public static void main(String[] args) throws IOException {

		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		PrintWriter pw = new PrintWriter(System.out);
		StringTokenizer st = new StringTokenizer(br.readLine());
		int n = Integer.parseInt(st.nextToken());
		int m = Integer.parseInt(st.nextToken());
		if (n % 2 == 1) {
			for (int i = 1; i <= m; i++) {
				pw.println(i + " " + (n - i + 1));
			}
		} else {
			int odd = (m + 1) / 2;
			for (int i = 1; i <= odd ; i++) {
				pw.println(i + " " + (n - i + 1));
			}
			for (int i = odd+1; i <= m; i++) {
				pw.println(i + " " + (n - i));
			}
		}

		pw.flush();
	}

}

</source>
</class>

<class classid="178" nclones="2" nlines="417" similarity="100">
<source file="../hum_codes_raw/s330468875.java" startline="1" endline="484" pcid="11063">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Deque;
import java.util.ArrayList;
import java.math.BigDecimal;
import java.util.Map;
import java.io.OutputStreamWriter;
import java.io.OutputStream;
import java.io.PrintStream;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.util.List;
import java.io.Closeable;
import java.io.Writer;
import java.util.Comparator;
import java.util.ArrayDeque;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            CHoles solver = new CHoles();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class CHoles {
        Debug debug = new Debug(false);

        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            Point2D[] pts = new Point2D[n];
            for (int i = 0; i < n; i++) {
                pts[i] = new Point2D(in.readInt(), in.readInt());
            }

            if (n == 2) {
                for (int i = 0; i < 2; i++) {
                    out.println(0.5);
                }
                return;
            }

            PointPolygon pointPolygon = new PointPolygon(Arrays.asList(pts));
            PointConvexHull ch = PointConvexHull.grahamScan(pointPolygon);
            List<Point2D> outside = ch.getData();
            Map<Point2D, Double> prob = new HashMap<>(n);
            KahanSummation sum = new KahanSummation();
            if (outside.size() == 2) {
                for (Point2D pt : outside) {
                    prob.put(pt, 0.5);
                }
                sum.add(1);
            } else {
                for (int i = 0; i < outside.size(); i++) {
                    Point2D a = outside.get(i);
                    Point2D b = outside.get(DigitUtils.mod(i - 1, outside.size()));
                    Point2D c = outside.get(DigitUtils.mod(i + 1, outside.size()));
                    double ab = a.distanceBetween(b);
                    double ac = a.distanceBetween(c);
                    double bc = b.distanceBetween(c);
                    double ans = Math.PI - GeometryUtils.triangleAngle(bc, ab, ac);
                    prob.put(a, ans);
                    sum.add(ans);
                }
            }

            debug.debug("sum", sum);
            for (Point2D pt : pts) {
                double ans = prob.getOrDefault(pt, 0D);
                ans /= sum.sum();
                out.println(ans);
            }
        }

    }

    static class DigitUtils {
        private DigitUtils() {
        }

        public static int mod(int x, int mod) {
            x %= mod;
            if (x < 0) {
                x += mod;
            }
            return x;
        }

    }

    static class Point2D {
        public final double x;
        public final double y;

        public Point2D(double x, double y) {
            this.x = x;//GeometryUtils.valueOf(x);
            this.y = y;//GeometryUtils.valueOf(y);
        }

        public double distance2Between(Point2D another) {
            double dx = x - another.x;
            double dy = y - another.y;
            return dx * dx + dy * dy;
        }

        public double distanceBetween(Point2D another) {
            return Math.sqrt(distance2Between(another));
        }

        public double cross(Point2D a, Point2D b) {
            return GeometryUtils.cross(a.x - x, a.y - y, b.x - x, b.y - y);
        }

        public String toString() {
            return String.format("(%f, %f)", x, y);
        }

        public int hashCode() {
            return (int) (Double.doubleToLongBits(x) * 31 + Double.doubleToLongBits(y));
        }

        public boolean equals(Object obj) {
            Point2D other = (Point2D) obj;
            return x == other.x && y == other.y;
        }

    }

    static class PointConvexHull extends PointPolygon {
        PointConvexHull(List<Point2D> points) {
            super(points);
        }

        public static PointConvexHull grahamScan(PointPolygon pointPolygon) {
            final Point2D[] points = pointPolygon.data.toArray(new Point2D[0]);
            int n = points.length;
            for (int i = 1; i < n; i++) {
                int cmp = points[i].y != points[0].y ? Double.compare(points[i].y, points[0].y)
                        : Double.compare(points[i].x, points[0].x);
                if (cmp >= 0) {
                    continue;
                }
                Point2D tmp = points[0];
                points[0] = points[i];
                points[i] = tmp;
            }


            Comparator<Point2D> cmp = new Comparator<Point2D>() {

                public int compare(Point2D o1, Point2D o2) {
                    return GeometryUtils.signOf(GeometryUtils.valueOf(-points[0].cross(o1, o2)));
                }
            };
            Arrays.sort(points, 1, n, cmp);

            int shrinkSize = 2;
            for (int i = 2; i < n; i++) {
                if (cmp.compare(points[i], points[shrinkSize - 1]) == 0) {
                    if (points[i].distance2Between(points[0]) > points[shrinkSize - 1].distance2Between(points[0])) {
                        points[shrinkSize - 1] = points[i];
                    }
                } else {
                    points[shrinkSize++] = points[i];
                }
            }

            n = shrinkSize;
            Deque<Point2D> stack = new ArrayDeque(n);
            stack.addLast(points[0]);
            for (int i = 1; i < n; i++) {
                while (stack.size() >= 2) {
                    Point2D last = stack.removeLast();
                    Point2D second = stack.peekLast();
                    if (GeometryUtils.valueOf(second.cross(points[i], last)) < 0) {
                        stack.addLast(last);
                        break;
                    }
                }
                stack.addLast(points[i]);
            }

            return new PointConvexHull(new ArrayList(stack));
        }

    }

    static class Debug {
        private boolean offline;
        private PrintStream out = System.err;
        static int[] empty = new int[0];

        public Debug(boolean enable) {
            offline = enable && System.getSecurityManager() == null;
        }

        public Debug debug(String name, Object x) {
            return debug(name, x, empty);
        }

        public Debug debug(String name, Object x, int... indexes) {
            if (offline) {
                if (x == null || !x.getClass().isArray()) {
                    out.append(name);
                    for (int i : indexes) {
                        out.printf("[%d]", i);
                    }
                    out.append("=").append("" + x);
                    out.println();
                } else {
                    indexes = Arrays.copyOf(indexes, indexes.length + 1);
                    if (x instanceof byte[]) {
                        byte[] arr = (byte[]) x;
                        for (int i = 0; i < arr.length; i++) {
                            indexes[indexes.length - 1] = i;
                            debug(name, arr[i], indexes);
                        }
                    } else if (x instanceof short[]) {
                        short[] arr = (short[]) x;
                        for (int i = 0; i < arr.length; i++) {
                            indexes[indexes.length - 1] = i;
                            debug(name, arr[i], indexes);
                        }
                    } else if (x instanceof boolean[]) {
                        boolean[] arr = (boolean[]) x;
                        for (int i = 0; i < arr.length; i++) {
                            indexes[indexes.length - 1] = i;
                            debug(name, arr[i], indexes);
                        }
                    } else if (x instanceof char[]) {
                        char[] arr = (char[]) x;
                        for (int i = 0; i < arr.length; i++) {
                            indexes[indexes.length - 1] = i;
                            debug(name, arr[i], indexes);
                        }
                    } else if (x instanceof int[]) {
                        int[] arr = (int[]) x;
                        for (int i = 0; i < arr.length; i++) {
                            indexes[indexes.length - 1] = i;
                            debug(name, arr[i], indexes);
                        }
                    } else if (x instanceof float[]) {
                        float[] arr = (float[]) x;
                        for (int i = 0; i < arr.length; i++) {
                            indexes[indexes.length - 1] = i;
                            debug(name, arr[i], indexes);
                        }
                    } else if (x instanceof double[]) {
                        double[] arr = (double[]) x;
                        for (int i = 0; i < arr.length; i++) {
                            indexes[indexes.length - 1] = i;
                            debug(name, arr[i], indexes);
                        }
                    } else if (x instanceof long[]) {
                        long[] arr = (long[]) x;
                        for (int i = 0; i < arr.length; i++) {
                            indexes[indexes.length - 1] = i;
                            debug(name, arr[i], indexes);
                        }
                    } else {
                        Object[] arr = (Object[]) x;
                        for (int i = 0; i < arr.length; i++) {
                            indexes[indexes.length - 1] = i;
                            debug(name, arr[i], indexes);
                        }
                    }
                }
            }
            return this;
        }

    }

    static class PointPolygon extends Polygon<Point2D> {
        public PointPolygon(List<Point2D> points) {
            super(points);
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(double c) {
            cache.append(new BigDecimal(c).toPlainString());
            return this;
        }

        public FastOutput println(double c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class Polygon<T> {
        protected List<T> data;

        protected Polygon(List<T> data) {
            this.data = data;
        }

        public List<T> getData() {
            return data;
        }

    }

    static class GeometryUtils {
        public static final double PREC = 1e-15;

        public static double valueOf(double x) {
            return x > -PREC && x < PREC ? 0 : x;
        }

        public static double triangleAngle(double a, double b, double c) {
            double cosa = (b * b + c * c - a * a) / (2 * b * c);
            return Math.acos(cosa);
        }

        public static double cross(double x1, double y1, double x2, double y2) {
            return valueOf(x1 * y2 - y1 * x2);
        }

        public static int signOf(double x) {
            return x > 0 ? 1 : x < 0 ? -1 : 0;
        }

    }

    static class KahanSummation {
        private double error;
        private double sum;

        public double sum() {
            return sum;
        }

        public void add(double x) {
            x = x - error;
            double t = sum + x;
            error = (t - sum) - x;
            sum = t;
        }

        public String toString() {
            return new BigDecimal(sum).toString();
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }
}


</source>
<source file="../hum_codes_raw/s428749243.java" startline="1" endline="484" pcid="14407">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Deque;
import java.util.ArrayList;
import java.math.BigDecimal;
import java.util.Map;
import java.io.OutputStreamWriter;
import java.io.OutputStream;
import java.io.PrintStream;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.util.List;
import java.io.Closeable;
import java.io.Writer;
import java.util.Comparator;
import java.util.ArrayDeque;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            CHoles solver = new CHoles();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class CHoles {
        Debug debug = new Debug(false);

        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            Point2D[] pts = new Point2D[n];
            for (int i = 0; i < n; i++) {
                pts[i] = new Point2D(in.readInt(), in.readInt());
            }

            if (n == 2) {
                for (int i = 0; i < 2; i++) {
                    out.println(0.5);
                }
                return;
            }

            PointPolygon pointPolygon = new PointPolygon(Arrays.asList(pts));
            PointConvexHull ch = PointConvexHull.grahamScan(pointPolygon);
            List<Point2D> outside = ch.getData();
            Map<Point2D, Double> prob = new HashMap<>(n);
            KahanSummation sum = new KahanSummation();
            if (outside.size() == 2) {
                for (Point2D pt : outside) {
                    prob.put(pt, 0.5);
                }
                sum.add(1);
            } else {
                for (int i = 0; i < outside.size(); i++) {
                    Point2D a = outside.get(i);
                    Point2D b = outside.get(DigitUtils.mod(i - 1, outside.size()));
                    Point2D c = outside.get(DigitUtils.mod(i + 1, outside.size()));
                    double ab = a.distanceBetween(b);
                    double ac = a.distanceBetween(c);
                    double bc = b.distanceBetween(c);
                    double ans = Math.PI - GeometryUtils.triangleAngle(bc, ab, ac);
                    prob.put(a, ans);
                    sum.add(ans);
                }
            }

            debug.debug("sum", sum);
            for (Point2D pt : pts) {
                double ans = prob.getOrDefault(pt, 0D);
                ans /= sum.sum();
                out.println(ans);
            }
        }

    }

    static class DigitUtils {
        private DigitUtils() {
        }

        public static int mod(int x, int mod) {
            x %= mod;
            if (x < 0) {
                x += mod;
            }
            return x;
        }

    }

    static class Point2D {
        public final double x;
        public final double y;

        public Point2D(double x, double y) {
            this.x = x;//GeometryUtils.valueOf(x);
            this.y = y;//GeometryUtils.valueOf(y);
        }

        public double distance2Between(Point2D another) {
            double dx = x - another.x;
            double dy = y - another.y;
            return dx * dx + dy * dy;
        }

        public double distanceBetween(Point2D another) {
            return Math.sqrt(distance2Between(another));
        }

        public double cross(Point2D a, Point2D b) {
            return GeometryUtils.cross(a.x - x, a.y - y, b.x - x, b.y - y);
        }

        public String toString() {
            return String.format("(%f, %f)", x, y);
        }

        public int hashCode() {
            return (int) (Double.doubleToLongBits(x) * 31 + Double.doubleToLongBits(y));
        }

        public boolean equals(Object obj) {
            Point2D other = (Point2D) obj;
            return x == other.x && y == other.y;
        }

    }

    static class PointConvexHull extends PointPolygon {
        PointConvexHull(List<Point2D> points) {
            super(points);
        }

        public static PointConvexHull grahamScan(PointPolygon pointPolygon) {
            final Point2D[] points = pointPolygon.data.toArray(new Point2D[0]);
            int n = points.length;
            for (int i = 1; i < n; i++) {
                int cmp = points[i].y != points[0].y ? Double.compare(points[i].y, points[0].y)
                        : Double.compare(points[i].x, points[0].x);
                if (cmp >= 0) {
                    continue;
                }
                Point2D tmp = points[0];
                points[0] = points[i];
                points[i] = tmp;
            }


            Comparator<Point2D> cmp = new Comparator<Point2D>() {

                public int compare(Point2D o1, Point2D o2) {
                    return GeometryUtils.signOf(GeometryUtils.valueOf(-points[0].cross(o1, o2)));
                }
            };
            Arrays.sort(points, 1, n, cmp);

            int shrinkSize = 2;
            for (int i = 2; i < n; i++) {
                if (cmp.compare(points[i], points[shrinkSize - 1]) == 0) {
                    if (points[i].distance2Between(points[0]) > points[shrinkSize - 1].distance2Between(points[0])) {
                        points[shrinkSize - 1] = points[i];
                    }
                } else {
                    points[shrinkSize++] = points[i];
                }
            }

            n = shrinkSize;
            Deque<Point2D> stack = new ArrayDeque(n);
            stack.addLast(points[0]);
            for (int i = 1; i < n; i++) {
                while (stack.size() >= 2) {
                    Point2D last = stack.removeLast();
                    Point2D second = stack.peekLast();
                    if (GeometryUtils.valueOf(second.cross(points[i], last)) < 0) {
                        stack.addLast(last);
                        break;
                    }
                }
                stack.addLast(points[i]);
            }

            return new PointConvexHull(new ArrayList(stack));
        }

    }

    static class Debug {
        private boolean offline;
        private PrintStream out = System.err;
        static int[] empty = new int[0];

        public Debug(boolean enable) {
            offline = enable && System.getSecurityManager() == null;
        }

        public Debug debug(String name, Object x) {
            return debug(name, x, empty);
        }

        public Debug debug(String name, Object x, int... indexes) {
            if (offline) {
                if (x == null || !x.getClass().isArray()) {
                    out.append(name);
                    for (int i : indexes) {
                        out.printf("[%d]", i);
                    }
                    out.append("=").append("" + x);
                    out.println();
                } else {
                    indexes = Arrays.copyOf(indexes, indexes.length + 1);
                    if (x instanceof byte[]) {
                        byte[] arr = (byte[]) x;
                        for (int i = 0; i < arr.length; i++) {
                            indexes[indexes.length - 1] = i;
                            debug(name, arr[i], indexes);
                        }
                    } else if (x instanceof short[]) {
                        short[] arr = (short[]) x;
                        for (int i = 0; i < arr.length; i++) {
                            indexes[indexes.length - 1] = i;
                            debug(name, arr[i], indexes);
                        }
                    } else if (x instanceof boolean[]) {
                        boolean[] arr = (boolean[]) x;
                        for (int i = 0; i < arr.length; i++) {
                            indexes[indexes.length - 1] = i;
                            debug(name, arr[i], indexes);
                        }
                    } else if (x instanceof char[]) {
                        char[] arr = (char[]) x;
                        for (int i = 0; i < arr.length; i++) {
                            indexes[indexes.length - 1] = i;
                            debug(name, arr[i], indexes);
                        }
                    } else if (x instanceof int[]) {
                        int[] arr = (int[]) x;
                        for (int i = 0; i < arr.length; i++) {
                            indexes[indexes.length - 1] = i;
                            debug(name, arr[i], indexes);
                        }
                    } else if (x instanceof float[]) {
                        float[] arr = (float[]) x;
                        for (int i = 0; i < arr.length; i++) {
                            indexes[indexes.length - 1] = i;
                            debug(name, arr[i], indexes);
                        }
                    } else if (x instanceof double[]) {
                        double[] arr = (double[]) x;
                        for (int i = 0; i < arr.length; i++) {
                            indexes[indexes.length - 1] = i;
                            debug(name, arr[i], indexes);
                        }
                    } else if (x instanceof long[]) {
                        long[] arr = (long[]) x;
                        for (int i = 0; i < arr.length; i++) {
                            indexes[indexes.length - 1] = i;
                            debug(name, arr[i], indexes);
                        }
                    } else {
                        Object[] arr = (Object[]) x;
                        for (int i = 0; i < arr.length; i++) {
                            indexes[indexes.length - 1] = i;
                            debug(name, arr[i], indexes);
                        }
                    }
                }
            }
            return this;
        }

    }

    static class PointPolygon extends Polygon<Point2D> {
        public PointPolygon(List<Point2D> points) {
            super(points);
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(double c) {
            cache.append(new BigDecimal(c).toPlainString());
            return this;
        }

        public FastOutput println(double c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class Polygon<T> {
        protected List<T> data;

        protected Polygon(List<T> data) {
            this.data = data;
        }

        public List<T> getData() {
            return data;
        }

    }

    static class GeometryUtils {
        public static final double PREC = 1e-15;

        public static double valueOf(double x) {
            return x > -PREC && x < PREC ? 0 : x;
        }

        public static double triangleAngle(double a, double b, double c) {
            double cosa = (b * b + c * c - a * a) / (2 * b * c);
            return Math.acos(cosa);
        }

        public static double cross(double x1, double y1, double x2, double y2) {
            return valueOf(x1 * y2 - y1 * x2);
        }

        public static int signOf(double x) {
            return x > 0 ? 1 : x < 0 ? -1 : 0;
        }

    }

    static class KahanSummation {
        private double error;
        private double sum;

        public double sum() {
            return sum;
        }

        public void add(double x) {
            x = x - error;
            double t = sum + x;
            error = (t - sum) - x;
            sum = t;
        }

        public String toString() {
            return new BigDecimal(sum).toString();
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }
}


</source>
</class>

<class classid="179" nclones="2" nlines="37" similarity="100">
<source file="../hum_codes_raw/s336149885.java" startline="1" endline="41" pcid="11275">
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		char[][] board = new char[n + 1][];
		for(int i = 0; i < n + 1; i++) {
			board[i] = sc.next().toCharArray();
		}
		int sum = 0; //print
		for(int i = 1; i <= n; i++) {//?????????????????????????????
			out: for(int j = 0; j < board[i].length; j++) {//1???????????????
				if(board[i][j] == board[0][0]) {
					for(int k = j + 1; k < board[i].length; k++) {//2???????????????
						if(board[i][k] == board[0][1]) {
							int interval = k - j;//1???????????2??????????????????
							int cnt = 2;//?????????????????????????????????
							for(int m = k + interval; m < board[i].length; m = m + interval) {//3???????????\?????????
								if(board[i][m] == board[0][cnt]) {
									cnt = cnt + 1;
									if(cnt == board[0].length) {
										sum = sum + 1;
										break out;
									}
								} else {
									break;
								}
							}
						}
					}
				}
			}
		}
		System.out.println(sum);
	}

}

</source>
<source file="../hum_codes_raw/s770812123.java" startline="1" endline="41" pcid="25876">
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		char[][] board = new char[n + 1][];
		for(int i = 0; i < n + 1; i++) {
			board[i] = sc.next().toCharArray();
		}
		int sum = 0; //print
		for(int i = 1; i <= n; i++) {//?????????????????????????????
			out: for(int j = 0; j < board[i].length; j++) {//1???????????????
				if(board[i][j] == board[0][0]) {
					for(int k = j + 1; k < board[i].length; k++) {//2???????????????
						if(board[i][k] == board[0][1]) {
							int interval = k - j;//1???????????2??????????????????
							int cnt = 2;//?????????????????????????????????
							for(int m = k + interval; m < board[i].length; m = m + interval) {//3???????????\?????????
								if(board[i][m] == board[0][cnt]) {
									cnt = cnt + 1;
									if(cnt == board[0].length) {
										sum = sum + 1;
										break out;
									}
								} else {
									break;
								}
							}
						}
					}
				}
			}
		}
		System.out.println(sum);
	}

}

</source>
</class>

<class classid="180" nclones="2" nlines="193" similarity="100">
<source file="../hum_codes_raw/s343584397.java" startline="1" endline="191" pcid="11528">
import java.io.*;
      
class Main{
static int[] sx={0,0,1,0,-1};
static int[] sy={0,1,0,-1,0};
static int[] mx={0,0,1,0,-1,-1,-1,1,1};
static int[] my={0,1,0,-1,0,-1,1,-1,1};
static int[] lx={0,0,1,0,-1,-1,-1,1,1,0,2,0,-2};
static int[] ly={0,1,0,-1,0,-1,1,-1,1,2,0,-2,0};
static int total;
static int res;
static int[][] map=new int[10][10];
static int[][][] drop=new int[10][10][3];
static void sd(int x,int y){
for(int i=0;i<sx.length;i++){
map[x+sx[i]][y+sy[i]]--;
}
total-=5;
res--;
}
static void sr(int x,int y){
for(int i=0;i<sx.length;i++){
map[x+sx[i]][y+sy[i]]++;
}
total+=5;
res++;
}
static boolean scd(int x,int y){
for(int i=0;i<sx.length;i++){
int nx=x+sx[i];
int ny=y+sy[i];
if(nx<0||ny<0||nx>=10||ny>=10||map[nx][ny]==0){
return false;
}
}
return true;
}
static void md(int x,int y){
for(int i=0;i<mx.length;i++){
map[x+mx[i]][y+my[i]]--;
}
total-=9;
res--;
}
static void mr(int x,int y){
for(int i=0;i<mx.length;i++){
map[x+mx[i]][y+my[i]]++;
}
total+=9;
res++;
}
static boolean mcd(int x,int y){
for(int i=0;i<mx.length;i++){
int nx=x+mx[i];
int ny=y+my[i];
if(nx<0||ny<0||nx>=10||ny>=10||map[nx][ny]==0){
return false;
}
}
return true;
}
static void ld(int x,int y){
for(int i=0;i<lx.length;i++){
map[x+lx[i]][y+ly[i]]--;
}
total-=13;
res--;
}
static void lr(int x,int y){
for(int i=0;i<lx.length;i++){
map[x+lx[i]][y+ly[i]]++;
}
total+=13;
res++;
}
static boolean lcd(int x,int y){
for(int i=0;i<lx.length;i++){
int nx=x+lx[i];
int ny=y+ly[i];
if(nx<0||ny<0||nx>=10||ny>=10||map[nx][ny]==0){
return false;
}
}
return true;
}
public static void main(String[] args) throws IOException{
BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
res=Integer.parseInt(br.readLine());
total=0;
for(int i=0;i<10;i++){
String[] value=br.readLine().split(" ");
for(int j=0;j<10;j++){
int num=Integer.parseInt(value[j]);
map[i][j]=num;
total+=num;
}
}
if(search(1,1,3)){
for(int i=1;i<9;i++){
for(int j=1;j<9;j++){
for(int k=0;k<3;k++){
if(drop[i][j][k]!=0){
for(int l=0;l<drop[i][j][k];l++){
int m=k+1;
System.out.println(j+" "+i+" "+m);
}
}
}
}
}
}
}
static boolean searchnext(int x,int y){
if(y==8){
return search(x+1,1,3);
}
return search(x,y+1,3);
}
static boolean search(int x,int y,int size){
if(res==0&&total==0){
return true;
}
else if(total<res*5||total>res*13){
return false;
}
else if(res==0){
return false;
}
if(x==9){
return false;
}
if(x>2&&y==1){
for(int i=0;i<10;i++){
if(map[x-3][i]!=0){
return false;
}
}
}
while(true){
switch(size){
case 3:if(lcd(x,y)){
       ld(x,y);
       drop[x][y][2]++;
       if(searchnext(x,y)){
       return true;
       }
       else{
       if(scd(x,y)&&search(x,y,3)){
       return true;
       }
       lr(x,y);
       drop[x][y][2]--;
       }
       }
       size--;
case 2:if(mcd(x,y)){
       md(x,y);
       drop[x][y][1]++;
       if(searchnext(x,y)){
       return true;
       }
       else{
       if(scd(x,y)&&search(x,y,2)){
       return true;
       }
       mr(x,y);
       drop[x][y][1]--;
       }
       }
       size--;
case 1:if(scd(x,y)){
       sd(x,y);
       drop[x][y][0]++;
       if(searchnext(x,y)){
       return true;
       }
       else{
       if(scd(x,y)&&search(x,y,1)){
       return true;
       }
       sr(x,y);
       drop[x][y][0]--;
       }
       }
       size--;
case 0:return searchnext(x,y);
}
}
}
}

</source>
<source file="../hum_codes_raw/s425716661.java" startline="1" endline="191" pcid="14314">
import java.io.*;
     
class Main{
static int[] sx={0,0,1,0,-1};
static int[] sy={0,1,0,-1,0};
static int[] mx={0,0,1,0,-1,-1,-1,1,1};
static int[] my={0,1,0,-1,0,-1,1,-1,1};
static int[] lx={0,0,1,0,-1,-1,-1,1,1,0,2,0,-2};
static int[] ly={0,1,0,-1,0,-1,1,-1,1,2,0,-2,0};
static int total;
static int res;
static int[][] map=new int[10][10];
static int[][][] drop=new int[10][10][3];
static void sd(int x,int y){
for(int i=0;i<sx.length;i++){
map[x+sx[i]][y+sy[i]]--;
}
total-=5;
res--;
}
static void sr(int x,int y){
for(int i=0;i<sx.length;i++){
map[x+sx[i]][y+sy[i]]++;
}
total+=5;
res++;
}
static boolean scd(int x,int y){
for(int i=0;i<sx.length;i++){
int nx=x+sx[i];
int ny=y+sy[i];
if(nx<0||ny<0||nx>=10||ny>=10||map[nx][ny]==0){
return false;
}
}
return true;
}
static void md(int x,int y){
for(int i=0;i<mx.length;i++){
map[x+mx[i]][y+my[i]]--;
}
total-=9;
res--;
}
static void mr(int x,int y){
for(int i=0;i<mx.length;i++){
map[x+mx[i]][y+my[i]]++;
}
total+=9;
res++;
}
static boolean mcd(int x,int y){
for(int i=0;i<mx.length;i++){
int nx=x+mx[i];
int ny=y+my[i];
if(nx<0||ny<0||nx>=10||ny>=10||map[nx][ny]==0){
return false;
}
}
return true;
}
static void ld(int x,int y){
for(int i=0;i<lx.length;i++){
map[x+lx[i]][y+ly[i]]--;
}
total-=13;
res--;
}
static void lr(int x,int y){
for(int i=0;i<lx.length;i++){
map[x+lx[i]][y+ly[i]]++;
}
total+=13;
res++;
}
static boolean lcd(int x,int y){
for(int i=0;i<lx.length;i++){
int nx=x+lx[i];
int ny=y+ly[i];
if(nx<0||ny<0||nx>=10||ny>=10||map[nx][ny]==0){
return false;
}
}
return true;
}
public static void main(String[] args) throws IOException{
BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
res=Integer.parseInt(br.readLine());
total=0;
for(int i=0;i<10;i++){
String[] value=br.readLine().split(" ");
for(int j=0;j<10;j++){
int num=Integer.parseInt(value[j]);
map[i][j]=num;
total+=num;
}
}
if(search(1,1,3)){
for(int i=1;i<9;i++){
for(int j=1;j<9;j++){
for(int k=0;k<3;k++){
if(drop[i][j][k]!=0){
for(int l=0;l<drop[i][j][k];l++){
int m=k+1;
System.out.println(j+" "+i+" "+m);
}
}
}
}
}
}
}
static boolean searchnext(int x,int y){
if(y==8){
return search(x+1,1,3);
}
return search(x,y+1,3);
}
static boolean search(int x,int y,int size){
if(res==0&&total==0){
return true;
}
else if(total<res*5||total>res*13){
return false;
}
else if(res==0){
return false;
}
if(x==9){
return false;
}
if(x>2&&y==1){
for(int i=0;i<10;i++){
if(map[x-3][i]!=0){
return false;
}
}
}
while(true){
switch(size){
case 3:if(lcd(x,y)){
       ld(x,y);
       drop[x][y][2]++;
       if(searchnext(x,y)){
       return true;
       }
       else{
       if(scd(x,y)&&search(x,y,3)){
       return true;
       }
       lr(x,y);
       drop[x][y][2]--;
       }
       }
       size--;
case 2:if(mcd(x,y)){
       md(x,y);
       drop[x][y][1]++;
       if(searchnext(x,y)){
       return true;
       }
       else{
       if(scd(x,y)&&search(x,y,2)){
       return true;
       }
       mr(x,y);
       drop[x][y][1]--;
       }
       }
       size--;
case 1:if(scd(x,y)){
       sd(x,y);
       drop[x][y][0]++;
       if(searchnext(x,y)){
       return true;
       }
       else{
       if(scd(x,y)&&search(x,y,1)){
       return true;
       }
       sr(x,y);
       drop[x][y][0]--;
       }
       }
       size--;
case 0:return searchnext(x,y);
}
}
}
}

</source>
</class>

<class classid="181" nclones="2" nlines="39" similarity="100">
<source file="../hum_codes_raw/s345464736.java" startline="1" endline="42" pcid="11599">
import java.util.Arrays;
import java.util.Scanner;
 
public class Main{
    public static void main(String[] args) {
        try(Scanner sc = new Scanner(System.in)){
            while(true) {
                int n = Integer.parseInt(sc.nextLine());
                if(n==0) break;
                int [] kouho = new int[26];
                int [] sokuhou = new int[26];
                String[] vote = new String[n];
                for(int i=0;i<26;i++) {
                    kouho[i] = 0;
                }
                vote = sc.nextLine().split(" ");
                boolean flag = true;
                loop:for(int i=1;i<=n;i++) {
                    int d = vote[i-1].charAt(0) - 'A';
                    kouho[d] += 1;
                    for(int j=0;j<26;j++) {
                        sokuhou[j] = kouho[j];
                    }
                    Arrays.sort(sokuhou);
                    if(sokuhou[24]+(n-i)<sokuhou[25]) {
                        int k=0;
                        for(k=0;k<26;k++) {
                            if(kouho[k] == sokuhou[25]) break;
                        }
                        System.out.printf("%c %d", k +'A',i);
                        System.out.println();
                        flag = false;
                        break loop;
                    }
                }
                if(flag) System.out.println("TIE");
            }
 
        }   
    }
}

</source>
<source file="../hum_codes_raw/s437483033.java" startline="1" endline="43" pcid="14672">
import java.util.Arrays;
import java.util.Scanner;

public class Main{
	public static void main(String[] args) {
		try(Scanner sc = new Scanner(System.in)){
			while(true) {
				int n = Integer.parseInt(sc.nextLine());
				if(n==0) break;
				int [] kouho = new int[26];
				int [] sokuhou = new int[26];
				String[] vote = new String[n];
				for(int i=0;i<26;i++) {
					kouho[i] = 0;
				}
				vote = sc.nextLine().split(" ");
				boolean flag = true;
				loop:for(int i=1;i<=n;i++) {
					int d = vote[i-1].charAt(0) - 'A';
					kouho[d] += 1;
					for(int j=0;j<26;j++) {
						sokuhou[j] = kouho[j];
					}
					Arrays.sort(sokuhou);
					if(sokuhou[24]+(n-i)<sokuhou[25]) {
						int k=0;
						for(k=0;k<26;k++) {
							if(kouho[k] == sokuhou[25]) break;
						}
						System.out.printf("%c %d", k +'A',i);
						System.out.println();
						flag = false;
						break loop;
					}
				}
				if(flag) System.out.println("TIE");
			}

		}	
	}
}


</source>
</class>

<class classid="182" nclones="2" nlines="88" similarity="100">
<source file="../hum_codes_raw/s346647414.java" startline="1" endline="62" pcid="11634">
import java.util.*;
public class Main{
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();
		int[] A = new int[N];
		for(int i=0; i<N; i++){
			A[i] = sc.nextInt();
		}
		sort(A);
		long answer = 0;
		int l = N/2;
		for(int i=N-1; i>=l; i--){
			answer += A[i]*2;
		}
		for(int i=0; i<l; i++){
			answer -= A[i]*2;
		}
		if(N%2==0){
			answer += A[l-1];
			answer -= A[l];
		}else{
			if(A[l-1]+A[l+1] > A[l]*2){
				answer += A[l-1];
				answer -= A[l]*3;
			}else{
				answer -= A[l]+A[l+1];
			}
		}
		System.out.println(answer);
		System.out.flush();
		return;
	}

	public static void sort(int[] a){
		quickSort(a, 0, a.length-1);
	}

	private static void quickSort(int[] a, int left, int right){
		if(left >= right){return;}
		int pivot = med3(a[left], a[left+(right-left)/2], a[right]);
		int l=left, r=right;
		while(true){
			while (a[l] < pivot){l++;}
			while (pivot < a[r]){r--;}
			if(l>=r){break;}
			int t=a[l]; a[l]=a[r]; a[r]=t;
			l++; r--;
		}
		quickSort(a, left, l-1);
		quickSort(a, r+1, right);
	}

	private static int med3(int x, int y, int z){
	    if(x < y){
	        if (y < z){return y;}else if(z < x){return x;}else{return z;}
	    } else {
	        if (z < y){return y;}else if(x < z){return x;}else{return z;}
	    }
	}
}

</source>
<source file="../hum_codes_raw/s828654204.java" startline="1" endline="62" pcid="27801">
import java.util.*;
public class Main{
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();
		int[] A = new int[N];
		for(int i=0; i<N; i++){
			A[i] = sc.nextInt();
		}
		sort(A);
		long answer = 0;
		int l = N/2;
		for(int i=N-1; i>=l; i--){
			answer += A[i]*2;
		}
		for(int i=0; i<l; i++){
			answer -= A[i]*2;
		}
		if(N%2==0){
			answer += A[l-1];
			answer -= A[l];
		}else{
			if(A[l-1]+A[l+1] > A[l]*2){
				answer += A[l-1];
				answer -= A[l]*3;
			}else{
				answer -= A[l]+A[l+1];
			}
		}
		System.out.println(answer);
		System.out.flush();
		return;
	}

	public static void sort(int[] a){
		quickSort(a, 0, a.length-1);
	}

	private static void quickSort(int[] a, int left, int right){
		if(left >= right){return;}
		int pivot = med3(a[left], a[left+(right-left)/2], a[right]);
		int l=left, r=right;
		while(true){
			while (a[l] < pivot){l++;}
			while (pivot < a[r]){r--;}
			if(l>=r){break;}
			int t=a[l]; a[l]=a[r]; a[r]=t;
			l++; r--;
		}
		quickSort(a, left, l-1);
		quickSort(a, r+1, right);
	}

	private static int med3(int x, int y, int z){
	    if(x < y){
	        if (y < z){return y;}else if(z < x){return x;}else{return z;}
	    } else {
	        if (z < y){return y;}else if(x < z){return x;}else{return z;}
	    }
	}
}

</source>
</class>

<class classid="183" nclones="2" nlines="150" similarity="100">
<source file="../hum_codes_raw/s348638788.java" startline="1" endline="157" pcid="11702">
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

public class Main{

	static PrintWriter out;
	static InputReader ir;

	static void solve(){
		for(;;){
            int n=ir.nextInt();
            if(n==0)
                break;
            char[][] ap=new char[n][];
            String[] cd=new String[n];
            int ma=0;
            for(int i=0;i<n;i++){
            	ap[i]=ir.next().toCharArray();
            	cd[i]=Character.toString(ap[i][0]);
            	for(int j=0;j<ap[i].length-1;j++){
            		if(ap[i][j]=='a'||ap[i][j]=='i'||ap[i][j]=='u'||ap[i][j]=='e'||ap[i][j]=='o'){
            			cd[i]+=Character.toString(ap[i][j+1]);
            		}
            	}
            	ma=Math.max(ma,cd[i].length());
            }
            outer:
            for(int i=0;i<ma;i++){
            	for(int j=0;j<n;j++){
            		for(int k=j+1;k<n;k++){
            			if(code(cd[j],i+1).equals(code(cd[k],i+1))){
            				if(i==ma-1)
            					out.println(-1);
            				continue outer;
            			}
            		}
            	}
            	out.println(i+1);
            	break;
            }
        }
	}

	static String code(String s,int k){
		if(s.length()<=k) return s;
		return s.substring(0,k);
	}

	public static void main(String[] args) throws Exception{
		ir=new InputReader(System.in);
		out=new PrintWriter(System.out);
		solve();
		out.flush();
	}

	static class InputReader {

		private InputStream in;
		private byte[] buffer=new byte[1024];
		private int curbuf;
		private int lenbuf;

		public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}

		public boolean hasNextByte() {
			if(curbuf>=lenbuf){
				curbuf= 0;
				try{
					lenbuf=in.read(buffer);
				}catch(IOException e) {
					throw new InputMismatchException();
				}
				if(lenbuf<=0) return false;
			}
			return true;
		}

		private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}

		private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}

		private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}

		public boolean hasNext(){skip(); return hasNextByte();}

		public String next(){
			if(!hasNext()) throw new NoSuchElementException();
			StringBuilder sb=new StringBuilder();
			int b=readByte();
			while(!isSpaceChar(b)){
				sb.appendCodePoint(b);
				b=readByte();
			}
			return sb.toString();
		}

		public int nextInt() {
			if(!hasNext()) throw new NoSuchElementException();
			int c=readByte();
			while (isSpaceChar(c)) c=readByte();
			boolean minus=false;
			if (c=='-') {
				minus=true;
				c=readByte();
			}
			int res=0;
			do{
				if(c<'0'||c>'9') throw new InputMismatchException();
				res=res*10+c-'0';
				c=readByte();
			}while(!isSpaceChar(c));
			return (minus)?-res:res;
		}

		public long nextLong() {
			if(!hasNext()) throw new NoSuchElementException();
			int c=readByte();
			while (isSpaceChar(c)) c=readByte();
			boolean minus=false;
			if (c=='-') {
				minus=true;
				c=readByte();
			}
			long res = 0;
			do{
				if(c<'0'||c>'9') throw new InputMismatchException();
				res=res*10+c-'0';
				c=readByte();
			}while(!isSpaceChar(c));
			return (minus)?-res:res;
		}

		public double nextDouble(){return Double.parseDouble(next());}

		public int[] nextIntArray(int n){
			int[] a=new int[n];
			for(int i=0;i<n;i++) a[i]=nextInt();
			return a;
		}

		public long[] nextLongArray(int n){
			long[] a=new long[n];
			for(int i=0;i<n;i++) a[i]=nextLong();
			return a;
		}

		public char[][] nextCharMap(int n,int m){
			char[][] map=new char[n][m];
			for(int i=0;i<n;i++) map[i]=next().toCharArray();
			return map;
		}
	}
}

</source>
<source file="../hum_codes_raw/s861226215.java" startline="1" endline="157" pcid="28954">
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

public class Main{

	static PrintWriter out;
	static InputReader ir;

	static void solve(){
		for(;;){
            int n=ir.nextInt();
            if(n==0)
                break;
            char[][] ap=new char[n][];
            String[] cd=new String[n];
            int ma=0;
            for(int i=0;i<n;i++){
            	ap[i]=ir.next().toCharArray();
            	cd[i]=Character.toString(ap[i][0]);
            	for(int j=0;j<ap[i].length-1;j++){
            		if(ap[i][j]=='a'||ap[i][j]=='i'||ap[i][j]=='u'||ap[i][j]=='e'||ap[i][j]=='o'){
            			cd[i]+=Character.toString(ap[i][j+1]);
            		}
            	}
            	ma=Math.max(ma,cd[i].length());
            }
            outer:
            for(int i=0;i<ma;i++){
            	for(int j=0;j<n;j++){
            		for(int k=j+1;k<n;k++){
            			if(code(cd[j],i+1).equals(code(cd[k],i+1))){
            				if(i==ma-1)
            					out.println(-1);
            				continue outer;
            			}
            		}
            	}
            	out.println(i+1);
            	break;
            }
        }
	}

	static String code(String s,int k){
		if(s.length()<=k) return s;
		return s.substring(0,k);
	}

	public static void main(String[] args) throws Exception{
		ir=new InputReader(System.in);
		out=new PrintWriter(System.out);
		solve();
		out.flush();
	}

	static class InputReader {

		private InputStream in;
		private byte[] buffer=new byte[1024];
		private int curbuf;
		private int lenbuf;

		public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}

		public boolean hasNextByte() {
			if(curbuf>=lenbuf){
				curbuf= 0;
				try{
					lenbuf=in.read(buffer);
				}catch(IOException e) {
					throw new InputMismatchException();
				}
				if(lenbuf<=0) return false;
			}
			return true;
		}

		private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}

		private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}

		private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}

		public boolean hasNext(){skip(); return hasNextByte();}

		public String next(){
			if(!hasNext()) throw new NoSuchElementException();
			StringBuilder sb=new StringBuilder();
			int b=readByte();
			while(!isSpaceChar(b)){
				sb.appendCodePoint(b);
				b=readByte();
			}
			return sb.toString();
		}

		public int nextInt() {
			if(!hasNext()) throw new NoSuchElementException();
			int c=readByte();
			while (isSpaceChar(c)) c=readByte();
			boolean minus=false;
			if (c=='-') {
				minus=true;
				c=readByte();
			}
			int res=0;
			do{
				if(c<'0'||c>'9') throw new InputMismatchException();
				res=res*10+c-'0';
				c=readByte();
			}while(!isSpaceChar(c));
			return (minus)?-res:res;
		}

		public long nextLong() {
			if(!hasNext()) throw new NoSuchElementException();
			int c=readByte();
			while (isSpaceChar(c)) c=readByte();
			boolean minus=false;
			if (c=='-') {
				minus=true;
				c=readByte();
			}
			long res = 0;
			do{
				if(c<'0'||c>'9') throw new InputMismatchException();
				res=res*10+c-'0';
				c=readByte();
			}while(!isSpaceChar(c));
			return (minus)?-res:res;
		}

		public double nextDouble(){return Double.parseDouble(next());}

		public int[] nextIntArray(int n){
			int[] a=new int[n];
			for(int i=0;i<n;i++) a[i]=nextInt();
			return a;
		}

		public long[] nextLongArray(int n){
			long[] a=new long[n];
			for(int i=0;i<n;i++) a[i]=nextLong();
			return a;
		}

		public char[][] nextCharMap(int n,int m){
			char[][] map=new char[n][m];
			for(int i=0;i<n;i++) map[i]=next().toCharArray();
			return map;
		}
	}
}

</source>
</class>

<class classid="184" nclones="2" nlines="22" similarity="100">
<source file="../hum_codes_raw/s356478895.java" startline="1" endline="41" pcid="11963">
import java.util.*;

public class Main {

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int N = sc.nextInt();
    int arr[] = new int[N+1];
    int srt[] = new int[N+1];
    for(int i = 1; i<=N; i++){
      arr[i] = sc.nextInt();
      srt[i] = arr[i];
    }
    Arrays.sort(srt);
    for(int i = 1; i<=N; i++){
      if(arr[i] >= srt[N/2+1]){
        System.out.println(srt[N/2]); 
      }
      else{
        System.out.println(srt[N/2+1]); 
      }
    }
  }

}


/*

pre[i] = arr[1] + arr[2] + arr[3] + arr[4] + ... + arr[i]
The question for some l and r
arr[l] + arr[l+1] + arr[l+2] + ... + arr[r]
= 
pre[r] - pre[l-1]

pre[r]   = arr[1] + arr[2] + ... + arr[l-1] + arr[l] + arr[l+1] + ... + arr[r]
-
pre[l-1] = arr[1] + arr[2] + ... + arr[l-1]

*/

</source>
<source file="../hum_codes_raw/s768585881.java" startline="1" endline="24" pcid="25800">
import java.util.*;
public class Main {

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int N = sc.nextInt();
    int arr[] = new int[N+1];
    int srt[] = new int[N+1];
    for(int i = 1; i<=N; i++){
      arr[i] = sc.nextInt();
      srt[i] = arr[i];
    }
    Arrays.sort(srt);
    for(int i = 1; i<=N; i++){
      if(arr[i] >= srt[N/2+1]){
        System.out.println(srt[N/2]); 
      }
      else{
        System.out.println(srt[N/2+1]); 
      }
    }
  }
}

</source>
</class>

<class classid="185" nclones="2" nlines="23" similarity="100">
<source file="../hum_codes_raw/s356499693.java" startline="1" endline="26" pcid="11965">
import java.util.Scanner;
 
public class Main {
 
    public static void main(String[] args) {
        Scanner stdIn = new Scanner(System.in);
        int n = stdIn.nextInt();
        int[] a = new int[n];
        int min = Integer.MAX_VALUE;
        for(int i=0;i<n;i++){
            a[i] = stdIn.nextInt();
            if(min>a[i]) min = a[i];
        }
        for(int i=1;i<=min;i++){
            boolean flag = true;
            for(int j=0;j<n;j++){
                if(a[j]%i!=0){
                    flag = false;
                    break;
                }
            }
            if(flag) System.out.println(i);
        }
    }
}

</source>
<source file="../hum_codes_raw/s677108130.java" startline="1" endline="26" pcid="22757">
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner stdIn = new Scanner(System.in);
		int n = stdIn.nextInt();
		int[] a = new int[n];
		int min = Integer.MAX_VALUE;
		for(int i=0;i<n;i++){
			a[i] = stdIn.nextInt();
			if(min>a[i]) min = a[i];
		}
		for(int i=1;i<=min;i++){
			boolean flag = true;
			for(int j=0;j<n;j++){
				if(a[j]%i!=0){
					flag = false;
					break;
				}
			}
			if(flag) System.out.println(i);
		}
	}
}

</source>
</class>

<class classid="186" nclones="2" nlines="64" similarity="100">
<source file="../hum_codes_raw/s363586947.java" startline="1" endline="79" pcid="12204">
import java.util.*;

public class Main {
	public static void main(String[] args){
		Prime p = new Prime();
		int n;
		Scanner sc = new Scanner(System.in);
		
		while(true){
			n = sc.nextInt();
			if(n == 0){
				break;
			}
			System.out.println(p.searchMaxQuadruplet(n));
		}
	}
}

class Prime {
	
	private final int size = 664579;
	private int[] prime;
	
	public Prime(){
		prime = new int[size];
		setPrime();
	}
	
    public void setPrime() {
        int ptr = 0;
        

        prime[ptr++] = 2;
        prime[ptr++] = 3;

        for (int n=5; n<=10000000; n+=2) {
            boolean flag = false;
            for (int i=1; prime[i]*prime[i]<=n; i++) {
                if (0 == n%prime[i]) {
                    flag = true;
                    break;
                }
            }
            
            if (!flag) {
                prime[ptr++] = n;
            }
        }
    }
    
    private int getIndex(int n){
    	for(int i=0; i<size; i++){
    		if(prime[i] > n){
    			return i-1;
    		}else if(prime[i] == n){
    			return i;
    		}
    	}
    	
    	return size-1;
    }
    
    public int searchMaxQuadruplet(int n){
    	int idx = getIndex(n);
    	
    	while(true){
    		if(prime[idx]-prime[idx-1] == 2){
    			if(prime[idx]-prime[idx-2] == 6){
    				if(prime[idx]-prime[idx-3] == 8){
    	    			return prime[idx];
    	    		}
        		}
    		}
    		idx --;
    	}
    	
    }
}

</source>
<source file="../hum_codes_raw/s446409773.java" startline="1" endline="79" pcid="14954">
import java.util.*;

public class Main {
	public static void main(String[] args){
		Prime p = new Prime();
		int n;
		Scanner sc = new Scanner(System.in);
		
		while(true){
			n = sc.nextInt();
			if(n == 0){
				break;
			}
			System.out.println(p.searchMaxQuadruplet(n));
		}
	}
}

class Prime {
	
	private final int size = 664579;
	private int[] prime;
	
	public Prime(){
		prime = new int[size];
		setPrime();
	}
	
    public void setPrime() {
        int ptr = 0;
        

        prime[ptr++] = 2;
        prime[ptr++] = 3;

        for (int n = 5; n <= 10000000; n += 2) {
            boolean flag = false;
            for (int i=1; prime[i]*prime[i]<=n; i++) {
                if (0 == n%prime[i]) {
                    flag = true;
                    break;
                }
            }
            
            if (!flag) {
                prime[ptr++] = n;
            }
        }
    }
    
    private int getIndex(int n){
    	for(int i=0; i<size; i++){
    		if(prime[i] > n){
    			return i-1;
    		}else if(prime[i] == n){
    			return i;
    		}
    	}
    	
    	return size-1;
    }
    
    public int searchMaxQuadruplet(int n){
    	int idx = getIndex(n);
    	
    	while(true){
    		if(prime[idx]-prime[idx-1] == 2){
    			if(prime[idx]-prime[idx-2] == 6){
    				if(prime[idx]-prime[idx-3] == 8){
    	    			return prime[idx];
    	    		}
        		}
    		}
    		idx --;
    	}
    	
    }
}

</source>
</class>

<class classid="187" nclones="2" nlines="180" similarity="100">
<source file="../hum_codes_raw/s365181821.java" startline="1" endline="225" pcid="12264">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in Actual solution is at the top
 * 
 * @author daltao
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "daltao", 1 << 27);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            TaskB solver = new TaskB();
            solver.solve(1, in, out);
            out.close();
        }
    }
    static class TaskB {
        NumberTheory.Modular mod = new NumberTheory.Modular(1e9 + 7);

        public void solve(int testNumber, FastInput in, FastOutput out) {
            long n = in.readLong();
            int[] bits = new int[64];
            DigitUtils.BitOperator bo = new DigitUtils.BitOperator();
            for (int i = 0; i < 64; i++) {
                bits[i] = bo.bitAt(n, i);
            }

            long[][] dp = new long[64][3];
            // 0 equal, 1 less 1, 2 less more than 1
            dp[63][0] = 1;
            for (int i = 62; i >= 0; i--) {
                if (bits[i] == 1) {
                    // a put and b put
                    dp[i][0] = dp[i + 1][0];
                    // b not put
                    // b and a put
                    dp[i][1] += dp[i + 1][0] + dp[i + 1][1];
                    // b put or not
                    // b and a put or not
                    dp[i][2] += dp[i + 1][1] * 2 + dp[i + 1][2] * 3;
                } else {
                    // a not put and b not put
                    // a put and b put
                    dp[i][0] += dp[i + 1][0] + dp[i + 1][1];
                    // b put
                    dp[i][1] += dp[i + 1][1];
                    // b and a not put
                    dp[i][2] += dp[i + 1][1] + dp[i + 1][2] * 3;
                }

                for (int j = 0; j < 3; j++) {
                    dp[i][j] = mod.valueOf(dp[i][j]);
                }
            }

            long ans = mod.valueOf(dp[0][0] + dp[0][1] + dp[0][2]);
            out.println(ans);
        }

    }
    static class NumberTheory {
        public static class Modular {
            int m;

            public Modular(int m) {
                this.m = m;
            }

            public Modular(long m) {
                this.m = (int) m;
                if (this.m != m) {
                    throw new IllegalArgumentException();
                }
            }

            public Modular(double m) {
                this.m = (int) m;
                if (this.m != m) {
                    throw new IllegalArgumentException();
                }
            }

            public int valueOf(long x) {
                x %= m;
                if (x < 0) {
                    x += m;
                }
                return (int) x;
            }

            public String toString() {
                return "mod " + m;
            }

        }

    }
    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public long readLong() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            long val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }
    static class FastOutput implements AutoCloseable, Closeable {
        private StringBuilder cache = new StringBuilder(1 << 20);
        private final Writer os;

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput println(long c) {
            cache.append(c).append('\n');
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

    }
    static class DigitUtils {
        private DigitUtils() {}

        public static class BitOperator {
            public int bitAt(long x, int i) {
                return (int) ((x >> i) & 1);
            }

        }

    }
}


</source>
<source file="../hum_codes_raw/s591135494.java" startline="1" endline="225" pcid="19833">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in Actual solution is at the top
 * 
 * @author daltao
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "daltao", 1 << 27);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            TaskB solver = new TaskB();
            solver.solve(1, in, out);
            out.close();
        }
    }
    static class TaskB {
        NumberTheory.Modular mod = new NumberTheory.Modular(1e9 + 7);

        public void solve(int testNumber, FastInput in, FastOutput out) {
            long n = in.readLong();
            int[] bits = new int[64];
            DigitUtils.BitOperator bo = new DigitUtils.BitOperator();
            for (int i = 0; i < 64; i++) {
                bits[i] = bo.bitAt(n, i);
            }

            long[][] dp = new long[64][3];
            // 0 equal, 1 less 1, 2 less more than 1
            dp[63][0] = 1;
            for (int i = 62; i >= 0; i--) {
                if (bits[i] == 1) {
                    // a put and b put
                    dp[i][0] = dp[i + 1][0];
                    // b not put
                    // b and a put
                    dp[i][1] += dp[i + 1][0] + dp[i + 1][1];
                    // b put or not
                    // b and a put or not
                    dp[i][2] += dp[i + 1][1] * 2 + dp[i + 1][2] * 3;
                } else {
                    // a not put and b not put
                    // a put and b put
                    dp[i][0] += dp[i + 1][0] + dp[i + 1][1];
                    // b put
                    dp[i][1] += dp[i + 1][1];
                    // b and a not put
                    dp[i][2] += dp[i + 1][1] + dp[i + 1][2] * 3;
                }

                for (int j = 0; j < 3; j++) {
                    dp[i][j] = mod.valueOf(dp[i][j]);
                }
            }

            long ans = mod.valueOf(dp[0][0] + dp[0][1] + dp[0][2]);
            out.println(ans);
        }

    }
    static class NumberTheory {
        public static class Modular {
            int m;

            public Modular(int m) {
                this.m = m;
            }

            public Modular(long m) {
                this.m = (int) m;
                if (this.m != m) {
                    throw new IllegalArgumentException();
                }
            }

            public Modular(double m) {
                this.m = (int) m;
                if (this.m != m) {
                    throw new IllegalArgumentException();
                }
            }

            public int valueOf(long x) {
                x %= m;
                if (x < 0) {
                    x += m;
                }
                return (int) x;
            }

            public String toString() {
                return "mod " + m;
            }

        }

    }
    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public long readLong() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            long val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }
    static class FastOutput implements AutoCloseable, Closeable {
        private StringBuilder cache = new StringBuilder(1 << 20);
        private final Writer os;

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput println(long c) {
            cache.append(c).append('\n');
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

    }
    static class DigitUtils {
        private DigitUtils() {}

        public static class BitOperator {
            public int bitAt(long x, int i) {
                return (int) ((x >> i) & 1);
            }

        }

    }
}


</source>
</class>

<class classid="188" nclones="2" nlines="340" similarity="100">
<source file="../hum_codes_raw/s365509257.java" startline="1" endline="405" pcid="12274">
import java.io.PrintWriter;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;

class Main implements Runnable {
	public static void main(String[] args) {
		new Thread(null, new Main(), "", Runtime.getRuntime().maxMemory()).start();
	}

	class State {
		int i;
		int parent;
		int j;// ?????????g[i][j]?????????

		public State(int i_, int parent_, int j_) {
			i = i_;
			parent = parent_;
			j = j_;
		}
	}

	int two_edge_connected_componets(ArrayList<Integer>[] g, int[] col) {
		int n = g.length;
		Arrays.fill(col, -1);
		int cols = 0;
		int[] low = new int[n];
		int[] ord = new int[n];
		boolean[] marked = new boolean[n];
		Arrays.fill(low, -1);
		Arrays.fill(ord, -1);
		int order = 0;
		ArrayDeque<State> stk = new ArrayDeque<>();
		ArrayDeque<Integer> pnd = new ArrayDeque<>();
		for (int ii = 0; ii < n; ++ii) {
			if (ord[ii] == -1) {
				stk.add(new State(ii, -1, 0));
			}
			while (!stk.isEmpty()) {
				State s = stk.pollFirst();
				if (ord[s.i] == -1) {
					low[s.i] = (ord[s.i] = order++);
					pnd.addFirst(s.i);
				}
				if (s.j > 0 && s.parent != g[s.i].get(s.j - 1) && !marked[g[s.i].get(s.j - 1)]) {
					if (low[g[s.i].get(s.j - 1)] == -1) {
						throw new AssertionError();
					}
					low[s.i] = Math.min(low[s.i], low[g[s.i].get(s.j - 1)]);
				}
				if (s.j == g[s.i].size() && low[s.i] == ord[s.i]) {
					while (true) {
						int v = pnd.pollFirst();
						col[v] = cols;
						marked[v] = true;
						if (v == s.i)
							break;
					}
					++cols;
					continue;
				}
				if (s.j == g[s.i].size())
					continue;
				int v = g[s.i].get(s.j);
				stk.addFirst(new State(s.i, s.parent, s.j + 1));
				if (ord[v] == -1) {
					stk.addFirst(new State(v, s.i, 0));
					// } else if (v != s.parent && !marked[v]) {
				} else if (!marked[v]) {
					low[s.i] = Math.min(low[s.i], low[v]);
				}
			}
		}
		return cols;
	}

	@SuppressWarnings("unchecked")
	public void run() {
		Scanner sc = new Scanner(System.in);
		PrintWriter pw = new PrintWriter(System.out);
		int V = sc.nextInt();
		int E = sc.nextInt();
		ArrayList<Integer>[] g = new ArrayList[V];
		for (int i = 0; i < V; ++i) {
			g[i] = new ArrayList<>();
		}
		for (int i = 0; i < E; ++i) {
			int s = sc.nextInt();
			int t = sc.nextInt();
			g[s].add(t);
		}
		int[] col = new int[V];
		two_edge_connected_componets(g, col);
		int q = sc.nextInt();
		while (q-- > 0) {
			int u = sc.nextInt();
			int v = sc.nextInt();
			System.out.println(col[u] == col[v] ? "1" : "0");
		}
		// int n = sc.nextInt();
		// int m = sc.nextInt();
		// int q = sc.nextInt();
		// ArrayList<Integer>[] g = new ArrayList[n];
		// for (int i = 0; i < n; ++i) {
		// g[i] = new ArrayList<>();
		// }
		//
		// for (int i = 0; i < m; ++i) {
		// int a = sc.nextInt() - 1;
		// int b = sc.nextInt() - 1;
		// g[a].add(b);
		// g[b].add(a);
		// }
		// two_edge_connected_componets(g);
		// HLDecomposition hl = new HLDecomposition(n);
		// hl.pre();
		// SegmentTree st = new SegmentTree(n);
		// for (int i = st.n - 2; i >= 0; --i) {
		// st.v[i] = merge(st.v[2 * i + 1], st.v[2 * i + 2]);
		// }
		// while (q-- > 0) {
		// int t = sc.nextInt();
		// int a = sc.nextInt();
		// int b = sc.nextInt();
		// if (t == 1) {//
		//
		// } else {//
		//
		// }
		// }
		pw.close();
	}

	long output(int a, int b, HLDecomposition hl, SegmentTree st) {
		E ea = new E(-(Long.MAX_VALUE >> 8), 1);
		E eb = new E(-(Long.MAX_VALUE >> 8), 1);

		while (hl.head[a] != hl.head[b]) {
			if (hl.depth[hl.head[a]] < hl.depth[hl.head[b]]) {
				int tmp = a;
				a = b;
				b = tmp;
				E tmp_e = ea;
				ea = eb;
				eb = tmp_e;
			}
			ea = merge(st.query(hl.id[hl.head[a]], hl.id[a] + 1), ea);
			a = hl.parent[hl.head[a]];
		}
		if (hl.depth[a] < hl.depth[b]) {
			int tmp = a;
			a = b;
			b = tmp;
			E tmp_e = ea;
			ea = eb;
			eb = tmp_e;
		}
		return merge(eb.reverse(), merge(st.query(hl.id[b], hl.id[a] + 1), ea)).max;
	}

	void modification(int a, int b, int c, HLDecomposition hl, SegmentTree st) {
		while (hl.head[a] != hl.head[b]) {
			if (hl.depth[hl.head[a]] < hl.depth[hl.head[b]]) {
				int tmp = a;
				a = b;
				b = tmp;
			}
			st.modification(hl.id[hl.head[a]], hl.id[a] + 1, c);
			a = hl.parent[hl.head[a]];
		}
		if (hl.depth[a] < hl.depth[b]) {
			int tmp = a;
			a = b;
			b = tmp;
		}
		if (hl.id[b] > hl.id[a]) {
			throw new AssertionError();
		}
		st.modification(hl.id[b], hl.id[a] + 1, c);
	}

	class E {
		long top;
		long bottom;
		long max;
		long sum;

		public E(long top, long bottom, long max, long sum) {
			this.top = top;
			this.bottom = bottom;
			this.max = max;
			this.sum = sum;
		}

		public E(long v, int width) {
			this.top = Math.max(v, v * width);
			this.bottom = Math.max(v, v * width);
			this.max = Math.max(v, v * width);
			this.sum = width * v;
		}

		public E() {
			this.top = -(Long.MAX_VALUE >> 8);
			this.bottom = -(Long.MAX_VALUE >> 8);
			this.max = -(Long.MAX_VALUE >> 8);
			this.sum = 0;
		}

		E reverse() {
			E e = new E();
			e.top = this.bottom;
			e.bottom = this.top;
			e.sum = this.sum;
			e.max = this.max;
			return e;
		}

		void tr() {
			System.out.println("top" + top);
			System.out.println("bottom" + bottom);
			System.out.println("max" + max);
			System.out.println("sum" + sum);
		}
	}

	E merge(E top, E bottom) {
		E e = new E();
		e.top = Math.max(top.top, top.sum + bottom.top);
		e.bottom = Math.max(bottom.bottom, top.bottom + bottom.sum);
		e.max = Math.max(Math.max(top.max, bottom.max), top.bottom + bottom.top);
		e.sum = top.sum + bottom.sum;
		return e;
	}

	class SegmentTree {
		int n;
		E[] v;
		long[] lazy;
		long nil = Long.MAX_VALUE >> 3;

		public SegmentTree(int n) {
			this.n = 1;
			while (this.n < n) {
				this.n *= 2;
			}
			v = new E[2 * this.n - 1];
			lazy = new long[2 * this.n - 1];
			Arrays.fill(lazy, nil);
			Arrays.fill(v, new E());
		}

		void push(int k, int l, int r) {
			if (lazy[k] == nil) {
				return;
			}
			v[k] = new E(lazy[k], r - l);
			if (r - l > 1) {
				lazy[2 * k + 1] = lazy[k];
				lazy[2 * k + 2] = lazy[k];
			}
			lazy[k] = nil;
		}

		void modification(int a, int b, int c) {
			modification(a, b, c, 0, n, 0);
		}

		// [a,b),[l,r)
		void modification(int a, int b, int c, int l, int r, int k) {
			push(k, l, r);
			if (b <= l || r <= a) {
				return;
			}
			if (a <= l && r <= b) {
				lazy[k] = c;
				push(k, l, r);
			} else {
				modification(a, b, c, l, (l + r) / 2, 2 * k + 1);
				modification(a, b, c, (l + r) / 2, r, 2 * k + 2);
				v[k] = merge(v[2 * k + 1], v[2 * k + 2]);
			}
		}

		E query(int a, int b) {
			return query(a, b, 0, n, 0);
		}

		E query(int a, int b, int l, int r, int k) {
			if (b <= l || r <= a) {
				return new E();
			}
			push(k, l, r);
			if (a <= l && r <= b) {
				return v[k];
			} else {
				E vl = query(a, b, l, (l + r) / 2, 2 * k + 1);
				E vr = query(a, b, (l + r) / 2, r, 2 * k + 2);
				return merge(vl, vr);
			}
		}
	}

	class HLDecomposition {
		int n;
		int[] depth;
		int[] head;
		int[] heavy;
		int[] parent;
		int[] sz;
		ArrayList<Integer>[] g;
		int[] id;

		@SuppressWarnings("unchecked")
		public HLDecomposition(int n) {
			this.n = n;
			depth = new int[n];
			head = new int[n];
			heavy = new int[n];
			parent = new int[n];
			id = new int[n];
			sz = new int[n];
			g = new ArrayList[n];
			for (int i = 0; i < n; ++i) {
				g[i] = new ArrayList<>();
			}
			Arrays.fill(head, -1);
			Arrays.fill(id, -1);
			Arrays.fill(parent, -1);
		}

		void ae(int a, int b) {
			g[a].add(b);
			g[b].add(a);
		}

		void pre() {
			dfs(0, -1);
			bfs();
		}

		void bfs() {
			ArrayDeque<Integer> pend = new ArrayDeque<>();
			int gen = 0;
			pend.add(0);
			while (!pend.isEmpty()) {
				int v = pend.pollFirst();
				int top = v;
				for (; v != -1; v = heavy[v]) {
					id[v] = gen++;
					head[v] = top;
					for (int d : g[v]) {
						if (d == parent[v] || d == heavy[v]) {
							continue;
						}
						pend.add(d);
					}
				}
			}
		}

		int lca(int u, int v) {
			if (head[u] != head[v]) {
				if (depth[head[u]] < depth[head[v]]) {
					int tmp = u;
					u = v;
					v = tmp;
				}
				return lca(parent[head[u]], v);
			} else {
				if (depth[u] > depth[v]) {
					int tmp = u;
					u = v;
					v = tmp;
				}
				return u;
			}
		}

		int dfs(int c, int p) {
			parent[c] = p;
			int s = 1;
			int to = -1;
			for (int d : g[c]) {
				if (d == p)
					continue;
				depth[d] = depth[c] + 1;
				s += dfs(d, c);
				if (to == -1 || sz[d] > sz[to]) {
					to = d;
				}
			}
			sz[c] = s;
			heavy[c] = to;
			return s;
		}

	}

	static void tr(Object... objects) {
		System.out.println(Arrays.deepToString(objects));
	}

}

</source>
<source file="../hum_codes_raw/s726195920.java" startline="1" endline="410" pcid="24421">
import java.io.PrintWriter;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;

class Main implements Runnable {
	public static void main(String[] args) {
		new Thread(null, new Main(), "", Runtime.getRuntime().maxMemory()).start();
	}

	class State {
		int i;
		int parent;
		int j;// ?????????g[i][j]?????????

		public State(int i_, int parent_, int j_) {
			i = i_;
			parent = parent_;
			j = j_;
		}
	}

	int two_edge_connected_componets(ArrayList<Integer>[] g, int[] col) {
		int n = g.length;
		Arrays.fill(col, -1);
		int cols = 0;
		int[] low = new int[n];
		int[] ord = new int[n];
		boolean[] marked = new boolean[n];
		Arrays.fill(low, -1);
		Arrays.fill(ord, -1);
		int order = 0;
		ArrayDeque<State> stk = new ArrayDeque<>();
		ArrayDeque<Integer> pnd = new ArrayDeque<>();
		for (int ii = 0; ii < n; ++ii) {
			if (ord[ii] == -1) {
				stk.add(new State(ii, -1, 0));
			}
			while (!stk.isEmpty()) {
				State s = stk.pollFirst();
				if (ord[s.i] == -1) {
					low[s.i] = (ord[s.i] = order++);
					pnd.addFirst(s.i);
				}
				if (s.j > 0 && s.parent != g[s.i].get(s.j - 1) && !marked[g[s.i].get(s.j - 1)]) {
					if (low[g[s.i].get(s.j - 1)] == -1) {
						throw new AssertionError();
					}
					low[s.i] = Math.min(low[s.i], low[g[s.i].get(s.j - 1)]);
				}
				if (s.j == g[s.i].size() && low[s.i] == ord[s.i]) {
					while (true) {
						int v = pnd.pollFirst();
						col[v] = cols;
						marked[v] = true;
						if (v == s.i)
							break;
					}
					++cols;
					continue;
				}
				if (s.j == g[s.i].size())
					continue;
				int v = g[s.i].get(s.j);
				stk.addFirst(new State(s.i, s.parent, s.j + 1));
				// ???????????????????????????????????
				if (ord[v] == -1) {
					stk.addFirst(new State(v, s.i, 0));
					// } else if (v != s.parent && !marked[v]) {
				} else if (!marked[v]) {
					low[s.i] = Math.min(low[s.i], low[v]);
				}
			}
		}
		return cols;
	}

	@SuppressWarnings("unchecked")
	public void run() {
		Scanner sc = new Scanner(System.in);
		PrintWriter pw = new PrintWriter(System.out);
		int V = sc.nextInt();
		int E = sc.nextInt();
		ArrayList<Integer>[] g = new ArrayList[V];
		for (int i = 0; i < V; ++i) {
			g[i] = new ArrayList<>();
		}
		for (int i = 0; i < E; ++i) {
			int s = sc.nextInt();
			int t = sc.nextInt();
			g[s].add(t);
		}
		int[] col = new int[V];
		two_edge_connected_componets(g, col);
		int q = sc.nextInt();
		while (q-- > 0) {
			int u = sc.nextInt();
			int v = sc.nextInt();
			System.out.println(col[u] == col[v] ? "1" : "0");
		}
		// int n = sc.nextInt();
		// int m = sc.nextInt();
		// int q = sc.nextInt();
		// ArrayList<Integer>[] g = new ArrayList[n];
		// for (int i = 0; i < n; ++i) {
		// g[i] = new ArrayList<>();
		// }
		//
		// for (int i = 0; i < m; ++i) {
		// int a = sc.nextInt() - 1;
		// int b = sc.nextInt() - 1;
		// g[a].add(b);
		// g[b].add(a);
		// }
		// two_edge_connected_componets(g);
		// HLDecomposition hl = new HLDecomposition(n);
		// hl.pre();
		// SegmentTree st = new SegmentTree(n);
		// for (int i = st.n - 2; i >= 0; --i) {
		// st.v[i] = merge(st.v[2 * i + 1], st.v[2 * i + 2]);
		// }
		// while (q-- > 0) {
		// int t = sc.nextInt();
		// int a = sc.nextInt();
		// int b = sc.nextInt();
		// if (t == 1) {//
		//
		// } else {//
		//
		// }
		// }
		pw.close();
	}

	long output(int a, int b, HLDecomposition hl, SegmentTree st) {
		E ea = new E(-(Long.MAX_VALUE >> 8), 1);
		E eb = new E(-(Long.MAX_VALUE >> 8), 1);

		while (hl.head[a] != hl.head[b]) {
			if (hl.depth[hl.head[a]] < hl.depth[hl.head[b]]) {
				int tmp = a;
				a = b;
				b = tmp;
				E tmp_e = ea;
				ea = eb;
				eb = tmp_e;
			}
			// a???head???????????????
			ea = merge(st.query(hl.id[hl.head[a]], hl.id[a] + 1), ea);
			a = hl.parent[hl.head[a]];
		}
		if (hl.depth[a] < hl.depth[b]) {
			int tmp = a;
			a = b;
			b = tmp;
			E tmp_e = ea;
			ea = eb;
			eb = tmp_e;
		}
		// a???????????????
		return merge(eb.reverse(), merge(st.query(hl.id[b], hl.id[a] + 1), ea)).max;
	}

	void modification(int a, int b, int c, HLDecomposition hl, SegmentTree st) {
		while (hl.head[a] != hl.head[b]) {
			if (hl.depth[hl.head[a]] < hl.depth[hl.head[b]]) {
				int tmp = a;
				a = b;
				b = tmp;
			}
			// a???head???????????????
			st.modification(hl.id[hl.head[a]], hl.id[a] + 1, c);
			a = hl.parent[hl.head[a]];
		}
		if (hl.depth[a] < hl.depth[b]) {
			int tmp = a;
			a = b;
			b = tmp;
		}
		// a???????????????
		if (hl.id[b] > hl.id[a]) {
			throw new AssertionError();
		}
		st.modification(hl.id[b], hl.id[a] + 1, c);
	}

	class E {
		long top;
		long bottom;
		long max;
		long sum;

		public E(long top, long bottom, long max, long sum) {
			this.top = top;
			this.bottom = bottom;
			this.max = max;
			this.sum = sum;
		}

		public E(long v, int width) {
			this.top = Math.max(v, v * width);
			this.bottom = Math.max(v, v * width);
			this.max = Math.max(v, v * width);
			this.sum = width * v;
		}

		public E() {
			this.top = -(Long.MAX_VALUE >> 8);
			this.bottom = -(Long.MAX_VALUE >> 8);
			this.max = -(Long.MAX_VALUE >> 8);
			this.sum = 0;
		}

		E reverse() {
			E e = new E();
			e.top = this.bottom;
			e.bottom = this.top;
			e.sum = this.sum;
			e.max = this.max;
			return e;
		}

		void tr() {
			System.out.println("top" + top);
			System.out.println("bottom" + bottom);
			System.out.println("max" + max);
			System.out.println("sum" + sum);
		}
	}

	E merge(E top, E bottom) {
		E e = new E();
		e.top = Math.max(top.top, top.sum + bottom.top);
		e.bottom = Math.max(bottom.bottom, top.bottom + bottom.sum);
		e.max = Math.max(Math.max(top.max, bottom.max), top.bottom + bottom.top);
		e.sum = top.sum + bottom.sum;
		return e;
	}

	class SegmentTree {
		int n;
		E[] v;
		long[] lazy;
		long nil = Long.MAX_VALUE >> 3;

		public SegmentTree(int n) {
			this.n = 1;
			while (this.n < n) {
				this.n *= 2;
			}
			v = new E[2 * this.n - 1];
			lazy = new long[2 * this.n - 1];
			Arrays.fill(lazy, nil);
			Arrays.fill(v, new E());
		}

		void push(int k, int l, int r) {
			if (lazy[k] == nil) {
				return;
			}
			v[k] = new E(lazy[k], r - l);
			if (r - l > 1) {
				lazy[2 * k + 1] = lazy[k];
				lazy[2 * k + 2] = lazy[k];
			}
			lazy[k] = nil;
		}

		void modification(int a, int b, int c) {
			modification(a, b, c, 0, n, 0);
		}

		// [a,b),[l,r)
		void modification(int a, int b, int c, int l, int r, int k) {
			push(k, l, r);
			if (b <= l || r <= a) {
				return;
			}
			if (a <= l && r <= b) {
				lazy[k] = c;
				push(k, l, r);
			} else {
				modification(a, b, c, l, (l + r) / 2, 2 * k + 1);
				modification(a, b, c, (l + r) / 2, r, 2 * k + 2);
				v[k] = merge(v[2 * k + 1], v[2 * k + 2]);
			}
		}

		E query(int a, int b) {
			return query(a, b, 0, n, 0);
		}

		E query(int a, int b, int l, int r, int k) {
			if (b <= l || r <= a) {
				return new E();
			}
			push(k, l, r);
			if (a <= l && r <= b) {
				return v[k];
			} else {
				E vl = query(a, b, l, (l + r) / 2, 2 * k + 1);
				E vr = query(a, b, (l + r) / 2, r, 2 * k + 2);
				return merge(vl, vr);
			}
		}
	}

	class HLDecomposition {
		int n;
		int[] depth;
		int[] head;
		int[] heavy;
		int[] parent;
		int[] sz;
		ArrayList<Integer>[] g;
		int[] id;

		@SuppressWarnings("unchecked")
		public HLDecomposition(int n) {
			this.n = n;
			depth = new int[n];
			head = new int[n];
			heavy = new int[n];
			parent = new int[n];
			id = new int[n];
			sz = new int[n];
			g = new ArrayList[n];
			for (int i = 0; i < n; ++i) {
				g[i] = new ArrayList<>();
			}
			Arrays.fill(head, -1);
			Arrays.fill(id, -1);
			Arrays.fill(parent, -1);
		}

		void ae(int a, int b) {
			g[a].add(b);
			g[b].add(a);
		}

		void pre() {
			dfs(0, -1);
			bfs();
		}

		void bfs() {
			ArrayDeque<Integer> pend = new ArrayDeque<>();
			int gen = 0;
			pend.add(0);
			while (!pend.isEmpty()) {
				int v = pend.pollFirst();
				int top = v;
				for (; v != -1; v = heavy[v]) {
					id[v] = gen++;
					head[v] = top;
					for (int d : g[v]) {
						if (d == parent[v] || d == heavy[v]) {
							continue;
						}
						pend.add(d);
					}
				}
			}
		}

		int lca(int u, int v) {
			if (head[u] != head[v]) {
				if (depth[head[u]] < depth[head[v]]) {
					int tmp = u;
					u = v;
					v = tmp;
				}
				return lca(parent[head[u]], v);
			} else {
				if (depth[u] > depth[v]) {
					int tmp = u;
					u = v;
					v = tmp;
				}
				return u;
			}
		}

		int dfs(int c, int p) {
			parent[c] = p;
			int s = 1;
			int to = -1;
			for (int d : g[c]) {
				if (d == p)
					continue;
				depth[d] = depth[c] + 1;
				s += dfs(d, c);
				if (to == -1 || sz[d] > sz[to]) {
					to = d;
				}
			}
			sz[c] = s;
			heavy[c] = to;
			return s;
		}

	}

	static void tr(Object... objects) {
		System.out.println(Arrays.deepToString(objects));
	}

}

</source>
</class>

<class classid="189" nclones="2" nlines="33" similarity="100">
<source file="../hum_codes_raw/s366950302.java" startline="1" endline="45" pcid="12332">
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;

public class Main {
  public static void main(String[] args) {
    Scanner scanner = new Scanner(System.in);

    int N = scanner.nextInt();
    int K = scanner.nextInt();
    long M = 1_000_000_007;

    List<Integer> factors = new ArrayList<>();
    factors.add(0);
    for (int i = 1; i * i <= N; i++) {
      int j = N / i;
      factors.add(i);
      if (j != i) factors.add(j);
    }
    Collections.sort(factors);

    int F = factors.size() - 1;
    long[][] dp = new long[K][F + 1];
    for (int i = 1; i <= F; i++) {
      dp[0][i] = factors.get(i);
    }
    for (int i = 1; i < K; i++) {
      for (int j = 1; j <= F; j++) {
        dp[i][j] = dp[i][j - 1];
        dp[i][j] += dp[i - 1][F - j + 1] * (factors.get(j) - factors.get(j - 1)) % M;
        if (dp[i][j] >= M) dp[i][j] -= M;
        //for (int k = 1; k <= F - j + 1; k++) {
        //  dp[i][j] += dp[i - 1][k];
        //  if (dp[i][j] >= M) dp[i][j] -= M;
        //}
        //dp[i][j] *= factors.get(j) - factors.get(j - 1);
        //dp[i][j] %= M;
      }
    }

    System.out.println(dp[K - 1][F]);
  }
}

</source>
<source file="../hum_codes_raw/s615983931.java" startline="1" endline="39" pcid="20702">
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;

public class Main {
  public static void main(String[] args) {
    Scanner scanner = new Scanner(System.in);

    int N = scanner.nextInt();
    int K = scanner.nextInt();
    long M = 1_000_000_007;

    List<Integer> factors = new ArrayList<>();
    factors.add(0);
    for (int i = 1; i * i <= N; i++) {
      int j = N / i;
      factors.add(i);
      if (j != i) factors.add(j);
    }
    Collections.sort(factors);

    int F = factors.size() - 1;
    long[][] dp = new long[K][F + 1];
    for (int i = 1; i <= F; i++) {
      dp[0][i] = factors.get(i);
    }
    for (int i = 1; i < K; i++) {
      for (int j = 1; j <= F; j++) {
        dp[i][j] = dp[i][j - 1];
        dp[i][j] += dp[i - 1][F - j + 1] * (factors.get(j) - factors.get(j - 1)) % M;
        if (dp[i][j] >= M) dp[i][j] -= M;
      }
    }

    System.out.println(dp[K - 1][F]);
  }
}

</source>
</class>

<class classid="190" nclones="2" nlines="21" similarity="100">
<source file="../hum_codes_raw/s367208360.java" startline="1" endline="21" pcid="12342">
import java.util.Scanner;
public class Main {
	public static void main(String[] args) throws java.io.IOException {
		Scanner scan = new Scanner(System.in);
		int n = scan.nextInt();
		int[] k = new int[n];
		int[] p = new int[n];
		for(int i = 0 ; i<n ; i++){
			k[i] = scan.nextInt();
			p[i] = scan.nextInt();
		}
		for(int i = 0 ; i<n ; i++){
			if(k[i]%p[i] == 0){
				System.out.println(p[i]);
			}else{
				System.out.println(k[i]%p[i]);
			}
		}
	}
}

</source>
<source file="../hum_codes_raw/s372355840.java" startline="1" endline="21" pcid="12520">
import java.util.Scanner;
public class Main {
	public static void main(String[] args) throws java.io.IOException {
		Scanner scan = new Scanner(System.in);
		int n = scan.nextInt();
		int[] k = new int[n];
		int[] p = new int[n];
		for(int i = 0 ; i<n ; i++){
			k[i] = scan.nextInt();
			p[i] = scan.nextInt();
		}
		for(int i = 0 ; i<n ; i++){
			if(k[i]%p[i] == 0){
				System.out.println(p[i]);
			}else{
				System.out.println(k[i]%p[i]);
			}
		}
	}
}

</source>
</class>

<class classid="191" nclones="2" nlines="53" similarity="100">
<source file="../hum_codes_raw/s368238428.java" startline="1" endline="74" pcid="12376">
import java.util.*;
public class Main 
{
	public static void main(String arg[])
	{
		Scanner in=new Scanner(System.in);
		for(;;)
		{
			int n=in.nextInt();
			String t=in.nextLine();
			ArrayList<String> AL=new ArrayList<String>();
			if(n==0)
				return;
			for(int i=0;i<n;i++)
			{
				String s[]=in.nextLine().split(" ");
				for(int j=0;j<s.length;j++)
					AL.add(s[j]);
			}
			String se=in.next();
			for(int i=0;i<AL.size();i++)
				if(se.charAt(0)!=AL.get(i).charAt(0))
				{
					AL.remove(i);
					i--;
				}
			if(AL.isEmpty())
			{
				System.out.println("NA");
				continue;
			}
			Collections.sort(AL);
			int count[]=new int[AL.size()];
			for(int i=0;i<AL.size()-1;i++)
			{
				while(i+1<AL.size()&&AL.get(i).equals(AL.get(i+1)))
				{
					count[i]++;
					AL.remove(i);
				}
			}
			ArrayList<Integer> cou=new ArrayList<Integer>();
			for(int i=0;i<count.length;i++)
				cou.add(count[i]);

			ArrayList<String> ANS=new ArrayList<String>();
			while(!AL.isEmpty())
			{
				int m=0;
				for(int j=0;j<cou.size();j++)
				{
					if(cou.get(m)<cou.get(j))
						m=j;
				}
				ANS.add(AL.get(m));
				AL.remove(m);
				cou.remove(m);
			}
			int p=0;
			for(int i=0;i<ANS.size();i++)
			{
				if(p==0)
					System.out.print(ANS.get(i));
				else
					System.out.print(" "+ANS.get(i));
				if(i>3)
					break;
				p=1;
			}
			System.out.println();
		}
	}
}

</source>
<source file="../hum_codes_raw/s563727636.java" startline="1" endline="74" pcid="18976">
import java.util.*;
public class Main
{
	public static void main(String arg[])
	{
		Scanner in=new Scanner(System.in);
		for(;;)
		{
			int n=in.nextInt();
			String t=in.nextLine();
			ArrayList<String> AL=new ArrayList<String>();
			if(n==0)
				return;
			for(int i=0;i<n;i++)
			{
				String s[]=in.nextLine().split(" ");
				for(int j=0;j<s.length;j++)
					AL.add(s[j]);
			}
			String se=in.next();
			for(int i=0;i<AL.size();i++)
				if(se.charAt(0)!=AL.get(i).charAt(0))
				{
					AL.remove(i);
					i--;
				}
			if(AL.isEmpty())
			{
				System.out.println("NA");
				continue;
			}
			Collections.sort(AL);
			int count[]=new int[AL.size()];
			for(int i=0;i<AL.size()-1;i++)
			{
				while(i+1<AL.size()&&AL.get(i).equals(AL.get(i+1)))
				{
					count[i]++;
					AL.remove(i);
				}
			}
			ArrayList<Integer> cou=new ArrayList<Integer>();
			for(int i=0;i<count.length;i++)
				cou.add(count[i]);

			ArrayList<String> ANS=new ArrayList<String>();
			while(!AL.isEmpty())
			{
				int m=0;
				for(int j=0;j<cou.size();j++)
				{
					if(cou.get(m)<cou.get(j))
						m=j;
				}
				ANS.add(AL.get(m));
				AL.remove(m);
				cou.remove(m);
			}
			int p=0;
			for(int i=0;i<ANS.size();i++)
			{
				if(p==0)
					System.out.print(ANS.get(i));
				else
					System.out.print(" "+ANS.get(i));
				if(i>3)
					break;
				p=1;
			}
			System.out.println();
		}
	}
}

</source>
</class>

<class classid="192" nclones="2" nlines="209" similarity="100">
<source file="../hum_codes_raw/s371628418.java" startline="1" endline="176" pcid="12500">
import java.util.*;
public class Main {
	Scanner in = new Scanner(System.in);
	public static void main(String[] args) {
		new Main();
	}
	public Main() {
		new AOJ0502();
	}

	class AOJ0502{
		public AOJ0502() {
			while(true){
				int n = in.nextInt();
				if(n==0)break;
				Dice dice = new Dice(1, 2);
				int sum = 1;
				for(int i=0;i<n;i++){
					String input = in.next();
					if(input.equals("North"))dice.rotateNorth();
					else if(input.equals("East"))dice.rotateEast();
					else if(input.equals("West"))dice.rotateWest();
					else if(input.equals("South"))dice.rotateSouth();
					else if(input.equals("Right"))dice.rotateCW();
					else if(input.equals("Left"))dice.rotateCCW();
//					System.out.println(dice.getTop());
					sum+=dice.getTop();
				}
				System.out.println(sum);
			}
		}

		class Dice{
			private int top=1,bottom=6,east=5,west=2,north=4,south=3;
			public Dice(int t,int s) {
				switch(t){
				case 1: break;
				case 2: rotateEast(); break;
				case 3: rotateNorth(); break;
				case 4: rotateSouth(); break;
				case 5: rotateWest(); break;
				case 6: reverse(); break;
				}
				while(s!=south) rotateCW();
			}
			boolean IsDice(){
				return north+south==7&&top+bottom==7&&west+east==7;
			}
			Dice rotateEast(){
				int temp=east;east=top;top=west;west=bottom;bottom=temp;
				return this;
			}
			Dice rotateWest(){
				int tmp=west; west=top; top=east; east=bottom; bottom=tmp;
				return this;
			}
			Dice rotateSouth(){
				int tmp=south; south=top; top=north; north=bottom; bottom=tmp;
				return this;
			}
			Dice rotateNorth(){
				int tmp=north; north=top; top=south; south=bottom; bottom=tmp;
				return this;
			}
			Dice reverse(){
				rotateNorth(); rotateNorth(); rotateCW(); rotateCW();
				return this;
			}
			Dice rotateCW(){//
				int tmp=north; north=west; west=south; south=east; east=tmp;
				return this;
			}
			Dice rotateCCW(){//
				int tmp=north; north=east; east=south; south=west; west=tmp;
				return this;
			}
			int getTop(){
				return top;
			}
			int getBottom(){
				return bottom;
			}
			int getEast(){
				return east;
			}
			int getWest(){
				return west;
			}
			int getSourth(){
				return south;
			}
			int getNorth(){
				return north;
			}
			@Override public String toString(){
				return "top"+top+" north"+north+" east"+east+" south"+south+" west"+west+" bottom"+bottom;
			}
			@Override public boolean equals(Object obj){
				if(obj==this)return true;
				if(!(obj instanceof Dice))return false;
				Dice d = (Dice)obj;
				if(this.top==d.getTop()&&this.bottom==d.getBottom()&&
						this.east==d.getWest()&&this.west==d.getWest()&&
						this.north==d.getNorth()&&this.south==d.getSourth())return true;
				return false;
			}
		}
	}

	class AOJ0119{
		HashMap<Integer, ArrayList<Integer>> map;
		HashMap<Integer, ArrayList<Integer>> map2;
		boolean sw[];
		boolean flg;
		int m,n;
		ArrayList<Integer> result;
		void dfs(int person,int cnt){
			if(cnt==m){
				if(map2.get(person).size()!=0)return;
				flg=true;
				return;
			}
			if(flg)return;
			ArrayList<Integer> get_list = map2.get(person);
			for(int i=0;i<get_list.size();i++)if(!sw[get_list.get(i)]){
				sw[get_list.get(i)]=true;
				result.add(get_list.get(i));
				dfs(get_list.get(i),cnt+1);
				if(flg)return;
				result.remove(result.size()-1);
				sw[get_list.get(i)]=false;
			}
			if(map2.get(person).size()!=0)return;
			for(int key:map2.keySet())if(!sw[key]){
				sw[key] = true;
				result.add(key);
				dfs(key,cnt+1);
				if(flg)return;
				result.remove(result.size()-1);
				sw[key]=false;
			}
		}

		public AOJ0119() {
			map = new HashMap<Integer, ArrayList<Integer>>();
			map2 = new HashMap<Integer, ArrayList<Integer>>();
			m = in.nextInt();//
			n = in.nextInt();//
			sw = new boolean[m+1];
			result = new ArrayList<Integer>();
			for(int i=1;i<=m;i++){
				map.put(i, new ArrayList<Integer>());
				map2.put(i,new ArrayList<Integer>());
			}
			for(int i=0;i<n;i++){
				int x = in.nextInt();
				int y = in.nextInt();
				ArrayList<Integer> a = map.remove(x);a.add(y);
				map.put(x,a);
			}
			//			System.out.println(map);//deba
			for(int i=1;i<=m;i++){
				for(int s=1;s<=m;s++)if(map.get(s).contains(i)){
					ArrayList<Integer> a = map2.remove(i);a.add(s);
					map2.put(i,a);
				}
			}
			//			System.out.println(map2);//deba
			flg = false;sw[2]=true;result.add(2);
			dfs(2,1);
			for(int i=result.size()-1;i>=0;i--)System.out.println(result.get(i));
		}
	}

}

</source>
<source file="../hum_codes_raw/s467195810.java" startline="1" endline="176" pcid="15678">
import java.util.*;
public class Main {
	Scanner in = new Scanner(System.in);
	public static void main(String[] args) {
		new Main();
	}
	public Main() {
		new AOJ0502();
	}

	class AOJ0502{
		public AOJ0502() {
			while(true){
				int n = in.nextInt();
				if(n==0)break;
				Dice dice = new Dice(1, 2);
				int sum = 1;
				for(int i=0;i<n;i++){
					String input = in.next();
					if(input.equals("North"))dice.rotateNorth();
					else if(input.equals("East"))dice.rotateEast();
					else if(input.equals("West"))dice.rotateWest();
					else if(input.equals("South"))dice.rotateSouth();
					else if(input.equals("Right"))dice.rotateCW();
					else if(input.equals("Left"))dice.rotateCCW();
//					System.out.println(dice.getTop());
					sum+=dice.getTop();
				}
				System.out.println(sum);
			}
		}

		class Dice{
			private int top=1,bottom=6,east=5,west=2,north=4,south=3;
			public Dice(int t,int s) {
				switch(t){
				case 1: break;
				case 2: rotateEast(); break;
				case 3: rotateNorth(); break;
				case 4: rotateSouth(); break;
				case 5: rotateWest(); break;
				case 6: reverse(); break;
				}
				while(s!=south) rotateCW();
			}
			boolean IsDice(){
				return north+south==7&&top+bottom==7&&west+east==7;
			}
			Dice rotateEast(){
				int temp=east;east=top;top=west;west=bottom;bottom=temp;
				return this;
			}
			Dice rotateWest(){
				int tmp=west; west=top; top=east; east=bottom; bottom=tmp;
				return this;
			}
			Dice rotateSouth(){
				int tmp=south; south=top; top=north; north=bottom; bottom=tmp;
				return this;
			}
			Dice rotateNorth(){
				int tmp=north; north=top; top=south; south=bottom; bottom=tmp;
				return this;
			}
			Dice reverse(){
				rotateNorth(); rotateNorth(); rotateCW(); rotateCW();
				return this;
			}
			Dice rotateCW(){//
				int tmp=north; north=west; west=south; south=east; east=tmp;
				return this;
			}
			Dice rotateCCW(){//
				int tmp=north; north=east; east=south; south=west; west=tmp;
				return this;
			}
			int getTop(){
				return top;
			}
			int getBottom(){
				return bottom;
			}
			int getEast(){
				return east;
			}
			int getWest(){
				return west;
			}
			int getSourth(){
				return south;
			}
			int getNorth(){
				return north;
			}
			@Override public String toString(){
				return "top"+top+" north"+north+" east"+east+" south"+south+" west"+west+" bottom"+bottom;
			}
			@Override public boolean equals(Object obj){
				if(obj==this)return true;
				if(!(obj instanceof Dice))return false;
				Dice d = (Dice)obj;
				if(this.top==d.getTop()&&this.bottom==d.getBottom()&&
						this.east==d.getWest()&&this.west==d.getWest()&&
						this.north==d.getNorth()&&this.south==d.getSourth())return true;
				return false;
			}
		}
	}

	class AOJ0119{
		HashMap<Integer, ArrayList<Integer>> map;
		HashMap<Integer, ArrayList<Integer>> map2;
		boolean sw[];
		boolean flg;
		int m,n;
		ArrayList<Integer> result;
		void dfs(int person,int cnt){
			if(cnt==m){
				if(map2.get(person).size()!=0)return;
				flg=true;
				return;
			}
			if(flg)return;
			ArrayList<Integer> get_list = map2.get(person);
			for(int i=0;i<get_list.size();i++)if(!sw[get_list.get(i)]){
				sw[get_list.get(i)]=true;
				result.add(get_list.get(i));
				dfs(get_list.get(i),cnt+1);
				if(flg)return;
				result.remove(result.size()-1);
				sw[get_list.get(i)]=false;
			}
			if(map2.get(person).size()!=0)return;
			for(int key:map2.keySet())if(!sw[key]){
				sw[key] = true;
				result.add(key);
				dfs(key,cnt+1);
				if(flg)return;
				result.remove(result.size()-1);
				sw[key]=false;
			}
		}

		public AOJ0119() {
			map = new HashMap<Integer, ArrayList<Integer>>();
			map2 = new HashMap<Integer, ArrayList<Integer>>();
			m = in.nextInt();//
			n = in.nextInt();//
			sw = new boolean[m+1];
			result = new ArrayList<Integer>();
			for(int i=1;i<=m;i++){
				map.put(i, new ArrayList<Integer>());
				map2.put(i,new ArrayList<Integer>());
			}
			for(int i=0;i<n;i++){
				int x = in.nextInt();
				int y = in.nextInt();
				ArrayList<Integer> a = map.remove(x);a.add(y);
				map.put(x,a);
			}
			//			System.out.println(map);//deba
			for(int i=1;i<=m;i++){
				for(int s=1;s<=m;s++)if(map.get(s).contains(i)){
					ArrayList<Integer> a = map2.remove(i);a.add(s);
					map2.put(i,a);
				}
			}
			//			System.out.println(map2);//deba
			flg = false;sw[2]=true;result.add(2);
			dfs(2,1);
			for(int i=result.size()-1;i>=0;i--)System.out.println(result.get(i));
		}
	}

}

</source>
</class>

<class classid="193" nclones="2" nlines="31" similarity="100">
<source file="../hum_codes_raw/s374155861.java" startline="1" endline="35" pcid="12587">
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;
 
class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        while (true) {
            int n = sc.nextInt();
            if (n == 0)
                break;
            Map<String, Integer> items = new HashMap<String, Integer>();
            for (int i = 0; i < n; i++) {
                String s = sc.next();
                int cost = sc.nextInt();
                items.put(s, cost);
            }
            int m = sc.nextInt();
            for (int i = 0; i < m; i++) {
                String recipeName = sc.next();
                int k = sc.nextInt();
                int sum = 0;
                for (int j = 0; j < k; j++) {
                    String name = sc.next();
                    if (items.containsKey(name))
                        sum += items.get(name);
                }
                items.put(recipeName, Math.min(sum, items.get(recipeName)));
            }
            String query = sc.next();
            System.out.println(items.get(query));
        }
    }
}

</source>
<source file="../hum_codes_raw/s699620841.java" startline="1" endline="35" pcid="23531">
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while (true) {
			int n = sc.nextInt();
			if (n == 0)
				break;
			Map<String, Integer> items = new HashMap<String, Integer>();
			for (int i = 0; i < n; i++) {
				String s = sc.next();
				int cost = sc.nextInt();
				items.put(s, cost);
			}
			int m = sc.nextInt();
			for (int i = 0; i < m; i++) {
				String recipeName = sc.next();
				int k = sc.nextInt();
				int sum = 0;
				for (int j = 0; j < k; j++) {
					String name = sc.next();
					if (items.containsKey(name))
						sum += items.get(name);
				}
				items.put(recipeName, Math.min(sum, items.get(recipeName)));
			}
			String query = sc.next();
			System.out.println(items.get(query));
		}
	}
}

</source>
</class>

<class classid="194" nclones="2" nlines="152" similarity="100">
<source file="../hum_codes_raw/s376338679.java" startline="1" endline="196" pcid="12657">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

  public static void main(String[] args) {
    
    new Main().run();
  }

  public void run() {

    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      final int n = Integer.parseInt(br.readLine());
      String op;
      String[] words;
      Tree tree = new Tree();
      int t;

      for(int i=0,k=0; i<n; i++,k=0){
        words = br.readLine().split(" ");
        op  = words[k++];

        switch( op ) {
          case "insert" :
            tree.insert(Integer.parseInt(words[k]));
            break;
          case "find" :
            t = Integer.parseInt(words[k]);
            System.out.println( tree.find(t) ? "yes" : "no" );
            break;
          case "delete" :
            tree.delete(Integer.parseInt(words[k]));
            break;
          default :
            tree.dispRoundPath();
        }
      }

    }
    catch(IOException e) {
      System.out.println("IOException!");
    }
  }
}

class Tree {

  static final BTreeNode NIL = new BTreeNode(Integer.MIN_VALUE);
  BTreeNode root;
  StringBuilder buf;

  public Tree() {
    root = NIL;
    buf = new StringBuilder();
  }

  public void insert(int val) {
    BTreeNode y = NIL;
    BTreeNode x = root;
    BTreeNode z = new BTreeNode(val);

    while( !x.equals(NIL) ) {
      y = x;
      x = z.key < x.key ? x.left : x.right;
    }
    z.parent = y;

    if( y.equals(NIL) )
      root = z;
    else if( z.key < y.key )
      y.left = z;
    else
      y.right = z;
  }
  boolean find(int target) {
    BTreeNode x = root;

    while( !x.equals(NIL) ) {
      if( target == x.key )
        return true;
      else
        x = target < x.key ? x.left : x.right;
    }

    return false;
  }
  void delete(int target) {
    BTreeNode x = root;

    while( !x.equals(NIL) ) {
      if( target == x.key )
        break;
      else
        x = target < x.key ? x.left : x.right;
    }

    deleteNode(x);
  }
  void deleteNode(BTreeNode x) {

    if( x.left.equals(NIL) && x.right.equals(NIL) ) {
      int target = x.key;
      x = x.parent;
      if(x.left.key == target) x.left = NIL;
      else x.right = NIL;
    }
    else if( !x.left.equals(NIL) && !x.right.equals(NIL) ) {
      BTreeNode t = getSuccessor(x);
      x.key = t.key;
      deleteNode(t);
    }
    else {
      int target = x.key;
      BTreeNode t;
      if( !x.left.equals(NIL) ) t = x.left;
      else t = x.right;
      x = x.parent;

      if(x.left.key == target) x.left = t;
      else x.right = t;

      t.parent = x;
    }
  }
  BTreeNode getSuccessor(BTreeNode x) {
    if(!x.right.equals(NIL)) return getMinimum(x.right);

    BTreeNode p = x.parent;
    while(!p.equals(NIL) && x.equals(p.right)) {
      x = p;
      p = p.parent;
    }

    return p;
  }
  BTreeNode getMinimum(BTreeNode x) {
    while(!x.left.equals(NIL)) {
      x = x.left;
    }

    return x;
  }  
  void preParse(BTreeNode u) {
    if( !u.equals(NIL) ) {
      buf.append(" ").append(u.key);
      preParse(u.left);
      preParse(u.right);
    }
  }
  void inParse(BTreeNode u) {
    if( !u.equals(NIL) ) {
      inParse(u.left);
      buf.append(" ").append(u.key);
      inParse(u.right);
    }
  }

  void dispRoundPath() {

    inParse(root);
    buf.append("\n");
    preParse(root);
    buf.append("\n");

    System.out.print(buf);
    buf.setLength(0);
  }
}

class BTreeNode {
  int key;
  BTreeNode parent,left,right;

  public BTreeNode(int key) {
    this.key = key;
    this.parent =
    this.left =
    this.right = Tree.NIL;
  }

  @Override
  public boolean equals(Object o) {
    if(o == this) return true;
    if(o == null) return false;
    if(!(o instanceof BTreeNode)) return false;

    BTreeNode node = (BTreeNode)o;
    if(!(this.key == node.key)) return false;

    return true;
  }
}

</source>
<source file="../hum_codes_raw/s799283876.java" startline="1" endline="196" pcid="26857">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

  public static void main(String[] args) {
    
    new Main().run();
  }

  public void run() {

    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      final int n = Integer.parseInt(br.readLine());
      String op;
      String[] words;
      Tree tree = new Tree();
      int t;

      for(int i=0,k=0; i<n; i++,k=0){
        words = br.readLine().split(" ");
        op  = words[k++];

        switch( op ) {
          case "insert" :
            tree.insert(Integer.parseInt(words[k]));
            break;
          case "find" :
            t = Integer.parseInt(words[k]);
            System.out.println( tree.find(t) ? "yes" : "no" );
            break;
          case "delete" :
            tree.delete(Integer.parseInt(words[k]));
            break;
          default :
            tree.dispRoundPath();
        }
      }

    }
    catch(IOException e) {
      System.out.println("IOException!");
    }
  }
}

class Tree {

  static final BTreeNode NIL = new BTreeNode(Integer.MIN_VALUE);
  BTreeNode root;
  StringBuilder buf;

  public Tree() {
    root = NIL;
    buf = new StringBuilder();
  }

  public void insert(int val) {
    BTreeNode y = NIL;
    BTreeNode x = root;
    BTreeNode z = new BTreeNode(val);

    while( !x.equals(NIL) ) {
      y = x;
      x = z.key < x.key ? x.left : x.right;
    }
    z.parent = y;

    if( y.equals(NIL) )
      root = z;
    else if( z.key < y.key )
      y.left = z;
    else
      y.right = z;
  }
  boolean find(int target) {
    BTreeNode x = root;

    while( !x.equals(NIL) ) {
      if( target == x.key )
        return true;
      else
        x = target < x.key ? x.left : x.right;
    }

    return false;
  }
  void delete(int target) {
    BTreeNode x = root;

    while( !x.equals(NIL) ) {
      if( target == x.key )
        break;
      else
        x = target < x.key ? x.left : x.right;
    }

    deleteNode(x);
  }
  void deleteNode(BTreeNode x) {

    if( x.left.equals(NIL) && x.right.equals(NIL) ) {
      int target = x.key;
      x = x.parent;
      if(x.left.key == target) x.left = NIL;
      else x.right = NIL;
    }
    else if( !x.left.equals(NIL) && !x.right.equals(NIL) ) {
      BTreeNode t = getSuccessor(x);
      x.key = t.key;
      deleteNode(t);
    }
    else {
      int target = x.key;
      BTreeNode t;
      if( !x.left.equals(NIL) ) t = x.left;
      else t = x.right;
      x = x.parent;

      if(x.left.key == target) x.left = t;
      else x.right = t;

      t.parent = x;
    }
  }
  BTreeNode getSuccessor(BTreeNode x) {
    if(!x.right.equals(NIL)) return getMinimum(x.right);

    BTreeNode p = x.parent;
    while(!p.equals(NIL) && x.equals(p.right)) {
      x = p;
      p = p.parent;
    }

    return p;
  }
  BTreeNode getMinimum(BTreeNode x) {
    while(!x.left.equals(NIL)) {
      x = x.left;
    }

    return x;
  }  
  void preParse(BTreeNode u) {
    if( !u.equals(NIL) ) {
      buf.append(" ").append(u.key);
      preParse(u.left);
      preParse(u.right);
    }
  }
  void inParse(BTreeNode u) {
    if( !u.equals(NIL) ) {
      inParse(u.left);
      buf.append(" ").append(u.key);
      inParse(u.right);
    }
  }

  void dispRoundPath() {

    inParse(root);
    buf.append("\n");
    preParse(root);
    buf.append("\n");

    System.out.print(buf);
    buf.setLength(0);
  }
}

class BTreeNode {
  int key;
  BTreeNode parent,left,right;

  public BTreeNode(int key) {
    this.key = key;
    this.parent =
    this.left =
    this.right = Tree.NIL;
  }

  @Override
  public boolean equals(Object o) {
    if(o == this) return true;
    if(o == null) return false;
    if(!(o instanceof BTreeNode)) return false;

    BTreeNode node = (BTreeNode)o;
    if(!(this.key == node.key)) return false;

    return true;
  }
}

</source>
</class>

<class classid="195" nclones="2" nlines="18" similarity="100">
<source file="../hum_codes_raw/s379155896.java" startline="1" endline="23" pcid="12746">
import java.util.Scanner;

class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		
		int ans = 1;
		int now = 1;
		
		for(int i = 0; i < n; i++) {
			if(sc.nextInt() == 1) now++;
			else {
				ans = Math.max(ans, now);
				now = 1;
			}
		}
		ans = Math.max(ans,now);
		
		System.out.println(ans);
	}
}

</source>
<source file="../hum_codes_raw/s541624732.java" startline="1" endline="22" pcid="18228">
import java.util.Scanner;
 
class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
         
        int ans = 1;
        int now = 1;
         
        for(int i = 0; i < n; i++) {
            if(sc.nextInt() == 1) now++;
            else {
                ans = Math.max(ans, now);
                now = 1;
            }
        }
        ans = Math.max(ans,now);
        System.out.println(ans);
    }
}

</source>
</class>

<class classid="196" nclones="2" nlines="25" similarity="100">
<source file="../hum_codes_raw/s384917989.java" startline="1" endline="31" pcid="12943">
import java.util.Scanner;

public class Main {
	public static void main(String args[]) {
		
		try(Scanner scan = new Scanner(System.in)){

			int n = scan.nextInt();
			int[] array = new int[n];
			for(int i=0; i<n; i++) {
				array[i] = scan.nextInt();
			}
			
			int dice = 0;
			int counter = 0; 
			
			for(int i=0; i<array.length; i++) {

				if(array[i] == 1) {
					counter++;
				}else {
					dice = Math.max(dice, counter);
					counter = 0;
				}
			}
			dice = Math.max(dice, counter);
			System.out.println(dice+1);
		}
	}
}

</source>
<source file="../hum_codes_raw/s699958608.java" startline="1" endline="31" pcid="23541">
import java.util.Scanner;

public class Main {
	public static void main(String args[]) {
		
		try(Scanner scan = new Scanner(System.in)){

			int n = scan.nextInt();
			int[] array = new int[n];
			for(int i=0; i<n; i++) {
				array[i] = scan.nextInt();
			}
			
			int dice = 0;
			int counter = 0; 
			
			for(int i=0; i<array.length; i++) {

				if(array[i] == 1) {
					counter++;
				}else {
					dice = Math.max(dice, counter);
					counter = 0;
				}
			}
			dice = Math.max(dice, counter);
			System.out.println(dice+1);
		}
	}
}

</source>
</class>

<class classid="197" nclones="2" nlines="31" similarity="100">
<source file="../hum_codes_raw/s385381357.java" startline="1" endline="33" pcid="12959">
// 2717 
import java.util.Scanner;
public class Main{
    
    public void solve(){
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        for(int cnt=0;cnt<N;cnt++){
            int x = sc.nextInt();
            int y = sc.nextInt();
            int b = sc.nextInt();
            int p = sc.nextInt();
            int gokei=x*b+y*p;
            if(b<5){
                b=5;
            }
            if(p<2){
                p=2;
            }
            int waribikigo=(x*b+y*p)*8/10;
            if(gokei>=waribikigo){
                System.out.println(waribikigo);
            }else{
                System.out.println(gokei);
            }
        }
    }
    public static void main(String[]args){
        Main obj = new Main();
        obj.solve();
    }
}

</source>
<source file="../hum_codes_raw/s689084658.java" startline="1" endline="33" pcid="23163">
// 2717 
import java.util.Scanner;
public class Main{
    
    public void solve(){
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        for(int cnt=0;cnt<N;cnt++){
            int x = sc.nextInt();
            int y = sc.nextInt();
            int b = sc.nextInt();
            int p = sc.nextInt();
            int gokei=x*b+y*p;
            if(b<5){
                b=5;
            }
            if(p<2){
                p=2;
            }
            int waribikigo=(x*b+y*p)*8/10;
            if(gokei>=waribikigo){
                System.out.println(waribikigo);
            }else{
                System.out.println(gokei);
            }
        }
    }
    public static void main(String[]args){
        Main obj = new Main();
        obj.solve();
    }
}

</source>
</class>

<class classid="198" nclones="3" nlines="97" similarity="100">
<source file="../hum_codes_raw/s388764829.java" startline="1" endline="173" pcid="13070">
/*import java.util.*;
import java.io.*;
import java.lang.*;
public class test{
	static double res=0;
	public static void help(int p,int r,int n){
		double tmp=p;
		for(int i=1;i<=n;i++){
			double x=1+(double)r/1200 ;
			tmp*=x;
		}
		res+=tmp;
		int k=100000,m=360;
		for(int i=m;i>0;i--){
			help(k,5,i);
		}
		System.out.println("paid amount "+k*m+" ");
		System.out.println((long)res);
	}
	public static void main(String[] args){
		Scanner s=new Scanner(System.in);
	    int n=s.nextInt();
		int[] arr=new int[n];
		for(int i=0;i<n;i++){
			arr[i]=s.nextInt();
		}
		long[] dp1=new long[n];
		long[] dp2=new long[n];
		if(arr[0]>0){dp1[0]=1;}
		else{dp2[0]=1;}
		long pos=dp1[0],neg=dp2[0];
		for(int i=1;i<n;i++){
			if(arr[i]>0){
				dp1[i]=dp1[i-1]+1;
				dp2[i]=dp2[i-1];
			}
			else{
				dp1[i]=dp2[i-1];
				dp2[i]=dp1[i-1]+1;
			}
			pos+=dp1[i];
			neg+=dp2[i];
		}
		System.out.println(neg+" "+pos);
	}
}			
	

*/
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskB solver = new TaskB();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskB {
        static final long MODULO = 998244353;

        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int n = in.nextInt();
            String s = in.next();
            int[][] pos = new int[3][n];
            int[] cnt = new int[3];
            for (int i = 0; i < s.length(); ++i) {
                int what = "RGB".indexOf(s.charAt(i));
                pos[what][cnt[what]++] = i;
            }
            int[] val = new int[s.length()];
            int[] minusOneType = new int[s.length()];
            Arrays.fill(minusOneType, -1);
            Arrays.fill(val, -2);
            Arrays.fill(cnt, 0);
            for (int i = 0; i < s.length(); ++i)
                if (val[i] == -2) {
                    val[i] = -1;
                    int what = "RGB".indexOf(s.charAt(i));
                    int p1 = -1;
                    int p2 = -1;
                    for (int j = 0; j < 3; ++j)
                        if (j != what) {
                            while (val[pos[j][cnt[j]]] != -2) ++cnt[j];
                            if (p1 < 0) p1 = pos[j][cnt[j]];
                            else p2 = pos[j][cnt[j]];
                        }
                    val[Math.min(p1, p2)] = 0;
                    minusOneType[Math.min(p1, p2)] = what;
                    val[Math.max(p1, p2)] = 1;
                }
            long res = 1;
            for (int i = 1; i <= n; ++i) {
                res = res * i % MODULO;
            }
            Arrays.fill(cnt, 0);
            for (int i = 0; i < s.length(); ++i) {
                int what = "RGB".indexOf(s.charAt(i));
                if (val[i] == -1) ++cnt[what];
                if (val[i] == 0) {
                    int need = minusOneType[i];
                    res = res * cnt[need]-- % MODULO;
                }
            }
            Arrays.fill(cnt, 0);
            for (int i = s.length() - 1; i >= 0; --i) {
                int what = "RGB".indexOf(s.charAt(i));
                if (val[i] == 1) ++cnt[what];
                if (val[i] == 0) {
                    int need = 3 - what - minusOneType[i];
                    res = res * cnt[need]-- % MODULO;
                }
            }
            out.println(res);
        }

    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

    }
}












</source>
<source file="../hum_codes_raw/s414697717.java" startline="1" endline="114" pcid="13940">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskB solver = new TaskB();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskB {
        static final long MODULO = 998244353;

        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int n = in.nextInt();
            String s = in.next();
            int[][] pos = new int[3][n];
            int[] cnt = new int[3];
            for (int i = 0; i < s.length(); ++i) {
                int what = "RGB".indexOf(s.charAt(i));
                pos[what][cnt[what]++] = i;
            }
            int[] val = new int[s.length()];
            int[] minusOneType = new int[s.length()];
            Arrays.fill(minusOneType, -1);
            Arrays.fill(val, -2);
            Arrays.fill(cnt, 0);
            for (int i = 0; i < s.length(); ++i)
                if (val[i] == -2) {
                    val[i] = -1;
                    int what = "RGB".indexOf(s.charAt(i));
                    int p1 = -1;
                    int p2 = -1;
                    for (int j = 0; j < 3; ++j)
                        if (j != what) {
                            while (val[pos[j][cnt[j]]] != -2) ++cnt[j];
                            if (p1 < 0) p1 = pos[j][cnt[j]];
                            else p2 = pos[j][cnt[j]];
                        }
                    val[Math.min(p1, p2)] = 0;
                    minusOneType[Math.min(p1, p2)] = what;
                    val[Math.max(p1, p2)] = 1;
                }
            long res = 1;
            for (int i = 1; i <= n; ++i) {
                res = res * i % MODULO;
            }
            Arrays.fill(cnt, 0);
            for (int i = 0; i < s.length(); ++i) {
                int what = "RGB".indexOf(s.charAt(i));
                if (val[i] == -1) ++cnt[what];
                if (val[i] == 0) {
                    int need = minusOneType[i];
                    res = res * cnt[need]-- % MODULO;
                }
            }
            Arrays.fill(cnt, 0);
            for (int i = s.length() - 1; i >= 0; --i) {
                int what = "RGB".indexOf(s.charAt(i));
                if (val[i] == 1) ++cnt[what];
                if (val[i] == 0) {
                    int need = 3 - what - minusOneType[i];
                    res = res * cnt[need]-- % MODULO;
                }
            }
            out.println(res);
        }

    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

    }
}


</source>
<source file="../hum_codes_raw/s767521242.java" startline="1" endline="173" pcid="25770">
/*import java.util.*;
import java.io.*;
import java.lang.*;
public class test{
	static double res=0;
	public static void help(int p,int r,int n){
		double tmp=p;
		for(int i=1;i<=n;i++){
			double x=1+(double)r/1200 ;
			tmp*=x;
		}
		res+=tmp;
		int k=100000,m=360;
		for(int i=m;i>0;i--){
			help(k,5,i);
		}
		System.out.println("paid amount "+k*m+" ");
		System.out.println((long)res);
	}
	public static void main(String[] args){
		Scanner s=new Scanner(System.in);
	    int n=s.nextInt();
		int[] arr=new int[n];
		for(int i=0;i<n;i++){
			arr[i]=s.nextInt();
		}
		long[] dp1=new long[n];
		long[] dp2=new long[n];
		if(arr[0]>0){dp1[0]=1;}
		else{dp2[0]=1;}
		long pos=dp1[0],neg=dp2[0];
		for(int i=1;i<n;i++){
			if(arr[i]>0){
				dp1[i]=dp1[i-1]+1;
				dp2[i]=dp2[i-1];
			}
			else{
				dp1[i]=dp2[i-1];
				dp2[i]=dp1[i-1]+1;
			}
			pos+=dp1[i];
			neg+=dp2[i];
		}
		System.out.println(neg+" "+pos);
	}
}			
	

*/
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.StringTokenizer;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskB solver = new TaskB();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskB {
        static final long MODULO = 998244353;

        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int n = in.nextInt();
            String s = in.next();
            int[][] pos = new int[3][n];
            int[] cnt = new int[3];
            for (int i = 0; i < s.length(); ++i) {
                int what = "RGB".indexOf(s.charAt(i));
                pos[what][cnt[what]++] = i;
            }
            int[] val = new int[s.length()];
            int[] minusOneType = new int[s.length()];
            Arrays.fill(minusOneType, -1);
            Arrays.fill(val, -2);
            Arrays.fill(cnt, 0);
            for (int i = 0; i < s.length(); ++i)
                if (val[i] == -2) {
                    val[i] = -1;
                    int what = "RGB".indexOf(s.charAt(i));
                    int p1 = -1;
                    int p2 = -1;
                    for (int j = 0; j < 3; ++j)
                        if (j != what) {
                            while (val[pos[j][cnt[j]]] != -2) ++cnt[j];
                            if (p1 < 0) p1 = pos[j][cnt[j]];
                            else p2 = pos[j][cnt[j]];
                        }
                    val[Math.min(p1, p2)] = 0;
                    minusOneType[Math.min(p1, p2)] = what;
                    val[Math.max(p1, p2)] = 1;
                }
            long res = 1;
            for (int i = 1; i <= n; ++i) {
                res = res * i % MODULO;
            }
            Arrays.fill(cnt, 0);
            for (int i = 0; i < s.length(); ++i) {
                int what = "RGB".indexOf(s.charAt(i));
                if (val[i] == -1) ++cnt[what];
                if (val[i] == 0) {
                    int need = minusOneType[i];
                    res = res * cnt[need]-- % MODULO;
                }
            }
            Arrays.fill(cnt, 0);
            for (int i = s.length() - 1; i >= 0; --i) {
                int what = "RGB".indexOf(s.charAt(i));
                if (val[i] == 1) ++cnt[what];
                if (val[i] == 0) {
                    int need = 3 - what - minusOneType[i];
                    res = res * cnt[need]-- % MODULO;
                }
            }
            out.println(res);
        }

    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

    }
}












</source>
</class>

<class classid="199" nclones="2" nlines="33" similarity="100">
<source file="../hum_codes_raw/s390338757.java" startline="1" endline="37" pcid="13121">
import java.util.Scanner;
public class Main {
 
    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int m=sc.nextInt();
        int[] fpoint=new int[n];
        int[] tage=new int[m];
        int[][] who=new int[m][n];
        for(int i=0;i<m;i++){
             tage[i]=sc.nextInt();
        }
        for(int j=0;j<m;j++){
            for(int i=0;i<n;i++){
                who[j][i]=sc.nextInt();
            }
        }
        sc.close();
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(tage[i]==who[i][j]){
                    fpoint[j]++;
                }else{
                    fpoint[tage[i]-1]++;
                }
 
            }
        }
 
        for(int i=0;i<n;i++){
            System.out.printf("%d\n", fpoint[i]);
            }
        }
 
}

</source>
<source file="../hum_codes_raw/s446577061.java" startline="1" endline="39" pcid="14961">
import java.util.Scanner;
public class Main {

	public static void main(String[] args) {
		// TODO ?????????????????????????????????????????????
		Scanner sc=new Scanner(System.in);
		int n=sc.nextInt();
		int m=sc.nextInt();
		int[] fpoint=new int[n];
		int[] tage=new int[m];
		int[][] who=new int[m][n];
		for(int i=0;i<m;i++){
			 tage[i]=sc.nextInt();
		}
		for(int j=0;j<m;j++){
			for(int i=0;i<n;i++){
				who[j][i]=sc.nextInt();
			}
		}
		sc.close();
		for(int i=0;i<m;i++){
			for(int j=0;j<n;j++){
				if(tage[i]==who[i][j]){
					fpoint[j]++;
				}else{
					fpoint[tage[i]-1]++;
				}

			}
		}

		for(int i=0;i<n;i++){
			System.out.printf("%d\n", fpoint[i]);
			//System.out.printf("%d\n", n);
			}
		}

}

</source>
</class>

<class classid="200" nclones="2" nlines="12" similarity="100">
<source file="../hum_codes_raw/s391050410.java" startline="1" endline="15" pcid="13145">
import java.math.BigInteger;
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			BigInteger b = sc.nextBigInteger();
			if(b.intValue()==-1)break;
			System.out.println(b.toString(4));
		}
	}
}

</source>
<source file="../hum_codes_raw/s590993918.java" startline="1" endline="16" pcid="19826">
import java.math.BigInteger;
import java.util.Scanner;

//A King in Hawaii
public class Main{

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			BigInteger b = sc.nextBigInteger();
			if(b.intValue()==-1)break;
			System.out.println(b.toString(4));
		}
	}
}

</source>
</class>

<class classid="201" nclones="2" nlines="158" similarity="100">
<source file="../hum_codes_raw/s395339830.java" startline="1" endline="205" pcid="13293">
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.NoSuchElementException;
import java.util.TreeMap;

/*
                   _ooOoo_
                  o8888888o
                  88" . "88
                  (| -_- |)
                  O\  =  /O
               ____/`---'\____
             .'  \\|     |//  `.
            /  \\|||  :  |||//  \
           /  _||||| -:- |||||-  \
           |   | \\\  -  /// |   |
           | \_|  ''\---/''  |   |
           \  .-\__  `-`  ___/-. /
         ___`. .'  /--.--\  `. . __
      ."" '<  `.___\_<|>_/___.'  >'"".
     | | :  `- \`.;`\ _ /`;.`/ - ` : | |
     \  \ `-.   \_ __\ /__ _/   .-` /  /
======`-.____`-.___\_____/___.-`____.-'======
                   `=---='
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            pass System Test!
*/

public class Main {

  private static class Task {
    int MOD = (int) (1e9 + 7);

    TreeMap<Long, TreeMap<Long, Long>> dp = new TreeMap<>();

    long func(long S, long X) {
      if (S == 0) return 1;
      TreeMap<Long, Long> d = dp.get(S);
      if (d == null) dp.put(S, d = new TreeMap<>());
      else {
        Long ans = d.get(X);
        if (ans != null) return ans;
      }
      long ans = func(S / 2, X / 2) % MOD;
      ans = (ans + func((S - 1) / 2, (X - 1) / 2)) % MOD;
      if (S >= 2) ans = (ans + func((S - 2) / 2, X / 2)) % MOD;
      d.put(X, ans);
      return ans;
    }

    void solve(FastScanner in, PrintWriter out) throws Exception {

      long N = in.nextLong();
      out.println(func(N, N));
    }
  }

  /**
   * 
   */
  public static void main(String[] args) throws Exception {
    OutputStream outputStream = System.out;
    FastScanner in = new FastScanner();
    PrintWriter out = new PrintWriter(outputStream);
    Task solver = new Task();
    solver.solve(in, out);
    out.close();
  }
  private static class FastScanner {
    private final InputStream in = System.in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int bufferLength = 0;

    private boolean hasNextByte() {
      if (ptr < bufferLength) {
        return true;
      } else {
        ptr = 0;
        try {
          bufferLength = in.read(buffer);
        } catch (IOException e) {
          e.printStackTrace();
        }
        if (bufferLength <= 0) {
          return false;
        }
      }
      return true;
    }

    private int readByte() {
      if (hasNextByte()) return buffer[ptr++];
      else return -1;
    }

    private static boolean isPrintableChar(int c) {
      return 33 <= c && c <= 126;
    }

    private void skipUnprintable() {
      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
    }

    boolean hasNext() {
      skipUnprintable();
      return hasNextByte();
    }

    public String next() {
      if (!hasNext()) throw new NoSuchElementException();
      StringBuilder sb = new StringBuilder();
      int b = readByte();
      while (isPrintableChar(b)) {
        sb.appendCodePoint(b);
        b = readByte();
      }
      return sb.toString();
    }

    long nextLong() {
      if (!hasNext()) throw new NoSuchElementException();
      long n = 0;
      boolean minus = false;
      int b = readByte();
      if (b == '-') {
        minus = true;
        b = readByte();
      }
      if (b < '0' || '9' < b) {
        throw new NumberFormatException();
      }
      while (true) {
        if ('0' <= b && b <= '9') {
          n *= 10;
          n += b - '0';
        } else if (b == -1 || !isPrintableChar(b)) {
          return minus ? -n : n;
        } else {
          throw new NumberFormatException();
        }
        b = readByte();
      }
    }

    double nextDouble() {
      return Double.parseDouble(next());
    }

    double[] nextDoubleArray(int n) {
      double[] array = new double[n];
      for (int i = 0; i < n; i++) {
        array[i] = nextDouble();
      }
      return array;
    }

    double[][] nextDoubleMap(int n, int m) {
      double[][] map = new double[n][];
      for (int i = 0; i < n; i++) {
        map[i] = nextDoubleArray(m);
      }
      return map;
    }

    public int nextInt() {
      return (int) nextLong();
    }

    public int[] nextIntArray(int n) {
      int[] array = new int[n];
      for (int i = 0; i < n; i++) array[i] = nextInt();
      return array;
    }

    public long[] nextLongArray(int n) {
      long[] array = new long[n];
      for (int i = 0; i < n; i++) array[i] = nextLong();
      return array;
    }

    public String[] nextStringArray(int n) {
      String[] array = new String[n];
      for (int i = 0; i < n; i++) array[i] = next();
      return array;
    }

    public char[][] nextCharMap(int n) {
      char[][] array = new char[n][];
      for (int i = 0; i < n; i++) array[i] = next().toCharArray();
      return array;
    }

    public int[][] nextIntMap(int n, int m) {
      int[][] map = new int[n][];
      for (int i = 0; i < n; i++) {
        map[i] = nextIntArray(m);
      }
      return map;
    }
  }
}

</source>
<source file="../hum_codes_raw/s862939736.java" startline="1" endline="205" pcid="29021">
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.NoSuchElementException;
import java.util.TreeMap;

/*
                   _ooOoo_
                  o8888888o
                  88" . "88
                  (| -_- |)
                  O\  =  /O
               ____/`---'\____
             .'  \\|     |//  `.
            /  \\|||  :  |||//  \
           /  _||||| -:- |||||-  \
           |   | \\\  -  /// |   |
           | \_|  ''\---/''  |   |
           \  .-\__  `-`  ___/-. /
         ___`. .'  /--.--\  `. . __
      ."" '<  `.___\_<|>_/___.'  >'"".
     | | :  `- \`.;`\ _ /`;.`/ - ` : | |
     \  \ `-.   \_ __\ /__ _/   .-` /  /
======`-.____`-.___\_____/___.-`____.-'======
                   `=---='
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            pass System Test!
*/

public class Main {

  private static class Task {
    int MOD = (int) (1e9 + 7);

    TreeMap<Long, TreeMap<Long, Long>> dp = new TreeMap<>();

    long func(long S, long X) {
      if (S == 0) return 1;
      TreeMap<Long, Long> d = dp.get(S);
      if (d == null) dp.put(S, d = new TreeMap<>());
      else {
        Long ans = d.get(X);
        if (ans != null) return ans;
      }
      long ans = func(S / 2, X / 2) % MOD;
      ans = (ans + func((S - 1) / 2, (X - 1) / 2)) % MOD;
      if (S >= 2) ans = (ans + func((S - 2) / 2, X / 2)) % MOD;
      d.put(X, ans);
      return ans;
    }

    void solve(FastScanner in, PrintWriter out) throws Exception {

      long N = in.nextLong();
      out.println(func(N, N));
    }
  }

  /**
   * 
   */
  public static void main(String[] args) throws Exception {
    OutputStream outputStream = System.out;
    FastScanner in = new FastScanner();
    PrintWriter out = new PrintWriter(outputStream);
    Task solver = new Task();
    solver.solve(in, out);
    out.close();
  }
  private static class FastScanner {
    private final InputStream in = System.in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int bufferLength = 0;

    private boolean hasNextByte() {
      if (ptr < bufferLength) {
        return true;
      } else {
        ptr = 0;
        try {
          bufferLength = in.read(buffer);
        } catch (IOException e) {
          e.printStackTrace();
        }
        if (bufferLength <= 0) {
          return false;
        }
      }
      return true;
    }

    private int readByte() {
      if (hasNextByte()) return buffer[ptr++];
      else return -1;
    }

    private static boolean isPrintableChar(int c) {
      return 33 <= c && c <= 126;
    }

    private void skipUnprintable() {
      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
    }

    boolean hasNext() {
      skipUnprintable();
      return hasNextByte();
    }

    public String next() {
      if (!hasNext()) throw new NoSuchElementException();
      StringBuilder sb = new StringBuilder();
      int b = readByte();
      while (isPrintableChar(b)) {
        sb.appendCodePoint(b);
        b = readByte();
      }
      return sb.toString();
    }

    long nextLong() {
      if (!hasNext()) throw new NoSuchElementException();
      long n = 0;
      boolean minus = false;
      int b = readByte();
      if (b == '-') {
        minus = true;
        b = readByte();
      }
      if (b < '0' || '9' < b) {
        throw new NumberFormatException();
      }
      while (true) {
        if ('0' <= b && b <= '9') {
          n *= 10;
          n += b - '0';
        } else if (b == -1 || !isPrintableChar(b)) {
          return minus ? -n : n;
        } else {
          throw new NumberFormatException();
        }
        b = readByte();
      }
    }

    double nextDouble() {
      return Double.parseDouble(next());
    }

    double[] nextDoubleArray(int n) {
      double[] array = new double[n];
      for (int i = 0; i < n; i++) {
        array[i] = nextDouble();
      }
      return array;
    }

    double[][] nextDoubleMap(int n, int m) {
      double[][] map = new double[n][];
      for (int i = 0; i < n; i++) {
        map[i] = nextDoubleArray(m);
      }
      return map;
    }

    public int nextInt() {
      return (int) nextLong();
    }

    public int[] nextIntArray(int n) {
      int[] array = new int[n];
      for (int i = 0; i < n; i++) array[i] = nextInt();
      return array;
    }

    public long[] nextLongArray(int n) {
      long[] array = new long[n];
      for (int i = 0; i < n; i++) array[i] = nextLong();
      return array;
    }

    public String[] nextStringArray(int n) {
      String[] array = new String[n];
      for (int i = 0; i < n; i++) array[i] = next();
      return array;
    }

    public char[][] nextCharMap(int n) {
      char[][] array = new char[n][];
      for (int i = 0; i < n; i++) array[i] = next().toCharArray();
      return array;
    }

    public int[][] nextIntMap(int n, int m) {
      int[][] map = new int[n][];
      for (int i = 0; i < n; i++) {
        map[i] = nextIntArray(m);
      }
      return map;
    }
  }
}

</source>
</class>

<class classid="202" nclones="2" nlines="117" similarity="100">
<source file="../hum_codes_raw/s400496604.java" startline="1" endline="135" pcid="13478">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.IOException;
import java.util.InputMismatchException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;
 
/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskD solver = new TaskD();
        solver.solve(1, in, out);
        out.close();
    }
 
    static class TaskD {
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int n = in.nextInt();
            long[] x = new long[n];
            long[] y = new long[n];
            for (int i = 0; i < n; i++) {
                x[i] = in.nextLong();
                y[i] = in.nextLong();
            }
 
            boolean isAllOdd = true;
            boolean isAllEven = true;
            for (int i = 0; i < n; i++) {
                if ((x[i] + y[i]) % 2 == 0) isAllOdd = false;
                else isAllEven = false;
            }
 
            if (!(isAllOdd ^ isAllEven)) {
                out.println(-1);
                return;
            }
 
            if (isAllEven) {
                for (int i = 0; i < n; i++) {
                    x[i] -= 1;
                }
            }
 
            for (int i = 0; i < n; i++) {
                long tmpX = x[i];
                long tmpY = y[i];
                x[i] = tmpX - tmpY;
                y[i] = tmpX + tmpY;
            }
 
            if (isAllEven) {
                out.println(38);
                out.print("1 ");
            } else {
                out.println(37);
            }
            for (int i = 0; i < 37; i++) {
                if (i > 0) out.print(" ");
                out.print(1L << 36 - i);
            }
            out.println();
 
            for (int i = 0; i < n; i++) {
                if (isAllEven) out.print("R");
 
                for (int j = 36; j >= 0; j--) {
                    if (x[i] > 0) {
                        if (y[i] > 0) {
                            out.print("R");
                            y[i] -= 1L << j;
                        } else {
                            out.print("D");
                            y[i] += 1L << j;
                        }
                        x[i] -= 1L << j;
                    } else {
                        if (y[i] > 0) {
                            out.print("U");
                            y[i] -= 1L << j;
                        } else {
                            out.print("L");
                            y[i] += 1L << j;
                        }
                        x[i] += 1L << j;
                    }
                }
 
                out.println();
            }
        }
 
    }
 
    static class InputReader {
        private BufferedReader br;
        private StringTokenizer st;
 
        public InputReader(InputStream inputStream) {
            br = new BufferedReader(new InputStreamReader(inputStream));
            st = new StringTokenizer("");
        }
 
        public String nextString() {
            while (!st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(br.readLine(), " ");
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
            }
            return st.nextToken();
        }
 
        public int nextInt() {
            return Integer.parseInt(nextString());
        }
 
        public long nextLong() {
            return Long.parseLong(nextString());
        }
 
    }
}

</source>
<source file="../hum_codes_raw/s766389190.java" startline="1" endline="136" pcid="25737">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.IOException;
import java.util.InputMismatchException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskD solver = new TaskD();
        solver.solve(1, in, out);
        out.close();
    }

    static class TaskD {
        public void solve(int testNumber, InputReader in, PrintWriter out) {
            int n = in.nextInt();
            long[] x = new long[n];
            long[] y = new long[n];
            for (int i = 0; i < n; i++) {
                x[i] = in.nextLong();
                y[i] = in.nextLong();
            }

            boolean isAllOdd = true;
            boolean isAllEven = true;
            for (int i = 0; i < n; i++) {
                if ((x[i] + y[i]) % 2 == 0) isAllOdd = false;
                else isAllEven = false;
            }

            if (!(isAllOdd ^ isAllEven)) {
                out.println(-1);
                return;
            }

            if (isAllEven) {
                for (int i = 0; i < n; i++) {
                    x[i] -= 1;
                }
            }

            for (int i = 0; i < n; i++) {
                long tmpX = x[i];
                long tmpY = y[i];
                x[i] = tmpX - tmpY;
                y[i] = tmpX + tmpY;
            }

            if (isAllEven) {
                out.println(38);
                out.print("1 ");
            } else {
                out.println(37);
            }
            for (int i = 0; i < 37; i++) {
                if (i > 0) out.print(" ");
                out.print(1L << 36 - i);
            }
            out.println();

            for (int i = 0; i < n; i++) {
                if (isAllEven) out.print("R");

                for (int j = 36; j >= 0; j--) {
                    if (x[i] > 0) {
                        if (y[i] > 0) {
                            out.print("R");
                            y[i] -= 1L << j;
                        } else {
                            out.print("D");
                            y[i] += 1L << j;
                        }
                        x[i] -= 1L << j;
                    } else {
                        if (y[i] > 0) {
                            out.print("U");
                            y[i] -= 1L << j;
                        } else {
                            out.print("L");
                            y[i] += 1L << j;
                        }
                        x[i] += 1L << j;
                    }
                }

                out.println();
            }
        }

    }

    static class InputReader {
        private BufferedReader br;
        private StringTokenizer st;

        public InputReader(InputStream inputStream) {
            br = new BufferedReader(new InputStreamReader(inputStream));
            st = new StringTokenizer("");
        }

        public String nextString() {
            while (!st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(br.readLine(), " ");
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
            }
            return st.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(nextString());
        }

        public long nextLong() {
            return Long.parseLong(nextString());
        }

    }
}


</source>
</class>

<class classid="203" nclones="2" nlines="31" similarity="100">
<source file="../hum_codes_raw/s401410685.java" startline="1" endline="39" pcid="13519">
import java.util.*;

public class Main{
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		int n = Integer.parseInt(sc.nextLine());

		while(n-- > 0){
			char[] s = sc.nextLine().toCharArray();
			for(int i=0;i<s.length;i++) s[i] -= 'a';

			String aft = "";

			for(int a=1;aft.equals("");a++){
				if(gcd(a,26) != 1) continue;
				for(int b=0;b<26;b++){
					for(int i=0;i<s.length;i++){
						if(0<=s[i] && s[i]<26){
							aft += (char)((a * s[i] + b) % 26 + 'a');
						}
						else{
							aft += (char)(s[i] + 'a');
						}
					}

					if(aft.contains("that") || aft.contains("this")) break;
					aft = "";
				}
			}

			System.out.println(aft);
		}
	}

	private static int gcd(int a,int b){
		return b==0 ? a : gcd(b,a%b);
	}
}

</source>
<source file="../hum_codes_raw/s807880419.java" startline="1" endline="39" pcid="27147">
import java.util.*;
 
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = Integer.parseInt(sc.nextLine());
 
        while(n-- > 0){
            char[] s = sc.nextLine().toCharArray();
            for(int i=0;i<s.length;i++) s[i] -= 'a';
 
            String aft = "";
 
            for(int a=1;aft.equals("");a++){
                if(gcd(a,26) != 1) continue;
                for(int b=0;b<26;b++){
                    for(int i=0;i<s.length;i++){
                        if(0<=s[i] && s[i]<26){
                            aft += (char)((a * s[i] + b) % 26 + 'a');
                        }
                        else{
                            aft += (char)(s[i] + 'a');
                        }
                    }
 
                    if(aft.contains("that") || aft.contains("this")) break;
                    aft = "";
                }
            }
 
            System.out.println(aft);
        }
    }
 
    private static int gcd(int a,int b){
        return b==0 ? a : gcd(b,a%b);
    }
}

</source>
</class>

<class classid="204" nclones="2" nlines="185" similarity="100">
<source file="../hum_codes_raw/s405233405.java" startline="1" endline="259" pcid="13648">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.PriorityQueue;
import java.util.InputMismatchException;
import java.io.IOException;
import java.util.AbstractCollection;
import java.util.Comparator;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author KharYusuf
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "KharYusuf", 1 << 27);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastReader in = new FastReader(inputStream);
            PrintWriter out = new PrintWriter(outputStream);
            FPondSkater solver = new FPondSkater();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class FPondSkater {
        int[] dx = {1, -1, 0, 0};
        int[] dy = {0, 0, 1, -1};

        public void solve(int testNumber, FastReader s, PrintWriter w) {
            int h = s.nextInt(), wi = s.nextInt(), k = s.nextInt();
            int x1 = s.nextInt() - 1, y1 = s.nextInt() - 1, x2 = s.nextInt() - 1, y2 = s.nextInt() - 1;
            char[][] c = new char[h][];
            for (int i = 0; i < h; i++) c[i] = s.next().toCharArray();
            PriorityQueue<pair<pair<Integer, Integer>, dist>> l = new PriorityQueue<>(new Comparator<pair<pair<Integer, Integer>, dist>>() {

                public int compare(pair<pair<Integer, Integer>, dist> o1, pair<pair<Integer, Integer>, dist> o2) {
                    return Integer.compare(o1.y.z, o2.y.z);
                }
            });
            int[][][] dis = new int[h][wi][4];
            for (int i = 0; i < h; i++) {
                for (int j = 0; j < wi; j++) Arrays.fill(dis[i][j], Integer.MAX_VALUE);
            }
            for (int i = 0; i < 4; i++) {
                l.add(new pair<>(new pair<>(x1, y1), new dist(i, k, 0)));
                dis[x1][y1][i] = 0;
            }
            while (!l.isEmpty()) {
                pair<pair<Integer, Integer>, dist> cur = l.poll();
                if (cur.y.z != dis[cur.x.x][cur.x.y][cur.y.x]) continue;
                for (int i = 0; i < 4; i++) {
                    int xx = cur.x.x + dx[i], yy = cur.x.y + dy[i];
                    if (xx >= 0 && xx < h && yy >= 0 && yy < wi && c[xx][yy] != '@') {
                   /* if(xx == 2 && yy == 3 ) {
                        w.println(cur.y.x+" "+cur.y.y+" "+cur.y.z+" "+i);
                    }
                    if(xx == 1 && yy == 3 ) {
                        w.println(cur.y.x+"y "+cur.y.y+" "+cur.y.z+" "+i);
                    }*/
                        if (i == cur.y.x && cur.y.y < k) {
                            if (dis[xx][yy][i] > cur.y.z) {
                                dis[xx][yy][i] = cur.y.z;
                                //w.println(xx+" "+yy);
                                l.add(new pair<>(new pair<>(xx, yy), new dist(i, cur.y.y + 1, dis[xx][yy][i])));
//                            for (int j = 0; j < 4; j++)
//                                if (i != j) l.add(new pair<>(new pair<>(xx, yy), new dist(j, 1, dis[xx][yy] + 1)));
                            }
                        } else {
                            if (dis[xx][yy][i] > cur.y.z + 1) {
                                dis[xx][yy][i] = cur.y.z + 1;
                                l.add(new pair<>(new pair<>(xx, yy), new dist(i, 1, dis[xx][yy][i])));
                            }
                        }
                    }
                }
            }
        /*r (int i = 0; i < h; i++) {
            for (int j = 0; j < wi; j++) for (int x = 0; x < 4; x++) w.print(dis[i][j][x]+" ");
            w.println();
        }*/
            w.println(func.min(dis[x2][y2]) == Integer.MAX_VALUE ? -1 : func.min(dis[x2][y2]));
        }

    }

    static class pair<U extends Comparable<U>, V extends Comparable<V>> implements Comparable<pair<U, V>> {
        public U x;
        public V y;

        public pair(U x, V y) {
            this.x = x;
            this.y = y;
        }

        public int compareTo(pair<U, V> other) {
            int i = x.compareTo(other.x);
            if (i != 0) return i;
            return y.compareTo(other.y);
        }

        public String toString() {
            return x.toString() + " " + y.toString();
        }

        public boolean equals(Object obj) {
            if (this.getClass() != obj.getClass()) return false;
            pair<U, V> other = (pair<U, V>) obj;
            return x.equals(other.x) && y.equals(other.y);
        }

        public int hashCode() {
            return 31 * x.hashCode() + y.hashCode();
        }

    }

    static class FastReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private FastReader.SpaceCharFilter filter;

        public FastReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {

            if (numChars == -1)
                throw new InputMismatchException();

            if (curChar >= numChars) {

                curChar = 0;

                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }

                if (numChars <= 0)
                    return -1;
            }

            return buf[curChar++];
        }

        public int nextInt() {

            int c = read();

            while (isSpaceChar(c))
                c = read();

            int sgn = 1;

            if (c == '-') {
                sgn = -1;
                c = read();
            }

            int res = 0;

            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();

                res *= 10;
                res += c - '0';
                c = read();
            }
            while (!isSpaceChar(c));

            return res * sgn;
        }

        public String next() {

            int c = read();

            while (isSpaceChar(c))
                c = read();

            StringBuilder res = new StringBuilder();

            do {
                res.appendCodePoint(c);
                c = read();
            }
            while (!isSpaceChar(c));

            return res.toString();
        }

        public boolean isSpaceChar(int c) {

            if (filter != null)
                return filter.isSpaceChar(c);

            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);

        }

    }

    static class func {
        public static int min(int... v) {
            int min = Integer.MAX_VALUE;
            for (int i : v) min = Math.min(min, i);
            return min;
        }

    }

    static class dist implements Comparable<dist> {
        public int x;
        public int y;
        public int z;

        public dist(int xi, int yi, int zi) {
            x = xi;
            y = yi;
            z = zi;
        }

        public int compareTo(dist other) {
            if (this.z > other.z) {
                return 1;
            }
            if (this.z < other.z) {
                return -1;
            }
            return 0;
        }

    }
}


</source>
<source file="../hum_codes_raw/s787765746.java" startline="1" endline="259" pcid="26448">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.PriorityQueue;
import java.util.InputMismatchException;
import java.io.IOException;
import java.util.AbstractCollection;
import java.util.Comparator;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 *
 * @author KharYusuf
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "KharYusuf", 1 << 27);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastReader in = new FastReader(inputStream);
            PrintWriter out = new PrintWriter(outputStream);
            FPondSkater solver = new FPondSkater();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class FPondSkater {
        int[] dx = {1, -1, 0, 0};
        int[] dy = {0, 0, 1, -1};

        public void solve(int testNumber, FastReader s, PrintWriter w) {
            int h = s.nextInt(), wi = s.nextInt(), k = s.nextInt();
            int x1 = s.nextInt() - 1, y1 = s.nextInt() - 1, x2 = s.nextInt() - 1, y2 = s.nextInt() - 1;
            char[][] c = new char[h][];
            for (int i = 0; i < h; i++) c[i] = s.next().toCharArray();
            PriorityQueue<pair<pair<Integer, Integer>, dist>> l = new PriorityQueue<>(new Comparator<pair<pair<Integer, Integer>, dist>>() {

                public int compare(pair<pair<Integer, Integer>, dist> o1, pair<pair<Integer, Integer>, dist> o2) {
                    return Integer.compare(o1.y.z, o2.y.z);
                }
            });
            int[][][] dis = new int[h][wi][4];
            for (int i = 0; i < h; i++) {
                for (int j = 0; j < wi; j++) Arrays.fill(dis[i][j], Integer.MAX_VALUE);
            }
            for (int i = 0; i < 4; i++) {
                l.add(new pair<>(new pair<>(x1, y1), new dist(i, k, 0)));
                dis[x1][y1][i] = 0;
            }
            while (!l.isEmpty()) {
                pair<pair<Integer, Integer>, dist> cur = l.poll();
                if (cur.y.z != dis[cur.x.x][cur.x.y][cur.y.x]) continue;
                for (int i = 0; i < 4; i++) {
                    int xx = cur.x.x + dx[i], yy = cur.x.y + dy[i];
                    if (xx >= 0 && xx < h && yy >= 0 && yy < wi && c[xx][yy] != '@') {
                   /* if(xx == 2 && yy == 3 ) {
                        w.println(cur.y.x+" "+cur.y.y+" "+cur.y.z+" "+i);
                    }
                    if(xx == 1 && yy == 3 ) {
                        w.println(cur.y.x+"y "+cur.y.y+" "+cur.y.z+" "+i);
                    }*/
                        if (i == cur.y.x && cur.y.y < k) {
                            if (dis[xx][yy][i] > cur.y.z) {
                                dis[xx][yy][i] = cur.y.z;
                                //w.println(xx+" "+yy);
                                l.add(new pair<>(new pair<>(xx, yy), new dist(i, cur.y.y + 1, dis[xx][yy][i])));
//                            for (int j = 0; j < 4; j++)
//                                if (i != j) l.add(new pair<>(new pair<>(xx, yy), new dist(j, 1, dis[xx][yy] + 1)));
                            }
                        } else {
                            if (dis[xx][yy][i] > cur.y.z + 1) {
                                dis[xx][yy][i] = cur.y.z + 1;
                                l.add(new pair<>(new pair<>(xx, yy), new dist(i, 1, dis[xx][yy][i])));
                            }
                        }
                    }
                }
            }
        /*r (int i = 0; i < h; i++) {
            for (int j = 0; j < wi; j++) for (int x = 0; x < 4; x++) w.print(dis[i][j][x]+" ");
            w.println();
        }*/
            w.println(func.min(dis[x2][y2]) == Integer.MAX_VALUE ? -1 : func.min(dis[x2][y2]));
        }

    }

    static class pair<U extends Comparable<U>, V extends Comparable<V>> implements Comparable<pair<U, V>> {
        public U x;
        public V y;

        public pair(U x, V y) {
            this.x = x;
            this.y = y;
        }

        public int compareTo(pair<U, V> other) {
            int i = x.compareTo(other.x);
            if (i != 0) return i;
            return y.compareTo(other.y);
        }

        public String toString() {
            return x.toString() + " " + y.toString();
        }

        public boolean equals(Object obj) {
            if (this.getClass() != obj.getClass()) return false;
            pair<U, V> other = (pair<U, V>) obj;
            return x.equals(other.x) && y.equals(other.y);
        }

        public int hashCode() {
            return 31 * x.hashCode() + y.hashCode();
        }

    }

    static class FastReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private FastReader.SpaceCharFilter filter;

        public FastReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {

            if (numChars == -1)
                throw new InputMismatchException();

            if (curChar >= numChars) {

                curChar = 0;

                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }

                if (numChars <= 0)
                    return -1;
            }

            return buf[curChar++];
        }

        public int nextInt() {

            int c = read();

            while (isSpaceChar(c))
                c = read();

            int sgn = 1;

            if (c == '-') {
                sgn = -1;
                c = read();
            }

            int res = 0;

            do {
                if (c < '0' || c > '9')
                    throw new InputMismatchException();

                res *= 10;
                res += c - '0';
                c = read();
            }
            while (!isSpaceChar(c));

            return res * sgn;
        }

        public String next() {

            int c = read();

            while (isSpaceChar(c))
                c = read();

            StringBuilder res = new StringBuilder();

            do {
                res.appendCodePoint(c);
                c = read();
            }
            while (!isSpaceChar(c));

            return res.toString();
        }

        public boolean isSpaceChar(int c) {

            if (filter != null)
                return filter.isSpaceChar(c);

            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);

        }

    }

    static class func {
        public static int min(int... v) {
            int min = Integer.MAX_VALUE;
            for (int i : v) min = Math.min(min, i);
            return min;
        }

    }

    static class dist implements Comparable<dist> {
        public int x;
        public int y;
        public int z;

        public dist(int xi, int yi, int zi) {
            x = xi;
            y = yi;
            z = zi;
        }

        public int compareTo(dist other) {
            if (this.z > other.z) {
                return 1;
            }
            if (this.z < other.z) {
                return -1;
            }
            return 0;
        }

    }
}


</source>
</class>

<class classid="205" nclones="2" nlines="78" similarity="100">
<source file="../hum_codes_raw/s406457629.java" startline="1" endline="91" pcid="13683">
import java.io.*;
import java.util.*;
 
/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskD solver = new TaskD();
        solver.solve(1, in, out);
        out.close();
    }
 
    static class TaskD {
        public void solve(int testNumber, InputReader in, PrintWriter out) {
 
            int N = in.nextInt();
            for (int i = 0; i < N; i++) {
                long A = in.nextLong();
                long B = in.nextLong();
 
                long a = Math.min(A, B);
                long b = Math.max(A, B);
 
                long ans = 2L * (a - 1) + przedzial(a, b);
 
                out.println(ans);
            }
        }
 
        private long przedzial(long a, long b) {
            if (a == b || a + 1 == b) {
                return 0;
            }
 
            return 1L + szukaj(a + 1, b - 2, a * b);
        }
 
        private long szukaj(long a, long b, long LIMIT) {
            if (a > b) return 0;
            if (a == b) {
                return a * b < LIMIT ? 1 : 0;
            }
            long lo = a, hi = b;
            while (lo + 1 < hi) {
                long m = lo + (hi - lo) / 2;
                if (m * m >= LIMIT) {
                    hi = m;
                } else {
                    lo = m;
                }
            }
            long ans1 = 1 + 2L * (lo - 1 - a + 1);
            long ans2 = 0;
            if (lo * (lo + 1) < LIMIT) {
                ans2 = 2L * (lo - a + 1);
            }
            return Math.max(ans1, ans2);
        }
    }
    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;
        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }
        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }
        public long nextLong() {
            return Long.parseLong(next());
        }
        public int nextInt() {
            return Integer.parseInt(next());
        }
    }
}

</source>
<source file="../hum_codes_raw/s546530291.java" startline="1" endline="87" pcid="18403">
import java.io.*;
import java.util.*;
 
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        TaskD solver = new TaskD();
        solver.solve(1, in, out);
        out.close();
    }
 
    static class TaskD {
        public void solve(int testNumber, InputReader in, PrintWriter out) {
 
            int N = in.nextInt();
            for (int i = 0; i < N; i++) {
                long A = in.nextLong();
                long B = in.nextLong();
 
                long a = Math.min(A, B);
                long b = Math.max(A, B);
 
                long ans = 2L * (a - 1) + przedzial(a, b);
 
                out.println(ans);
            }
        }
 
        private long przedzial(long a, long b) {
            if (a == b || a + 1 == b) {
                return 0;
            }
 
            return 1L + szukaj(a + 1, b - 2, a * b);
        }
 
        private long szukaj(long a, long b, long LIMIT) {
            if (a > b) return 0;
            if (a == b) {
                return a * b < LIMIT ? 1 : 0;
            }
            long lo = a, hi = b;
            while (lo + 1 < hi) {
                long m = lo + (hi - lo) / 2;
                if (m * m >= LIMIT) {
                    hi = m;
                } else {
                    lo = m;
                }
            }
            long ans1 = 1 + 2L * (lo - 1 - a + 1);
            long ans2 = 0;
            if (lo * (lo + 1) < LIMIT) {
                ans2 = 2L * (lo - a + 1);
            }
            return Math.max(ans1, ans2);
        }
    }
    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;
        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }
        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }
        public long nextLong() {
            return Long.parseLong(next());
        }
        public int nextInt() {
            return Integer.parseInt(next());
        }
    }
}

</source>
</class>

<class classid="206" nclones="2" nlines="1237" similarity="100">
<source file="../hum_codes_raw/s406917789.java" startline="1" endline="1567" pcid="13700">

import java.io.*;

import static java.lang.Math.*;
import static java.lang.Math.min;

import java.math.BigDecimal;
import java.util.*;

import static java.util.Arrays.*;

import java.util.stream.*;

/**
 * @author baito
 */
@SuppressWarnings("unchecked")
public class Main {
    static boolean DEBUG = true;
    static StringBuilder sb = new StringBuilder();
    static int INF = 1234567890;
    static int MINF = -1234567890;
    static long LINF = 123456789123456789L;
    static long MLINF = -123456789123456789L;
    static int MOD = (int) 1e9 + 7;
    static double EPS = 1e-10;
    static int[] y4 = {-1, 1, 0, 0};
    static int[] x4 = {0, 0, -1, 1};
    static int[] y8 = {0, 1, 0, -1, -1, 1, 1, -1};
    static int[] x8 = {1, 0, -1, 0, 1, -1, 1, -1};
    static int[] Fa;
    static boolean[] isPrime;
    static ArrayList<Integer> primes;
    static char[][] S;
    static long maxRes = Long.MIN_VALUE;
    static long minRes = Long.MAX_VALUE;
    static int[] fac, finv, inv;

    //    static int N;
//    static int[] A;
    static int N, A, B, C, D;
    static int[][] dp;

    public static void solve() throws Exception {
//        long
//        N = ni();
//        A = nia(N);
//        $END$
        int N = ni();
        int A = ni();
        int B = ni();
        int C = ni();
        int D = ni();
        setMod();
        long[][] dp = new long[N + 1][N + 1];
        for (int i = 0; i < N + 1; i++) {
            dp[i][0] = 1;
        }
        long[][] mPowFinv = new long[N + 1][N + 1];
        for (int k = 0; k < N + 1; k++) {
            mPowFinv[k][1] = finv[k];
        }
        for (int k = 0; k < N + 1; k++) {
            for (int i = 2; i < D + 1; i++) {
                mPowFinv[k][i] = mPowFinv[k][i - 1] * finv[k] % MOD;
            }
        }
        for (int k = 1; k <= N; k++) {
            for (int n = 1; n <= N; n++) {
                //k0
                dp[k][n] = dp[k - 1][n];
                if (!(A <= k && k <= B)) continue;
                for (int x = C; x <= D && n - k * x >= 0; x++) {
                    //nkxk-1
                    long cal = mMuls(fac[n], finv[n - k * x], mPowFinv[k][x], finv[x]);
                    cal = mMul(cal, dp[k - 1][n - k * x]);
                    dp[k][n] = mSum(dp[k][n], cal);
                }
            }
        }
        System.out.println(dp[N][N]);
    }


    public static boolean calc(long va) {
        //
        int v = (int) va;
        return true;
    }

    //
    static int mgr(long ok, long ng) {
        //int ok = 0; //
        //int ng = N; //
        while (Math.abs(ok - ng) > 1) {
            long mid;
            if (ok < 0 && ng > 0 || ok > 0 && ng < 0) mid = (ok + ng) / 2;
            else mid = ok + (ng - ok) / 2;

            if (calc(mid)) {
                ok = mid;
            } else {
                ng = mid;
            }
        }
        if (calc(ok)) return (int) ok;
        else return -1;
    }

    static <T> void initStreamArray(ArrayList<T>[] a, int n) {
        a = Stream.generate(ArrayList::new).limit(n).toArray(ArrayList[]::new);
    }

    //
    static ArrayList<Integer> divisors(int n) {
        ArrayList<Integer> res = new ArrayList<>();
        for (int i = 1; i <= Math.sqrt(n); i++) {
            if (n % i == 0) {
                res.add(i);
                if (i != n / i) res.add(n / i);
            }
        }
        return res;
    }

    static ArrayList<Long> divisors(long n) {
        ArrayList<Long> res = new ArrayList<>();
        for (long i = 1; i <= Math.sqrt(n); i++) {
            if (n % i == 0) {
                res.add(i);
                if (i != n / i) res.add(n / i);
            }
        }
        return res;
    }

    static ArrayList<Integer> factorization(int n) {
        if (primes == null) setPrimes();
        ArrayList<Integer> fact = new ArrayList<>();
        for (int p : primes) {
            if (n % p == 0) fact.add(p);
            while (n % p == 0) n /= p;
            if (n == 1) break;
        }
        if (n != 1) fact.add(n);
        return fact;
    }

    boolean equal(double a, double b) {
        return a == 0 ? abs(b) < EPS : abs((a - b) / a) < EPS;
    }

    public static void chMax(long v) {
        maxRes = Math.max(maxRes, v);
    }

    public static void chMin(long v) {
        minRes = Math.min(minRes, v);
    }

    //
    //
    public static void setLR(int[] a, ArrayList<Integer> l, ArrayList<Integer> r) {
        for (int i = 0; i < a.length; i++) {
            if (a[i] > 0) {
                int j = i;
                while (a[j] > 0) j++;
                l.add(i);
                r.add(j);
                i = j - 1;
            }
        }
    }

    public static long[] rui(int[] a) {
        long[] res = new long[a.length + 1];
        for (int i = 0; i < a.length; i++) {
            res[i + 1] = a[i];
        }
        for (int i = 0; i < a.length; i++) {
            res[i + 1] += res[i];
        }
        return res;
    }

    //p[i].nowx := i p[i].nowy := 
    //0
    public static P[] mato(int[] a) {
        CouMap map = new CouMap(a);
        P[] res = new P[map.size()];
        int i = 0;
        for (Map.Entry<Long, Long> m : map.map.entrySet()) {
            res[i++] = new P((int) (long) m.getKey(), (int) (long) m.getValue());
        }
        sort(res);
        return res;
    }

    public static int[] imosu(int[] f, int[] t, int n) {
        int[] imosu = new int[n + 1];
        for (int i = 0; i < f.length; i++) {
            imosu[f[i]]++;
            imosu[t[i] + 1]--;
        }
        for (int i = 0; i < n; i++) {
            imosu[i + 1] += imosu[i];
        }
        return imosu;
    }

    static int[] inverse(int[] a) {
        int[] res = new int[a.length];
        for (int i = 0; i < a.length; i++)
            res[a[i]] = i;
        return res;
    }

    public static String notE(double v) {
        return BigDecimal.valueOf(v).toPlainString();
    }

    public static void print(char[][] a) {
        for (int i = 0; i < a.length; i++) {
            for (int j = 0; j < a[0].length; j++) {
                System.out.print(a[i][j]);
            }
            System.out.println("");
        }
    }

    public static void print(int[][] a) {
        for (int i = 0; i < a.length; i++) {
            for (int j = 0; j < a[0].length; j++) {
                System.out.print(a[i][j] + " ");
            }
            System.out.println("");
        }
    }

    public static <T> void print(ArrayList<T> a) {
        for (T t : a) {
            System.out.println(t);
        }
    }

    public static void print(int[] a) {
        for (int i = 0; i < a.length; i++)
            System.out.println(a[i]);
    }

    public static void print(long[] a) {
        for (int i = 0; i < a.length; i++)
            System.out.println(a[i]);
    }

    //bit
    public static boolean bget(BitSet bit, int keta) {
        return bit.nextSetBit(keta) == keta;
    }

    public static boolean bget(long bit, int keta) {
        return ((bit >> keta) & 1) == 1;
    }

    public static int bget3(long bit, int keta) {
        bit /= (long) pow(3, keta);
        return (int) (bit % 3);
    }

    public static int getHashA(long key) {
        return (int) (key >> 32);
    }

    public static int getHashB(long key) {
        return (int) (key & -1);
    }

    //
    public static long getHashKey(int a, int b) {
        return (long) a << 32 | b;
    }
    //--------------------------------

    //a/b
    public static long ceil(long a, long b) {
        return (a % b == 0) ? a / b : a / b + 1;
    }

    public static double sqrt(double v) {
        return Math.sqrt(v);
    }

    public static long sqrt(long v) {
        long res = (long) Math.sqrt(v);
        while (res * res > v) res--;
        return res;
    }

    static double[][] PER_DP;

    static double ncrPer(int n, int r) {
        if (n < r) return 0;
        if (PER_DP == null) {
            PER_DP = new double[5001][5001];
            PER_DP[0][0] = 1;
            for (int ni = 0; ni < PER_DP.length - 1; ni++) {
                for (int ri = 0; ri < ni + 1; ri++) {
                    PER_DP[ni + 1][ri] += PER_DP[ni][ri] / 2;
                    PER_DP[ni + 1][ri + 1] += PER_DP[ni][ri] / 2;
                }
            }
        }
        return PER_DP[n][r];
    }

    //mod
    public static int mod(long a, int m) {
        return (int) ((a % m + m) % m);
    }

    static void setMod() {
        fac = new int[(int) 1e6 + 1000];
        finv = new int[(int) 1e6 + 1000];
        inv = new int[(int) 1e6 + 1000];
        fac[0] = fac[1] = 1;
        finv[0] = finv[1] = 1;
        inv[1] = 1;
        for (int i = 2; i < 1e6 + 1000; i++) {
            fac[i] = mMul(fac[i - 1], i);
            inv[i] = MOD - mMul(inv[MOD % i], (MOD / i));
            finv[i] = mMul(finv[i - 1], inv[i]);
        }
    }

    static int mNcr(int n, int r) {
        if (n < 0 || r < 0 || n < r) return 0;
        int result = mMul(Fa[n], finv[n - r]);
        result = mMul(result, finv[r]);
        return result;
    }

    public static int mSum(long a, long b) {
        return (int) (((a % MOD + b % MOD) % MOD + MOD) % MOD);
    }

    public static int mDiff(long a, long b) {
        return mSum(a, -b);
    }

    public static int mMul(long a, long b) {
        return (int) (((a % MOD * b % MOD) % MOD + MOD) % MOD);
    }

    public static int mDiv(long a, long b) {
        return mMul(a, mInv(b));
    }

    public static long mSums(long... lar) {
        long res = 0;
        for (long l : lar)
            res = (res + l % MOD) % MOD;
        return (res + MOD) % MOD;
    }

    public static long mDiffs(long... lar) {
        long res = lar[0] % MOD;
        for (int i = 1; i < lar.length; i++) {
            res = (res - lar[i] % MOD) % MOD;
        }
        return (res + MOD) % MOD;
    }

    public static long mMuls(long... lar) {
        long res = 1;
        for (long l : lar)
            res = (res * (l % MOD)) % MOD;
        return (res + MOD) % MOD;
    }

    public static long mDivs(long... lar) {
        long res = lar[0] % MOD;
        for (int i = 1; i < lar.length; i++) {
            res = mMul(res, mInv(lar[i]));
        }
        return (res + MOD) % MOD;
    }

    static long mInv(long n) {
        return mPow(n, MOD - 2);
    }

    static int mPow(long x, long n) {
        long res = 1L;
        while (n > 0) {
            if ((n & 1) == 1) {
                res = res * x % MOD;
            }
            x = x * x % MOD;
            n >>= 1;
        }
        return (int) ((res + MOD) % MOD);
    }

    static void factorial() {
        Fa = new int[(int) 1e6 + 1];
        Fa[0] = Fa[1] = 1;
        for (int i = 2; i < Fa.length; i++) {
            Fa[i] = (int) ((Fa[i - 1] * 1L * i) % MOD);
        }
    }


    //nCrmod
    static long lcm(long n, long r) {
        return n / gcd(n, r) * r;
    }

    static int gcd(int n, int r) {
        return r == 0 ? n : gcd(r, n % r);
    }

    static long gcd(long n, long r) {
        return r == 0 ? n : gcd(r, n % r);
    }

    public static int u0(int a) {
        if (a < 0) return 0;
        return a;
    }

    public static long u0(long a) {
        if (a < 0) return 0;
        return a;
    }

    public static double u0(double a) {
        if (a < 0) return 0;
        return a;
    }

    public static boolean[][] tbt(char[][] s, char c) {
        boolean[][] res = new boolean[s.length][s[0].length];
        for (int hi = 0; hi < s.length; hi++)
            for (int wi = 0; wi < s[0].length; wi++)
                if (s[hi][wi] == c) res[hi][wi] = true;
        return res;
    }

    public static int[] tia(int a) {
        int[] res = new int[keta(a)];
        for (int i = res.length - 1; i >= 0; i--) {
            res[i] = a % 10;
            a /= 10;
        }
        return res;
    }

    public static int[][] tit(char[][] a) {
        int[][] res = new int[a.length][a[0].length];
        for (int hi = 0; hi < a.length; hi++) {
            for (int wi = 0; wi < a[0].length; wi++) {
                res[hi][wi] = a[hi][wi] - '0';
            }
        }
        return res;
    }

    public static Integer[] toIntegerArray(int[] ar) {
        Integer[] res = new Integer[ar.length];
        for (int i = 0; i < ar.length; i++) {
            res[i] = ar[i];
        }
        return res;
    }

    //k  110110 -> 111001
    public static long bitNextComb(long comb) {
        long x = comb & -comb; //1
        long y = comb + x; //1
        return ((comb & ~y) / x >> 1) | y;
    }

    public static int keta(long num) {
        int res = 0;
        while (num > 0) {
            num /= 10;
            res++;
        }
        return res;
    }

    public static int ketaSum(long num) {
        int res = 0;
        while (num > 0) {
            res += num % 10;
            num /= 10;
        }
        return res;
    }

    public static boolean isOutofIndex(int x, int y, int w, int h) {
        if (x < 0 || y < 0) return true;
        if (w <= x || h <= y) return true;
        return false;
    }

    public static boolean isOutofIndex(int x, int y, char[][] ban) {
        if (x < 0 || y < 0) return true;
        if (ban[0].length <= x || ban.length <= y) return true;
        return false;
    }


    public static void setPrimes() {
        int n = 100001;
        isPrime = new boolean[n];
        Arrays.fill(isPrime, true);
        isPrime[0] = isPrime[1] = false;
        for (int i = 2; i * i <= n; i++) {
            if (!isPrime[i]) continue;
            for (int j = i * 2; j < n; j += i) {
                isPrime[j] = false;
            }
        }
        primes = new ArrayList<>();
        for (int i = 2; i < n; i++) {
            if (isPrime[i]) primes.add(i);
        }
    }

    public static void revSort(int[] a) {
        Arrays.sort(a);
        reverse(a);
    }

    public static void revSort(long[] a) {
        Arrays.sort(a);
        reverse(a);
    }

    public static P[] clone(P[] ar) {
        P[] res = new P[ar.length];
        for (int i = 0; i < ar.length; i++) {
            res[i] = new P(ar[i].x, ar[i].y);
        }
        return res;
    }

    public static int[][] clone(int[][] ar) {
        int[][] nr = new int[ar.length][ar[0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = ar[i].clone();
        return nr;
    }

    public static long[][] clone(long[][] ar) {
        long[][] nr = new long[ar.length][ar[0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = ar[i].clone();
        return nr;
    }

    public static double[][] clone(double[][] ar) {
        double[][] nr = new double[ar.length][ar[0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = ar[i].clone();
        return nr;
    }

    public static boolean[][] clone(boolean[][] ar) {
        boolean[][] nr = new boolean[ar.length][ar[0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = ar[i].clone();
        return nr;
    }

    public static char[][] clone(char[][] ar) {
        char[][] nr = new char[ar.length][ar[0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = ar[i].clone();
        return nr;
    }

    public static int[][][] clone(int[][][] ar) {
        int[][][] nr = new int[ar.length][ar[0].length][ar[0][0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = clone(ar[i]);
        return nr;
    }

    public static long[][][] clone(long[][][] ar) {
        long[][][] nr = new long[ar.length][ar[0].length][ar[0][0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = clone(ar[i]);
        return nr;
    }

    public static double[][][] clone(double[][][] ar) {
        double[][][] nr = new double[ar.length][ar[0].length][ar[0][0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = clone(ar[i]);
        return nr;
    }

    public static boolean[][][] clone(boolean[][][] ar) {
        boolean[][][] nr = new boolean[ar.length][ar[0].length][ar[0][0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = clone(ar[i]);
        return nr;
    }

    public static char[][][] clone(char[][][] ar) {
        char[][][] nr = new char[ar.length][ar[0].length][ar[0][0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = clone(ar[i]);
        return nr;
    }

    /**
     * <h1></h1>
     * <p></p>
     *
     * @return<b>int</b>  
     * 
     */
    public static <T extends Number> int lowerBound(final List<T> lis, final T value) {
        int low = 0;
        int high = lis.size();
        int mid;

        while (low < high) {
            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 ()
            if (lis.get(mid).doubleValue() < value.doubleValue()) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    //vivii
    public static <T extends Number> int rlowerBound(final List<T> lis, final T value) {
        int ind = lowerBound(lis, value);
        if (ind == lis.size() || !lis.get(ind).equals(value)) ind--;
        return ind;
    }

    /**
     * <h1></h1>
     * <p></p>
     *
     * @return<b>int</b>  
     * 
     */
    public static <T extends Number> int upperBound(final List<T> lis, final T value) {
        int low = 0;
        int high = lis.size();
        int mid;
        while (low < high) {
            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 ()
            if (lis.get(mid).doubleValue() < value.doubleValue()) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(final int[] arr, final int value) {
        int low = 0;
        int high = arr.length;
        int mid;

        while (low < high) {
            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 ()
            if (arr[mid] < value) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int rlowerBound(final int[] arr, final int value) {
        int ind = lowerBound(arr, value);
        if (ind == arr.length || arr[ind] != value) ind--;
        return ind;
    }


    public static int upperBound(final int[] arr, final int value) {
        int low = 0;
        int high = arr.length;
        int mid;
        while (low < high) {
            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 ()
            if (arr[mid] <= value) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(final long[] arr, final long value) {
        int low = 0;
        int high = arr.length;
        int mid;
        while (low < high) {
            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 ()
            if (arr[mid] < value) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int rlowerBound(final long[] arr, final long value) {
        int ind = lowerBound(arr, value);
        if (ind == arr.length || arr[ind] != value) ind--;
        return ind;
    }

    public static int upperBound(final long[] arr, final long value) {
        int low = 0;
        int high = arr.length;
        int mid;
        while (low < high) {
            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 ()
            if (arr[mid] <= value) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    //false
    public static boolean nextPermutation(int A[]) {
        int len = A.length;
        int pos = len - 2;
        for (; pos >= 0; pos--) {
            if (A[pos] < A[pos + 1]) break;
        }
        if (pos == -1) return false;
        //pos
        int ok = pos + 1;
        int ng = len;
        while (Math.abs(ng - ok) > 1) {
            int mid = (ok + ng) / 2;
            if (A[mid] > A[pos]) ok = mid;
            else ng = mid;
        }
        swap(A, pos, ok);
        reverse(A, pos + 1, len - 1);
        return true;
    }

    //false
    public static boolean prevPermutation(int A[]) {
        int len = A.length;
        int pos = len - 2;
        for (; pos >= 0; pos--) {
            if (A[pos] > A[pos + 1]) break;
        }
        if (pos == -1) return false;
        //pos
        int ok = pos + 1;
        int ng = len;
        while (Math.abs(ng - ok) > 1) {
            int mid = (ok + ng) / 2;
            if (A[mid] < A[pos]) ok = mid;
            else ng = mid;
        }
        swap(A, pos, ok);
        reverse(A, pos + 1, len - 1);
        return true;
    }

    static <T> void swap(T[] x, int i, int j) {
        T t = x[i];
        x[i] = x[j];
        x[j] = t;
    }

    static void swap(char[] x, int i, int j) {
        char t = x[i];
        x[i] = x[j];
        x[j] = t;
    }

    static void swap(int[] x, int i, int j) {
        int t = x[i];
        x[i] = x[j];
        x[j] = t;
    }

    public static String reverse(String a) {
        sb.append(a);
        String res = sb.reverse().toString();
        sb.setLength(0);
        return new String(res);
    }

    public static void reverse(int[] x) {
        int l = 0;
        int r = x.length - 1;
        while (l < r) {
            int temp = x[l];
            x[l] = x[r];
            x[r] = temp;
            l++;
            r--;
        }
    }

    public static void reverse(long[] x) {
        int l = 0;
        int r = x.length - 1;
        while (l < r) {
            long temp = x[l];
            x[l] = x[r];
            x[r] = temp;
            l++;
            r--;
        }
    }

    public static void reverse(char[] x) {
        int l = 0;
        int r = x.length - 1;
        while (l < r) {
            char temp = x[l];
            x[l] = x[r];
            x[r] = temp;
            l++;
            r--;
        }
    }

    public static void reverse(int[] x, int s, int e) {
        int l = s;
        int r = e;
        while (l < r) {
            int temp = x[l];
            x[l] = x[r];
            x[r] = temp;
            l++;
            r--;
        }
    }

    static int cou(boolean[] a) {
        int res = 0;
        for (boolean b : a) {
            if (b) res++;
        }
        return res;
    }

    static int cou(boolean[][] a) {
        int res = 0;
        for (boolean[] b : a) {
            res += cou(b);
        }
        return res;
    }

    static int cou(String s, char c) {
        int res = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == c) res++;
        }
        return res;
    }

    static int cou(char[][] a, char c) {
        int co = 0;
        for (int i = 0; i < a.length; i++)
            for (int j = 0; j < a[0].length; j++)
                if (a[i][j] == c) co++;
        return co;
    }

    static int cou(int[] a, int key) {
        int co = 0;
        for (int i = 0; i < a.length; i++)
            if (a[i] == key) co++;
        return co;
    }

    static int cou(long[] a, long key) {
        int co = 0;
        for (int i = 0; i < a.length; i++)
            if (a[i] == key) co++;
        return co;
    }

    static int cou(int[][] a, int key) {
        int co = 0;
        for (int i = 0; i < a.length; i++)
            co += (cou(a[i], key));
        return co;
    }

    static int[] couArray(int[] a) {
        int[] res = new int[maxs(a) + 1];
        for (int i : a) {
            res[i]++;
        }
        return res;
    }

    static void fill(int[] a, int v) {
        Arrays.fill(a, v);
    }

    static void fill(long[] a, int v) {
        Arrays.fill(a, v);
    }

    static void fill(boolean[] a, boolean v) {
        Arrays.fill(a, v);
    }

    static void fill(int[][] a, int v) {
        for (int i = 0; i < a.length; i++)
            Arrays.fill(a[i], v);
    }

    static void fill(char[][] a, char c) {
        for (int i = 0; i < a.length; i++)
            Arrays.fill(a[i], c);
    }

    static void fill(long[][] a, long v) {
        for (int i = 0; i < a.length; i++)
            Arrays.fill(a[i], v);
    }

    static void fill(double[][] a, double v) {
        for (int i = 0; i < a.length; i++)
            Arrays.fill(a[i], v);
    }

    static void fill(boolean[][] a, boolean v) {
        for (int i = 0; i < a.length; i++)
            Arrays.fill(a[i], v);
    }

    static void fill(int[][][] a, int v) {
        for (int i = 0; i < a.length; i++)
            fill(a[i], v);
    }

    static void fill(long[][][] a, long v) {
        for (int i = 0; i < a.length; i++)
            fill(a[i], v);
    }

    static int maxs(int... a) {
        int res = Integer.MIN_VALUE;
        for (int i : a) {
            res = Math.max(res, i);
        }
        return res;
    }

    static long maxs(long... a) {
        long res = Long.MIN_VALUE;
        for (long i : a) {
            res = Math.max(res, i);
        }
        return res;
    }

    static double maxs(double... a) {
        double res = Double.MIN_VALUE;
        for (double i : a) {
            res = Math.max(res, i);
        }
        return res;
    }

    static long mins(long... a) {
        long res = Long.MAX_VALUE;
        for (long i : a) {
            res = Math.min(res, i);
        }
        return res;
    }

    static int maxs(int[][] ar) {
        int res = Integer.MIN_VALUE;
        for (int i[] : ar)
            res = Math.max(res, maxs(i));
        return res;
    }

    static long maxs(long[][] ar) {
        long res = Integer.MIN_VALUE;
        for (long i[] : ar)
            res = Math.max(res, maxs(i));
        return res;
    }

    static int mins(int... a) {
        int res = Integer.MAX_VALUE;
        for (int i : a) {
            res = Math.min(res, i);
        }
        return res;
    }


    static int mins(int[][] ar) {
        int res = Integer.MAX_VALUE;
        for (int i[] : ar)
            res = Math.min(res, mins(i));
        return res;
    }

    public static <T extends Number> long sum(ArrayList<T> lis) {
        long res = 0;
        for (T li : lis) {
            res += li.longValue();
        }
        return res;
    }

    static long sum(int[] a) {
        long cou = 0;
        for (int i : a)
            cou += i;
        return cou;
    }

    static long sum(long[] a) {
        long cou = 0;
        for (long i : a)
            cou += i;
        return cou;
    }


//FastScanner

    static BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
    static StringTokenizer tokenizer = null;

    public static String next() {
        if (tokenizer == null || !tokenizer.hasMoreTokens()) {
            try {
                tokenizer = new StringTokenizer(reader.readLine());
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
        return tokenizer.nextToken();
    }

    public static String nextLine() {
        if (tokenizer == null || !tokenizer.hasMoreTokens()) {
            try {
                return reader.readLine();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }

        return tokenizer.nextToken("\n");
    }

    public static long nl() {
        return Long.parseLong(next());
    }

    public static String n() {
        return next();
    }

    public static int ni() {
        return Integer.parseInt(next());
    }

    public static double nd() {
        return Double.parseDouble(next());
    }

    public static int[] nia(int n) {
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = ni();
        }
        return a;
    }

    //1-index
    public static int[] niao(int n) {
        int[] a = new int[n + 1];
        for (int i = 1; i < n + 1; i++) {
            a[i] = ni();
        }
        return a;
    }

    //
    public static int[] nias(int n, int end) {
        int[] a = new int[n + 1];
        for (int i = 0; i < n; i++) {
            a[i] = ni();
        }
        a[n] = end;
        return a;
    }

    public static int[] niad(int n) {
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = ni() - 1;
        }
        return a;
    }

    public static P[] npa(int n) {
        P[] p = new P[n];
        for (int i = 0; i < n; i++) {
            p[i] = new P(ni(), ni());
        }
        return p;
    }

    public static P[] npad(int n) {
        P[] p = new P[n];
        for (int i = 0; i < n; i++) {
            p[i] = new P(ni() - 1, ni() - 1);
        }
        return p;
    }

    public static int[][] nit(int h, int w) {
        int[][] a = new int[h][w];
        for (int hi = 0; hi < h; hi++) {
            for (int wi = 0; wi < w; wi++) {
                a[hi][wi] = ni();
            }
        }
        return a;
    }

    public static int[][] nitd(int h, int w) {
        int[][] a = new int[h][w];
        for (int hi = 0; hi < h; hi++) {
            for (int wi = 0; wi < w; wi++) {
                a[hi][wi] = ni() - 1;
            }
        }
        return a;
    }

    static int[][] S_ARRAY;
    static long[][] S_LARRAY;
    static int S_INDEX;
    static int S_LINDEX;

    //
    public static int[] niah(int n, int k) throws Exception {
        if (S_ARRAY == null) {
            S_ARRAY = new int[k][n];
            for (int j = 0; j < n; j++) {
                for (int i = 0; i < k; i++) {
                    S_ARRAY[i][j] = ni();
                }
            }
        }
        return S_ARRAY[S_INDEX++];
    }

    public static long[] nlah(int n, int k) throws Exception {
        if (S_LARRAY == null) {
            S_LARRAY = new long[k][n];
            for (int j = 0; j < n; j++) {
                for (int i = 0; i < k; i++) {
                    S_LARRAY[i][j] = nl();
                }
            }
        }
        return S_LARRAY[S_LINDEX++];
    }

    //
    public static int[] niahd(int n, int k) throws Exception {
        if (S_ARRAY == null) {
            S_ARRAY = new int[k][n];
            for (int j = 0; j < n; j++) {
                for (int i = 0; i < k; i++) {
                    S_ARRAY[i][j] = ni() - 1;
                }
            }
        }
        return S_ARRAY[S_INDEX++];
    }

    public static long[] nlahd(int n, int k) throws Exception {
        if (S_LARRAY == null) {
            S_LARRAY = new long[k][n];
            for (int j = 0; j < n; j++) {
                for (int i = 0; i < k; i++) {
                    S_LARRAY[i][j] = nl() - 1;
                }
            }
        }
        return S_LARRAY[S_LINDEX++];
    }

    public static char[] nca() {
        char[] a = next().toCharArray();
        return a;
    }


    public static String[] nsa(int n) {
        String[] res = new String[n];
        for (int i = 0; i < n; i++) {
            res[i] = n();
        }
        return res;
    }

    //
    public static char[][] ncts(int h, int w) {
        char[][] a = new char[h][w];
        for (int hi = 0; hi < h; hi++) {
            String s = nextLine().replace(" ", "");
            for (int wi = 0; wi < s.length(); wi++) {
                a[hi][wi] = s.charAt(wi);
            }
        }
        return a;
    }

    public static char[][] nct(int h, int w) {
        char[][] a = new char[h][w];
        for (int hi = 0; hi < h; hi++) {
            String s = nextLine();
            for (int wi = 0; wi < s.length(); wi++) {
                a[hi][wi] = s.charAt(wi);
            }
        }
        return a;
    }

    public static char[][] nctp(int h, int w, char c) {
        char[][] a = new char[h + 2][w + 2];
        for (int hi = 1; hi < h + 1; hi++) {
            String s = nextLine();
            for (int wi = 1; wi < s.length() + 1; wi++) {
                a[hi][wi] = s.charAt(wi - 1);
            }
        }
        for (int wi = 0; wi < w + 2; wi++)
            a[0][wi] = a[h + 1][wi] = c;
        for (int hi = 0; hi < h + 2; hi++)
            a[hi][0] = a[hi][w + 1] = c;
        return a;
    }

    //
    public static char[][] nctsp(int h, int w, char c) {
        char[][] a = new char[h + 2][w + 2];
        //char c = '*';
        int i;
        for (i = 0; i < w + 2; i++)
            a[0][i] = c;
        for (i = 1; i < h + 1; i++) {
            a[i] = (c + nextLine().replace(" ", "") + c).toCharArray();
        }
        for (i = 0; i < w + 2; i++)
            a[h + 1][i] = c;
        return a;
    }

    public static long[] nla(int n) {
        long[] a = new long[n];
        for (int i = 0; i < n; i++) {
            a[i] = nl();
        }
        return a;
    }

    public static long[] nlas(int n, long e) {
        long[] a = new long[n + 1];
        for (int i = 0; i < n; i++) {
            a[i] = nl();
        }
        a[n] = e;
        return a;
    }

    public static long[] nlao(int n) {
        long[] a = new long[n + 1];
        for (int i = 0; i < n; i++) {
            a[i + 1] = nl();
        }
        return a;
    }

    public static long[] nlad(int n) {
        long[] a = new long[n];
        for (int i = 0; i < n; i++) {
            a[i] = nl() - 1;
        }
        return a;
    }

    public static long[][] nlt(int h, int w) {
        long[][] a = new long[h][w];
        for (int hi = 0; hi < h; hi++) {
            for (int wi = 0; wi < w; wi++) {
                a[hi][wi] = nl();
            }
        }
        return a;
    }

    //
    static class CouMap {
        public HashMap<Long, Long> map;
        public HashMap<String, Long> smap;

        CouMap() {
            map = new HashMap();
            smap = new HashMap();
        }

        CouMap(int[] a) {
            map = new HashMap();
            smap = new HashMap();
            for (int i : a) {
                put(i);
            }
        }

        public int size() {
            return map.size();
        }

        public void put(long key, long value) {
            Long nowValue = map.get(key);
            map.put(key, nowValue == null ? value : nowValue + value);
        }

        public void put(String key, long value) {
            Long nowValue = smap.get(key);
            smap.put(key, nowValue == null ? value : nowValue + value);
        }

        public void mput(long key, long value) {
            Long nowValue = map.get(key);
            map.put(key, nowValue == null ? value % MOD : mSum(nowValue, value));
        }

        public void put(long key) {
            put(key, 1);
        }

        public void put(String key) {
            put(key, 1);
        }

        public void put(int... arg) {
            for (int i : arg) {
                put(i, 1);
            }
        }

        public void put(long... arg) {
            for (long i : arg) {
                put(i, 1);
            }
        }

        public void mput(int... arg) {
            for (int i : arg) {
                mput(i, 1);
            }
        }

        public void mput(long... arg) {
            for (long i : arg) {
                mput(i, 1);
            }
        }

        public long get(long key) {
            Long v = map.get(key);
            return v == null ? 0 : v;
        }

        public long get(String key) {
            Long v = map.get(key);
            return v == null ? 0 : v;
        }
    }

    static class P implements Comparable<P> {
        int x, y;

        @Override
        public int compareTo(P p) {
            //xy
            return x == p.x ? y - p.y : x - p.x;
            //xy
            //return (nowx == p.nowx ? nowy - p.nowy : nowx - p.nowx) * -1;
            //yx
            //return nowy == p.nowy ? nowx - p.nowx : nowy - p.nowy;
            //yx
            //return (nowy == p.nowy ? nowx - p.nowx : nowy - p.nowy) * -1;

            //x y
            //return nowx == p.nowx ? p.nowy - nowy : nowx - p.nowx;
            //x y
            //return (nowx == p.nowx ? p.nowy - nowy : nowx - p.nowx) * -1;
            //y x
            //return nowy == p.nowy ? p.nowx - nowx : nowy - p.nowy;
            //y x
            //return (nowy == p.nowy ? p.nowx - nowx : nowy - p.nowy) * -1;
        }

        P(int a, int b) {
            x = a;
            y = b;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof P)) return false;
            P p = (P) o;
            return x == p.x && y == p.y;
        }

        @Override
        public int hashCode() {
            return Objects.hash(x, y);
        }

    }

    static class PL implements Comparable<PL> {
        long x, y;

        public int compareTo(PL p) {
            //xy
            long res = x == p.x ? y - p.y : x - p.x;
            //xy
            //long res = (nowx == p.nowx ? nowy - p.nowy : nowx - p.nowx) * -1;
            //yx
            //long res = nowy == p.nowy ? nowx - p.nowx : nowy - p.nowy;
            //yx
            //long res = (nowy == p.nowy ? nowx - p.nowx : nowy - p.nowy) * -1;

            //x y
            //long res = nowx == p.nowx ? p.nowy - nowy : nowx - p.nowx;
            //x y
            //long res = (nowx == p.nowx ? p.nowy - nowy : nowx - p.nowx) * -1;
            //y x
            //long res = nowy == p.nowy ? p.nowx - nowx : nowy - p.nowy;
            //y x
            //long res = (nowy == p.nowy ? p.nowx - nowx : nowy - p.nowy) * -1;

            return (res == 0) ? 0 : res > 0 ? 1 : -1;
        }

        PL(long a, long b) {
            x = a;
            y = b;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof PL)) return false;
            PL p = (PL) o;
            return x == p.x && y == p.y;
        }

        @Override
        public int hashCode() {
            return Objects.hash(x, y);
        }

    }

    //
    static class RectangleSum {
        // 00
        long[][] rui;
        int H, W;

        RectangleSum(long[][] ori) {
            H = ori.length;
            W = ori[0].length;
            rui = new long[H + 1][W + 1];
            for (int hi = 0; hi < H; hi++) {
                for (int wi = 0; wi < W; wi++) {
                    rui[hi + 1][wi + 1] = ori[hi][wi];
                }
            }
            for (int hi = 1; hi < H + 1; hi++) {
                for (int wi = 1; wi < W + 1; wi++) {
                    rui[hi][wi] += rui[hi - 1][wi];
                    rui[hi][wi] += rui[hi][wi - 1];
                    rui[hi][wi] -= rui[hi - 1][wi - 1];
                }
            }
        }

        RectangleSum(int[][] ori) {
            H = ori.length;
            W = ori[0].length;
            rui = new long[H + 1][W + 1];
            for (int hi = 0; hi < H; hi++) {
                for (int wi = 0; wi < W; wi++) {
                    rui[hi + 1][wi + 1] = ori[hi][wi];
                }
            }
            for (int hi = 1; hi < H + 1; hi++) {
                for (int wi = 1; wi < W + 1; wi++) {
                    rui[hi][wi] += rui[hi - 1][wi];
                    rui[hi][wi] += rui[hi][wi - 1];
                    rui[hi][wi] -= rui[hi - 1][wi - 1];
                }
            }
        }

        //
        public long getSum(int left, int right, int top, int bottom) {
            if (right > W || bottom > H) return 0;
            if (left < 0 || top < 0) return 0;
            if (top >= bottom || left >= right) return 0;
            long res = rui[bottom][right];
            res -= rui[top][right];
            res -= rui[bottom][left];
            res += rui[top][left];
            return res;
        }

    }

    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        solve();
        System.out.flush();
        long endTime = System.currentTimeMillis();
        if (DEBUG) System.err.println(endTime - startTime);
    }

}

</source>
<source file="../hum_codes_raw/s613685593.java" startline="1" endline="1566" pcid="20610">
import java.io.*;

import static java.lang.Math.*;
import static java.lang.Math.min;

import java.math.BigDecimal;
import java.util.*;

import static java.util.Arrays.*;

import java.util.stream.*;

/**
 * @author baito
 */
@SuppressWarnings("unchecked")
public class Main {
    static boolean DEBUG = true;
    static StringBuilder sb = new StringBuilder();
    static int INF = 1234567890;
    static int MINF = -1234567890;
    static long LINF = 123456789123456789L;
    static long MLINF = -123456789123456789L;
    static int MOD = (int) 1e9 + 7;
    static double EPS = 1e-10;
    static int[] y4 = {-1, 1, 0, 0};
    static int[] x4 = {0, 0, -1, 1};
    static int[] y8 = {0, 1, 0, -1, -1, 1, 1, -1};
    static int[] x8 = {1, 0, -1, 0, 1, -1, 1, -1};
    static int[] Fa;
    static boolean[] isPrime;
    static ArrayList<Integer> primes;
    static char[][] S;
    static long maxRes = Long.MIN_VALUE;
    static long minRes = Long.MAX_VALUE;
    static int[] fac, finv, inv;

    //    static int N;
//    static int[] A;
    static int N, A, B, C, D;
    static int[][] dp;

    public static void solve() throws Exception {
//        long
//        N = ni();
//        A = nia(N);
//        $END$
        int N = ni();
        int A = ni();
        int B = ni();
        int C = ni();
        int D = ni();
        setMod();
        long[][] dp = new long[N + 1][N + 1];
        for (int i = 0; i < N + 1; i++) {
            dp[i][0] = 1;
        }
        long[][] mPowFinv = new long[N + 1][N + 1];
        for (int k = 0; k < N + 1; k++) {
            mPowFinv[k][1] = finv[k];
        }
        for (int k = 0; k < N + 1; k++) {
            for (int i = 2; i < D + 1; i++) {
                mPowFinv[k][i] = mPowFinv[k][i - 1] * finv[k] % MOD;
            }
        }
        for (int k = 1; k <= N; k++) {
            for (int n = 1; n <= N; n++) {
                //k0
                dp[k][n] = dp[k - 1][n];
                if (!(A <= k && k <= B)) continue;
                for (int x = C; x <= D && n - k * x >= 0; x++) {
                    //nkxk-1
                    long cal = mMuls(fac[n], finv[n - k * x], mPowFinv[k][x], finv[x]);
                    cal = mMul(cal, dp[k - 1][n - k * x]);
                    dp[k][n] = mSum(dp[k][n], cal);
                }
            }
        }
        System.out.println(dp[N][N]);
    }


    public static boolean calc(long va) {
        //
        int v = (int) va;
        return true;
    }

    //
    static int mgr(long ok, long ng) {
        //int ok = 0; //
        //int ng = N; //
        while (Math.abs(ok - ng) > 1) {
            long mid;
            if (ok < 0 && ng > 0 || ok > 0 && ng < 0) mid = (ok + ng) / 2;
            else mid = ok + (ng - ok) / 2;

            if (calc(mid)) {
                ok = mid;
            } else {
                ng = mid;
            }
        }
        if (calc(ok)) return (int) ok;
        else return -1;
    }

    static <T> void initStreamArray(ArrayList<T>[] a, int n) {
        a = Stream.generate(ArrayList::new).limit(n).toArray(ArrayList[]::new);
    }

    //
    static ArrayList<Integer> divisors(int n) {
        ArrayList<Integer> res = new ArrayList<>();
        for (int i = 1; i <= Math.sqrt(n); i++) {
            if (n % i == 0) {
                res.add(i);
                if (i != n / i) res.add(n / i);
            }
        }
        return res;
    }

    static ArrayList<Long> divisors(long n) {
        ArrayList<Long> res = new ArrayList<>();
        for (long i = 1; i <= Math.sqrt(n); i++) {
            if (n % i == 0) {
                res.add(i);
                if (i != n / i) res.add(n / i);
            }
        }
        return res;
    }

    static ArrayList<Integer> factorization(int n) {
        if (primes == null) setPrimes();
        ArrayList<Integer> fact = new ArrayList<>();
        for (int p : primes) {
            if (n % p == 0) fact.add(p);
            while (n % p == 0) n /= p;
            if (n == 1) break;
        }
        if (n != 1) fact.add(n);
        return fact;
    }

    boolean equal(double a, double b) {
        return a == 0 ? abs(b) < EPS : abs((a - b) / a) < EPS;
    }

    public static void chMax(long v) {
        maxRes = Math.max(maxRes, v);
    }

    public static void chMin(long v) {
        minRes = Math.min(minRes, v);
    }

    //
    //
    public static void setLR(int[] a, ArrayList<Integer> l, ArrayList<Integer> r) {
        for (int i = 0; i < a.length; i++) {
            if (a[i] > 0) {
                int j = i;
                while (a[j] > 0) j++;
                l.add(i);
                r.add(j);
                i = j - 1;
            }
        }
    }

    public static long[] rui(int[] a) {
        long[] res = new long[a.length + 1];
        for (int i = 0; i < a.length; i++) {
            res[i + 1] = a[i];
        }
        for (int i = 0; i < a.length; i++) {
            res[i + 1] += res[i];
        }
        return res;
    }

    //p[i].nowx := i p[i].nowy := 
    //0
    public static P[] mato(int[] a) {
        CouMap map = new CouMap(a);
        P[] res = new P[map.size()];
        int i = 0;
        for (Map.Entry<Long, Long> m : map.map.entrySet()) {
            res[i++] = new P((int) (long) m.getKey(), (int) (long) m.getValue());
        }
        sort(res);
        return res;
    }

    public static int[] imosu(int[] f, int[] t, int n) {
        int[] imosu = new int[n + 1];
        for (int i = 0; i < f.length; i++) {
            imosu[f[i]]++;
            imosu[t[i] + 1]--;
        }
        for (int i = 0; i < n; i++) {
            imosu[i + 1] += imosu[i];
        }
        return imosu;
    }

    static int[] inverse(int[] a) {
        int[] res = new int[a.length];
        for (int i = 0; i < a.length; i++)
            res[a[i]] = i;
        return res;
    }

    public static String notE(double v) {
        return BigDecimal.valueOf(v).toPlainString();
    }

    public static void print(char[][] a) {
        for (int i = 0; i < a.length; i++) {
            for (int j = 0; j < a[0].length; j++) {
                System.out.print(a[i][j]);
            }
            System.out.println("");
        }
    }

    public static void print(int[][] a) {
        for (int i = 0; i < a.length; i++) {
            for (int j = 0; j < a[0].length; j++) {
                System.out.print(a[i][j] + " ");
            }
            System.out.println("");
        }
    }

    public static <T> void print(ArrayList<T> a) {
        for (T t : a) {
            System.out.println(t);
        }
    }

    public static void print(int[] a) {
        for (int i = 0; i < a.length; i++)
            System.out.println(a[i]);
    }

    public static void print(long[] a) {
        for (int i = 0; i < a.length; i++)
            System.out.println(a[i]);
    }

    //bit
    public static boolean bget(BitSet bit, int keta) {
        return bit.nextSetBit(keta) == keta;
    }

    public static boolean bget(long bit, int keta) {
        return ((bit >> keta) & 1) == 1;
    }

    public static int bget3(long bit, int keta) {
        bit /= (long) pow(3, keta);
        return (int) (bit % 3);
    }

    public static int getHashA(long key) {
        return (int) (key >> 32);
    }

    public static int getHashB(long key) {
        return (int) (key & -1);
    }

    //
    public static long getHashKey(int a, int b) {
        return (long) a << 32 | b;
    }
    //--------------------------------

    //a/b
    public static long ceil(long a, long b) {
        return (a % b == 0) ? a / b : a / b + 1;
    }

    public static double sqrt(double v) {
        return Math.sqrt(v);
    }

    public static long sqrt(long v) {
        long res = (long) Math.sqrt(v);
        while (res * res > v) res--;
        return res;
    }

    static double[][] PER_DP;

    static double ncrPer(int n, int r) {
        if (n < r) return 0;
        if (PER_DP == null) {
            PER_DP = new double[5001][5001];
            PER_DP[0][0] = 1;
            for (int ni = 0; ni < PER_DP.length - 1; ni++) {
                for (int ri = 0; ri < ni + 1; ri++) {
                    PER_DP[ni + 1][ri] += PER_DP[ni][ri] / 2;
                    PER_DP[ni + 1][ri + 1] += PER_DP[ni][ri] / 2;
                }
            }
        }
        return PER_DP[n][r];
    }

    //mod
    public static int mod(long a, int m) {
        return (int) ((a % m + m) % m);
    }

    static void setMod() {
        fac = new int[(int) 1e6 + 1000];
        finv = new int[(int) 1e6 + 1000];
        inv = new int[(int) 1e6 + 1000];
        fac[0] = fac[1] = 1;
        finv[0] = finv[1] = 1;
        inv[1] = 1;
        for (int i = 2; i < 1e6 + 1000; i++) {
            fac[i] = mMul(fac[i - 1], i);
            inv[i] = MOD - mMul(inv[MOD % i], (MOD / i));
            finv[i] = mMul(finv[i - 1], inv[i]);
        }
    }

    static int mNcr(int n, int r) {
        if (n < 0 || r < 0 || n < r) return 0;
        int result = mMul(Fa[n], finv[n - r]);
        result = mMul(result, finv[r]);
        return result;
    }

    public static int mSum(long a, long b) {
        return (int) (((a % MOD + b % MOD) % MOD + MOD) % MOD);
    }

    public static int mDiff(long a, long b) {
        return mSum(a, -b);
    }

    public static int mMul(long a, long b) {
        return (int) (((a % MOD * b % MOD) % MOD + MOD) % MOD);
    }

    public static int mDiv(long a, long b) {
        return mMul(a, mInv(b));
    }

    public static long mSums(long... lar) {
        long res = 0;
        for (long l : lar)
            res = (res + l % MOD) % MOD;
        return (res + MOD) % MOD;
    }

    public static long mDiffs(long... lar) {
        long res = lar[0] % MOD;
        for (int i = 1; i < lar.length; i++) {
            res = (res - lar[i] % MOD) % MOD;
        }
        return (res + MOD) % MOD;
    }

    public static long mMuls(long... lar) {
        long res = 1;
        for (long l : lar)
            res = (res * (l % MOD)) % MOD;
        return (res + MOD) % MOD;
    }

    public static long mDivs(long... lar) {
        long res = lar[0] % MOD;
        for (int i = 1; i < lar.length; i++) {
            res = mMul(res, mInv(lar[i]));
        }
        return (res + MOD) % MOD;
    }

    static long mInv(long n) {
        return mPow(n, MOD - 2);
    }

    static int mPow(long x, long n) {
        long res = 1L;
        while (n > 0) {
            if ((n & 1) == 1) {
                res = res * x % MOD;
            }
            x = x * x % MOD;
            n >>= 1;
        }
        return (int) ((res + MOD) % MOD);
    }

    static void factorial() {
        Fa = new int[(int) 1e6 + 1];
        Fa[0] = Fa[1] = 1;
        for (int i = 2; i < Fa.length; i++) {
            Fa[i] = (int) ((Fa[i - 1] * 1L * i) % MOD);
        }
    }


    //nCrmod
    static long lcm(long n, long r) {
        return n / gcd(n, r) * r;
    }

    static int gcd(int n, int r) {
        return r == 0 ? n : gcd(r, n % r);
    }

    static long gcd(long n, long r) {
        return r == 0 ? n : gcd(r, n % r);
    }

    public static int u0(int a) {
        if (a < 0) return 0;
        return a;
    }

    public static long u0(long a) {
        if (a < 0) return 0;
        return a;
    }

    public static double u0(double a) {
        if (a < 0) return 0;
        return a;
    }

    public static boolean[][] tbt(char[][] s, char c) {
        boolean[][] res = new boolean[s.length][s[0].length];
        for (int hi = 0; hi < s.length; hi++)
            for (int wi = 0; wi < s[0].length; wi++)
                if (s[hi][wi] == c) res[hi][wi] = true;
        return res;
    }

    public static int[] tia(int a) {
        int[] res = new int[keta(a)];
        for (int i = res.length - 1; i >= 0; i--) {
            res[i] = a % 10;
            a /= 10;
        }
        return res;
    }

    public static int[][] tit(char[][] a) {
        int[][] res = new int[a.length][a[0].length];
        for (int hi = 0; hi < a.length; hi++) {
            for (int wi = 0; wi < a[0].length; wi++) {
                res[hi][wi] = a[hi][wi] - '0';
            }
        }
        return res;
    }

    public static Integer[] toIntegerArray(int[] ar) {
        Integer[] res = new Integer[ar.length];
        for (int i = 0; i < ar.length; i++) {
            res[i] = ar[i];
        }
        return res;
    }

    //k  110110 -> 111001
    public static long bitNextComb(long comb) {
        long x = comb & -comb; //1
        long y = comb + x; //1
        return ((comb & ~y) / x >> 1) | y;
    }

    public static int keta(long num) {
        int res = 0;
        while (num > 0) {
            num /= 10;
            res++;
        }
        return res;
    }

    public static int ketaSum(long num) {
        int res = 0;
        while (num > 0) {
            res += num % 10;
            num /= 10;
        }
        return res;
    }

    public static boolean isOutofIndex(int x, int y, int w, int h) {
        if (x < 0 || y < 0) return true;
        if (w <= x || h <= y) return true;
        return false;
    }

    public static boolean isOutofIndex(int x, int y, char[][] ban) {
        if (x < 0 || y < 0) return true;
        if (ban[0].length <= x || ban.length <= y) return true;
        return false;
    }


    public static void setPrimes() {
        int n = 100001;
        isPrime = new boolean[n];
        Arrays.fill(isPrime, true);
        isPrime[0] = isPrime[1] = false;
        for (int i = 2; i * i <= n; i++) {
            if (!isPrime[i]) continue;
            for (int j = i * 2; j < n; j += i) {
                isPrime[j] = false;
            }
        }
        primes = new ArrayList<>();
        for (int i = 2; i < n; i++) {
            if (isPrime[i]) primes.add(i);
        }
    }

    public static void revSort(int[] a) {
        Arrays.sort(a);
        reverse(a);
    }

    public static void revSort(long[] a) {
        Arrays.sort(a);
        reverse(a);
    }

    public static P[] clone(P[] ar) {
        P[] res = new P[ar.length];
        for (int i = 0; i < ar.length; i++) {
            res[i] = new P(ar[i].x, ar[i].y);
        }
        return res;
    }

    public static int[][] clone(int[][] ar) {
        int[][] nr = new int[ar.length][ar[0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = ar[i].clone();
        return nr;
    }

    public static long[][] clone(long[][] ar) {
        long[][] nr = new long[ar.length][ar[0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = ar[i].clone();
        return nr;
    }

    public static double[][] clone(double[][] ar) {
        double[][] nr = new double[ar.length][ar[0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = ar[i].clone();
        return nr;
    }

    public static boolean[][] clone(boolean[][] ar) {
        boolean[][] nr = new boolean[ar.length][ar[0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = ar[i].clone();
        return nr;
    }

    public static char[][] clone(char[][] ar) {
        char[][] nr = new char[ar.length][ar[0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = ar[i].clone();
        return nr;
    }

    public static int[][][] clone(int[][][] ar) {
        int[][][] nr = new int[ar.length][ar[0].length][ar[0][0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = clone(ar[i]);
        return nr;
    }

    public static long[][][] clone(long[][][] ar) {
        long[][][] nr = new long[ar.length][ar[0].length][ar[0][0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = clone(ar[i]);
        return nr;
    }

    public static double[][][] clone(double[][][] ar) {
        double[][][] nr = new double[ar.length][ar[0].length][ar[0][0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = clone(ar[i]);
        return nr;
    }

    public static boolean[][][] clone(boolean[][][] ar) {
        boolean[][][] nr = new boolean[ar.length][ar[0].length][ar[0][0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = clone(ar[i]);
        return nr;
    }

    public static char[][][] clone(char[][][] ar) {
        char[][][] nr = new char[ar.length][ar[0].length][ar[0][0].length];
        for (int i = 0; i < ar.length; i++)
            nr[i] = clone(ar[i]);
        return nr;
    }

    /**
     * <h1></h1>
     * <p></p>
     *
     * @return<b>int</b>  
     * 
     */
    public static <T extends Number> int lowerBound(final List<T> lis, final T value) {
        int low = 0;
        int high = lis.size();
        int mid;

        while (low < high) {
            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 ()
            if (lis.get(mid).doubleValue() < value.doubleValue()) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    //vivii
    public static <T extends Number> int rlowerBound(final List<T> lis, final T value) {
        int ind = lowerBound(lis, value);
        if (ind == lis.size() || !lis.get(ind).equals(value)) ind--;
        return ind;
    }

    /**
     * <h1></h1>
     * <p></p>
     *
     * @return<b>int</b>  
     * 
     */
    public static <T extends Number> int upperBound(final List<T> lis, final T value) {
        int low = 0;
        int high = lis.size();
        int mid;
        while (low < high) {
            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 ()
            if (lis.get(mid).doubleValue() < value.doubleValue()) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(final int[] arr, final int value) {
        int low = 0;
        int high = arr.length;
        int mid;

        while (low < high) {
            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 ()
            if (arr[mid] < value) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int rlowerBound(final int[] arr, final int value) {
        int ind = lowerBound(arr, value);
        if (ind == arr.length || arr[ind] != value) ind--;
        return ind;
    }


    public static int upperBound(final int[] arr, final int value) {
        int low = 0;
        int high = arr.length;
        int mid;
        while (low < high) {
            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 ()
            if (arr[mid] <= value) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(final long[] arr, final long value) {
        int low = 0;
        int high = arr.length;
        int mid;
        while (low < high) {
            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 ()
            if (arr[mid] < value) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int rlowerBound(final long[] arr, final long value) {
        int ind = lowerBound(arr, value);
        if (ind == arr.length || arr[ind] != value) ind--;
        return ind;
    }

    public static int upperBound(final long[] arr, final long value) {
        int low = 0;
        int high = arr.length;
        int mid;
        while (low < high) {
            mid = ((high - low) >>> 1) + low;    //(low + high) / 2 ()
            if (arr[mid] <= value) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    //false
    public static boolean nextPermutation(int A[]) {
        int len = A.length;
        int pos = len - 2;
        for (; pos >= 0; pos--) {
            if (A[pos] < A[pos + 1]) break;
        }
        if (pos == -1) return false;
        //pos
        int ok = pos + 1;
        int ng = len;
        while (Math.abs(ng - ok) > 1) {
            int mid = (ok + ng) / 2;
            if (A[mid] > A[pos]) ok = mid;
            else ng = mid;
        }
        swap(A, pos, ok);
        reverse(A, pos + 1, len - 1);
        return true;
    }

    //false
    public static boolean prevPermutation(int A[]) {
        int len = A.length;
        int pos = len - 2;
        for (; pos >= 0; pos--) {
            if (A[pos] > A[pos + 1]) break;
        }
        if (pos == -1) return false;
        //pos
        int ok = pos + 1;
        int ng = len;
        while (Math.abs(ng - ok) > 1) {
            int mid = (ok + ng) / 2;
            if (A[mid] < A[pos]) ok = mid;
            else ng = mid;
        }
        swap(A, pos, ok);
        reverse(A, pos + 1, len - 1);
        return true;
    }

    static <T> void swap(T[] x, int i, int j) {
        T t = x[i];
        x[i] = x[j];
        x[j] = t;
    }

    static void swap(char[] x, int i, int j) {
        char t = x[i];
        x[i] = x[j];
        x[j] = t;
    }

    static void swap(int[] x, int i, int j) {
        int t = x[i];
        x[i] = x[j];
        x[j] = t;
    }

    public static String reverse(String a) {
        sb.append(a);
        String res = sb.reverse().toString();
        sb.setLength(0);
        return new String(res);
    }

    public static void reverse(int[] x) {
        int l = 0;
        int r = x.length - 1;
        while (l < r) {
            int temp = x[l];
            x[l] = x[r];
            x[r] = temp;
            l++;
            r--;
        }
    }

    public static void reverse(long[] x) {
        int l = 0;
        int r = x.length - 1;
        while (l < r) {
            long temp = x[l];
            x[l] = x[r];
            x[r] = temp;
            l++;
            r--;
        }
    }

    public static void reverse(char[] x) {
        int l = 0;
        int r = x.length - 1;
        while (l < r) {
            char temp = x[l];
            x[l] = x[r];
            x[r] = temp;
            l++;
            r--;
        }
    }

    public static void reverse(int[] x, int s, int e) {
        int l = s;
        int r = e;
        while (l < r) {
            int temp = x[l];
            x[l] = x[r];
            x[r] = temp;
            l++;
            r--;
        }
    }

    static int cou(boolean[] a) {
        int res = 0;
        for (boolean b : a) {
            if (b) res++;
        }
        return res;
    }

    static int cou(boolean[][] a) {
        int res = 0;
        for (boolean[] b : a) {
            res += cou(b);
        }
        return res;
    }

    static int cou(String s, char c) {
        int res = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == c) res++;
        }
        return res;
    }

    static int cou(char[][] a, char c) {
        int co = 0;
        for (int i = 0; i < a.length; i++)
            for (int j = 0; j < a[0].length; j++)
                if (a[i][j] == c) co++;
        return co;
    }

    static int cou(int[] a, int key) {
        int co = 0;
        for (int i = 0; i < a.length; i++)
            if (a[i] == key) co++;
        return co;
    }

    static int cou(long[] a, long key) {
        int co = 0;
        for (int i = 0; i < a.length; i++)
            if (a[i] == key) co++;
        return co;
    }

    static int cou(int[][] a, int key) {
        int co = 0;
        for (int i = 0; i < a.length; i++)
            co += (cou(a[i], key));
        return co;
    }

    static int[] couArray(int[] a) {
        int[] res = new int[maxs(a) + 1];
        for (int i : a) {
            res[i]++;
        }
        return res;
    }

    static void fill(int[] a, int v) {
        Arrays.fill(a, v);
    }

    static void fill(long[] a, int v) {
        Arrays.fill(a, v);
    }

    static void fill(boolean[] a, boolean v) {
        Arrays.fill(a, v);
    }

    static void fill(int[][] a, int v) {
        for (int i = 0; i < a.length; i++)
            Arrays.fill(a[i], v);
    }

    static void fill(char[][] a, char c) {
        for (int i = 0; i < a.length; i++)
            Arrays.fill(a[i], c);
    }

    static void fill(long[][] a, long v) {
        for (int i = 0; i < a.length; i++)
            Arrays.fill(a[i], v);
    }

    static void fill(double[][] a, double v) {
        for (int i = 0; i < a.length; i++)
            Arrays.fill(a[i], v);
    }

    static void fill(boolean[][] a, boolean v) {
        for (int i = 0; i < a.length; i++)
            Arrays.fill(a[i], v);
    }

    static void fill(int[][][] a, int v) {
        for (int i = 0; i < a.length; i++)
            fill(a[i], v);
    }

    static void fill(long[][][] a, long v) {
        for (int i = 0; i < a.length; i++)
            fill(a[i], v);
    }

    static int maxs(int... a) {
        int res = Integer.MIN_VALUE;
        for (int i : a) {
            res = Math.max(res, i);
        }
        return res;
    }

    static long maxs(long... a) {
        long res = Long.MIN_VALUE;
        for (long i : a) {
            res = Math.max(res, i);
        }
        return res;
    }

    static double maxs(double... a) {
        double res = Double.MIN_VALUE;
        for (double i : a) {
            res = Math.max(res, i);
        }
        return res;
    }

    static long mins(long... a) {
        long res = Long.MAX_VALUE;
        for (long i : a) {
            res = Math.min(res, i);
        }
        return res;
    }

    static int maxs(int[][] ar) {
        int res = Integer.MIN_VALUE;
        for (int i[] : ar)
            res = Math.max(res, maxs(i));
        return res;
    }

    static long maxs(long[][] ar) {
        long res = Integer.MIN_VALUE;
        for (long i[] : ar)
            res = Math.max(res, maxs(i));
        return res;
    }

    static int mins(int... a) {
        int res = Integer.MAX_VALUE;
        for (int i : a) {
            res = Math.min(res, i);
        }
        return res;
    }


    static int mins(int[][] ar) {
        int res = Integer.MAX_VALUE;
        for (int i[] : ar)
            res = Math.min(res, mins(i));
        return res;
    }

    public static <T extends Number> long sum(ArrayList<T> lis) {
        long res = 0;
        for (T li : lis) {
            res += li.longValue();
        }
        return res;
    }

    static long sum(int[] a) {
        long cou = 0;
        for (int i : a)
            cou += i;
        return cou;
    }

    static long sum(long[] a) {
        long cou = 0;
        for (long i : a)
            cou += i;
        return cou;
    }


//FastScanner

    static BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
    static StringTokenizer tokenizer = null;

    public static String next() {
        if (tokenizer == null || !tokenizer.hasMoreTokens()) {
            try {
                tokenizer = new StringTokenizer(reader.readLine());
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
        return tokenizer.nextToken();
    }

    public static String nextLine() {
        if (tokenizer == null || !tokenizer.hasMoreTokens()) {
            try {
                return reader.readLine();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }

        return tokenizer.nextToken("\n");
    }

    public static long nl() {
        return Long.parseLong(next());
    }

    public static String n() {
        return next();
    }

    public static int ni() {
        return Integer.parseInt(next());
    }

    public static double nd() {
        return Double.parseDouble(next());
    }

    public static int[] nia(int n) {
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = ni();
        }
        return a;
    }

    //1-index
    public static int[] niao(int n) {
        int[] a = new int[n + 1];
        for (int i = 1; i < n + 1; i++) {
            a[i] = ni();
        }
        return a;
    }

    //
    public static int[] nias(int n, int end) {
        int[] a = new int[n + 1];
        for (int i = 0; i < n; i++) {
            a[i] = ni();
        }
        a[n] = end;
        return a;
    }

    public static int[] niad(int n) {
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = ni() - 1;
        }
        return a;
    }

    public static P[] npa(int n) {
        P[] p = new P[n];
        for (int i = 0; i < n; i++) {
            p[i] = new P(ni(), ni());
        }
        return p;
    }

    public static P[] npad(int n) {
        P[] p = new P[n];
        for (int i = 0; i < n; i++) {
            p[i] = new P(ni() - 1, ni() - 1);
        }
        return p;
    }

    public static int[][] nit(int h, int w) {
        int[][] a = new int[h][w];
        for (int hi = 0; hi < h; hi++) {
            for (int wi = 0; wi < w; wi++) {
                a[hi][wi] = ni();
            }
        }
        return a;
    }

    public static int[][] nitd(int h, int w) {
        int[][] a = new int[h][w];
        for (int hi = 0; hi < h; hi++) {
            for (int wi = 0; wi < w; wi++) {
                a[hi][wi] = ni() - 1;
            }
        }
        return a;
    }

    static int[][] S_ARRAY;
    static long[][] S_LARRAY;
    static int S_INDEX;
    static int S_LINDEX;

    //
    public static int[] niah(int n, int k) throws Exception {
        if (S_ARRAY == null) {
            S_ARRAY = new int[k][n];
            for (int j = 0; j < n; j++) {
                for (int i = 0; i < k; i++) {
                    S_ARRAY[i][j] = ni();
                }
            }
        }
        return S_ARRAY[S_INDEX++];
    }

    public static long[] nlah(int n, int k) throws Exception {
        if (S_LARRAY == null) {
            S_LARRAY = new long[k][n];
            for (int j = 0; j < n; j++) {
                for (int i = 0; i < k; i++) {
                    S_LARRAY[i][j] = nl();
                }
            }
        }
        return S_LARRAY[S_LINDEX++];
    }

    //
    public static int[] niahd(int n, int k) throws Exception {
        if (S_ARRAY == null) {
            S_ARRAY = new int[k][n];
            for (int j = 0; j < n; j++) {
                for (int i = 0; i < k; i++) {
                    S_ARRAY[i][j] = ni() - 1;
                }
            }
        }
        return S_ARRAY[S_INDEX++];
    }

    public static long[] nlahd(int n, int k) throws Exception {
        if (S_LARRAY == null) {
            S_LARRAY = new long[k][n];
            for (int j = 0; j < n; j++) {
                for (int i = 0; i < k; i++) {
                    S_LARRAY[i][j] = nl() - 1;
                }
            }
        }
        return S_LARRAY[S_LINDEX++];
    }

    public static char[] nca() {
        char[] a = next().toCharArray();
        return a;
    }


    public static String[] nsa(int n) {
        String[] res = new String[n];
        for (int i = 0; i < n; i++) {
            res[i] = n();
        }
        return res;
    }

    //
    public static char[][] ncts(int h, int w) {
        char[][] a = new char[h][w];
        for (int hi = 0; hi < h; hi++) {
            String s = nextLine().replace(" ", "");
            for (int wi = 0; wi < s.length(); wi++) {
                a[hi][wi] = s.charAt(wi);
            }
        }
        return a;
    }

    public static char[][] nct(int h, int w) {
        char[][] a = new char[h][w];
        for (int hi = 0; hi < h; hi++) {
            String s = nextLine();
            for (int wi = 0; wi < s.length(); wi++) {
                a[hi][wi] = s.charAt(wi);
            }
        }
        return a;
    }

    public static char[][] nctp(int h, int w, char c) {
        char[][] a = new char[h + 2][w + 2];
        for (int hi = 1; hi < h + 1; hi++) {
            String s = nextLine();
            for (int wi = 1; wi < s.length() + 1; wi++) {
                a[hi][wi] = s.charAt(wi - 1);
            }
        }
        for (int wi = 0; wi < w + 2; wi++)
            a[0][wi] = a[h + 1][wi] = c;
        for (int hi = 0; hi < h + 2; hi++)
            a[hi][0] = a[hi][w + 1] = c;
        return a;
    }

    //
    public static char[][] nctsp(int h, int w, char c) {
        char[][] a = new char[h + 2][w + 2];
        //char c = '*';
        int i;
        for (i = 0; i < w + 2; i++)
            a[0][i] = c;
        for (i = 1; i < h + 1; i++) {
            a[i] = (c + nextLine().replace(" ", "") + c).toCharArray();
        }
        for (i = 0; i < w + 2; i++)
            a[h + 1][i] = c;
        return a;
    }

    public static long[] nla(int n) {
        long[] a = new long[n];
        for (int i = 0; i < n; i++) {
            a[i] = nl();
        }
        return a;
    }

    public static long[] nlas(int n, long e) {
        long[] a = new long[n + 1];
        for (int i = 0; i < n; i++) {
            a[i] = nl();
        }
        a[n] = e;
        return a;
    }

    public static long[] nlao(int n) {
        long[] a = new long[n + 1];
        for (int i = 0; i < n; i++) {
            a[i + 1] = nl();
        }
        return a;
    }

    public static long[] nlad(int n) {
        long[] a = new long[n];
        for (int i = 0; i < n; i++) {
            a[i] = nl() - 1;
        }
        return a;
    }

    public static long[][] nlt(int h, int w) {
        long[][] a = new long[h][w];
        for (int hi = 0; hi < h; hi++) {
            for (int wi = 0; wi < w; wi++) {
                a[hi][wi] = nl();
            }
        }
        return a;
    }

    //
    static class CouMap {
        public HashMap<Long, Long> map;
        public HashMap<String, Long> smap;

        CouMap() {
            map = new HashMap();
            smap = new HashMap();
        }

        CouMap(int[] a) {
            map = new HashMap();
            smap = new HashMap();
            for (int i : a) {
                put(i);
            }
        }

        public int size() {
            return map.size();
        }

        public void put(long key, long value) {
            Long nowValue = map.get(key);
            map.put(key, nowValue == null ? value : nowValue + value);
        }

        public void put(String key, long value) {
            Long nowValue = smap.get(key);
            smap.put(key, nowValue == null ? value : nowValue + value);
        }

        public void mput(long key, long value) {
            Long nowValue = map.get(key);
            map.put(key, nowValue == null ? value % MOD : mSum(nowValue, value));
        }

        public void put(long key) {
            put(key, 1);
        }

        public void put(String key) {
            put(key, 1);
        }

        public void put(int... arg) {
            for (int i : arg) {
                put(i, 1);
            }
        }

        public void put(long... arg) {
            for (long i : arg) {
                put(i, 1);
            }
        }

        public void mput(int... arg) {
            for (int i : arg) {
                mput(i, 1);
            }
        }

        public void mput(long... arg) {
            for (long i : arg) {
                mput(i, 1);
            }
        }

        public long get(long key) {
            Long v = map.get(key);
            return v == null ? 0 : v;
        }

        public long get(String key) {
            Long v = map.get(key);
            return v == null ? 0 : v;
        }
    }

    static class P implements Comparable<P> {
        int x, y;

        @Override
        public int compareTo(P p) {
            //xy
            return x == p.x ? y - p.y : x - p.x;
            //xy
            //return (nowx == p.nowx ? nowy - p.nowy : nowx - p.nowx) * -1;
            //yx
            //return nowy == p.nowy ? nowx - p.nowx : nowy - p.nowy;
            //yx
            //return (nowy == p.nowy ? nowx - p.nowx : nowy - p.nowy) * -1;

            //x y
            //return nowx == p.nowx ? p.nowy - nowy : nowx - p.nowx;
            //x y
            //return (nowx == p.nowx ? p.nowy - nowy : nowx - p.nowx) * -1;
            //y x
            //return nowy == p.nowy ? p.nowx - nowx : nowy - p.nowy;
            //y x
            //return (nowy == p.nowy ? p.nowx - nowx : nowy - p.nowy) * -1;
        }

        P(int a, int b) {
            x = a;
            y = b;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof P)) return false;
            P p = (P) o;
            return x == p.x && y == p.y;
        }

        @Override
        public int hashCode() {
            return Objects.hash(x, y);
        }

    }

    static class PL implements Comparable<PL> {
        long x, y;

        public int compareTo(PL p) {
            //xy
            long res = x == p.x ? y - p.y : x - p.x;
            //xy
            //long res = (nowx == p.nowx ? nowy - p.nowy : nowx - p.nowx) * -1;
            //yx
            //long res = nowy == p.nowy ? nowx - p.nowx : nowy - p.nowy;
            //yx
            //long res = (nowy == p.nowy ? nowx - p.nowx : nowy - p.nowy) * -1;

            //x y
            //long res = nowx == p.nowx ? p.nowy - nowy : nowx - p.nowx;
            //x y
            //long res = (nowx == p.nowx ? p.nowy - nowy : nowx - p.nowx) * -1;
            //y x
            //long res = nowy == p.nowy ? p.nowx - nowx : nowy - p.nowy;
            //y x
            //long res = (nowy == p.nowy ? p.nowx - nowx : nowy - p.nowy) * -1;

            return (res == 0) ? 0 : res > 0 ? 1 : -1;
        }

        PL(long a, long b) {
            x = a;
            y = b;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof PL)) return false;
            PL p = (PL) o;
            return x == p.x && y == p.y;
        }

        @Override
        public int hashCode() {
            return Objects.hash(x, y);
        }

    }

    //
    static class RectangleSum {
        // 00
        long[][] rui;
        int H, W;

        RectangleSum(long[][] ori) {
            H = ori.length;
            W = ori[0].length;
            rui = new long[H + 1][W + 1];
            for (int hi = 0; hi < H; hi++) {
                for (int wi = 0; wi < W; wi++) {
                    rui[hi + 1][wi + 1] = ori[hi][wi];
                }
            }
            for (int hi = 1; hi < H + 1; hi++) {
                for (int wi = 1; wi < W + 1; wi++) {
                    rui[hi][wi] += rui[hi - 1][wi];
                    rui[hi][wi] += rui[hi][wi - 1];
                    rui[hi][wi] -= rui[hi - 1][wi - 1];
                }
            }
        }

        RectangleSum(int[][] ori) {
            H = ori.length;
            W = ori[0].length;
            rui = new long[H + 1][W + 1];
            for (int hi = 0; hi < H; hi++) {
                for (int wi = 0; wi < W; wi++) {
                    rui[hi + 1][wi + 1] = ori[hi][wi];
                }
            }
            for (int hi = 1; hi < H + 1; hi++) {
                for (int wi = 1; wi < W + 1; wi++) {
                    rui[hi][wi] += rui[hi - 1][wi];
                    rui[hi][wi] += rui[hi][wi - 1];
                    rui[hi][wi] -= rui[hi - 1][wi - 1];
                }
            }
        }

        //
        public long getSum(int left, int right, int top, int bottom) {
            if (right > W || bottom > H) return 0;
            if (left < 0 || top < 0) return 0;
            if (top >= bottom || left >= right) return 0;
            long res = rui[bottom][right];
            res -= rui[top][right];
            res -= rui[bottom][left];
            res += rui[top][left];
            return res;
        }

    }

    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        solve();
        System.out.flush();
        long endTime = System.currentTimeMillis();
        if (DEBUG) System.err.println(endTime - startTime);
    }

}

</source>
</class>

<class classid="207" nclones="2" nlines="72" similarity="100">
<source file="../hum_codes_raw/s409947235.java" startline="1" endline="98" pcid="13786">
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

public class Main{

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int n = sc.nextInt();
			if(n == 0){
				break;
			}
			int[][] students = new int[n][n];
			boolean[][] tallest = new boolean[n][n];
			boolean[][] shortest = new boolean[n][n];
			int[][] x = new int[n][n];
			for(int i = 0; i < n; i++){
				for(int j = 0; j < n; j++){
					students[i][j] = sc.nextInt();
				}
			}
			
			for(int i = 0; i < n; i++){
				int columnMax = -1, maxj = -1;
				for(int j = 0; j < n; j++){
					if(columnMax < students[j][i]){
						columnMax = students[j][i];
                        maxj = j;
                    }
//					columnMax = Math.max(columnMax, students[j][i]);
				}
				for(int j = 0; j < n; j++){
					if(columnMax == students[j][i]){
						tallest[j][i] = true;
						x[j][i] |= 2;
					}
				}
			}
			for(int i = 0; i < n; i++){
				int rowMin = Integer.MAX_VALUE, minj = -1;
				for(int j = 0; j < n; j++){
					if(rowMin > students[i][j]){
						rowMin = students[i][j];
                        minj = j;
                    }
//					rowMin = Math.min(rowMin, students[i][j]);
//					minj = j;
				}
				for(int j = 0; j < n; j++){
					if(rowMin == students[i][minj]){
						shortest[i][minj] = true;
						x[i][minj] |= 1;
					}
				}
			}
			
			Set<Integer> both = new HashSet<Integer>();
            for(int i = 0;i < n;i++){
                for(int j = 0;j < n;j++){
                    if(x[i][j] == 3){
                        both.add(students[i][j]);
                    }
                }
            }
			
            if(both.size() == 1){
            	StringBuilder sb = new StringBuilder();
                for(int v : both){
                    sb.append(v + " ");
                }
                sb.deleteCharAt(sb.length() - 1);
                System.out.println(sb);
            }else{
            	System.out.println(0);
            }
/*			boolean noAns = true;
			StringBuilder sb = new StringBuilder();
			for(int i = 0; i < n; i++){
				for(int j = 0; j < n; j++){
					if(shortest[i][j] && tallest[i][j]){
						sb.append(students[i][j] + " ");
						noAns = false;
					}
				}
			}
			
			if(noAns){
				System.out.println(0);
			}else{
				sb.deleteCharAt(sb.length() - 1);
				System.out.print(sb);
			}
*/		}
		
	}
}

</source>
<source file="../hum_codes_raw/s742365105.java" startline="1" endline="98" pcid="24944">
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int n = sc.nextInt();
			if(n == 0){
				break;
			}
			int[][] students = new int[n][n];
			boolean[][] tallest = new boolean[n][n];
			boolean[][] shortest = new boolean[n][n];
			int[][] x = new int[n][n];
			for(int i = 0; i < n; i++){
				for(int j = 0; j < n; j++){
					students[i][j] = sc.nextInt();
				}
			}
			
			for(int i = 0; i < n; i++){
				int columnMax = -1, maxj = -1;
				for(int j = 0; j < n; j++){
					if(columnMax < students[j][i]){
						columnMax = students[j][i];
                        maxj = j;
                    }
//					columnMax = Math.max(columnMax, students[j][i]);
				}
				for(int j = 0; j < n; j++){
					if(columnMax == students[j][i]){
						tallest[j][i] = true;
						x[j][i] |= 2;
					}
				}
			}
			for(int i = 0; i < n; i++){
				int rowMin = Integer.MAX_VALUE, minj = -1;
				for(int j = 0; j < n; j++){
					if(rowMin > students[i][j]){
						rowMin = students[i][j];
                        minj = j;
                    }
//					rowMin = Math.min(rowMin, students[i][j]);
//					minj = j;
				}
				for(int j = 0; j < n; j++){
					if(rowMin == students[i][minj]){
						shortest[i][minj] = true;
						x[i][minj] |= 1;
					}
				}
			}
			
			Set<Integer> both = new HashSet<Integer>();
            for(int i = 0;i < n;i++){
                for(int j = 0;j < n;j++){
                    if(x[i][j] == 3){
                        both.add(students[i][j]);
                    }
                }
            }
			
            if(both.size() == 1){
            	StringBuilder sb = new StringBuilder();
                for(int v : both){
                    sb.append(v + " ");
                }
                sb.deleteCharAt(sb.length() - 1);
                System.out.println(sb);
            }else{
            	System.out.println(0);
            }
/*			boolean noAns = true;
			StringBuilder sb = new StringBuilder();
			for(int i = 0; i < n; i++){
				for(int j = 0; j < n; j++){
					if(shortest[i][j] && tallest[i][j]){
						sb.append(students[i][j] + " ");
						noAns = false;
					}
				}
			}
			
			if(noAns){
				System.out.println(0);
			}else{
				sb.deleteCharAt(sb.length() - 1);
				System.out.print(sb);
			}
*/		}
		
	}
}

</source>
</class>

<class classid="208" nclones="2" nlines="84" similarity="100">
<source file="../hum_codes_raw/s411393121.java" startline="1" endline="89" pcid="13832">
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main
{
    static class Node{
        int b = 0;
        int w = 0;
        List<Integer> child;
    }
    static int subsetSum(int[] arr, int target){
        int n = arr.length;
        int m = target + 1;
        boolean[][] dp = new boolean[n][m];
        for (int i = 0; i < n; i++) {
            if (arr[i] > target) continue;
            dp[i][arr[i]] = true;
        }
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (dp[i-1][j]){
                    dp[i][j] = true;
                    if (j + arr[i] <= target){
                        dp[i][j+arr[i]] = true;
                    }
                }
            }
        }
        for (int i = m-1; i >= 0;i--) {
            if (dp[n-1][i]){
                return i;
            }
        }
        return 0;
    }

    static Node[] nodes;
    static int[] X;
    public static void main(String[] args) throws FileNotFoundException {
        Scanner sc= new Scanner(System.in);
        int N = sc.nextInt();
        nodes = new Node[N];
        X = new int[N];
        for (int i = 0; i < N; i++) {
            nodes[i] = new Node();
            nodes[i].child = new ArrayList<>();
        }
        for (int i = 1; i < N; i++) {
            int par = sc.nextInt();
            nodes[par - 1].child.add(i);
        }
        for (int i = 0; i < N; i++) {
            X[i] = sc.nextInt();
        }
        System.out.println(recur(0) ? "POSSIBLE": "IMPOSSIBLE");
    }

    public static boolean recur(int nodeIdx){
        Node cur = nodes[nodeIdx];
        if (cur.child == null || cur.child.size() == 0){
            cur.b = 0; cur.w = X[nodeIdx];
            return true;
        }
        for (int i = 0; i < cur.child.size(); i++) {
            if (!recur(cur.child.get(i))) {
                return false;
            }
        }
        int b = 0, w = 0;
        int[] swap = new int[cur.child.size()];
        for (int i = 0; i < cur.child.size(); i++) {
            int black = nodes[cur.child.get(i)].b;
            int white = nodes[cur.child.get(i)].w;
            b += Math.min(white, black);
            w += Math.max(white, black);
            swap[i] = Math.max(white, black) - Math.min(white, black);
        }
        if (b > X[nodeIdx]) {
            return false;
        }
        int sww = subsetSum(swap, X[nodeIdx] - b);
        cur.b = X[nodeIdx];
        cur.w = w - sww;
        return true;
    }

}

</source>
<source file="../hum_codes_raw/s836232524.java" startline="1" endline="89" pcid="28074">
import java.io.*;
import java.math.BigInteger;
import java.util.*;

public class Main
{
    static class Node{
        int b = 0;
        int w = 0;
        List<Integer> child;
    }
    static int subsetSum(int[] arr, int target){
        int n = arr.length;
        int m = target + 1;
        boolean[][] dp = new boolean[n][m];
        for (int i = 0; i < n; i++) {
            if (arr[i] > target) continue;
            dp[i][arr[i]] = true;
        }
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (dp[i-1][j]){
                    dp[i][j] = true;
                    if (j + arr[i] <= target){
                        dp[i][j+arr[i]] = true;
                    }
                }
            }
        }
        for (int i = m-1; i >= 0;i--) {
            if (dp[n-1][i]){
                return i;
            }
        }
        return 0;
    }

    static Node[] nodes;
    static int[] X;
    public static void main(String[] args) throws FileNotFoundException {
        Scanner sc= new Scanner(System.in);
        int N = sc.nextInt();
        nodes = new Node[N];
        X = new int[N];
        for (int i = 0; i < N; i++) {
            nodes[i] = new Node();
            nodes[i].child = new ArrayList<>();
        }
        for (int i = 1; i < N; i++) {
            int par = sc.nextInt();
            nodes[par - 1].child.add(i);
        }
        for (int i = 0; i < N; i++) {
            X[i] = sc.nextInt();
        }
        System.out.println(recur(0) ? "POSSIBLE": "IMPOSSIBLE");
    }

    public static boolean recur(int nodeIdx){
        Node cur = nodes[nodeIdx];
        if (cur.child == null || cur.child.size() == 0){
            cur.b = 0; cur.w = X[nodeIdx];
            return true;
        }
        for (int i = 0; i < cur.child.size(); i++) {
            if (!recur(cur.child.get(i))) {
                return false;
            }
        }
        int b = 0, w = 0;
        int[] swap = new int[cur.child.size()];
        for (int i = 0; i < cur.child.size(); i++) {
            int black = nodes[cur.child.get(i)].b;
            int white = nodes[cur.child.get(i)].w;
            b += Math.min(white, black);
            w += Math.max(white, black);
            swap[i] = Math.max(white, black) - Math.min(white, black);
        }
        if (b > X[nodeIdx]) {
            return false;
        }
        int sww = subsetSum(swap, X[nodeIdx] - b);
        cur.b = X[nodeIdx];
        cur.w = w - sww;
        return true;
    }

}

</source>
</class>

<class classid="209" nclones="2" nlines="61" similarity="100">
<source file="../hum_codes_raw/s414915935.java" startline="1" endline="73" pcid="13948">
import java.util.*;
import java.util.Map.Entry;
import java.lang.*;
import java.math.*;

public class Main{
	Scanner sc=new Scanner(System.in);

	int INF=1<<28;
	double EPS=1e-9;

	int n;
	HashMap<String, String> map=new HashMap<String, String>();
	String start, end;
	int ans;

	void run(){
		for(;;){
			n=sc.nextInt();
			//println("n:"+n);
			if(n==0){
				break;
			}
			map.clear();
			for(int i=0; i<n; i++){
				String s=sc.next();
				String t=sc.next();
				map.put(s, t);
			}
			start=sc.next();
			end=sc.next();
			ans=-1;
			dfs(start, 0);
			println(""+ans);
			//println("here");
		}
	}

	void dfs(String s, int r){
		// if(r==4)
		// println("r:"+r+" s:"+s);
		if(r>=ans&&r>=10){
			return;
		}else if(s.length()>end.length()){
			return;
		}else if(s.equals(end)){
			if(ans==-1||r<ans){
				ans=r;
			}
			return;
		}
		for(Entry<String, String> entry : map.entrySet()){
			if(s.contains(entry.getKey())){
				String t=s.replaceAll(entry.getKey(), entry.getValue());
				dfs(t, r+1);
			}
		}
	}

	void print(String s){
		System.out.print(s);
	}

	void println(String s){
		System.out.println(s);
	}

	public static void main(String[] args){
		new Main().run();

	}
}

</source>
<source file="../hum_codes_raw/s464589311.java" startline="1" endline="69" pcid="15581">
import java.util.*;
import java.util.Map.Entry;
import java.lang.*;
import java.math.*;

public class Main{
	Scanner sc=new Scanner(System.in);

	int INF=1<<28;
	double EPS=1e-9;

	int n;
	HashMap<String, String> map=new HashMap<String, String>();
	String start, end;
	int ans;

	void run(){
		for(;;){
			n=sc.nextInt();
			if(n==0){
				break;
			}
			map.clear();
			for(int i=0; i<n; i++){
				String s=sc.next();
				String t=sc.next();
				map.put(s, t);
			}
			start=sc.next();
			end=sc.next();
			ans=-1;
			dfs(start, 0);
			println(""+ans);
		}
	}

	void dfs(String s, int r){
		if(r>=ans&&r>=10){
			return;
		}else if(s.length()>end.length()){
			return;
		}else if(s.equals(end)){
			if(ans==-1||r<ans){
				ans=r;
			}
			return;
		}
		for(Entry<String, String> entry : map.entrySet()){
			if(s.contains(entry.getKey())){
				String t=s.replaceAll(entry.getKey(), entry.getValue());
				dfs(t, r+1);
			}
		}
	}

	void print(String s){
		System.out.print(s);
	}

	void println(String s){
		System.out.println(s);
	}

	public static void main(String[] args){
		new Main().run();

	}
}

</source>
</class>

<class classid="210" nclones="2" nlines="209" similarity="100">
<source file="../hum_codes_raw/s418980822.java" startline="1" endline="251" pcid="14081">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            DEars solver = new DEars();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class DEars {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            long[] A = new long[n];
            in.populate(A);

            long[][] props = new long[3][n];
            for (int i = 0; i < n; i++) {
                props[0][i] = A[i];
                props[1][i] = A[i] == 0 ? 1 : (A[i] - 1) % 2;
                props[2][i] = A[i] < 2 ? 2 - A[i] : (A[i] - 2) % 2;
            }

            //02120
            int[] pick = new int[]{0, 2, 1, 2, 0};
            long inf = (long) 1e18;
            long[][] dp = new long[5][n + 1];
            SequenceUtils.deepFill(dp, inf);
            dp[0][0] = 0;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < 5; j++) {
                    for (int t = j; t < 5; t++) {
                        dp[t][i + 1] = Math.min(dp[t][i + 1],
                                dp[j][i] + props[pick[t]][i]);
                    }
                }
            }

            long ans = inf;
            for (int i = 0; i < 5; i++) {
                ans = Math.min(ans, dp[i][n]);
            }

            out.println(ans);
        }

    }

    static class SequenceUtils {
        public static void deepFill(Object array, long val) {
            if (!array.getClass().isArray()) {
                throw new IllegalArgumentException();
            }
            if (array instanceof long[]) {
                long[] longArray = (long[]) array;
                Arrays.fill(longArray, val);
            } else {
                Object[] objArray = (Object[]) array;
                for (Object obj : objArray) {
                    deepFill(obj, val);
                }
            }
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        public void populate(long[] data) {
            for (int i = 0; i < data.length; i++) {
                data[i] = readLong();
            }
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

        public long readLong() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            long val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(long c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(long c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }
}


</source>
<source file="../hum_codes_raw/s892434344.java" startline="1" endline="251" pcid="30016">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            DEars solver = new DEars();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class DEars {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            long[] A = new long[n];
            in.populate(A);

            long[][] props = new long[3][n];
            for (int i = 0; i < n; i++) {
                props[0][i] = A[i];
                props[1][i] = A[i] == 0 ? 1 : (A[i] - 1) % 2;
                props[2][i] = A[i] < 2 ? 2 - A[i] : (A[i] - 2) % 2;
            }

            //02120
            int[] pick = new int[]{0, 2, 1, 2, 0};
            long inf = (long) 1e18;
            long[][] dp = new long[5][n + 1];
            SequenceUtils.deepFill(dp, inf);
            dp[0][0] = 0;
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < 5; j++) {
                    for (int t = j; t < 5; t++) {
                        dp[t][i + 1] = Math.min(dp[t][i + 1],
                                dp[j][i] + props[pick[t]][i]);
                    }
                }
            }

            long ans = inf;
            for (int i = 0; i < 5; i++) {
                ans = Math.min(ans, dp[i][n]);
            }

            out.println(ans);
        }

    }

    static class SequenceUtils {
        public static void deepFill(Object array, long val) {
            if (!array.getClass().isArray()) {
                throw new IllegalArgumentException();
            }
            if (array instanceof long[]) {
                long[] longArray = (long[]) array;
                Arrays.fill(longArray, val);
            } else {
                Object[] objArray = (Object[]) array;
                for (Object obj : objArray) {
                    deepFill(obj, val);
                }
            }
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        public void populate(long[] data) {
            for (int i = 0; i < data.length; i++) {
                data[i] = readLong();
            }
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

        public long readLong() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            long val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(long c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(long c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }
}


</source>
</class>

<class classid="211" nclones="2" nlines="12" similarity="100">
<source file="../hum_codes_raw/s419404211.java" startline="1" endline="13" pcid="14093">
import java.util.Scanner;
public class Main {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int a = sc.nextInt();
    int b = sc.nextInt();
    int area = a*b;
    int length = 2*(a + b);
    System.out.println(area + " " + length);
    sc.close();
  }
}

</source>
<source file="../hum_codes_raw/s698691854.java" startline="1" endline="14" pcid="23495">
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int a = sc.nextInt();
        int b = sc.nextInt();
        int area = a * b;
        int length = 2 * (a + b);
        System.out.println(area + " " + length);
        sc.close();
    }
}

</source>
</class>

<class classid="212" nclones="2" nlines="15" similarity="100">
<source file="../hum_codes_raw/s422743068.java" startline="1" endline="17" pcid="14201">
import java.util.Scanner;

public class Main {
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);

		int a = sc.nextInt();
		String op = sc.next();
		int b = sc.nextInt();
		if(op.equals("+")){
			System.out.println(a+b);
		}else{
			System.out.println(a-b);
		}
	}
}

</source>
<source file="../hum_codes_raw/s861601091.java" startline="1" endline="19" pcid="28969">
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);

		int a = sc.nextInt();
		String op = sc.next();
		int b = sc.nextInt();
		if (op.equals("+")) {
			System.out.println(a + b);
		} else {
			System.out.println(a - b);
		}
	}

}

</source>
</class>

<class classid="213" nclones="2" nlines="221" similarity="100">
<source file="../hum_codes_raw/s423699023.java" startline="1" endline="262" pcid="14246">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Collection;
import java.io.IOException;
import java.util.Deque;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.ArrayDeque;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            CLexicographicConstraints solver = new CLexicographicConstraints();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class CLexicographicConstraints {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            int[] a = new int[n];
            in.populate(a);
            Deque<Tag> dq = new ArrayDeque<>(n);
            IntBinarySearch ibs = new IntBinarySearch() {

                public boolean check(int mid) {
                    dq.clear();
                    int length = 0;
                    for (int x : a) {
                        if (length < x) {
                            length = x;
                            continue;
                        }
                        length = x;
                        if (mid == 1) {
                            return false;
                        }
                        while (!dq.isEmpty() && dq.peekLast().index >= length) {
                            dq.removeLast();
                        }
                        int cur = length - 1;
                        while (cur >= 0) {
                            Tag tail = dq.isEmpty() || dq.peekLast().index != cur ?
                                    new Tag(cur, 0) : dq.removeLast();
                            if (tail.val + 1 == mid) {
                                cur--;
                            } else {
                                tail.val++;
                                dq.addLast(tail);
                                break;
                            }
                        }
                        if (cur < 0) {
                            return false;
                        }
                    }
                    return true;
                }
            };

            int ans = ibs.binarySearch(1, n);
            out.println(ans);
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class DigitUtils {
        private DigitUtils() {
        }

        public static int floorAverage(int x, int y) {
            return (x & y) + ((x ^ y) >> 1);
        }

    }

    static abstract class IntBinarySearch {
        public abstract boolean check(int mid);

        public int binarySearch(int l, int r) {
            if (l > r) {
                throw new IllegalArgumentException();
            }
            while (l < r) {
                int mid = DigitUtils.floorAverage(l, r);
                if (check(mid)) {
                    r = mid;
                } else {
                    l = mid + 1;
                }
            }
            return l;
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        public void populate(int[] data) {
            for (int i = 0; i < data.length; i++) {
                data[i] = readInt();
            }
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }

    static class Tag {
        int index;
        int val;

        public Tag(int index, int val) {
            this.index = index;
            this.val = val;
        }

    }
}


</source>
<source file="../hum_codes_raw/s837746292.java" startline="1" endline="262" pcid="28123">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Collection;
import java.io.IOException;
import java.util.Deque;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.util.ArrayDeque;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            CLexicographicConstraints solver = new CLexicographicConstraints();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class CLexicographicConstraints {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            int[] a = new int[n];
            in.populate(a);
            Deque<Tag> dq = new ArrayDeque<>(n);
            IntBinarySearch ibs = new IntBinarySearch() {

                public boolean check(int mid) {
                    dq.clear();
                    int length = 0;
                    for (int x : a) {
                        if (length < x) {
                            length = x;
                            continue;
                        }
                        length = x;
                        if (mid == 1) {
                            return false;
                        }
                        while (!dq.isEmpty() && dq.peekLast().index >= length) {
                            dq.removeLast();
                        }
                        int cur = length - 1;
                        while (cur >= 0) {
                            Tag tail = dq.isEmpty() || dq.peekLast().index != cur ?
                                    new Tag(cur, 0) : dq.removeLast();
                            if (tail.val + 1 == mid) {
                                cur--;
                            } else {
                                tail.val++;
                                dq.addLast(tail);
                                break;
                            }
                        }
                        if (cur < 0) {
                            return false;
                        }
                    }
                    return true;
                }
            };

            int ans = ibs.binarySearch(1, n);
            out.println(ans);
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class DigitUtils {
        private DigitUtils() {
        }

        public static int floorAverage(int x, int y) {
            return (x & y) + ((x ^ y) >> 1);
        }

    }

    static abstract class IntBinarySearch {
        public abstract boolean check(int mid);

        public int binarySearch(int l, int r) {
            if (l > r) {
                throw new IllegalArgumentException();
            }
            while (l < r) {
                int mid = DigitUtils.floorAverage(l, r);
                if (check(mid)) {
                    r = mid;
                } else {
                    l = mid + 1;
                }
            }
            return l;
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        public void populate(int[] data) {
            for (int i = 0; i < data.length; i++) {
                data[i] = readInt();
            }
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }

    static class Tag {
        int index;
        int val;

        public Tag(int index, int val) {
            this.index = index;
            this.val = val;
        }

    }
}


</source>
</class>

<class classid="214" nclones="2" nlines="42" similarity="100">
<source file="../hum_codes_raw/s429139656.java" startline="1" endline="45" pcid="14422">
import java.util.Scanner;
import java.util.Stack;

public class Main {
    static int n;
    static Scanner sc = new Scanner(System.in);
    
    static boolean aun(){
        Stack<String> au = new Stack<>();
        for(int i=0;i<n;i++){
            String say = sc.next();
            //System.err.println(say);
            if(say.equals("A")){
                au.push("A");
            }
            if(say.equals("Un")){
                if(au.isEmpty()){
                    return false;
                }else{
                    au.pop();
                }
            }
            //System.err.println(au);
        }
        if(au.isEmpty()){
        	return true;
        }else {
        	return false;
        }
    }
    
    public static void main(String[] args) {
        n = sc.nextInt();
        if(n%2 == 1) {
        	System.out.println("NO");
        	return;
        }
        if(aun()){
            System.out.println("YES");
        }else{
            System.out.println("NO");
        }    
    }
}

</source>
<source file="../hum_codes_raw/s979472434.java" startline="1" endline="45" pcid="32938">
import java.util.Scanner;
import java.util.Stack;

public class Main {
    static int n;
    static Scanner sc = new Scanner(System.in);
    
    static boolean aun(){
        Stack<String> au = new Stack<>();
        for(int i=0;i<n;i++){
            String say = sc.next();
            //System.err.println(say);
            if(say.equals("A")){
                au.push("A");
            }
            if(say.equals("Un")){
                if(au.isEmpty()){
                    return false;
                }else{
                    au.pop();
                }
            }
            //System.err.println(au);
        }
        if(au.isEmpty()){
        	return true;
        }else {
        	return false;
        }
    }
    
    public static void main(String[] args) {
        n = sc.nextInt();
        if(n%2 == 1) {
        	System.out.println("NO");
        	return;
        }
        if(aun()){
            System.out.println("YES");
        }else{
            System.out.println("NO");
        }    
    }
}

</source>
</class>

<class classid="215" nclones="2" nlines="39" similarity="100">
<source file="../hum_codes_raw/s434195997.java" startline="1" endline="47" pcid="14577">
import java.io.IOException;
import java.util.Scanner;

public class Main {
	public static void main(String[] args) throws IOException {
		Scanner scanner = new Scanner(System.in);
		while (true) {
			int data = scanner.nextInt();
			if (data == 0) {
				scanner.close();
				break;
			}

			char[][] symbols = new char[data][];
			symbols[0] = scanner.next().toCharArray();

			for (int i = 1; i < data; i++) {
				symbols[i] = scanner.next().toCharArray();
				for (int j = 0; j < symbols[i].length; j++) {
					if (symbols[i][j + 1] != '.') {
						// '.''+'
						symbols[i][j] = '+';
						for (int k = i - 1; k >= 0; k--) {
							// '+''|'
							if (symbols[k][j] == ' ') {
								symbols[k][j] = '|';
							} else {
								break;
							}
						}
						break;
					} else {
						// 
						symbols[i][j] = ' ';
					}
				}
			}

			for (int i = 0; i < symbols.length; i++) {
				System.out.println(symbols[i]);
			}

		}

	}
}

</source>
<source file="../hum_codes_raw/s514961353.java" startline="1" endline="43" pcid="17278">
import java.io.IOException;
import java.util.Scanner;

public class Main {
	public static void main(String[] args) throws IOException {
		Scanner scanner = new Scanner(System.in);
		while (true) {
			int data = scanner.nextInt();
			if (data == 0) {
				scanner.close();
				break;
			}

			char[][] symbols = new char[data][];
			symbols[0] = scanner.next().toCharArray();
			for (int i = 1; i < data; i++) {
				symbols[i] = scanner.next().toCharArray();
				for (int j = 0; j < symbols[i].length; j++) {
					if (symbols[i][j + 1] != '.') {
						symbols[i][j] = '+';
						for (int k = i - 1; k >= 0; k--) {
							if (symbols[k][j] == ' ') {
								symbols[k][j] = '|';
							} else {
								break;
							}
						}
						break;
					} else {
						symbols[i][j] = ' ';
					}
				}
			}

			for (int i = 0; i < symbols.length; i++) {
				System.out.println(symbols[i]);
			}

		}

	}
}

</source>
</class>

<class classid="216" nclones="2" nlines="351" similarity="100">
<source file="../hum_codes_raw/s437788072.java" startline="1" endline="434" pcid="14685">
import java.io.*;
import java.util.*;

class Main{
    final static long INF = Long.MAX_VALUE / 2;
    final static int MOD = 1_000_000_007;
    final static int SIZE = 1_000_000;
    long[] fac = new long[SIZE];
    long[] inv = new long[SIZE];
    long[] finv = new long[SIZE];
    FastScanner sc = new FastScanner();

    public static void main(String[] args) {
        new Main().solve();
    }

    void solve(){

        int n = sc.nextInt();
        long[] a = new long[n + 1];

        for(int i = 0; i < n + 1; i++){
            a[i] = sc.nextLong();
        }

        if(a[0] > 1 || (a[0] == 1 && n > 1)){ // a[0] 1  1 a[0] 1  -1
            System.out.println(-1);
            System.exit(0);
        }

        // long b = 2;
        //
        // for(int i = 1; i < n + 1; i++){
        //     if(a[i] > b - a[i - 1] * 2){
        //         System.out.println(-1);
        //         System.exit(0);
        //     }
        //     b *= 2;
        //     if(b > 1000000000) break;
        // }

        long[] p = new long[n + 1]; // p[i] : 
        if(a[0] == 1) p[0] = 0;
        else p[0] = 1;

        for(int i = 1; i < n + 1; i++){
            p[i] = p[i - 1] * 2 - a[i]; // i = i - 1 * 2 - i ?
        }

        long[] m = new long[n + 1]; // m[i] : i
        m[0] = 1;

        for(int i = 1; i < n + 1; i++){
            m[i] = p[i - 1] * 2; // i = i - 1 * 2 ?
        }

        long[] s = new long[n + 1]; // s[i] : a[i], a[i + 1], ... a[n] 
        s[n] = a[n];

        for(int i = n - 1; i >= 0; i--){
            s[i] = s[i + 1] + a[i];
        }

        long sum = 0;

        for(int i = 0; i < n + 1; i++){
            if(m[i] >= 0){
                sum += Math.min(m[i], s[i]);
                if(a[i] > m[i]){
                    System.out.println(-1);
                    System.exit(0);
                }
            }else{
                sum += s[i];
            }
        }

        System.out.println(sum);

    }

    long gcd(long a, long b){ // return ab
        if(b == 0){
          return a;
        }
        return gcd(b, a % b);
    }

    long lcm(long a, long b){ // return ab
        return a * b / gcd(a, b);
    }

    long inv(long a){ // return a (mod MOD)
        return pow(a, MOD - 2);
    }

    long pow(long a, long r){ // return a^r (mod MOD)
        long sum = 1;
        while(r > 0){
            if((r & 1) == 1){ // 21
                sum *= a;
                sum %= MOD;
            }
            a *= a;
            a %= MOD;
            r >>= 1;
        }
        return sum;
    }

    long modFact(long n){ // retur n! (mod MOD)
        if(n == 0){
            return 1;
        }
        return n * modFact(n - 1) % MOD;
    }

    long fact(long n){ // return n!
        if(n == 0){
            return 1;
        }
        return n * fact(n - 1);
    }

    void initCOMB(){
        fac[0] = fac[1] = 1;
        inv[1] = 1;
        finv[0] = finv[1] = 1;
        for(int i = 2; i < SIZE; i++){
            fac[i] = fac[i - 1] * i % MOD;
            inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;
            finv[i] = finv[i - 1] * inv[i] % MOD;
        }
    }

    long modComb(int n, int r){ // return nCr (initCOMB())
        if(n < r || n < 0 || r < 0) return 0;
        return fac[n] * finv[r] % MOD * finv[n - r] % MOD;
    }

    long comb(long n, long r){ // return nCr
        long num = 1;
        for(long i = 1; i <= r; i++){
            num = num * (n - i + 1) / i;
        }
        return num;
    }

    boolean isPrime(long a){ // a
        if(a <= 1) return false;
        for(int i = 2; i * i <= a; i++){
            if(a % i == 0) return false;
        }
        return true;
    }

    int lowerBound(long[] a, long v){ // return av
        int r = a.length;
        int l = -1;
        while(r - l > 1){
            int mid = (r + l) / 2;
            if(a[mid] >= v){
                r = mid;
            }else{
                l = mid;
            }
        }
        return r;
    }

    int upperBound(long[] a, long v){ // return av
        int r = a.length;
        int l = -1;
        while(r - l > 1){
            int mid = (r + l) / 2;
            if(a[mid] > v){
                r = mid;
            }else{
                l = mid;
            }
        }
        return r;
    }

    String nextPermutation(String s){ // return s
        ArrayList<Character> list = new ArrayList<>();
        for(int i = 0; i < s.length(); i++) list.add(s.charAt(i));

        int pivotPos = -1;
        char pivot = 0;
        for(int i = list.size() - 2; i >= 0; i--){
            if(list.get(i) < list.get(i+1)){
    			pivotPos = i;
    			pivot = list.get(i);
    			break;
    		}
    	}

        if(pivotPos == -1 && pivot == 0) return null;

        int L = pivotPos + 1;
        int R = list.size() - 1;
    	int minPos = -1;
    	char min = Character.MAX_VALUE;
    	for(int i = R; i >= L; i--){
    		if(pivot < list.get(i)){
    			if(list.get(i) < min){
    				min = list.get(i);
    				minPos = i;
    			}
    		}
    	}

    	Collections.swap(list, pivotPos, minPos);
    	Collections.sort(list.subList(L, R + 1));

    	StringBuilder sb = new StringBuilder();
    	for(int i=0; i<list.size(); i++) sb.append(list.get(i));

    	return sb.toString();
    }

    boolean nextPermutation(long[] a){
        for(int i = a.length - 1; i > 0; i--){
            if(a[i - 1] < a[i]){
                int swapIndex = find(a[i - 1], a, i, a.length - 1);
                long temp = a[swapIndex];
                a[swapIndex] = a[i - 1];
                a[i - 1] = temp;
                Arrays.sort(a, i, a.length);
                return true;
            }
        }
        return false;
    }

    int find(long dest, long[] a, int s, int e){
        if(s == e){
            return s;
        }
        int m = (s + e + 1) / 2;
        return a[m] <= dest ? find(dest, a, s, m - 1) : find(dest, a, m, e);
    }

    void elimination(int[][] a, int[] b) {
        int n = a.length;
        double f;
        for(int k = 0; k < n - 1; k++){
            for(int i = k + 1; i < n; i++){
                f = - a[i][k] / a[k][k];
                for(int j = k + 1; j < n; j++){
                    a[i][j] += f * a[k][j];
                }
                b[i] += f * b[k];
            }
            for(int i = n - 1; i >= 0; i--){
                for(int j = i + 1; j < n; j++){
                    b[i] -= a[i][j] * b[j];
                }
                b[i] = b[i] / a[i][i];
            }
        }
   }



   class SegmentTree{

       //------------------------------------------------------------
       // 2 * n - 1 : 
       // i + n - 1 : i
       // 2 * i + 1, 2 * i + 2 : i
       // (i - 1) / 2 : i
       //
       // int n = sc.nextInt();
       // long[] a = new long[n];
       // for(int i = 0; i < n; i++) a[i] = sc.nextLong();
       // SegmentTree st = new SegmentTree(a);
       // int l = sc.nextInt() - 1;
       // int r = sc.nextInt() - 1;
       // System.out.println(st.query(l, r));
       //------------------------------------------------------------

       final static long INF = Long.MAX_VALUE / 2;

       // long e = INF; // 
       long e = 0;
       long func(long a, long b){ // 
           // return Math.min(a, b);
           return a + b;
       }

       int n; // 2
       long[] node;

       SegmentTree(long[] a){
           init(a);
       }

       void init(long[] a){ // a
           n = 1;
           while(n < a.length){
               n *= 2;
           }
           node = new long[2 * n - 1];
           Arrays.fill(node, e);
           for(int i = 0; i < a.length; i++){
               node[i + n - 1] = a[i];
           }
           for(int i = n - 2; i >= 0; i--){
               node[i] = func(node[2 * i + 1], node[2 * i + 2]);
           }
       }

       void update(int p, long v){ // pv
           p = p + n - 1;
           node[p] = v;
           while(p > 0){
               p = (p - 1) / 2;
               node[p] = func(node[2 * p + 1], node[2 * p + 2]);
           }
       }

       long query(int a, int b){ // [a, b)
           return query(a, b, 0, 0, n);
       }

       long query(int a, int b, int k, int l, int r){
           if(r <= a || b <= l) return e;
           if(a <= l && r <= b) return node[k];
           return func(query(a, b, 2 * k + 1, l, (l + r) / 2), query(a, b, 2 * k + 2, (l + r) / 2, r));
       }

   }



}



class Pair implements Comparable<Pair>{
    long a, b;
    public Pair(long i, long j){
        a = i;
        b = j;
    }

    @Override
    public int compareTo(Pair p){
        if(this.b < p.b) return -1;
        else if(this.b > p.b) return 1;
        else return 0;
    }
}



class FastScanner {
    private final InputStream in = System.in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;
    private boolean hasNextByte(){
        if(ptr < buflen){
            return true;
        }else{
            ptr = 0;
            try{
                buflen = in.read(buffer);
            }catch(IOException e){
                e.printStackTrace();
            }
            if(buflen <= 0){
                return false;
            }
        }
        return true;
    }
    private int readByte(){
        if(hasNextByte()) return buffer[ptr++];
        else return -1;
    }
    private static boolean isPrintableChar(int c){
        return 33 <= c && c <= 126;
    }
    public boolean hasNext(){
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next(){
        if(!hasNext()) throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)){
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
    public long nextLong(){
        if(!hasNext()) throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if(b == '-'){
            minus = true;
            b = readByte();
        }
        if(b < '0' || '9' < b){
            throw new NumberFormatException();
        }
        while(true){
            if('0' <= b && b <= '9'){
                n *= 10;
                n += b - '0';
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt(){
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble(){
        return Double.parseDouble(next());
    }
}

</source>
<source file="../hum_codes_raw/s470221652.java" startline="1" endline="435" pcid="15801">
import java.io.*;
import java.util.*;

class Main{
    final static long INF = Long.MAX_VALUE / 2;
    final static int MOD = 1_000_000_007;
    final static int SIZE = 1_000_000;
    long[] fac = new long[SIZE];
    long[] inv = new long[SIZE];
    long[] finv = new long[SIZE];
    FastScanner sc = new FastScanner();

    public static void main(String[] args) {
        new Main().solve();
    }

    void solve(){

        int n = sc.nextInt();
        long[] a = new long[n + 1];

        for(int i = 0; i < n + 1; i++){
            a[i] = sc.nextLong();
        }

        if(a[0] > 1 || (a[0] == 1 && n > 1)){ // a[0] 1  1 a[0] 1  -1
            System.out.println(-1);
            System.exit(0);
        }

        // long b = 2;
        //
        // for(int i = 1; i < n + 1; i++){
        //     if(a[i] > b - a[i - 1] * 2){
        //         System.out.println(-1);
        //         System.exit(0);
        //     }
        //     b *= 2;
        //     if(b > 1000000000) break;
        // }

        long[] p = new long[n + 1]; // p[i] : 
        if(a[0] == 1) p[0] = 0;
        else p[0] = 1;

        for(int i = 1; i < n + 1; i++){
            p[i] = p[i - 1] * 2 - a[i]; // i = i - 1 * 2 - i ?
        }

        long[] m = new long[n + 1]; // m[i] : i
        m[0] = 1;

        for(int i = 1; i < n + 1; i++){
            m[i] = p[i - 1] * 2; // i = i - 1 * 2 ?
        }

        long[] s = new long[n + 1]; // s[i] : a[i], a[i + 1], ... a[n] 
        s[n] = a[n];

        for(int i = n - 1; i >= 0; i--){
            s[i] = s[i + 1] + a[i];
        }

        long sum = 0;

        for(int i = 0; i < n + 1; i++){
            if(m[i] >= 0){
                sum += Math.min(m[i], s[i]);
                if(a[i] > m[i]){
                    System.out.println(-1);
                    System.exit(0);
                }
            }else{
                sum += s[i];
            }
        }

        System.out.println(sum);

    }

    long gcd(long a, long b){ // return ab
        if(b == 0){
          return a;
        }
        return gcd(b, a % b);
    }

    long lcm(long a, long b){ // return ab
        return a * b / gcd(a, b);
    }

    long inv(long a){ // return a (mod MOD)
        return pow(a, MOD - 2);
    }

    long pow(long a, long r){ // return a^r (mod MOD)
        long sum = 1;
        while(r > 0){
            if((r & 1) == 1){ // 21
                sum *= a;
                sum %= MOD;
            }
            a *= a;
            a %= MOD;
            r >>= 1;
        }
        return sum;
    }

    long modFact(long n){ // retur n! (mod MOD)
        if(n == 0){
            return 1;
        }
        return n * modFact(n - 1) % MOD;
    }

    long fact(long n){ // return n!
        if(n == 0){
            return 1;
        }
        return n * fact(n - 1);
    }

    void initCOMB(){
        fac[0] = fac[1] = 1;
        inv[1] = 1;
        finv[0] = finv[1] = 1;
        for(int i = 2; i < SIZE; i++){
            fac[i] = fac[i - 1] * i % MOD;
            inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;
            finv[i] = finv[i - 1] * inv[i] % MOD;
        }
    }

    long modComb(int n, int r){ // return nCr (initCOMB())
        if(n < r || n < 0 || r < 0) return 0;
        return fac[n] * finv[r] % MOD * finv[n - r] % MOD;
    }

    long comb(long n, long r){ // return nCr
        long num = 1;
        for(long i = 1; i <= r; i++){
            num = num * (n - i + 1) / i;
        }
        return num;
    }

    boolean isPrime(long a){ // a
        if(a <= 1) return false;
        for(int i = 2; i * i <= a; i++){
            if(a % i == 0) return false;
        }
        return true;
    }

    int lowerBound(long[] a, long v){ // return av
        int r = a.length;
        int l = -1;
        while(r - l > 1){
            int mid = (r + l) / 2;
            if(a[mid] >= v){
                r = mid;
            }else{
                l = mid;
            }
        }
        return r;
    }

    int upperBound(long[] a, long v){ // return av
        int r = a.length;
        int l = -1;
        while(r - l > 1){
            int mid = (r + l) / 2;
            if(a[mid] > v){
                r = mid;
            }else{
                l = mid;
            }
        }
        return r;
    }

    String nextPermutation(String s){ // return s
        ArrayList<Character> list = new ArrayList<>();
        for(int i = 0; i < s.length(); i++) list.add(s.charAt(i));

        int pivotPos = -1;
        char pivot = 0;
        for(int i = list.size() - 2; i >= 0; i--){
            if(list.get(i) < list.get(i+1)){
    			pivotPos = i;
    			pivot = list.get(i);
    			break;
    		}
    	}

        if(pivotPos == -1 && pivot == 0) return null;

        int L = pivotPos + 1;
        int R = list.size() - 1;
    	int minPos = -1;
    	char min = Character.MAX_VALUE;
    	for(int i = R; i >= L; i--){
    		if(pivot < list.get(i)){
    			if(list.get(i) < min){
    				min = list.get(i);
    				minPos = i;
    			}
    		}
    	}

    	Collections.swap(list, pivotPos, minPos);
    	Collections.sort(list.subList(L, R + 1));

    	StringBuilder sb = new StringBuilder();
    	for(int i=0; i<list.size(); i++) sb.append(list.get(i));

    	return sb.toString();
    }

    boolean nextPermutation(long[] a){
        for(int i = a.length - 1; i > 0; i--){
            if(a[i - 1] < a[i]){
                int swapIndex = find(a[i - 1], a, i, a.length - 1);
                long temp = a[swapIndex];
                a[swapIndex] = a[i - 1];
                a[i - 1] = temp;
                Arrays.sort(a, i, a.length);
                return true;
            }
        }
        return false;
    }

    int find(long dest, long[] a, int s, int e){
        if(s == e){
            return s;
        }
        int m = (s + e + 1) / 2;
        return a[m] <= dest ? find(dest, a, s, m - 1) : find(dest, a, m, e);
    }

    void elimination(int[][] a, int[] b) {
        int n = a.length;
        double f;
        for(int k = 0; k < n - 1; k++){
            for(int i = k + 1; i < n; i++){
                f = - a[i][k] / a[k][k];
                for(int j = k + 1; j < n; j++){
                    a[i][j] += f * a[k][j];
                }
                b[i] += f * b[k];
            }
            for(int i = n - 1; i >= 0; i--){
                for(int j = i + 1; j < n; j++){
                    b[i] -= a[i][j] * b[j];
                }
                b[i] = b[i] / a[i][i];
            }
        }
   }



   class SegmentTree{

       //------------------------------------------------------------
       // 2 * n - 1 : 
       // i + n - 1 : i
       // 2 * i + 1, 2 * i + 2 : i
       // (i - 1) / 2 : i
       //
       // int n = sc.nextInt();
       // long[] a = new long[n];
       // for(int i = 0; i < n; i++) a[i] = sc.nextLong();
       // SegmentTree st = new SegmentTree(a);
       // int l = sc.nextInt() - 1;
       // int r = sc.nextInt() - 1;
       // System.out.println(st.query(l, r));
       //------------------------------------------------------------

       final static long INF = Long.MAX_VALUE / 2;

       // long e = INF; // 
       long e = 0;
       long func(long a, long b){ // 
           // return Math.min(a, b);
           return a + b;
       }

       int n; // 2
       long[] node;

       SegmentTree(long[] a){
           init(a);
       }

       void init(long[] a){ // a
           n = 1;
           while(n < a.length){
               n *= 2;
           }
           node = new long[2 * n - 1];
           Arrays.fill(node, e);
           for(int i = 0; i < a.length; i++){
               node[i + n - 1] = a[i];
           }
           for(int i = n - 2; i >= 0; i--){
               node[i] = func(node[2 * i + 1], node[2 * i + 2]);
           }
       }

       void update(int p, long v){ // pv
           p = p + n - 1;
           node[p] = v;
           while(p > 0){
               p = (p - 1) / 2;
               node[p] = func(node[2 * p + 1], node[2 * p + 2]);
           }
       }

       long query(int a, int b){ // [a, b)
           return query(a, b, 0, 0, n);
       }

       long query(int a, int b, int k, int l, int r){
           if(r <= a || b <= l) return e;
           if(a <= l && r <= b) return node[k];
           return func(query(a, b, 2 * k + 1, l, (l + r) / 2), query(a, b, 2 * k + 2, (l + r) / 2, r));
       }

   }



}



class Pair implements Comparable<Pair>{
    long a, b;
    public Pair(long i, long j){
        a = i;
        b = j;
    }

    @Override
    public int compareTo(Pair p){
        if(this.b < p.b) return -1;
        else if(this.b > p.b) return 1;
        else return 0;
    }
}



class FastScanner {
    private final InputStream in = System.in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;
    private boolean hasNextByte(){
        if(ptr < buflen){
            return true;
        }else{
            ptr = 0;
            try{
                buflen = in.read(buffer);
            }catch(IOException e){
                e.printStackTrace();
            }
            if(buflen <= 0){
                return false;
            }
        }
        return true;
    }
    private int readByte(){
        if(hasNextByte()) return buffer[ptr++];
        else return -1;
    }
    private static boolean isPrintableChar(int c){
        return 33 <= c && c <= 126;
    }
    public boolean hasNext(){
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next(){
        if(!hasNext()) throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)){
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
    public long nextLong(){
        if(!hasNext()) throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if(b == '-'){
            minus = true;
            b = readByte();
        }
        if(b < '0' || '9' < b){
            throw new NumberFormatException();
        }
        while(true){
            if('0' <= b && b <= '9'){
                n *= 10;
                n += b - '0';
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt(){
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble(){
        return Double.parseDouble(next());
    }
}


</source>
</class>

<class classid="217" nclones="2" nlines="25" similarity="100">
<source file="../hum_codes_raw/s440260687.java" startline="1" endline="29" pcid="14765">
import java.util.Scanner;

//Hit and Blow
public class Main{

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			char[] r = sc.next().toCharArray();
			char[] a = sc.next().toCharArray();
			if(r.length==1)break;
			int h = 0;
			int b = 0;
			int[] c1 = new int[10];
			int[] c2 = new int[10];
			for(int i=0;i<4;i++){
				if(r[i]==a[i]){
					h++;
					continue;
				}
				c1[r[i]-'0']++;
				c2[a[i]-'0']++;
			}
			for(int i=0;i<10;i++)b+=Math.min(c1[i], c2[i]);
			System.out.println(h+" "+b);
		}
	}
}

</source>
<source file="../hum_codes_raw/s709290021.java" startline="1" endline="28" pcid="23847">
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			char[] r = sc.next().toCharArray();
			char[] a = sc.next().toCharArray();
			if(r.length==1)break;
			int h = 0;
			int b = 0;
			int[] c1 = new int[10];
			int[] c2 = new int[10];
			for(int i=0;i<4;i++){
				if(r[i]==a[i]){
					h++;
					continue;
				}
				c1[r[i]-'0']++;
				c2[a[i]-'0']++;
			}
			for(int i=0;i<10;i++)b+=Math.min(c1[i], c2[i]);
			System.out.println(h+" "+b);
		}
	}
}

</source>
</class>

<class classid="218" nclones="2" nlines="109" similarity="100">
<source file="../hum_codes_raw/s447540612.java" startline="1" endline="132" pcid="14997">
import java.io.*;
import java.util.*;

public class Main {
    private static final int MAX = (int) (2e9 + 1);
    public static void main(String[] args) throws Exception {
        new Main().solve();
    }

    //Floyd-Warshall's Algorithm
    private void solve() throws Exception{
        FastScanner scanner = new FastScanner(System.in);

        int V = scanner.nextInt();
        int E = scanner.nextInt();

        int[][] dist = new int[V][V];
        for(int i = 0; i < V; ++i){
            Arrays.fill(dist[i], MAX);
            dist[i][i] = 0;
        }

        for(int i = 0; i < E; ++i){
            int u = scanner.nextInt();
            int v = scanner.nextInt();
            int w = scanner.nextInt();

            dist[u][v] = w;
        }

        for(int k = 0; k < V; ++k){
            for(int i = 0; i < V; ++i){
                for(int j = 0; j < V; ++j){
                    if(dist[i][k] != MAX && dist[k][j] != MAX && dist[i][j] > dist[i][k] + dist[k][j]){
                        dist[i][j] = dist[i][k] + dist[k][j];
                    }
                }

                if(dist[i][i] < 0){
                    System.out.println("NEGATIVE CYCLE");
                    return;
                }
            }
        }

        PrintWriter printWriter = new PrintWriter(System.out);
        for(int i = 0; i < V; ++i){
            for(int j = 0; j < V; ++j){
                printWriter.print(dist[i][j] == MAX ? "INF" : dist[i][j]);

                if(j != V - 1){
                    printWriter.print(" ");
                }
                else{
                    printWriter.println();
                }
            }
        }

        printWriter.flush();
    }

    static class FastScanner {
        private InputStream in;
        private final byte[] buffer = new byte[1024 * 8];
        private int ptr = 0;
        private int buflen = 0;

        public FastScanner(InputStream in){
            this.in = in;
        }

        private boolean hasNextByte() {
            if (ptr < buflen) {
                return true;
            } else {
                ptr = 0;
                try {
                    buflen = in.read(buffer);
                } catch (IOException e) {
                    e.printStackTrace();
                }
                if (buflen <= 0) {
                    return false;
                }
            }
            return true;
        }

        private int readByte() {
            if (hasNextByte()) return buffer[ptr++];
            else return -1;
        }

        private static boolean isPrintableChar(int c) {
            return 33 <= c && c <= 126;
        }

        private void skipUnprintable() {
            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        }

        public boolean hasNext() {
            skipUnprintable();
            return hasNextByte();
        }

        public String next() {
            if (!hasNext()) throw new NoSuchElementException();
            StringBuilder sb = new StringBuilder();
            int b = readByte();
            while (isPrintableChar(b)) {
                sb.appendCodePoint(b);
                b = readByte();
            }
            return sb.toString();
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }
    }
}

</source>
<source file="../hum_codes_raw/s666412542.java" startline="1" endline="132" pcid="22378">
import java.io.*;
import java.util.*;

public class Main {
    private static final int MAX = (int) (2e9 + 1);
    public static void main(String[] args) throws Exception {
        new Main().solve();
    }

    //Floyd-Warshall's Algorithm
    private void solve() throws Exception{
        FastScanner scanner = new FastScanner(System.in);

        int V = scanner.nextInt();
        int E = scanner.nextInt();

        int[][] dist = new int[V][V];
        for(int i = 0; i < V; ++i){
            Arrays.fill(dist[i], MAX);
            dist[i][i] = 0;
        }

        for(int i = 0; i < E; ++i){
            int u = scanner.nextInt();
            int v = scanner.nextInt();
            int w = scanner.nextInt();

            dist[u][v] = w;
        }

        for(int k = 0; k < V; ++k){
            for(int i = 0; i < V; ++i){
                for(int j = 0; j < V; ++j){
                    if(dist[i][k] != MAX && dist[k][j] != MAX && dist[i][j] > dist[i][k] + dist[k][j]){
                        dist[i][j] = dist[i][k] + dist[k][j];
                    }
                }

                if(dist[i][i] < 0){
                    System.out.println("NEGATIVE CYCLE");
                    return;
                }
            }
        }

        PrintWriter printWriter = new PrintWriter(System.out);
        for(int i = 0; i < V; ++i){
            for(int j = 0; j < V; ++j){
                printWriter.print(dist[i][j] == MAX ? "INF" : dist[i][j]);

                if(j != V - 1){
                    printWriter.print(" ");
                }
                else{
                    printWriter.println();
                }
            }
        }

        printWriter.flush();
    }

    static class FastScanner {
        private InputStream in;
        private final byte[] buffer = new byte[1024 * 8];
        private int ptr = 0;
        private int buflen = 0;

        public FastScanner(InputStream in){
            this.in = in;
        }

        private boolean hasNextByte() {
            if (ptr < buflen) {
                return true;
            } else {
                ptr = 0;
                try {
                    buflen = in.read(buffer);
                } catch (IOException e) {
                    e.printStackTrace();
                }
                if (buflen <= 0) {
                    return false;
                }
            }
            return true;
        }

        private int readByte() {
            if (hasNextByte()) return buffer[ptr++];
            else return -1;
        }

        private static boolean isPrintableChar(int c) {
            return 33 <= c && c <= 126;
        }

        private void skipUnprintable() {
            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        }

        public boolean hasNext() {
            skipUnprintable();
            return hasNextByte();
        }

        public String next() {
            if (!hasNext()) throw new NoSuchElementException();
            StringBuilder sb = new StringBuilder();
            int b = readByte();
            while (isPrintableChar(b)) {
                sb.appendCodePoint(b);
                b = readByte();
            }
            return sb.toString();
        }

        public long nextLong() {
            return Long.parseLong(next());
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }

        public double nextDouble() {
            return Double.parseDouble(next());
        }
    }
}

</source>
</class>

<class classid="219" nclones="2" nlines="53" similarity="100">
<source file="../hum_codes_raw/s448593795.java" startline="1" endline="61" pcid="15035">
import java.io.*;
import java.math.*;
import java.util.*;

public class Main {
    private static boolean debug = false;
    private static boolean elapsed = false;

    private static PrintWriter _out = new PrintWriter(System.out);
    private static PrintWriter _err = new PrintWriter(System.err);

    private void solve(Scanner sc) {
        int a = sc.nextInt();
        int b = sc.nextInt();

        if (a == b) {
            _out.println("Draw");
        } else if (a == 1) {
            _out.println("Alice");
        } else if (b == 1) {
            _out.println("Bob");
        } else {
            _out.println((a > b ? "Alice" : "Bob"));
        }
    }
    private static BigInteger C(long n, long r) {
        BigInteger res = BigInteger.ONE;
        for (long i = n; i > n - r; --i) {
            res = res.multiply(BigInteger.valueOf(i));
        }
        for (long i = r; i > 1; --i) {
            res = res.divide(BigInteger.valueOf(i));
        }
        return res;
    }
    private static BigInteger P(long n, long r) {
        BigInteger res = BigInteger.ONE;
        for (long i = n; i > n - r; --i) {
            res = res.multiply(BigInteger.valueOf(i));
        }
        return res;
    }
    /*
     * 10^10 > Integer.MAX_VALUE = 2147483647 > 10^9
     * 10^19 > Long.MAX_VALUE = 9223372036854775807L > 10^18
     */
    public static void main(String[] args) {
        long S = System.currentTimeMillis();

        Scanner sc = new Scanner(System.in);
        new Main().solve(sc);
        _out.flush();

        long G = System.currentTimeMillis();
        if (elapsed) {
            _err.println((G - S) + "ms");
        }
        _err.flush();
    }
}

</source>
<source file="../hum_codes_raw/s919592382.java" startline="1" endline="61" pcid="30927">
import java.io.*;
import java.math.*;
import java.util.*;
 
public class Main {
    private static boolean debug = false;
    private static boolean elapsed = false;
 
    private static PrintWriter _out = new PrintWriter(System.out);
    private static PrintWriter _err = new PrintWriter(System.err);
 
    private void solve(Scanner sc) {
        int a = sc.nextInt();
        int b = sc.nextInt();
 
        if (a == b) {
            _out.println("Draw");
        } else if (a == 1) {
            _out.println("Alice");
        } else if (b == 1) {
            _out.println("Bob");
        } else {
            _out.println((a > b ? "Alice" : "Bob"));
        }
    }
    private static BigInteger C(long n, long r) {
        BigInteger res = BigInteger.ONE;
        for (long i = n; i > n - r; --i) {
            res = res.multiply(BigInteger.valueOf(i));
        }
        for (long i = r; i > 1; --i) {
            res = res.divide(BigInteger.valueOf(i));
        }
        return res;
    }
    private static BigInteger P(long n, long r) {
        BigInteger res = BigInteger.ONE;
        for (long i = n; i > n - r; --i) {
            res = res.multiply(BigInteger.valueOf(i));
        }
        return res;
    }
    /*
     * 10^10 > Integer.MAX_VALUE = 2147483647 > 10^9
     * 10^19 > Long.MAX_VALUE = 9223372036854775807L > 10^18
     */
    public static void main(String[] args) {
        long S = System.currentTimeMillis();
 
        Scanner sc = new Scanner(System.in);
        new Main().solve(sc);
        _out.flush();
 
        long G = System.currentTimeMillis();
        if (elapsed) {
            _err.println((G - S) + "ms");
        }
        _err.flush();
    }
}

</source>
</class>

<class classid="220" nclones="2" nlines="40" similarity="100">
<source file="../hum_codes_raw/s450059172.java" startline="1" endline="45" pcid="15085">
import java.util.Arrays;
import java.util.Scanner;

public class Main {
	public static void main(String[] args) throws Exception {

		Scanner sc = new Scanner(System.in);
		long INF = 1 << 58;
		while (true) {
			int n = sc.nextInt();
			int k = sc.nextInt();
			if ((n | k) == 0)
				break;
			long fare[][] = new long[n][n];
			for (int i = 0; i < n; i++) {
				Arrays.fill(fare[i], INF);
				fare[i][i] = 0;
			}
			for (int i = 0; i < k; i++) {
				int init = sc.nextInt();
				if (init == 1) {
					int c = sc.nextInt() - 1;
					int d = sc.nextInt() - 1;
					int e = sc.nextInt();
					if (e < fare[c][d]) {
						fare[c][d] = fare[d][c] = e;
						for (int p = 0; p < n; p++) {
							for (int q = 0; q < n; q++) {
								fare[p][q] = Math.min(fare[p][q], fare[p][c]
										+ fare[c][d] + fare[d][q]);
								fare[p][q] = Math.min(fare[p][q], fare[p][d]
										+ fare[c][d] + fare[c][q]);
							}
						}
					}
				} else {
					int a = sc.nextInt() - 1;
					int b = sc.nextInt() - 1;
					System.out.println(fare[a][b] != INF ? fare[a][b] : -1);
				}
			}
		}
	}
}

</source>
<source file="../hum_codes_raw/s510751196.java" startline="1" endline="45" pcid="17122">
import java.util.Arrays;
import java.util.Scanner;

public class Main {
	public static void main(String[] args) throws Exception {

		Scanner sc = new Scanner(System.in);
		long INF = 1 << 58;
		while (true) {
			int n = sc.nextInt();
			int k = sc.nextInt();
			if ((n | k) == 0)
				break;
			long fare[][] = new long[n][n];
			for (int i = 0; i < n; i++) {
				Arrays.fill(fare[i], INF);
				fare[i][i] = 0;
			}
			for (int i = 0; i < k; i++) {
				int init = sc.nextInt();
				if (init == 1) {
					int c = sc.nextInt() - 1;
					int d = sc.nextInt() - 1;
					int e = sc.nextInt();
					if (e < fare[c][d]) {
						fare[c][d] = fare[d][c] = e;
						for (int p = 0; p < n; p++) {
							for (int q = 0; q < n; q++) {
								fare[p][q] = Math.min(fare[p][q], fare[p][c]
										+ fare[c][d] + fare[d][q]);
								fare[p][q] = Math.min(fare[p][q], fare[p][d]
										+ fare[c][d] + fare[c][q]);
							}
						}
					}
				} else {
					int a = sc.nextInt() - 1;
					int b = sc.nextInt() - 1;
					System.out.println(fare[a][b] != INF ? fare[a][b] : -1);
				}
			}
		}
	}
}

</source>
</class>

<class classid="221" nclones="2" nlines="64" similarity="100">
<source file="../hum_codes_raw/s455106067.java" startline="1" endline="73" pcid="15265">
import java.util.ArrayDeque;
import java.util.Deque;
import java.io.BufferedReader;
import java.io.InputStreamReader;

public class Main {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] hwn = br.readLine().split(" ");
        int h = Integer.parseInt(hwn[0]);
        int w = Integer.parseInt(hwn[1]);
        int n = Integer.parseInt(hwn[2]);
        char[][] grid = new char[h][w];
        int sx=-1, sy=-1;
        
        for (int i = 0; i < h; i++) {
            String raw = br.readLine();
            for (int j = 0; j < w; j++) {
                grid[i][j] = raw.charAt(j);
                if (grid[i][j] == 'S') {
                    sy = i;
                    sx = j;
                }
            }
        }
        
        int next = 1;
        int[][] dfyxs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        boolean[][] visited = new boolean[h][w];
        visited[sy][sx] = true;
        int[][] distance = new int[h][w];
        distance[sy][sx] = 0;
        Deque<Integer> xq = new ArrayDeque<Integer>();
        Deque<Integer> yq = new ArrayDeque<Integer>();
        int d = 0;
        int ans = 0;
        outer: while (true) {
            inner: for (int[] dfyx: dfyxs) {
                if (sy-dfyx[0] < 0 || sx-dfyx[1] < 0 || sy-dfyx[0] >= h || sx-dfyx[1] >= w) continue;
                if (visited[sy-dfyx[0]][sx-dfyx[1]] == true) continue;
                if (grid[sy-dfyx[0]][sx-dfyx[1]] == 'X') {
                    continue;
                }
                distance[sy-dfyx[0]][sx-dfyx[1]] = distance[sy][sx] + 1;
                //System.out.println((sy-dfyx[0]) + " " + (sx-dfyx[1]));
                if ((int)grid[sy-dfyx[0]][sx-dfyx[1]]-48 == next) {
                    //System.out.println("aaa");
                    //System.out.println(distance[sy-dfyx[0]][sx-dfyx[1]]);
                    yq.clear();
                    xq.clear();
                    ans += distance[sy-dfyx[0]][sx-dfyx[1]];
                    if (next == n) break outer;
                    next++;
                    distance = new int[h][w];
                    distance[sy-dfyx[0]][sx-dfyx[1]] = 0;
                    visited = new boolean[h][w];
                    sy = sy-dfyx[0];
                    sx = sx-dfyx[1];
                    continue outer;
                }
                visited[sy-dfyx[0]][sx-dfyx[1]] = true;
                xq.addLast(sx-dfyx[1]);
                yq.addLast(sy-dfyx[0]);
            }
            sy = yq.removeFirst();
            sx = xq.removeFirst();
        }
        //System.out.println(distance[3][1]);
        System.out.println(ans);
    }
}


</source>
<source file="../hum_codes_raw/s749145584.java" startline="1" endline="73" pcid="25166">
import java.util.ArrayDeque;
import java.util.Deque;
import java.io.BufferedReader;
import java.io.InputStreamReader;

public class Main {
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] hwn = br.readLine().split(" ");
        int h = Integer.parseInt(hwn[0]);
        int w = Integer.parseInt(hwn[1]);
        int n = Integer.parseInt(hwn[2]);
        char[][] grid = new char[h][w];
        int sx=-1, sy=-1;
        
        for (int i = 0; i < h; i++) {
            String raw = br.readLine();
            for (int j = 0; j < w; j++) {
                grid[i][j] = raw.charAt(j);
                if (grid[i][j] == 'S') {
                    sy = i;
                    sx = j;
                }
            }
        }
        
        int next = 1;
        int[][] dfyxs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        boolean[][] visited = new boolean[h][w];
        visited[sy][sx] = true;
        int[][] distance = new int[h][w];
        distance[sy][sx] = 0;
        Deque<Integer> xq = new ArrayDeque<Integer>();
        Deque<Integer> yq = new ArrayDeque<Integer>();
        int d = 0;
        int ans = 0;
        outer: while (true) {
            inner: for (int[] dfyx: dfyxs) {
                if (sy-dfyx[0] < 0 || sx-dfyx[1] < 0 || sy-dfyx[0] >= h || sx-dfyx[1] >= w) continue;
                if (visited[sy-dfyx[0]][sx-dfyx[1]] == true) continue;
                if (grid[sy-dfyx[0]][sx-dfyx[1]] == 'X') {
                    continue;
                }
                distance[sy-dfyx[0]][sx-dfyx[1]] = distance[sy][sx] + 1;
                //System.out.println((sy-dfyx[0]) + " " + (sx-dfyx[1]));
                if ((int)grid[sy-dfyx[0]][sx-dfyx[1]]-48 == next) {
                    //System.out.println("aaa");
                    //System.out.println(distance[sy-dfyx[0]][sx-dfyx[1]]);
                    yq.clear();
                    xq.clear();
                    ans += distance[sy-dfyx[0]][sx-dfyx[1]];
                    if (next == n) break outer;
                    next++;
                    distance = new int[h][w];
                    distance[sy-dfyx[0]][sx-dfyx[1]] = 0;
                    visited = new boolean[h][w];
                    sy = sy-dfyx[0];
                    sx = sx-dfyx[1];
                    continue outer;
                }
                visited[sy-dfyx[0]][sx-dfyx[1]] = true;
                xq.addLast(sx-dfyx[1]);
                yq.addLast(sy-dfyx[0]);
            }
            sy = yq.removeFirst();
            sx = xq.removeFirst();
        }
        //System.out.println(distance[3][1]);
        System.out.println(ans);
    }
}


</source>
</class>

<class classid="222" nclones="2" nlines="71" similarity="100">
<source file="../hum_codes_raw/s456667608.java" startline="1" endline="73" pcid="15314">
import java.io.*;
import java.util.*;
class Solution {
	final int SIZE = 20;
	int[] dr = { 0, 1, 0, -1 };
	int[] dc = { 1, 0, -1, 0 };
	int w;
	int h;
	int[][] graph = new int[SIZE][SIZE];
	int ans;
	int sr;
	int sc;
	void compute() {
		Scanner scanner = new Scanner(new BufferedInputStream(System.in));
		while (true) {
			w = scanner.nextInt();
			h = scanner.nextInt();
			if (w == 0 && h == 0) {
				break;
			}
			for (int i = 0; i < h; i++) {
				for (int j = 0; j < w; j++) {
					graph[i][j] = scanner.nextInt();
					if (graph[i][j] == 2) {
						sr = i;
						sc = j;
					}
				}
			}
			ans = 11;
			dfs(sr, sc, 0);
			if (ans <= 10) {
				System.out.println(ans);
			} else {
				System.out.println(-1);
			}
		}
		scanner.close();
	}

	void dfs(int r, int c, int step) {
		if (step == 10) {
			return;
		}
		for (int direction = 0; direction < 4; direction++) {
			int nr = r;
			int nc = c;
			int cnt = 0;
			while (nr >= 0 && nr < h && nc >= 0 && nc < w && graph[nr][nc] != 1) {
				if (graph[nr][nc] == 3) {
					ans = Math.min(ans, step + 1);
					return;
				}
				nr += dr[direction];
				nc += dc[direction];
				cnt++;
			}
			if (nr >= 0 && nr < h && nc >= 0 && nc < w && graph[nr][nc] == 1 && cnt > 1) {
				graph[nr][nc] = 0;
				dfs(nr - dr[direction], nc - dc[direction], step + 1);
				graph[nr][nc] = 1;
			}
		}
	}
}
public class Main {
	public static void main(String args[]) {
		Solution solution = new Solution();
		solution.compute();
	}
}


</source>
<source file="../hum_codes_raw/s798822729.java" startline="1" endline="76" pcid="26835">
import java.io.*;
import java.util.*;

class Solution {
	final int SIZE = 20;
	int[] dr = { 0, 1, 0, -1 };
	int[] dc = { 1, 0, -1, 0 };
	int w;
	int h;
	int[][] graph = new int[SIZE][SIZE];
	int ans;
	int sr;
	int sc;

	void compute() {
		Scanner scanner = new Scanner(new BufferedInputStream(System.in));
		while (true) {
			w = scanner.nextInt();
			h = scanner.nextInt();
			if (w == 0 && h == 0) {
				break;
			}
			for (int i = 0; i < h; i++) {
				for (int j = 0; j < w; j++) {
					graph[i][j] = scanner.nextInt();
					if (graph[i][j] == 2) {
						sr = i;
						sc = j;
					}
				}
			}
			ans = 11;
			dfs(sr, sc, 0);
			if (ans <= 10) {
				System.out.println(ans);
			} else {
				System.out.println(-1);
			}
		}
		scanner.close();
	}

	void dfs(int r, int c, int step) {
		if (step == 10) {
			return;
		}
		for (int direction = 0; direction < 4; direction++) {
			int nr = r;
			int nc = c;
			int cnt = 0;
			while (nr >= 0 && nr < h && nc >= 0 && nc < w && graph[nr][nc] != 1) {
				if (graph[nr][nc] == 3) {
					ans = Math.min(ans, step + 1);
					return;
				}
				nr += dr[direction];
				nc += dc[direction];
				cnt++;
			}
			if (nr >= 0 && nr < h && nc >= 0 && nc < w && graph[nr][nc] == 1 && cnt > 1) {
				graph[nr][nc] = 0;
				dfs(nr - dr[direction], nc - dc[direction], step + 1);
				graph[nr][nc] = 1;
			}
		}
	}
}

public class Main {
	public static void main(String args[]) {
		Solution solution = new Solution();
		solution.compute();
	}
}


</source>
</class>

<class classid="223" nclones="2" nlines="122" similarity="100">
<source file="../hum_codes_raw/s457663140.java" startline="1" endline="135" pcid="15349">
import java.util.Arrays;

import java.io.IOException;
import java.io.InputStream;
import java.util.NoSuchElementException;

 class FS {
    private final InputStream in = System.in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        } else {
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }

    private int readByte() {
        return hasNextByte() ? buffer[ptr++] : -1;
    }

    private boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }

    private void skipUnprintable() {
        while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
    }

    public boolean hasNext() {
        skipUnprintable();
        return hasNextByte();
    }

    public String next() {
        if (!hasNext()) throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while (isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }

    public int nextInt() {
        return (int) nextLong();
    }

    public long nextLong() {
        if (!hasNext()) throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                n *= 10;
                n += b - '0';
            } else if (b == -1 || !isPrintableChar(b)) {
                return minus ? -n : n;
            } else {
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
}
public class Main {
    public static void main(String[] args) {
        FS fs = new FS();
        int n = fs.nextInt();
        Stuff a[] = new Stuff[n];
        boolean b[]  =new boolean[n];
        for (int i = 0; i < n; i++) {
            int wei = fs.nextInt();
            a[i]=new Stuff(i,wei);
        }
        Arrays.sort(a);
        int min=a[0].weight;
        int wcount=0;
        for (int i = 0; i < a.length; i++) {
            if (min>a[i].weight)min=a[i].weight;
            if (b[i])continue;
            if (a[i].index==i)continue;
            int minw=a[i].weight;
            int k=0;
            for (int j = a[i].index; !b[j]; j=a[j].index,k++){
                if (min>a[j].weight)min=a[j].weight;
                if (minw>a[j].weight)min=a[j].weight;
                b[j]=true;
                wcount+=a[j].weight;
            }
            wcount+=Math.min((k-2)*minw,minw+(k+1)*min);
        }
        System.out.println(wcount);
    }

   static class Stuff implements Comparable<Stuff> {
        int index;
        int weight;

        public Stuff(int index, int weight) {
            this.index = index;
            this.weight = weight;
        }



       @Override
       public int compareTo(Stuff o) {
            if (o.weight>this.weight)return -1;
            else return 1;
       }
   }
}

</source>
<source file="../hum_codes_raw/s467750820.java" startline="1" endline="135" pcid="15698">
import java.util.Arrays;

import java.io.IOException;
import java.io.InputStream;
import java.util.NoSuchElementException;

 class FS {
    private final InputStream in = System.in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        } else {
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }

    private int readByte() {
        return hasNextByte() ? buffer[ptr++] : -1;
    }

    private boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }

    private void skipUnprintable() {
        while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
    }

    public boolean hasNext() {
        skipUnprintable();
        return hasNextByte();
    }

    public String next() {
        if (!hasNext()) throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while (isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }

    public int nextInt() {
        return (int) nextLong();
    }

    public long nextLong() {
        if (!hasNext()) throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                n *= 10;
                n += b - '0';
            } else if (b == -1 || !isPrintableChar(b)) {
                return minus ? -n : n;
            } else {
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
}
public class Main {
    public static void main(String[] args) {
        FS fs = new FS();
        int n = fs.nextInt();
        Stuff a[] = new Stuff[n];
        boolean b[]  =new boolean[n];
        for (int i = 0; i < n; i++) {
            int wei = fs.nextInt();
            a[i]=new Stuff(i,wei);
        }
        Arrays.sort(a);
        int min=a[0].weight;
        int wcount=0;
        for (int i = 0; i < a.length; i++) {
            if (min>a[i].weight)min=a[i].weight;
            if (b[i])continue;
            if (a[i].index==i)continue;
            int minw=a[i].weight;
            int k=0;
            for (int j = a[i].index; !b[j]; j=a[j].index,k++){
                if (min>a[j].weight)min=a[j].weight;
                if (minw>a[j].weight)min=a[j].weight;
                b[j]=true;
                wcount+=a[j].weight;
            }
            wcount+=Math.min((k-2)*minw,minw+(k+1)*min);
        }
        System.out.println(wcount);
    }

   static class Stuff implements Comparable<Stuff> {
        int index;
        int weight;

        public Stuff(int index, int weight) {
            this.index = index;
            this.weight = weight;
        }



       @Override
       public int compareTo(Stuff o) {
            if (o.weight>this.weight)return -1;
            else return 1;
       }
   }
}

</source>
</class>

<class classid="224" nclones="2" nlines="194" similarity="100">
<source file="../hum_codes_raw/s459791849.java" startline="1" endline="237" pcid="15431">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            CRemainderGame solver = new CRemainderGame();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class CRemainderGame {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            int[] a = new int[n];
            int[] b = new int[n];
            in.populate(a);
            in.populate(b);

            long ans = 0;
            for (int i = 50; i >= 0; i--) {
                long mask = ans | ((1L << i) - 1);
                if (!check(mask, a, b)) {
                    ans = Bits.set(ans, i);
                }
            }

            if (!check(ans, a, b)) {
                out.println(-1);
                return;
            }

            out.println(ans);
        }

        public boolean check(long divisor, int[] a, int[] b) {
            long[] next = new long[51];
            for (int i = 0; i <= 50; i++) {
                next[i] = Bits.set(next[i], i);
                for (int j = 1; j <= 50; j++) {
                    if (Bits.get(divisor, j) == 1) {
                        next[i] |= next[i % j];
                    }
                }
            }

            for (int i = 0; i < a.length; i++) {
                if (Bits.get(next[a[i]], b[i]) == 0) {
                    return false;
                }
            }
            return true;
        }

    }

    static class Bits {
        private Bits() {
        }

        public static int get(long x, int i) {
            return (int) ((x >>> i) & 1);
        }

        public static long set(long x, int i) {
            return x | (1L << i);
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(long c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println(long c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        public void populate(int[] data) {
            for (int i = 0; i < data.length; i++) {
                data[i] = readInt();
            }
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }
}


</source>
<source file="../hum_codes_raw/s621444911.java" startline="1" endline="237" pcid="20868">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            CRemainderGame solver = new CRemainderGame();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class CRemainderGame {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            int[] a = new int[n];
            int[] b = new int[n];
            in.populate(a);
            in.populate(b);

            long ans = 0;
            for (int i = 50; i >= 0; i--) {
                long mask = ans | ((1L << i) - 1);
                if (!check(mask, a, b)) {
                    ans = Bits.set(ans, i);
                }
            }

            if (!check(ans, a, b)) {
                out.println(-1);
                return;
            }

            out.println(ans);
        }

        public boolean check(long divisor, int[] a, int[] b) {
            long[] next = new long[51];
            for (int i = 0; i <= 50; i++) {
                next[i] = Bits.set(next[i], i);
                for (int j = 1; j <= 50; j++) {
                    if (Bits.get(divisor, j) == 1) {
                        next[i] |= next[i % j];
                    }
                }
            }

            for (int i = 0; i < a.length; i++) {
                if (Bits.get(next[a[i]], b[i]) == 0) {
                    return false;
                }
            }
            return true;
        }

    }

    static class Bits {
        private Bits() {
        }

        public static int get(long x, int i) {
            return (int) ((x >>> i) & 1);
        }

        public static long set(long x, int i) {
            return x | (1L << i);
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(long c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println(long c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        public void populate(int[] data) {
            for (int i = 0; i < data.length; i++) {
                data[i] = readInt();
            }
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }
}


</source>
</class>

<class classid="225" nclones="2" nlines="61" similarity="100">
<source file="../hum_codes_raw/s459917263.java" startline="1" endline="61" pcid="15434">
import java.util.*;
public class Main {
    void run() {
        Scanner sc = new Scanner(System.in);
        while (true) {
            String s = sc.next();
            if (s.equals("0")) break;
            System.out.println(dfs(convert(s)));
        }
    }
    
    String dfs(String str) {
        Set<String> visited = new HashSet<String>();
        visited.add(str);
        
        LinkedList<String> q = new LinkedList<String>();
        LinkedList<Integer> qi = new LinkedList<Integer>();
        q.add(str); qi.add(0);
        
        while (!q.isEmpty()) {
            String s = q.removeFirst();
            int c = qi.removeFirst();  
            if (ok(s)) return "" + c;
            for (int i = 0; i < s.length() - 1; i++) if (s.charAt(i) != s.charAt(i + 1)) {
                int n = s.charAt(i) - '0' + s.charAt(i + 1) - '0';
                n = (3 - n % 3) % 3;
                String next = s.substring(0, i) + n + n + s.substring(i + 2, s.length());
                if (!visited.contains(next)) {
                    q.addLast(next);
                    qi.addLast(c+1);
                    visited.add(next);
                }
            }
        }
        return "NA";
    }
    
    String convert(String str) {
        String ret = "";
        for (int i = 0; i < str.length(); i++) {
            switch (str.charAt(i)) {
            case 'r': ret += "" + 0; break;
            case 'g': ret += "" + 1; break;
            case 'b': ret += "" + 2; break;
            }
        }
        return ret;
    }
    
    boolean ok(String s) {
        for (int i = 0; i < s.length() - 1; i++) {
            if (s.charAt(i) != s.charAt(i + 1)) return false;
        }
        return true;
    }
    
    public static void main(String[] args) {
        new Main().run();
    }
}

</source>
<source file="../hum_codes_raw/s775842977.java" startline="1" endline="61" pcid="26044">
import java.util.*;
public class Main {
    void run() {
        Scanner sc = new Scanner(System.in);
        while (true) {
            String s = sc.next();
            if (s.equals("0")) break;
            System.out.println(dfs(convert(s)));
        }
    }
    
    String dfs(String str) {
        Set<String> visited = new HashSet<String>();
        visited.add(str);
        
        LinkedList<String> q = new LinkedList<String>();
        LinkedList<Integer> qi = new LinkedList<Integer>();
        q.add(str); qi.add(0);
        
        while (!q.isEmpty()) {
            String s = q.removeFirst();
            int c = qi.removeFirst();  
            if (ok(s)) return "" + c;
            for (int i = 0; i < s.length() - 1; i++) if (s.charAt(i) != s.charAt(i + 1)) {
                int n = s.charAt(i) - '0' + s.charAt(i + 1) - '0';
                n = (3 - n % 3) % 3;
                String next = s.substring(0, i) + n + n + s.substring(i + 2, s.length());
                if (!visited.contains(next)) {
                    q.addLast(next);
                    qi.addLast(c+1);
                    visited.add(next);
                }
            }
        }
        return "NA";
    }
    
    String convert(String str) {
        String ret = "";
        for (int i = 0; i < str.length(); i++) {
            switch (str.charAt(i)) {
            case 'r': ret += "" + 0; break;
            case 'g': ret += "" + 1; break;
            case 'b': ret += "" + 2; break;
            }
        }
        return ret;
    }
    
    boolean ok(String s) {
        for (int i = 0; i < s.length() - 1; i++) {
            if (s.charAt(i) != s.charAt(i + 1)) return false;
        }
        return true;
    }
    
    public static void main(String[] args) {
        new Main().run();
    }
}

</source>
</class>

<class classid="226" nclones="2" nlines="35" similarity="100">
<source file="../hum_codes_raw/s461870565.java" startline="1" endline="43" pcid="15500">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
class Main {
	public static void main(String args[]) {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String base;
		String comparison;
		
		try {
			base = br.readLine();
			comparison = br.readLine();
			
			Inversions(base, comparison, br);
		} catch (IOException e) {
			// TODO  catch 
			e.printStackTrace();
		}
	}

	public static void Inversions(String base, String comparison,  BufferedReader br){ 
		StringBuilder sb = new StringBuilder();
		int length = base.length() - comparison.length();
		String 	container;
		int ans_num = 0;
		int[] ans = new int[1000000];
		
		for(int i = 0; i <= length ; i ++ ) {
			container = base.substring( i, i + comparison.length() );
			if( container.equals(comparison) ) {
				ans[ans_num] = i;
				ans_num ++;
			}
		}
		
		for(int i = 0; i <ans_num; i++){;
			sb.append(ans[i] + "\n");
		}
		 
		System.out.print(sb);
	}
}

</source>
<source file="../hum_codes_raw/s510671027.java" startline="1" endline="43" pcid="17121">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
class Main {
	public static void main(String args[]) {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String base;
		String comparison;
		
		try {
			base = br.readLine();
			comparison = br.readLine();
			
			Inversions(base, comparison, br);
		} catch (IOException e) {
			// TODO  catch 
			e.printStackTrace();
		}
	}

	public static void Inversions(String base, String comparison,  BufferedReader br){ 
		StringBuilder sb = new StringBuilder();
		int length = base.length() - comparison.length();
		String 	container;
		int ans_num = 0;
		int[] ans = new int[1000000];
		
		for(int i = 0; i <= length ; i ++ ) {
			container = base.substring( i, i + comparison.length() );
			if( container.equals(comparison) ) {
				ans[ans_num] = i;
				ans_num ++;
			}
		}
		
		for(int i = 0; i <ans_num; i++){;
			sb.append(ans[i] + "\n");
		}
		 
		System.out.print(sb);
	}
}

</source>
</class>

<class classid="227" nclones="2" nlines="13" similarity="100">
<source file="../hum_codes_raw/s466772245.java" startline="1" endline="14" pcid="15666">
import java.util.*;
public class Main {
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		
		 String S = sc.next();
      	
      if(S.charAt(2) == S.charAt(3) && S.charAt(4) == S.charAt(5)){
      System.out.println("Yes");}
      else{
      System.out.println("No");}
	}
}

</source>
<source file="../hum_codes_raw/s474958041.java" startline="1" endline="18" pcid="15940">
import java.util.*;

public class Main{
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    String S = sc.next();
    

    if(S.charAt(2) == S.charAt(3) && S.charAt(4) == S.charAt(5)){
      System.out.println("Yes");
    }else{
      System.out.println("No");
    }
  }
}



</source>
</class>

<class classid="228" nclones="2" nlines="48" similarity="100">
<source file="../hum_codes_raw/s467690671.java" startline="1" endline="53" pcid="15695">
import java.util.Scanner;

//Drawing Lots II
public class Main{

	static int sim(char[][] s, int n, int d, int start){
		int t = start;
		for(int i=0;i<d;i++){
			if(t>0&&s[i][t-1]=='1')t--;
			else if(t<n-1 && s[i][t]=='1')t++;
		}
		return t;
	}
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int n = sc.nextInt();
			if(n==0)break;
			int m = sc.nextInt()-1;
			int g = sc.nextInt()-1;
			int d = sc.nextInt();
			char[][] s = new char[d][n-1];
			for(int i=0;i<d;i++)s[i]=sc.next().toCharArray();
			if(sim(s,n,d,m)==g){
				System.out.println(0);
				continue;
			}
			boolean ok = false;
			for(int i=0;i<d;i++){
				for(int j=0;j<n-1;j++){
					if(ok || s[i][j]=='1')continue;
					boolean left, right;
					if(j==0||s[i][j-1]=='0')left = true;
					else left = false;
					if(j==n-2||s[i][j+1]=='0')right = true;
					else right = false;
					if(left&&right){
						s[i][j]='1';
						if(sim(s,n,d,m)==g){
							System.out.println((i+1)+" "+(j+1));
							ok = true;
							break;
						}
						s[i][j]='0';
					}
				}
			}
			if(!ok)System.out.println("1");
		}
	}
}

</source>
<source file="../hum_codes_raw/s607267764.java" startline="1" endline="52" pcid="20404">
import java.util.Scanner;

public class Main {

	static int sim(char[][] s, int n, int d, int start){
		int t = start;
		for(int i=0;i<d;i++){
			if(t>0&&s[i][t-1]=='1')t--;
			else if(t<n-1 && s[i][t]=='1')t++;
		}
		return t;
	}
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int n = sc.nextInt();
			if(n==0)break;
			int m = sc.nextInt()-1;
			int g = sc.nextInt()-1;
			int d = sc.nextInt();
			char[][] s = new char[d][n-1];
			for(int i=0;i<d;i++)s[i]=sc.next().toCharArray();
			if(sim(s,n,d,m)==g){
				System.out.println(0);
				continue;
			}
			boolean ok = false;
			for(int i=0;i<d;i++){
				for(int j=0;j<n-1;j++){
					if(ok || s[i][j]=='1')continue;
					boolean left, right;
					if(j==0||s[i][j-1]=='0')left = true;
					else left = false;
					if(j==n-2||s[i][j+1]=='0')right = true;
					else right = false;
					if(left&&right){
						s[i][j]='1';
						if(sim(s,n,d,m)==g){
							System.out.println((i+1)+" "+(j+1));
							ok = true;
							break;
						}
						s[i][j]='0';
					}
				}
			}
			if(!ok)System.out.println("1");
		}
	}
}

</source>
</class>

<class classid="229" nclones="2" nlines="50" similarity="100">
<source file="../hum_codes_raw/s473121306.java" startline="1" endline="49" pcid="15888">
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		String a = scan.nextLine();
		String[] a2 = a.split("");
		String b = scan.nextLine();
		String[] b2 = b.split("");
		int al = a.length();
		int bl = b.length();
		if(al<bl){
			int n=al; al=bl; bl=n;
			String[] nu=a2; a2=b2; b2=nu;
		}
		int[][] dp = new int[bl+1][al+1];
		for(int i=1;i<=al;++i){
			dp[0][i]=dp[0][i-1]+1;
		}
		for(int i=1;i<=bl;++i){
			dp[i][0]=dp[i-1][0]+1;
		}
		for(int i=1;i<=bl;++i){
			for(int j=1;j<=al;++j){
				int min=0;
				if(b2[i-1].equals(a2[j-1])==true){
					min = Min(dp[i-1][j-1],dp[i][j-1]+1,dp[i-1][j]+1);
				} else {
					min = Min(dp[i-1][j-1]+1,dp[i][j-1]+1,dp[i-1][j]+1);
				}
				dp[i][j]=min;
			}
		}
		System.out.println(dp[bl][al]);
	}

	public static int Min(int a, int b, int c){
		int min=a;
		if(a>b){
			min=b;
		}
		if(min>c){
			min=c;
		}
		return min;
	}
}


</source>
<source file="../hum_codes_raw/s723939010.java" startline="1" endline="48" pcid="24349">
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		String a = scan.nextLine();
		String[] a2 = a.split("");
		String b = scan.nextLine();
		String[] b2 = b.split("");
		int al = a.length();
		int bl = b.length();
		if(al<bl){
			int n=al; al=bl; bl=n;
			String[] nu=a2; a2=b2; b2=nu;
		}
		int[][] dp = new int[bl+1][al+1];
		for(int i=1;i<=al;++i){
			dp[0][i]=dp[0][i-1]+1;
		}
		for(int i=1;i<=bl;++i){
			dp[i][0]=dp[i-1][0]+1;
		}
		for(int i=1;i<=bl;++i){
			for(int j=1;j<=al;++j){
				int min=0;
				if(b2[i-1].equals(a2[j-1])==true){
					min = Min(dp[i-1][j-1],dp[i][j-1]+1,dp[i-1][j]+1);
				} else {
					min = Min(dp[i-1][j-1]+1,dp[i][j-1]+1,dp[i-1][j]+1);
				}
				dp[i][j]=min;
			}
		}
		System.out.println(dp[bl][al]);
	}

	public static int Min(int a, int b, int c){
		int min=a;
		if(a>b){
			min=b;
		}
		if(min>c){
			min=c;
		}
		return min;
	}
}

</source>
</class>

<class classid="230" nclones="2" nlines="31" similarity="100">
<source file="../hum_codes_raw/s474294531.java" startline="1" endline="55" pcid="15918">
import java.util.*;
import java.lang.*;
import java.io.*;

class Main
{

    private static int n;

    private static int rec(int sum,int pre,int cnt)
    {

	if(sum > n)
	    return 0;

	if(sum == n)
	    return 1;

	if(cnt >= 3)
	    {	   
		int dif = n-sum;
		
		    int res = (int)Math.sqrt(dif);
		    if(res >= pre)
			{
			    if(res*res == dif)return 1;
			}
		    return 0;
	    }
	
	
	int counter = 0;
	for(int i=pre;sum+Math.pow(i,2)<=n;i++)
	    {
		counter += rec(sum+i*i,i,cnt+1);
	    }
	return counter;
    }
    
      public static void main(String args[])throws IOException
    {
	BufferedReader in = new BufferedReader(new InputStreamReader(System.in));


	while(true)
	    {
		n = Integer.parseInt(in.readLine());
		if(n == 0)
		    break;
		System.out.println(rec(0,1,0));
	    }
    }
    
}

</source>
<source file="../hum_codes_raw/s896704308.java" startline="1" endline="94" pcid="30177">
import java.util.*;
import java.lang.*;
import java.io.*;

class Main
{

    private static int n;

    private static int rec(int sum,int pre,int cnt)
    {

	if(sum > n)
	    return 0;

	if(sum == n)
	    return 1;

	if(cnt >= 3)
	    {
		//return sum == n?1:0;
		   
		int dif = n-sum;
		
		    int res = (int)Math.sqrt(dif);
		    if(res >= pre){
			if(res*res == dif)return 1;
		    }
		return 0;
		
	    }


	int counter = 0;
	for(int i=pre;sum+Math.pow(i,2)<=n;i++)
	    {
		counter += rec(sum+i*i,i,cnt+1);
	    }
	return counter;
    }

      public static void main(String args[])throws IOException
    {
	BufferedReader in = new BufferedReader(new InputStreamReader(System.in));


	while(true)
	    {

		n = Integer.parseInt(in.readLine());
		if(n == 0)
		    break;
		/*
		int cnt = 0;
		for(int i=1;i*i<=n;i++)
		    {
			if(i*i == n)
			    {
				cnt++;
				break;
			    }
			for(int j=i;j*j+i*i<=n;j++)
			    {
				if(j*j+i*i == n)
				    {
					cnt++;
					continue;
				    }
				for(int k=j;k*k+j*j+i*i<=n;k++)
				    {
					if(k*k+j*j+i*i == n)
					    {
						cnt++;
						continue;
					    }
					int dif = n-(k*k+j*j+i*i);
					int res = (int)Math.sqrt(dif);
					if(res*res == dif)cnt++;

					    
				    }
			    }
		    }
		


		System.out.println(cnt);
*/
		System.out.println(rec(0,1,0));
	    }
    }

}

</source>
</class>

<class classid="231" nclones="2" nlines="145" similarity="100">
<source file="../hum_codes_raw/s477615844.java" startline="1" endline="219" pcid="16044">
import java.io.IOException;
import java.util.NoSuchElementException;

import java.io.InputStream;

import java.io.PrintWriter;

import java.util.Arrays;

@SuppressWarnings("unchecked")
public class Main {
    static int N;
    static long MAX_A;

    static long[] a;
    static long[] s;

    static long[] BIT;

    // v[x] += w
    // 
    // 
    static void bitAdd(long x) {
        // BIT 
        // 
        // 1-indexed n + 1
        // 0-indexed n
        long idx = x + N + 1;

        // Integer.lowestOneBit(idx)
        for (; idx < N * 2 + 2; idx += idx & -idx) BIT[(int) idx]++;
    }

    // v[1] +  + v[x]
    // 
    // 
    static long bitQuery(long x) {
        // BIT 
        // 
        // 1-indexed n + 1
        // 0-indexed n
        long idx = x + N + 1;
        long ret = 0;

        // Integer.lowestOneBit(idx)
        for (; 0 < idx; idx -= idx & -idx) ret += BIT[(int) idx];

        return ret;
    }

    static long f(long mid) {
        long ret = 0;
        long prev = 0;

        // 
        Arrays.fill(s, 0);

        for (int i = 0; i < N; i++) {
            if (mid <= a[i]) prev++;
            else prev--;

            s[i] = prev;
        }

        // 
        Arrays.fill(BIT, 0);

        bitAdd(0);

        for (int i = 0; i < N; i++) {
            ret += bitQuery(s[i]);

            // 
            // 
            // 
            bitAdd(s[i]);
        }

        return ret;
    }

    // Bisection Method
    // [left, right]
    // to narrow the range
    static long bisectionMethod() {
        // 
        // 
        // 2 2 ceil
        long p = (long)Math.ceil(((double) N * (N + 1) / 2) / 2);

        long l = 0;
        long r = MAX_A + 1;
        long ret = 0;

        while (l <= r) {
            long mid = (l + r) / 2;
            long num = f(mid);

            //  
            if (p <= num) {
                ret = mid;
                l = mid + 1;
            } else
                r = mid - 1;
        }

        return ret;
    }

    public static void main(String[] args) throws IOException {
        PrintWriter out = new PrintWriter(System.out);

        N = nextInt();

        a = new long[N];
        s = new long[N];
        BIT = new long[N * 2 + 2];

        for (int i = 0; i < N; i++) {
            a[i] = nextInt();
            MAX_A = Math.max(MAX_A, a[i]);
        }

        out.println(bisectionMethod());

        out.flush();
    }

    // FastScanner start
    static final InputStream in = System.in;
    static final byte[] buffer = new byte[1024];
    static int ptr = 0;
    static int buflen = 0;

    static boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        } else {
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }

    static int readByte() {
        if (hasNextByte())
            return buffer[ptr++];
        else
            return -1;
    }

    static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }

    static boolean hasNext() {
        while (hasNextByte() && !isPrintableChar(buffer[ptr]))
            ptr++;
        return hasNextByte();
    }

    static String next() {
        if (!hasNext())
            throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while (isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }

    static long nextLong() {
        if (!hasNext())
            throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                n *= 10;
                n += b - '0';
            } else if (b == -1 || !isPrintableChar(b)) {
                return minus ? -n : n;
            } else {
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }

    static int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)
            throw new NumberFormatException();
        return (int) nl;
    }

    static double nextDouble() {
        return Double.parseDouble(next());
    }
    // FastScanner end
}

</source>
<source file="../hum_codes_raw/s923583382.java" startline="1" endline="219" pcid="31056">
import java.io.IOException;
import java.util.NoSuchElementException;

import java.io.InputStream;

import java.io.PrintWriter;

import java.util.Arrays;

@SuppressWarnings("unchecked")
public class Main {
    static int N;
    static long MAX_A;

    static long[] a;
    static long[] s;

    static long[] BIT;

    // v[x] += w
    // 
    // 
    static void bitAdd(long x) {
        // BIT 
        // 
        // 1-indexed n + 1
        // 0-indexed n
        long idx = x + N + 1;

        // Integer.lowestOneBit(idx)
        for (; idx < N * 2 + 2; idx += idx & -idx) BIT[(int) idx]++;
    }

    // v[1] +  + v[x]
    // 
    // 
    static long bitQuery(long x) {
        // BIT 
        // 
        // 1-indexed n + 1
        // 0-indexed n
        long idx = x + N + 1;
        long ret = 0;

        // Integer.lowestOneBit(idx)
        for (; 0 < idx; idx -= idx & -idx) ret += BIT[(int) idx];

        return ret;
    }

    static long f(long mid) {
        long ret = 0;
        long prev = 0;

        // 
        Arrays.fill(s, 0);

        for (int i = 0; i < N; i++) {
            if (mid <= a[i]) prev++;
            else prev--;

            s[i] = prev;
        }

        // 
        Arrays.fill(BIT, 0);

        bitAdd(0);

        for (int i = 0; i < N; i++) {
            ret += bitQuery(s[i]);

            // 
            // 
            // 
            bitAdd(s[i]);
        }

        return ret;
    }

    // Bisection Method
    // [left, right]
    // to narrow the range
    static long bisectionMethod() {
        // 
        // 
        // 2 2 ceil
        long p = (long)Math.ceil(((double) N * (N + 1) / 2) / 2);

        long l = 0;
        long r = MAX_A + 1;
        long ret = 0;

        while (l <= r) {
            long mid = (l + r) / 2;
            long num = f(mid);

            //  
            if (p <= num) {
                ret = mid;
                l = mid + 1;
            } else
                r = mid - 1;
        }

        return ret;
    }

    public static void main(String[] args) throws IOException {
        PrintWriter out = new PrintWriter(System.out);

        N = nextInt();

        a = new long[N];
        s = new long[N];
        BIT = new long[N * 2 + 2];

        for (int i = 0; i < N; i++) {
            a[i] = nextInt();
            MAX_A = Math.max(MAX_A, a[i]);
        }

        out.println(bisectionMethod());

        out.flush();
    }

    // FastScanner start
    static final InputStream in = System.in;
    static final byte[] buffer = new byte[1024];
    static int ptr = 0;
    static int buflen = 0;

    static boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        } else {
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }

    static int readByte() {
        if (hasNextByte())
            return buffer[ptr++];
        else
            return -1;
    }

    static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }

    static boolean hasNext() {
        while (hasNextByte() && !isPrintableChar(buffer[ptr]))
            ptr++;
        return hasNextByte();
    }

    static String next() {
        if (!hasNext())
            throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while (isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }

    static long nextLong() {
        if (!hasNext())
            throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                n *= 10;
                n += b - '0';
            } else if (b == -1 || !isPrintableChar(b)) {
                return minus ? -n : n;
            } else {
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }

    static int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)
            throw new NumberFormatException();
        return (int) nl;
    }

    static double nextDouble() {
        return Double.parseDouble(next());
    }
    // FastScanner end
}

</source>
</class>

<class classid="232" nclones="2" nlines="34" similarity="100">
<source file="../hum_codes_raw/s480713764.java" startline="1" endline="38" pcid="16140">
import java.util.Scanner;

public class Main{
	public static void main(String[] args) {
		Scanner scan = new Scanner(System.in);
		double x_p1 = scan.nextDouble();
		double y_p1 = scan.nextDouble();
		double x_p2 = scan.nextDouble();
		double y_p2 = scan.nextDouble();
		double vx = x_p2 - x_p1;
		double vy = y_p2 - y_p1;
		int q = scan.nextInt();
		double l = norm(x_p1, y_p1, x_p2, y_p2);

		for(int i = 0; i < q; i++) {
			double x = scan.nextDouble();
			double y = scan.nextDouble();
			double ux = x - x_p1;
			double uy = y - y_p1;
			double t = dot(ux, uy, vx, vy);
			double k = t / l;
			double ax = k * vx + x_p1;
			double ay = k * vy + y_p1;
			double bx = 2 * ax - x;
			double by = 2 * ay - y;
			System.out.println(bx + " " + by);
		}
		scan.close();

	}
	static double dot(double x1, double y1, double x2, double y2) {
		return x1 * x2 + y1 * y2;
	}
	static double norm(double x1, double y1, double x2, double y2) {
		return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
	}
}

</source>
<source file="../hum_codes_raw/s861914098.java" startline="1" endline="44" pcid="28984">
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        double x_p1 = scan.nextDouble();
        double y_p1 = scan.nextDouble();
        double x_p2 = scan.nextDouble();
        double y_p2 = scan.nextDouble();
        
        double vx = x_p2 - x_p1;
        double vy = y_p2 - y_p1;
        
        int q = scan.nextInt();
        double l = norm(x_p1, y_p1, x_p2, y_p2);
        
        for(int i = 0; i < q; i++) {
            double x = scan.nextDouble();
            double y = scan.nextDouble();
            double ux = x - x_p1;
            double uy = y - y_p1;
            
            double t = dot(ux, uy, vx, vy);
            
            double k = t / l;
            double ax = k * vx + x_p1;
            double ay = k * vy + y_p1;
            
            double bx = 2 * ax - x;
            double by = 2 * ay - y;
            System.out.println(bx + " " + by);
        }
        scan.close();
    }
    
    static double dot(double x1, double y1, double x2, double y2) {
        return x1 * x2 + y1 * y2;
    }
    
    static double norm(double x1, double y1, double x2, double y2) {
        return (x1 - x2) * (x1 - x2) + (y1 -y2) * (y1 - y2);
    }
}

</source>
</class>

<class classid="233" nclones="2" nlines="62" similarity="100">
<source file="../hum_codes_raw/s489483606.java" startline="1" endline="106" pcid="16442">
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {
    public static void main(String args[]) {
        //2^24
        new Thread(null, () -> {
            int n;
            int k;
            List<Integer> as = new ArrayList<>();

            //try-with-resources(try)
            try (Scanner sc = new Scanner(System.in)) {
                n = sc.nextInt();
                k = sc.nextInt();
                for (int i = 0; i < n; i++) {
                    as.add(sc.nextInt() - 1);
                }
            }
            System.out.println(new Calculator(n, k, as).calculate());
        }, "", 1 << 24).start();
    }
}

/**
 * 
 */
class Calculator {
    /**
     * K
     */
    private int k;

    /**
     * 
     */
    private int answer = 0;

    /**
     * 
     */
    private boolean isCalculate = false;

    /**
     * 
     */
    private List<List<Integer>> lists = new ArrayList<>();

    /**
     * 
     *
     * @param n  
     * @param k  K
     * @param as 
     */
    Calculator(int n, int k, List<Integer> as) {
        this.k = k;
        for (int i = 0; i < n; i++) {
            this.lists.add(new ArrayList<>());
        }
        for (int i = 0; i < n; i++) {
            int j = as.get(i);
            if (0 < i) {
                this.lists.get(j).add(i);
            } else if (0 < j) {
                this.answer++;
            }
        }
    }

    /**
     * 
     *
     * @return 
     */
    int calculate() {
        if (!this.isCalculate) {
            this.dfs(0, 0);
            this.isCalculate = true;
        }
        return this.answer;
    }

    /**
     * 
     *
     * @param a   
     * @param pre 1
     * @return 
     */
    private int dfs(int a, int pre) {
        int h = 0;
        for (int i : this.lists.get(a)) {
            h = Math.max(h, this.dfs(i, a));
        }
        if (0 < pre && h == this.k - 1) {
            h = 0;
            this.answer++;
        } else {
            h++;
        }
        return h;
    }
}

</source>
<source file="../hum_codes_raw/s787185351.java" startline="1" endline="110" pcid="26429">
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {
    public static void main(String args[]) {
        //2^24
        new Thread(null, () -> {
            int n;
            int k;
            List<Integer> as = new ArrayList<>();

            //try-with-resources(try)
            try (Scanner sc = new Scanner(System.in)) {
                n = sc.nextInt();
                k = sc.nextInt();
                for (int i = 0; i < n; i++) {
                    as.add(sc.nextInt() - 1);
                }
            }
            System.out.println(new Calculator(n, k, as).calculate());
        }, "", 1 << 24).start();
    }
}

/**
 * 
 */
class Calculator {
    /**
     * K
     */
    private int k;

    /**
     * 
     */
    private int answer = 0;

    /**
     * 
     */
    private boolean isCalculate = false;

    /**
     * 
     */
    private List<List<Integer>> lists = new ArrayList<>();

    /**
     * 
     *
     * @param n  
     * @param k  K
     * @param as 
     */
    Calculator(int n, int k, List<Integer> as) {
        this.k = k;
        for (int i = 0; i < n; i++) {
            this.lists.add(new ArrayList<>());
        }
        for (int i = 0; i < n; i++) {
            int j = as.get(i);
            if (0 < i) {
                this.lists.get(j).add(i);
            } else if (0 < j) {
                this.answer++;
            }
        }
    }

    /**
     * 
     *
     * @return 
     */
    int calculate() {
        if (!this.isCalculate) {
            this.dfs(0, 0);
            this.isCalculate = true;
        }
        return this.answer;
    }

    /**
     * 
     *
     * @param a   
     * @param pre 1
     * @return 
     */
    private int dfs(int a, int pre) {
        int h = 0;

        //for(1)
        for (int i : this.lists.get(a)) {
            h = Math.max(h, this.dfs(i, a));
        }

        if (0 < pre && h == this.k - 1) {
            h = 0;
            this.answer++;
        } else {
            h++;
        }

        return h;
    }
}

</source>
</class>

<class classid="234" nclones="2" nlines="1007" similarity="100">
<source file="../hum_codes_raw/s492478736.java" startline="1" endline="674" pcid="16541">
import java.util.*;
import java.io.*;
public class Main {
	static boolean DEBUG;
	public static void main(String[] args) {
		DEBUG = args.length > 0 && args[0].equals("-DEBUG");
		Solver solver = new Solver();
		solver.solve();
		solver.exit();
	}

	static class FastScanner {
		private final InputStream in = System.in;
		private final byte[] buffer = new byte[1024];
		private int ptr = 0;
		private int buflen = 0;
		private boolean hasNextByte() {
			if (ptr < buflen) {
				return true;
			}else{
				ptr = 0;
				try {
					buflen = in.read(buffer);
				} catch (IOException e) {
					e.printStackTrace();
				}
				if (buflen <= 0) {
					return false;
				}
			}
			return true;
		}
		private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}
		private boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}
		private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}
		public boolean hasNext() { skipUnprintable(); return hasNextByte();}
		public String next() {
			if (!hasNext()) throw new NoSuchElementException();
			StringBuilder sb = new StringBuilder();
			int b = readByte();
			while(isPrintableChar(b)) {
				sb.appendCodePoint(b);
				b = readByte();
			}
			return sb.toString();
		}
		public long nextLong() {
			if (!hasNext()) throw new NoSuchElementException();
			long n = 0;
			boolean minus = false;
			int b = readByte();
			if (b == '-') {
				minus = true;
				b = readByte();
			}
			if (b < '0' || '9' < b) {
				throw new NumberFormatException();
			}
			while(true){
				if ('0' <= b && b <= '9') {
					n *= 10;
					n += b - '0';
				}else if(b == -1 || !isPrintableChar(b)){
					return minus ? -n : n;
				}else{
					throw new NumberFormatException();
				}
				b = readByte();
			}
		}
	}

	static class Solver {
		FastScanner sc = new FastScanner();
		public Solver() { }

		String ns() { return sc.next(); }
		String[] ns(int n) {
			String a[] = new String[n];
			for(int i = 0; i < n; i ++) { a[i] = ns(); }
			return a;
		}
		String[][] ns(int n, int m) {
			String a[][] = new String[n][m];
			for(int i = 0; i < n; i ++) { a[i] = ns(m); }
			return a;
		}
		char[] nc(int n) {
			String str = ns();
			char a[] = new char[str.length()];
			for(int i = 0; i < str.length(); i ++) { a[i] = str.charAt(i); }
			return a;
		}
		char[][] nc(int n, int m) {
			char a[][] = new char[n][m];
			for(int i = 0; i < n; i ++) { a[i] = nc(m); }
			return a;
		}
		boolean[] nb(int n, char t) {
			boolean a[] = new boolean[n];
			char c[] = nc(n);
			for(int i = 0; i < n; i ++) { a[i] = c[i] == t; }
			return a;
		}
		boolean[][] nb(int n, int m, char t) {
			boolean a[][] = new boolean[n][m];
			for(int i = 0; i < n; i ++) { a[i] = nb(m, t); }
			return a;
		}
		int ni() { return (int)sc.nextLong(); }
		int[] ni(int n) {
			int a[] = new int[n];
			for(int i = 0; i < n; i ++) { a[i] = ni(); }
			return a;
		}
		int[][] ni(int n, int m) {
			int a[][] = new int[n][m];
			for(int i = 0; i < n; i ++) { a[i] = ni(m); }
			return a;
		}
		long nl() { return sc.nextLong(); }
		long[] nl(int n) {
			long a[] = new long[n];
			for(int i = 0; i < n; i ++) { a[i] = nl(); }
			return a;
		}
		long[][] nl(int n, int m) {
			long a[][] = new long[n][m];
			for(int i = 0; i < n; i ++) { a[i] = nl(m); }
			return a;
		}

		PrintWriter out = new PrintWriter(System.out);
		PrintWriter err = new PrintWriter(System.err);
		void prt() { out.print(""); }
		<T> void prt(T a) { out.print(a); }
		void prtln() { out.println(""); }
		<T> void prtln(T a) { out.println(a); }
		void prtln(int... a) {
			StringBuilder sb = new StringBuilder();
			for(int element : a){ sb.append(element+" "); }
			prtln(sb.toString().trim());
		}
		void prtln(long... a) {
			StringBuilder sb = new StringBuilder();
			for(long element : a){ sb.append(element+" "); }
			prtln(sb.toString().trim());
		}
		void prtln(double... a) {
			StringBuilder sb = new StringBuilder();
			for(double element : a){ sb.append(element+" "); }
			prtln(sb.toString().trim());
		}
		void prtln(String... a) {
			StringBuilder sb = new StringBuilder();
			for(String element : a){ sb.append(element+" "); }
			prtln(sb.toString().trim());
		}
		void prtln(char... a) {
			StringBuilder sb = new StringBuilder();
			for(char element : a){ sb.append(element); }
			prtln(sb.toString().trim());
		}
		void prtln(int[][] a) { for(int[] element : a){ prtln(element); } }
		void prtln(long[][] a) { for(long[] element : a){ prtln(element); } }
		void prtln(double[][] a) { for(double[] element : a){ prtln(element); } }
		void prtln(String[][] a) { for(String[] element : a){ prtln(element); } }
		void prtln(char[][] a) { for(char[] element : a){ prtln(element); } }
		String errconvert(int a) { return isINF(a) ? "_" : String.valueOf(a); }
		String errconvert(long a) { return isINF(a) ? "_" : String.valueOf(a); }
		void errprt(int a) { if(DEBUG) { err.print(errconvert(a)); } }
		void errprt(long a) { if(DEBUG) { err.print(errconvert(a)); } }
		void errprt() { if(DEBUG) { err.print(""); } }
		<T> void errprt(T a) { if(DEBUG) { err.print(a); } }
		void errprt(boolean a) { if(DEBUG) { errprt(a ? "#" : "."); } }
		void errprtln() { if(DEBUG) { err.println(""); } }
		void errprtln(int a) { if(DEBUG) { err.println(errconvert(a)); } }
		void errprtln(long a) { if(DEBUG) { err.println(errconvert(a)); } }
		<T> void errprtln(T a) { if(DEBUG) { err.println(a); } }
		void errprtln(boolean a) { if(DEBUG) { errprtln(a ? "#" : "."); } }
		void errprtln(int... a) {
			if(DEBUG) {
				StringBuilder sb = new StringBuilder();
				for(int element : a){ sb.append(errconvert(element)+" "); }
				errprtln(sb.toString().trim());
			}
		}
		void errprtln(long... a) {
			if(DEBUG) {
				StringBuilder sb = new StringBuilder();
				for(long element : a){ sb.append(errconvert(element)+" "); }
				errprtln(sb.toString().trim());
			}
		}
		void errprtln(double... a) {
			if(DEBUG) {
				StringBuilder sb = new StringBuilder();
				for(double element : a){ sb.append(element+" "); }
				errprtln(sb.toString().trim());
			}
		}
		void errprtln(String... a) {
			if(DEBUG) {
				StringBuilder sb = new StringBuilder();
				for(String element : a){ sb.append(element+" "); }
				errprtln(sb.toString().trim());
			}
		}
		void errprtln(char... a) {
			if(DEBUG) {
				StringBuilder sb = new StringBuilder();
				for(char element : a){ sb.append(element); }
				errprtln(sb.toString().trim());
			}
		}
		void errprtln(boolean... a) {
			if(DEBUG) {
				StringBuilder sb = new StringBuilder();
				for(boolean element : a){ sb.append((element ? "#" : ".")+" "); }
				errprtln(sb.toString().trim());
			}
		}
		void errprtln(int[][] a) { if(DEBUG) { for(int[] element : a){ errprtln(element); } } }
		void errprtln(long[][] a) { if(DEBUG) { for(long[] element : a){ errprtln(element); } } }
		void errprtln(double[][] a) { if(DEBUG) { for(double[] element : a){ errprtln(element); } } }
		void errprtln(String[][] a) { if(DEBUG) { for(String[] element : a){ errprtln(element); } } }
		void errprtln(char[][] a) { if(DEBUG) { for(char[] element : a){ errprtln(element); } } }
		void errprtln(boolean[][] a) { if(DEBUG) { for(boolean[] element : a){ errprtln(element); } } }

		void reply(boolean b) { prtln(b ? "Yes" : "No"); }
		void REPLY(boolean b) { prtln(b ? "YES" : "NO"); }

		void flush() { out.flush(); if(DEBUG) { err.flush(); } }
		void exit() { flush(); System.exit(0); }

		int min(int a, int b) { return Math.min(a, b); }
		long min(long a, long b) { return Math.min(a, b); }
		double min(double a, double b) { return Math.min(a, b); }
		int min(int... x) {
			int min = x[0];
			for(int val : x) { min = min(min, val); }
			return min;
		}
		long min(long... x) {
			long min = x[0];
			for(long val : x) { min = min(min, val); }
			return min;
		}
		double min(double... x) {
			double min = x[0];
			for(double val : x) { min = min(min, val); }
			return min;
		}
		int max(int a, int b) { return Math.max(a, b); }
		long max(long a, long b) { return Math.max(a, b); }
		double max(double a, double b) { return Math.max(a, b); }
		int max(int... x) {
			int max = x[0];
			for(int val : x) { max = max(max, val); }
			return max;
		}
		long max(long... x) {
			long max = x[0];
			for(long val : x) { max = max(max, val); }
			return max;
		}
		double max(double... x) {
			double max = x[0];
			for(double val : x) { max = max(max, val); }
			return max;
		}
		long sum(int... a) {
			long sum = 0;
			for(int element : a) { sum += element; }
			return sum;
		}
		long sum(long... a) {
			long sum = 0;
			for(long element : a) { sum += element; }
			return sum;
		}
		double sum(double... a) {
			double sum = 0;
			for(double element : a) { sum += element; }
			return sum;
		}
		long[] sums(int[] a) {
			long sum[] = new long[a.length + 1];
			sum[0] = 0;
			for(int i = 0; i < a.length; i ++) { sum[i + 1] = sum[i] + a[i]; }
			return sum;
		}
		long[] sums(long[] a) {
			long sum[] = new long[a.length + 1];
			sum[0] = 0;
			for(int i = 0; i < a.length; i ++) { sum[i + 1] = sum[i] + a[i]; }
			return sum;
		}
		double[] sums(double[] a) {
			double sum[] = new double[a.length + 1];
			sum[0] = 0;
			for(int i = 0; i < a.length; i ++) { sum[i + 1] = sum[i] + a[i]; }
			return sum;
		}

		long abs(double x) { return (long)Math.abs(x); }
		long round(double x) { return Math.round(x); }
		long floor(double x) { return (long)Math.floor(x); }
		long ceil(double x) { return (long)Math.ceil(x); }
		double sqrt(double x) { return Math.sqrt(x); }
		double pow(double x, double y) { return Math.pow(x, y); }
		long pow(long x, long y) { return (long)Math.pow(x, y); }
		int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }
		long gcd(long a, long b) { return b == 0 ? a : gcd(b, a % b); }
		long lcm(long a, long b) { return a * b / gcd(a, b); }

		int upperToInt(char a) { return a - 'A'; }
		int lowerToInt(char a) { return a - 'a'; }
		int numToInt(char a) { return a - '0'; }
		int charToInt(char a) { return a >= 'a' ? lowerToInt(a) : a >= 'A' ? upperToInt(a) : numToInt(a); }
		char intToUpper(int a) { return (char)(a + 'A'); }
		char intToLower(int a) { return (char)(a + 'a'); }
		char intToNum(int a) { return (char)(a + '0'); }

		long[] div(long a) {
			List<Long> divList = new ArrayList<Long>();
			for(long i = 1; i * i <= a; i ++) {
				if(a % i == 0) {
					divList.add(i);
					if(i * i != a) { divList.add(a / i); };
				}
			}

			long div[] = new long[divList.size()];
			for(int i = 0; i < divList.size(); i ++) { div[i] = divList.get(i); }
			return div;
		}

		long[][] factor(long a) {
			List<Long> factorList = new ArrayList<Long>();
			List<Long> degreeList = new ArrayList<Long>();
			for(long i = 2; i * i <= a; i ++) {
				if(a % i == 0) {
					long count = 0;
					while(a % i == 0) {
						a /= i;
						count ++;
					}
					factorList.add(i);
					degreeList.add(count);
				}
			}
			if(a > 1) {
				factorList.add(a);
				degreeList.add(1L);
			}
			long factor[][] = new long[factorList.size()][2];
			for(int i = 0; i < factorList.size(); i ++) {
				factor[i][0] = factorList.get(i);
				factor[i][1] = degreeList.get(i);
			}
			return factor;
		}

		long[][] countElements(long[] a, boolean sort) {
			int len = a.length;
			long array[] = new long[len];
			for(int i = 0; i < len; i ++) {
				array[i] = a[i];
			}
			if(sort) { Arrays.sort(array); }
			List<Long> elem = new ArrayList<Long>();
			List<Long> cnt = new ArrayList<Long>();
			long tmp = 1;
			for(int i = 1; i <= len; i ++) {
				if(i == len || array[i] != array[i - 1]) {
					elem.add(array[i - 1]);
					cnt.add(tmp);
					tmp = 1;
				}else {
					tmp ++;
				}
			}
			long counts[][] = new long[elem.size()][2];
			for(int i = 0; i < elem.size(); i ++) {
				counts[i][0] = elem.get(i);
				counts[i][1] = cnt.get(i);
			}
			return counts;
		}
		long[][] countElements(String str, boolean sort) {
			int len = str.length();
			char array[] = str.toCharArray();
			if(sort) { Arrays.sort(array); }
			List<Long> elem = new ArrayList<Long>();
			List<Long> cnt = new ArrayList<Long>();
			long tmp = 1;
			for(int i = 1; i <= len; i ++) {
				if(i == len || array[i] != array[i - 1]) {
					elem.add((long)array[i - 1]);
					cnt.add(tmp);
					tmp = 1;
				}else {
					tmp ++;
				}
			}
			long counts[][] = new long[elem.size()][2];
			for(int i = 0; i < elem.size(); i ++) {
				counts[i][0] = elem.get(i);
				counts[i][1] = cnt.get(i);
			}
			return counts;
		}

		int numDigits(long a) { return Long.toString(a).length(); }
		long bitFlag(int a) { return 1L << (long)a; }
		boolean isFlagged(long x, int a) { return (x & bitFlag(a)) != 0; }

		long countString(String str, String a) { return (str.length() - str.replace(a, "").length()) / a.length(); }
		long countStringAll(String str, String a) { return str.length() - str.replaceAll(a, "").length(); }

		void reverse(String array[]) {
			String reversed[] = new String[array.length];
			for(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }
			for(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }
		}
		void reverse(int array[]) {
			int reversed[] = new int[array.length];
			for(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }
			for(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }
		}
		void reverse(long array[]) {
			long reversed[] = new long[array.length];
			for(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }
			for(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }
		}
		void reverse(double array[]) {
			double reversed[] = new double[array.length];
			for(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }
			for(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }
		}
		void reverse(boolean array[]) {
			boolean reversed[] = new boolean[array.length];
			for(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }
			for(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }
		}
		void fill(int array[], int x) { Arrays.fill(array, x); }
		void fill(long array[], long x) { Arrays.fill(array, x); }
		void fill(double array[], double x) { Arrays.fill(array, x); }
		void fill(boolean array[], boolean x) { Arrays.fill(array, x); }
		void fill(int array[][], int x) { for(int a[] : array) { fill(a, x); } }
		void fill(long array[][], long x) { for(long a[] : array) { fill(a, x); } }
		void fill(double array[][], double x) { for(double a[] : array) { fill(a, x); } }
		void fill(boolean array[][], boolean x) { for(boolean a[] : array) { fill(a, x); } }
		void fill(int array[][][], int x) { for(int a[][] : array) { fill(a, x); } }
		void fill(long array[][][], long x) { for(long a[][] : array) { fill(a, x); } }
		void fill(double array[][][], double x) { for(double a[][] : array) { fill(a, x); } }
		void fill(boolean array[][][], boolean x) { for(boolean a[][] : array) { fill(a, x); } }

		long INF = (long)1e18 + 7;
		boolean isINF(long a) { return abs(a) > INF / 1000; }
		boolean isPlusINF(long a) { return a > 0 && isINF(a); }
		boolean isMinusINF(long a) { return isPlusINF(- a); }
		int I_INF = (int)1e9 + 7;
		boolean isINF(int a) { return abs(a) > I_INF / 1000; }
		boolean isPlusINF(int a) { return a > 0 && isINF(a); }
		boolean isMinusINF(int a) { return isPlusINF(- a); }


		// mods
		long MOD = (long)1e9 + 7; // 998244353;
		public long mod(long i) { return i % MOD + ((i % MOD) < 0 ? MOD : 0); }

		long pow_m(long x, long y) {
			if (y == 0) { return 1;
			}else {
				long tmp = pow_m(x, y / 2);
				return mod(mod(tmp * tmp) * (y % 2 == 0 ? 1 : x));
			}
		}
		long[] pows_m(long x, int max) {
			long pow[] = new long[max + 1];
			pow[0] = 1;
			for(int i = 0; i < max; i ++) {
				pow[i + 1] = mod(pow[i] * x);
			}
			return pow;
		}

		long inv(long x) { return pow_m(x, MOD - 2); }

		int MAX_FACT = 5_000_100;
		long fact[];
		long invFact[];
		void prepareFact() {
			fact = new long[MAX_FACT];
			Arrays.fill(fact, 0);
			invFact = new long[MAX_FACT];
			Arrays.fill(invFact, 0);
			fact[0] = 1;
			int maxIndex = min(MAX_FACT, (int)MOD);
			for(int i = 1; i < maxIndex; i ++) { fact[i] = mod(fact[i - 1] * i); }
			invFact[maxIndex - 1] = inv(fact[maxIndex - 1]);
			for(int i = maxIndex - 1; i > 0; i --) { invFact[i - 1] = mod(invFact[i] * i); }
		}

		long P(int n, int r) {
			if(n < 0 || r < 0 || n < r) { return 0; }
			return mod(fact[n] * invFact[n - r]);
		}
		long C(int n, int r) {
			if(n < 0 || r < 0 || n < r) { return 0; }
			return mod(P(n, r) * invFact[r]);
		}
		long H(int n, int r) { return C((n - 1) + r, r); }


		// grid
		class Grid implements Comparable<Grid> {
			int h;
			int w;
			long val;

			Grid() {  }
			Grid(int h, int w) {
				this.h = h;
				this.w = w;
			}
			Grid(int h, int w, long val) {
				this.h = h;
				this.w = w;
				this.val = val;
			}

			@Override
			public int compareTo(Grid g) {
				return Long.compare(this.val, g.val);
			}
		}


		// graph
		class Graph {
			int numNode;
			int numEdge;
			boolean directed;
			Edge edges[];
			Node nodes[];
			Node reversedNodes[];

			Graph(int numNode, int numEdge, Edge edges[], boolean directed) {
				this.numNode = numNode;
				this.numEdge = numEdge;
				this.directed = directed;
				this.edges = edges;
				nodes = new Node[numNode];
				reversedNodes = new Node[numNode];
				for(int i = 0; i < numNode; i ++) {
					nodes[i] = new Node(i);
					reversedNodes[i] = new Node(i);
				}

				for(Edge edge : edges) {
					nodes[edge.source].add(edge.target, edge.cost);
					if(directed) {
						reversedNodes[edge.target].add(edge.source, edge.cost);
					}else {
						nodes[edge.target].add(edge.source, edge.cost);
					}
				}
			}

			void clearNodes() {
				for(Node n : nodes) { n.clear(); }
				for(Node n : reversedNodes) { n.clear(); }
			}
		}

		class Node {
			int id;
			ArrayList<Edge> edges = new ArrayList<Edge>();

			Node(int id) {
				this.id = id;
			}
			void add(int target, long cost) {
				edges.add(new Edge(id, target, cost));
			}
			void clear() {
				edges.clear();
			}
		}

		class Edge implements Comparable<Edge> {
			int source;
			int target;
			long cost;
			Edge(int source, int target, long cost) {
				this.source = source;
				this.target = target;
				this.cost = cost;
			}

			@Override
			public int compareTo(Edge e) {
				return Long.compare(this.cost, e.cost);
			}
		}

public void solve() {
	int num = ni();
	int p[][] = ni(num, 2);
	double min = INF;

	for(int i = 0; i < num; i ++) {
		for(int j = 0; j < num; j ++) {
if(i == j) { continue; }
double px = (p[j][0] + p[i][0]) * 0.5;
double py = (p[j][1] + p[i][1]) * 0.5;
double r = 0;
for(int l = 0; l < num; l ++) {
	double tmp = pow(p[l][0] - px, 2) + pow(p[l][1] - py, 2);
	tmp = sqrt(tmp);
	r = max(r, tmp);
}
min = min(min, r);
		}
	}
	for(int i = 0; i < num; i ++) {
		for(int j = 0; j < num; j ++) {
			for(int k = 0; k < num; k ++) {
				if(i == j || j == k || k == i) { continue; }
double a = p[i][0];
double b = p[i][1];
double c = p[j][0];
double d = p[j][1];
double e = p[k][0];
double f = p[k][1];
double aa = p[i][0] * p[i][0];
double bb = p[i][1] * p[i][1];
double cc = p[j][0] * p[j][0];
double dd = p[j][1] * p[j][1];
double ee = p[k][0] * p[k][0];
double ff = p[k][1] * p[k][1];

if(a == c && c == e) { continue; }
if(b == d && d == f) { continue; }
if((d - a) * (e - a) == (c - a) * (f - b)) { continue; }

double py = ((e - a) * (aa + bb - cc - dd) - (c - a) * (aa + bb - ee- ff)) / (2 * (e - a)*(b - d) - 2 * (c - a) * (b - f));

double px = 0;
if (c == a){ px = (2 * (b - f) * py - aa - bb + ee + ff) / (2 * (e - a));
}else {px = (2 * (b - d) * py - aa - bb + cc + dd) / (2 * (c - a));}
if(Double.isNaN(px) || Double.isNaN(py)) { continue; }

double r = 0;
for(int l = 0; l < num; l ++) {
	double tmp = pow(p[l][0] - px, 2) + pow(p[l][1] - py, 2);
	tmp = sqrt(tmp);
	r = max(r, tmp);
}
min = min(min, r);
			}
		}
	}
	prtln(min);
}



	}
}

</source>
<source file="../hum_codes_raw/s893599862.java" startline="1" endline="674" pcid="30055">
import java.util.*;
import java.io.*;
public class Main {
	static boolean DEBUG;
	public static void main(String[] args) {
		DEBUG = args.length > 0 && args[0].equals("-DEBUG");
		Solver solver = new Solver();
		solver.solve();
		solver.exit();
	}

	static class FastScanner {
		private final InputStream in = System.in;
		private final byte[] buffer = new byte[1024];
		private int ptr = 0;
		private int buflen = 0;
		private boolean hasNextByte() {
			if (ptr < buflen) {
				return true;
			}else{
				ptr = 0;
				try {
					buflen = in.read(buffer);
				} catch (IOException e) {
					e.printStackTrace();
				}
				if (buflen <= 0) {
					return false;
				}
			}
			return true;
		}
		private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}
		private boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}
		private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}
		public boolean hasNext() { skipUnprintable(); return hasNextByte();}
		public String next() {
			if (!hasNext()) throw new NoSuchElementException();
			StringBuilder sb = new StringBuilder();
			int b = readByte();
			while(isPrintableChar(b)) {
				sb.appendCodePoint(b);
				b = readByte();
			}
			return sb.toString();
		}
		public long nextLong() {
			if (!hasNext()) throw new NoSuchElementException();
			long n = 0;
			boolean minus = false;
			int b = readByte();
			if (b == '-') {
				minus = true;
				b = readByte();
			}
			if (b < '0' || '9' < b) {
				throw new NumberFormatException();
			}
			while(true){
				if ('0' <= b && b <= '9') {
					n *= 10;
					n += b - '0';
				}else if(b == -1 || !isPrintableChar(b)){
					return minus ? -n : n;
				}else{
					throw new NumberFormatException();
				}
				b = readByte();
			}
		}
	}

	static class Solver {
		FastScanner sc = new FastScanner();
		public Solver() { }

		String ns() { return sc.next(); }
		String[] ns(int n) {
			String a[] = new String[n];
			for(int i = 0; i < n; i ++) { a[i] = ns(); }
			return a;
		}
		String[][] ns(int n, int m) {
			String a[][] = new String[n][m];
			for(int i = 0; i < n; i ++) { a[i] = ns(m); }
			return a;
		}
		char[] nc(int n) {
			String str = ns();
			char a[] = new char[str.length()];
			for(int i = 0; i < str.length(); i ++) { a[i] = str.charAt(i); }
			return a;
		}
		char[][] nc(int n, int m) {
			char a[][] = new char[n][m];
			for(int i = 0; i < n; i ++) { a[i] = nc(m); }
			return a;
		}
		boolean[] nb(int n, char t) {
			boolean a[] = new boolean[n];
			char c[] = nc(n);
			for(int i = 0; i < n; i ++) { a[i] = c[i] == t; }
			return a;
		}
		boolean[][] nb(int n, int m, char t) {
			boolean a[][] = new boolean[n][m];
			for(int i = 0; i < n; i ++) { a[i] = nb(m, t); }
			return a;
		}
		int ni() { return (int)sc.nextLong(); }
		int[] ni(int n) {
			int a[] = new int[n];
			for(int i = 0; i < n; i ++) { a[i] = ni(); }
			return a;
		}
		int[][] ni(int n, int m) {
			int a[][] = new int[n][m];
			for(int i = 0; i < n; i ++) { a[i] = ni(m); }
			return a;
		}
		long nl() { return sc.nextLong(); }
		long[] nl(int n) {
			long a[] = new long[n];
			for(int i = 0; i < n; i ++) { a[i] = nl(); }
			return a;
		}
		long[][] nl(int n, int m) {
			long a[][] = new long[n][m];
			for(int i = 0; i < n; i ++) { a[i] = nl(m); }
			return a;
		}

		PrintWriter out = new PrintWriter(System.out);
		PrintWriter err = new PrintWriter(System.err);
		void prt() { out.print(""); }
		<T> void prt(T a) { out.print(a); }
		void prtln() { out.println(""); }
		<T> void prtln(T a) { out.println(a); }
		void prtln(int... a) {
			StringBuilder sb = new StringBuilder();
			for(int element : a){ sb.append(element+" "); }
			prtln(sb.toString().trim());
		}
		void prtln(long... a) {
			StringBuilder sb = new StringBuilder();
			for(long element : a){ sb.append(element+" "); }
			prtln(sb.toString().trim());
		}
		void prtln(double... a) {
			StringBuilder sb = new StringBuilder();
			for(double element : a){ sb.append(element+" "); }
			prtln(sb.toString().trim());
		}
		void prtln(String... a) {
			StringBuilder sb = new StringBuilder();
			for(String element : a){ sb.append(element+" "); }
			prtln(sb.toString().trim());
		}
		void prtln(char... a) {
			StringBuilder sb = new StringBuilder();
			for(char element : a){ sb.append(element); }
			prtln(sb.toString().trim());
		}
		void prtln(int[][] a) { for(int[] element : a){ prtln(element); } }
		void prtln(long[][] a) { for(long[] element : a){ prtln(element); } }
		void prtln(double[][] a) { for(double[] element : a){ prtln(element); } }
		void prtln(String[][] a) { for(String[] element : a){ prtln(element); } }
		void prtln(char[][] a) { for(char[] element : a){ prtln(element); } }
		String errconvert(int a) { return isINF(a) ? "_" : String.valueOf(a); }
		String errconvert(long a) { return isINF(a) ? "_" : String.valueOf(a); }
		void errprt(int a) { if(DEBUG) { err.print(errconvert(a)); } }
		void errprt(long a) { if(DEBUG) { err.print(errconvert(a)); } }
		void errprt() { if(DEBUG) { err.print(""); } }
		<T> void errprt(T a) { if(DEBUG) { err.print(a); } }
		void errprt(boolean a) { if(DEBUG) { errprt(a ? "#" : "."); } }
		void errprtln() { if(DEBUG) { err.println(""); } }
		void errprtln(int a) { if(DEBUG) { err.println(errconvert(a)); } }
		void errprtln(long a) { if(DEBUG) { err.println(errconvert(a)); } }
		<T> void errprtln(T a) { if(DEBUG) { err.println(a); } }
		void errprtln(boolean a) { if(DEBUG) { errprtln(a ? "#" : "."); } }
		void errprtln(int... a) {
			if(DEBUG) {
				StringBuilder sb = new StringBuilder();
				for(int element : a){ sb.append(errconvert(element)+" "); }
				errprtln(sb.toString().trim());
			}
		}
		void errprtln(long... a) {
			if(DEBUG) {
				StringBuilder sb = new StringBuilder();
				for(long element : a){ sb.append(errconvert(element)+" "); }
				errprtln(sb.toString().trim());
			}
		}
		void errprtln(double... a) {
			if(DEBUG) {
				StringBuilder sb = new StringBuilder();
				for(double element : a){ sb.append(element+" "); }
				errprtln(sb.toString().trim());
			}
		}
		void errprtln(String... a) {
			if(DEBUG) {
				StringBuilder sb = new StringBuilder();
				for(String element : a){ sb.append(element+" "); }
				errprtln(sb.toString().trim());
			}
		}
		void errprtln(char... a) {
			if(DEBUG) {
				StringBuilder sb = new StringBuilder();
				for(char element : a){ sb.append(element); }
				errprtln(sb.toString().trim());
			}
		}
		void errprtln(boolean... a) {
			if(DEBUG) {
				StringBuilder sb = new StringBuilder();
				for(boolean element : a){ sb.append((element ? "#" : ".")+" "); }
				errprtln(sb.toString().trim());
			}
		}
		void errprtln(int[][] a) { if(DEBUG) { for(int[] element : a){ errprtln(element); } } }
		void errprtln(long[][] a) { if(DEBUG) { for(long[] element : a){ errprtln(element); } } }
		void errprtln(double[][] a) { if(DEBUG) { for(double[] element : a){ errprtln(element); } } }
		void errprtln(String[][] a) { if(DEBUG) { for(String[] element : a){ errprtln(element); } } }
		void errprtln(char[][] a) { if(DEBUG) { for(char[] element : a){ errprtln(element); } } }
		void errprtln(boolean[][] a) { if(DEBUG) { for(boolean[] element : a){ errprtln(element); } } }

		void reply(boolean b) { prtln(b ? "Yes" : "No"); }
		void REPLY(boolean b) { prtln(b ? "YES" : "NO"); }

		void flush() { out.flush(); if(DEBUG) { err.flush(); } }
		void exit() { flush(); System.exit(0); }

		int min(int a, int b) { return Math.min(a, b); }
		long min(long a, long b) { return Math.min(a, b); }
		double min(double a, double b) { return Math.min(a, b); }
		int min(int... x) {
			int min = x[0];
			for(int val : x) { min = min(min, val); }
			return min;
		}
		long min(long... x) {
			long min = x[0];
			for(long val : x) { min = min(min, val); }
			return min;
		}
		double min(double... x) {
			double min = x[0];
			for(double val : x) { min = min(min, val); }
			return min;
		}
		int max(int a, int b) { return Math.max(a, b); }
		long max(long a, long b) { return Math.max(a, b); }
		double max(double a, double b) { return Math.max(a, b); }
		int max(int... x) {
			int max = x[0];
			for(int val : x) { max = max(max, val); }
			return max;
		}
		long max(long... x) {
			long max = x[0];
			for(long val : x) { max = max(max, val); }
			return max;
		}
		double max(double... x) {
			double max = x[0];
			for(double val : x) { max = max(max, val); }
			return max;
		}
		long sum(int... a) {
			long sum = 0;
			for(int element : a) { sum += element; }
			return sum;
		}
		long sum(long... a) {
			long sum = 0;
			for(long element : a) { sum += element; }
			return sum;
		}
		double sum(double... a) {
			double sum = 0;
			for(double element : a) { sum += element; }
			return sum;
		}
		long[] sums(int[] a) {
			long sum[] = new long[a.length + 1];
			sum[0] = 0;
			for(int i = 0; i < a.length; i ++) { sum[i + 1] = sum[i] + a[i]; }
			return sum;
		}
		long[] sums(long[] a) {
			long sum[] = new long[a.length + 1];
			sum[0] = 0;
			for(int i = 0; i < a.length; i ++) { sum[i + 1] = sum[i] + a[i]; }
			return sum;
		}
		double[] sums(double[] a) {
			double sum[] = new double[a.length + 1];
			sum[0] = 0;
			for(int i = 0; i < a.length; i ++) { sum[i + 1] = sum[i] + a[i]; }
			return sum;
		}

		long abs(double x) { return (long)Math.abs(x); }
		long round(double x) { return Math.round(x); }
		long floor(double x) { return (long)Math.floor(x); }
		long ceil(double x) { return (long)Math.ceil(x); }
		double sqrt(double x) { return Math.sqrt(x); }
		double pow(double x, double y) { return Math.pow(x, y); }
		long pow(long x, long y) { return (long)Math.pow(x, y); }
		int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }
		long gcd(long a, long b) { return b == 0 ? a : gcd(b, a % b); }
		long lcm(long a, long b) { return a * b / gcd(a, b); }

		int upperToInt(char a) { return a - 'A'; }
		int lowerToInt(char a) { return a - 'a'; }
		int numToInt(char a) { return a - '0'; }
		int charToInt(char a) { return a >= 'a' ? lowerToInt(a) : a >= 'A' ? upperToInt(a) : numToInt(a); }
		char intToUpper(int a) { return (char)(a + 'A'); }
		char intToLower(int a) { return (char)(a + 'a'); }
		char intToNum(int a) { return (char)(a + '0'); }

		long[] div(long a) {
			List<Long> divList = new ArrayList<Long>();
			for(long i = 1; i * i <= a; i ++) {
				if(a % i == 0) {
					divList.add(i);
					if(i * i != a) { divList.add(a / i); };
				}
			}

			long div[] = new long[divList.size()];
			for(int i = 0; i < divList.size(); i ++) { div[i] = divList.get(i); }
			return div;
		}

		long[][] factor(long a) {
			List<Long> factorList = new ArrayList<Long>();
			List<Long> degreeList = new ArrayList<Long>();
			for(long i = 2; i * i <= a; i ++) {
				if(a % i == 0) {
					long count = 0;
					while(a % i == 0) {
						a /= i;
						count ++;
					}
					factorList.add(i);
					degreeList.add(count);
				}
			}
			if(a > 1) {
				factorList.add(a);
				degreeList.add(1L);
			}
			long factor[][] = new long[factorList.size()][2];
			for(int i = 0; i < factorList.size(); i ++) {
				factor[i][0] = factorList.get(i);
				factor[i][1] = degreeList.get(i);
			}
			return factor;
		}

		long[][] countElements(long[] a, boolean sort) {
			int len = a.length;
			long array[] = new long[len];
			for(int i = 0; i < len; i ++) {
				array[i] = a[i];
			}
			if(sort) { Arrays.sort(array); }
			List<Long> elem = new ArrayList<Long>();
			List<Long> cnt = new ArrayList<Long>();
			long tmp = 1;
			for(int i = 1; i <= len; i ++) {
				if(i == len || array[i] != array[i - 1]) {
					elem.add(array[i - 1]);
					cnt.add(tmp);
					tmp = 1;
				}else {
					tmp ++;
				}
			}
			long counts[][] = new long[elem.size()][2];
			for(int i = 0; i < elem.size(); i ++) {
				counts[i][0] = elem.get(i);
				counts[i][1] = cnt.get(i);
			}
			return counts;
		}
		long[][] countElements(String str, boolean sort) {
			int len = str.length();
			char array[] = str.toCharArray();
			if(sort) { Arrays.sort(array); }
			List<Long> elem = new ArrayList<Long>();
			List<Long> cnt = new ArrayList<Long>();
			long tmp = 1;
			for(int i = 1; i <= len; i ++) {
				if(i == len || array[i] != array[i - 1]) {
					elem.add((long)array[i - 1]);
					cnt.add(tmp);
					tmp = 1;
				}else {
					tmp ++;
				}
			}
			long counts[][] = new long[elem.size()][2];
			for(int i = 0; i < elem.size(); i ++) {
				counts[i][0] = elem.get(i);
				counts[i][1] = cnt.get(i);
			}
			return counts;
		}

		int numDigits(long a) { return Long.toString(a).length(); }
		long bitFlag(int a) { return 1L << (long)a; }
		boolean isFlagged(long x, int a) { return (x & bitFlag(a)) != 0; }

		long countString(String str, String a) { return (str.length() - str.replace(a, "").length()) / a.length(); }
		long countStringAll(String str, String a) { return str.length() - str.replaceAll(a, "").length(); }

		void reverse(String array[]) {
			String reversed[] = new String[array.length];
			for(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }
			for(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }
		}
		void reverse(int array[]) {
			int reversed[] = new int[array.length];
			for(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }
			for(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }
		}
		void reverse(long array[]) {
			long reversed[] = new long[array.length];
			for(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }
			for(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }
		}
		void reverse(double array[]) {
			double reversed[] = new double[array.length];
			for(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }
			for(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }
		}
		void reverse(boolean array[]) {
			boolean reversed[] = new boolean[array.length];
			for(int i = 0; i < array.length; i ++) { reversed[array.length - i - 1] = array[i]; }
			for(int i = 0; i < array.length; i ++) { array[i] = reversed[i]; }
		}
		void fill(int array[], int x) { Arrays.fill(array, x); }
		void fill(long array[], long x) { Arrays.fill(array, x); }
		void fill(double array[], double x) { Arrays.fill(array, x); }
		void fill(boolean array[], boolean x) { Arrays.fill(array, x); }
		void fill(int array[][], int x) { for(int a[] : array) { fill(a, x); } }
		void fill(long array[][], long x) { for(long a[] : array) { fill(a, x); } }
		void fill(double array[][], double x) { for(double a[] : array) { fill(a, x); } }
		void fill(boolean array[][], boolean x) { for(boolean a[] : array) { fill(a, x); } }
		void fill(int array[][][], int x) { for(int a[][] : array) { fill(a, x); } }
		void fill(long array[][][], long x) { for(long a[][] : array) { fill(a, x); } }
		void fill(double array[][][], double x) { for(double a[][] : array) { fill(a, x); } }
		void fill(boolean array[][][], boolean x) { for(boolean a[][] : array) { fill(a, x); } }

		long INF = (long)1e18 + 7;
		boolean isINF(long a) { return abs(a) > INF / 1000; }
		boolean isPlusINF(long a) { return a > 0 && isINF(a); }
		boolean isMinusINF(long a) { return isPlusINF(- a); }
		int I_INF = (int)1e9 + 7;
		boolean isINF(int a) { return abs(a) > I_INF / 1000; }
		boolean isPlusINF(int a) { return a > 0 && isINF(a); }
		boolean isMinusINF(int a) { return isPlusINF(- a); }


		// mods
		long MOD = (long)1e9 + 7; // 998244353;
		public long mod(long i) { return i % MOD + ((i % MOD) < 0 ? MOD : 0); }

		long pow_m(long x, long y) {
			if (y == 0) { return 1;
			}else {
				long tmp = pow_m(x, y / 2);
				return mod(mod(tmp * tmp) * (y % 2 == 0 ? 1 : x));
			}
		}
		long[] pows_m(long x, int max) {
			long pow[] = new long[max + 1];
			pow[0] = 1;
			for(int i = 0; i < max; i ++) {
				pow[i + 1] = mod(pow[i] * x);
			}
			return pow;
		}

		long inv(long x) { return pow_m(x, MOD - 2); }

		int MAX_FACT = 5_000_100;
		long fact[];
		long invFact[];
		void prepareFact() {
			fact = new long[MAX_FACT];
			Arrays.fill(fact, 0);
			invFact = new long[MAX_FACT];
			Arrays.fill(invFact, 0);
			fact[0] = 1;
			int maxIndex = min(MAX_FACT, (int)MOD);
			for(int i = 1; i < maxIndex; i ++) { fact[i] = mod(fact[i - 1] * i); }
			invFact[maxIndex - 1] = inv(fact[maxIndex - 1]);
			for(int i = maxIndex - 1; i > 0; i --) { invFact[i - 1] = mod(invFact[i] * i); }
		}

		long P(int n, int r) {
			if(n < 0 || r < 0 || n < r) { return 0; }
			return mod(fact[n] * invFact[n - r]);
		}
		long C(int n, int r) {
			if(n < 0 || r < 0 || n < r) { return 0; }
			return mod(P(n, r) * invFact[r]);
		}
		long H(int n, int r) { return C((n - 1) + r, r); }


		// grid
		class Grid implements Comparable<Grid> {
			int h;
			int w;
			long val;

			Grid() {  }
			Grid(int h, int w) {
				this.h = h;
				this.w = w;
			}
			Grid(int h, int w, long val) {
				this.h = h;
				this.w = w;
				this.val = val;
			}

			@Override
			public int compareTo(Grid g) {
				return Long.compare(this.val, g.val);
			}
		}


		// graph
		class Graph {
			int numNode;
			int numEdge;
			boolean directed;
			Edge edges[];
			Node nodes[];
			Node reversedNodes[];

			Graph(int numNode, int numEdge, Edge edges[], boolean directed) {
				this.numNode = numNode;
				this.numEdge = numEdge;
				this.directed = directed;
				this.edges = edges;
				nodes = new Node[numNode];
				reversedNodes = new Node[numNode];
				for(int i = 0; i < numNode; i ++) {
					nodes[i] = new Node(i);
					reversedNodes[i] = new Node(i);
				}

				for(Edge edge : edges) {
					nodes[edge.source].add(edge.target, edge.cost);
					if(directed) {
						reversedNodes[edge.target].add(edge.source, edge.cost);
					}else {
						nodes[edge.target].add(edge.source, edge.cost);
					}
				}
			}

			void clearNodes() {
				for(Node n : nodes) { n.clear(); }
				for(Node n : reversedNodes) { n.clear(); }
			}
		}

		class Node {
			int id;
			ArrayList<Edge> edges = new ArrayList<Edge>();

			Node(int id) {
				this.id = id;
			}
			void add(int target, long cost) {
				edges.add(new Edge(id, target, cost));
			}
			void clear() {
				edges.clear();
			}
		}

		class Edge implements Comparable<Edge> {
			int source;
			int target;
			long cost;
			Edge(int source, int target, long cost) {
				this.source = source;
				this.target = target;
				this.cost = cost;
			}

			@Override
			public int compareTo(Edge e) {
				return Long.compare(this.cost, e.cost);
			}
		}

public void solve() {
	int num = ni();
	int p[][] = ni(num, 2);
	double min = INF;

	for(int i = 0; i < num; i ++) {
		for(int j = 0; j < num; j ++) {
if(i == j) { continue; }
double px = (p[j][0] + p[i][0]) * 0.5;
double py = (p[j][1] + p[i][1]) * 0.5;
double r = 0;
for(int l = 0; l < num; l ++) {
	double tmp = pow(p[l][0] - px, 2) + pow(p[l][1] - py, 2);
	tmp = sqrt(tmp);
	r = max(r, tmp);
}
min = min(min, r);
		}
	}
	for(int i = 0; i < num; i ++) {
		for(int j = 0; j < num; j ++) {
			for(int k = 0; k < num; k ++) {
				if(i == j || j == k || k == i) { continue; }
double a = p[i][0];
double b = p[i][1];
double c = p[j][0];
double d = p[j][1];
double e = p[k][0];
double f = p[k][1];
double aa = p[i][0] * p[i][0];
double bb = p[i][1] * p[i][1];
double cc = p[j][0] * p[j][0];
double dd = p[j][1] * p[j][1];
double ee = p[k][0] * p[k][0];
double ff = p[k][1] * p[k][1];

if(a == c && c == e) { continue; }
if(b == d && d == f) { continue; }
if((d - a) * (e - a) == (c - a) * (f - b)) { continue; }

double py = ((e - a) * (aa + bb - cc - dd) - (c - a) * (aa + bb - ee- ff)) / (2 * (e - a)*(b - d) - 2 * (c - a) * (b - f));

double px = 0;
if (c == a){ px = (2 * (b - f) * py - aa - bb + ee + ff) / (2 * (e - a));
}else {px = (2 * (b - d) * py - aa - bb + cc + dd) / (2 * (c - a));}
if(Double.isNaN(px) || Double.isNaN(py)) { continue; }

double r = 0;
for(int l = 0; l < num; l ++) {
	double tmp = pow(p[l][0] - px, 2) + pow(p[l][1] - py, 2);
	tmp = sqrt(tmp);
	r = max(r, tmp);
}
min = min(min, r);
			}
		}
	}
	prtln(min);
}



	}
}

</source>
</class>

<class classid="235" nclones="2" nlines="20" similarity="100">
<source file="../hum_codes_raw/s493465821.java" startline="1" endline="27" pcid="16579">
import java.util.Scanner;

public class Main {

	public static void main(String args[]) {

		Scanner sc = new Scanner(System.in);

		int N = sc.nextInt();
		int K = sc.nextInt();

		double p = 0;

		for(int i=1;i<=N;i++) {
			double pi = 1;
			int temp = i;
			while(temp < K) {
				pi /= 2;
				temp *= 2;
			}
			p += pi;
		}
		p /= N;
		System.out.println(p);
    }
}

</source>
<source file="../hum_codes_raw/s792996112.java" startline="1" endline="27" pcid="26638">
import java.util.Scanner;

public class Main {

	public static void main(String args[]) {

		Scanner sc = new Scanner(System.in);

		int N = sc.nextInt();
		int K = sc.nextInt();

		double p = 0;

		for(int i=1;i<=N;i++) {
			double pi = 1;
			int temp = i;
			while(temp < K) {
				pi /= 2;
				temp *= 2;
			}
			p += pi;
		}
		p /= N;
		System.out.println(p);
    }
}

</source>
</class>

<class classid="236" nclones="2" nlines="40" similarity="100">
<source file="../hum_codes_raw/s494089730.java" startline="1" endline="42" pcid="16597">
import java.io.PrintWriter;
import java.util.Scanner;

public class Main {
    private static int[] path;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int a = sc.nextInt();
        int b = sc.nextInt();
        path = new int[1 << n];
        if (Integer.bitCount(a ^ b) % 2 != 0) {
            System.out.println("YES");
        } else {
            System.out.println("NO");
            return;
        }
        path(a, b, 0, (1 << n) - 1);
        PrintWriter pw = new PrintWriter(System.out);
        for (int i = 0; i < path.length; i++) {
            pw.print(path[i] + " ");
        }
        pw.println();
        pw.flush();
    }

    private static void path(int a, int b, int st, int mask) {
        int diffBit = Integer.highestOneBit(mask & (a ^ b));
        mask = mask ^ diffBit;
        int size = Integer.bitCount(mask);
        if (size == 0) {
            path[st] = a;
            path[st + 1] = b;
        } else {
            int otherBit = Integer.highestOneBit(mask);
            path(a, a ^ otherBit, st, mask);
            path(a ^ diffBit ^ otherBit, b, st + (1 << size), mask);
        }
    }
}

</source>
<source file="../hum_codes_raw/s687838170.java" startline="1" endline="42" pcid="23105">
import java.io.PrintWriter;
import java.util.Scanner;
 
public class Main {
    private static int[] path;
 
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int a = sc.nextInt();
        int b = sc.nextInt();
        path = new int[1 << n];
        if (Integer.bitCount(a ^ b) % 2 != 0) {
            System.out.println("YES");
        } else {
            System.out.println("NO");
            return;
        }
        path(a, b, 0, (1 << n) - 1);
        PrintWriter pw = new PrintWriter(System.out);
        for (int i = 0; i < path.length; i++) {
            pw.print(path[i] + " ");
        }
        pw.println();
        pw.flush();
    }
 
    private static void path(int a, int b, int st, int mask) {
        int diffBit = Integer.highestOneBit(mask & (a ^ b));
        mask = mask ^ diffBit;
        int size = Integer.bitCount(mask);
        if (size == 0) {
            path[st] = a;
            path[st + 1] = b;
        } else {
            int otherBit = Integer.highestOneBit(mask);
            path(a, a ^ otherBit, st, mask);
            path(a ^ diffBit ^ otherBit, b, st + (1 << size), mask);
        }
    }
}

</source>
</class>

<class classid="237" nclones="2" nlines="56" similarity="100">
<source file="../hum_codes_raw/s502182318.java" startline="1" endline="99" pcid="16824">
import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;

public class Main{
    public static void main(String[] args){

	// ?????????????????????????
	Scanner sc = new Scanner(System.in);
	int ichiroNum = 0, jiroNum = 0; //?????

	while(sc.hasNext()){

	    ichiroNum = sc.nextInt(); // ?????????????
	    if(ichiroNum==0) break;

	    // **** ????????****
	    
	    int[] ichiroHeight = new int[ichiroNum];
	    int[] ichiroWeight = new int[ichiroNum];

	    for(int i = 0;i<ichiroNum;i++){
		ichiroHeight[i] = sc.nextInt();
		ichiroWeight[i] = sc.nextInt();
	    }
	    // **********************************

	    jiroNum = sc.nextInt();

	    // ***** ????***************
	    int[] jiroHeight = new int[jiroNum];
	    int[] jiroWeight = new int[jiroNum];

	    for(int i = 0;i<jiroNum;i++){
		jiroHeight[i] = sc.nextInt();
		jiroWeight[i] = sc.nextInt();
	    }
	    // **********************************
	    // ***** ????*****

	    // ?????????????????????????????????
	    // ?????????????????????????????
	    // ???????????????????????????????

	    int[] count = new int[ichiroNum+jiroNum];

	    int[][] dolls = new int[ichiroNum+jiroNum][2];
	    
	    // ???????
	    for(int i = 0;i<ichiroNum;i++){
	    	dolls[i][0] = ichiroHeight[i];
	    	dolls[i][1] = ichiroWeight[i];
	    }
	    for(int i = ichiroNum;i<ichiroNum+jiroNum;i++){
	    	dolls[i][0] = jiroHeight[i-ichiroNum];
	    	dolls[i][1] = jiroWeight[i-ichiroNum];
	    }
	    
	    Arrays.sort(dolls, new Comparator<int[]>() {
	     public int compare(int[] o1, int[] o2) {
	      if(o1[0] != o2[0]) return o1[0] - o2[0];
	      return o1[1] - o2[1];
	     }
	    });
	    
	    // ??????????

	    // ?????????
	    // ?????????????????????????????????????
	    // ??????????????????????????????????????+1????????????????
	    
	    for(int i = 0;i<count.length;i++){
	    	for(int j = 0;j<i;j++){
	    		if(dolls[j][0] < dolls[i][0] && dolls[j][1] < dolls[i][1])
	    			 if(count[i] < count[j] + 1) count[i] = count[j] + 1;
	    	}
	    }

	    Arrays.sort(count);
	    
	    int countMax = count[count.length-1];
	    // countMax???????????????????
	    // ??????????????????+1???????
	    // ?????????????????
	    System.out.println(countMax+1);

	    // ?
	    for(int i = 0;i<count.length;i++){
	    	count[i] = 0;
	    }
	    ichiroNum = 0;
	    jiroNum = 0;
	    
	}
	
    }

}

</source>
<source file="../hum_codes_raw/s628337290.java" startline="1" endline="99" pcid="21081">
import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;

public class Main{
    public static void main(String[] args){

	// ?????????????????????????
	Scanner sc = new Scanner(System.in);
	int ichiroNum = 0, jiroNum = 0; //?????

	while(sc.hasNext()){

	    ichiroNum = sc.nextInt(); // ?????????????
	    if(ichiroNum==0) break;

	    // **** ????????****
	    
	    int[] ichiroHeight = new int[ichiroNum];
	    int[] ichiroWeight = new int[ichiroNum];

	    for(int i = 0;i<ichiroNum;i++){
		ichiroHeight[i] = sc.nextInt();
		ichiroWeight[i] = sc.nextInt();
	    }
	    // **********************************

	    jiroNum = sc.nextInt();

	    // ***** ????***************
	    int[] jiroHeight = new int[jiroNum];
	    int[] jiroWeight = new int[jiroNum];

	    for(int i = 0;i<jiroNum;i++){
		jiroHeight[i] = sc.nextInt();
		jiroWeight[i] = sc.nextInt();
	    }
	    // **********************************
	    // ***** ????*****

	    // ?????????????????????????????????
	    // ?????????????????????????????
	    // ???????????????????????????????

	    int[] count = new int[ichiroNum+jiroNum];

	    int[][] dolls = new int[ichiroNum+jiroNum][2];
	    
	    // ???????
	    for(int i = 0;i<ichiroNum;i++){
	    	dolls[i][0] = ichiroHeight[i];
	    	dolls[i][1] = ichiroWeight[i];
	    }
	    for(int i = ichiroNum;i<ichiroNum+jiroNum;i++){
	    	dolls[i][0] = jiroHeight[i-ichiroNum];
	    	dolls[i][1] = jiroWeight[i-ichiroNum];
	    }
	    
	    Arrays.sort(dolls, new Comparator<int[]>() {
	     public int compare(int[] o1, int[] o2) {
	      if(o1[0] != o2[0]) return o1[0] - o2[0];
	      return o1[1] - o2[1];
	     }
	    });
	    
	    // ??????????

	    // ?????????
	    // ?????????????????????????????????????
	    // ??????????????????????????????????????+1????????????????
	    
	    for(int i = 0;i<count.length;i++){
	    	for(int j = 0;j<i;j++){
	    		if(dolls[j][0] < dolls[i][0] && dolls[j][1] < dolls[i][1])
	    			 if(count[i] < count[j] + 1) count[i] = count[j] + 1;
	    	}
	    }

	    Arrays.sort(count);
	    
	    int countMax = count[count.length-1];
	    // countMax???????????????????
	    // ??????????????????+1???????
	    // ?????????????????
	    System.out.println(countMax+1);

	    // ?
	    for(int i = 0;i<count.length;i++){
	    	count[i] = 0;
	    }
	    ichiroNum = 0;
	    jiroNum = 0;
	    
	}
	
    }

}

</source>
</class>

<class classid="238" nclones="2" nlines="19" similarity="100">
<source file="../hum_codes_raw/s502913181.java" startline="1" endline="26" pcid="16846">
import java.util.Arrays;
import java.util.Scanner;
public class Main
{
	public static void main(String arg[])
	{
		Scanner in = new Scanner(System.in);
		while(in.hasNext())
		{
			int n= in.nextInt();
			int a[] = new int[n];
			int ans = 0;
			for(int i=0; i<n; i++)
				a[i]=in.nextInt();
			Arrays.sort(a);
			int sum[]= new int [n];
			sum[0]=a[0];
			for(int i=1; i<n; i++)
				sum[i]=a[i]+sum[i-1];
			for(int i=0; i<n ;i++)
			ans+=sum[i];
			System.out.println(ans);
		}
	}
}

</source>
<source file="../hum_codes_raw/s759993942.java" startline="1" endline="29" pcid="25541">
import java.util.Arrays;
import java.util.Scanner;

public class Main
{
	public static void main(String arg[])
	{
		Scanner in = new Scanner(System.in);
		while(in.hasNext())
		{
			int n= in.nextInt();
			int a[] = new int[n];
			int ans = 0;
			for(int i=0; i<n; i++)
				a[i]=in.nextInt();
			Arrays.sort(a);
			int sum[]= new int [n];
			sum[0]=a[0];
			for(int i=1; i<n; i++)
				sum[i]=a[i]+sum[i-1];
			for(int i=0; i<n ;i++)
			ans+=sum[i];
			System.out.println(ans);
		}

	}

}

</source>
</class>

<class classid="239" nclones="2" nlines="26" similarity="100">
<source file="../hum_codes_raw/s510125076.java" startline="1" endline="31" pcid="17099">
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        String[] strArray = sc.next().split("");
        String[] akibaArray = "AKIHABARA".split("");
        boolean flag = true;
        int count = 0;
        int i = 0;

        for (; i < akibaArray.length; i++) {
            if (count >= strArray.length) {
                break;
            }
            if (strArray[count].equals(akibaArray[i])) {
                count++;
            } else if (!akibaArray[i].equals("A")) {
                break;
            }
        }

        if (i <= akibaArray.length - 2 || count < strArray.length) {
            flag = false;
        }

        System.out.println(flag ? "YES" : "NO");
    }
}

</source>
<source file="../hum_codes_raw/s901192790.java" startline="1" endline="31" pcid="30328">
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        String[] strArray = sc.next().split("");
        String[] akibaArray = "AKIHABARA".split("");
        boolean flag = true;
        int count = 0;
        int i = 0;

        for (; i < akibaArray.length; i++) {
            if (count >= strArray.length) {
                break;
            }
            if (strArray[count].equals(akibaArray[i])) {
                count++;
            } else if (!akibaArray[i].equals("A")) {
                break;
            }
        }

        if (i <= akibaArray.length - 2 || count < strArray.length) {
            flag = false;
        }

        System.out.println(flag ? "YES" : "NO");
    }
}

</source>
</class>

<class classid="240" nclones="2" nlines="26" similarity="100">
<source file="../hum_codes_raw/s513737318.java" startline="1" endline="28" pcid="17236">
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Main main = new Main();
        main.solve();
    }
    public void solve() {
        Scanner scan = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int N = scan.nextInt();
        int Z = scan.nextInt();
        int W = scan.nextInt();
        int[] a = new int[N];
        for (int i = 0; i < N; i++) {
            a[i] = scan.nextInt();
        }
        if (N == 1) {
            System.out.println(Math.abs(a[N-1]-W));
            return;
        }
        long answer = Math.max(Math.abs(a[N-1]-W),Math.abs(a[N-1]-a[N-2]));
        System.out.println(answer);
    }
}

</source>
<source file="../hum_codes_raw/s738552783.java" startline="1" endline="28" pcid="24827">
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Main main = new Main();
        main.solve();
    }
    public void solve() {
        Scanner scan = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int N = scan.nextInt();
        int Z = scan.nextInt();
        int W = scan.nextInt();
        int[] a = new int[N];
        for (int i = 0; i < N; i++) {
            a[i] = scan.nextInt();
        }
        if (N == 1) {
            System.out.println(Math.abs(a[N-1]-W));
            return;
        }
        long answer = Math.max(Math.abs(a[N-1]-W),Math.abs(a[N-1]-a[N-2]));
        System.out.println(answer);
    }
}

</source>
</class>

<class classid="241" nclones="2" nlines="99" similarity="100">
<source file="../hum_codes_raw/s514785616.java" startline="1" endline="149" pcid="17272">
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.ListIterator;
import java.util.PriorityQueue;
import java.util.Scanner;
 
public class Main {
     
    public static class WeightUnionFind{
        int[] parent;
        int[] rank;
        int[] diff_weight;
         
        WeightUnionFind(int n){
            parent=new int[n];
            rank = new int[n];
            diff_weight = new int[n];
             
            for(int i=0;i<n;i++){
                parent[i]=i;
                rank[i] = 0;
                diff_weight[i] = 0;
            }
        }
         
        public int find(int x){
            if(parent[x]==x){
                return x;
            }
             
            return find(parent[x]);
        }
         
        public int find_diff(int x){
            if(parent[x] == x){
                return 0;
            }
             
            return find_diff(parent[x]) + diff_weight[x];
        }
         
        public Boolean same(int x,int y){
            return find(x)==find(y);
        }
         
        public int get_diff(int x, int y){
            if(!same(x, y)){
                return Integer.MIN_VALUE;
            }else{
                return find_diff(x) - find_diff(y);
            }
        }
        /*
        public void unite(int x,int y){
            x = find(x);
            y = find(y);
             
            if(x == y){
                return;
            }
             
            if(rank[x] < rank[y]){
                parent[x] = y;
            }else{
                parent[y] = x;
                if(rank[x] == rank[y]){
                    rank[x]++;
                }
            }
        }
        */
        public void set_diff(int x,int y, int d){
            final int find_x = find(x);
            final int find_y = find(y);
             
            if(find_x == find_y){
                return;
            }
             
            //System.out.println(x + " " + find_x + " " + y + " " + find_y + " " + diff_weight[y] + " " + diff_weight[x]);
            d -= find_diff(x) - find_diff(y);
             
            if(rank[find_x] < rank[find_y]){
                //diff_weight[x] += d + find_diff(y);
                diff_weight[find_x] = d;
                 
                parent[find_x] = find_y;
            }else{
                diff_weight[find_y] = -d;
                 
                parent[find_y] = find_x;
                if(rank[find_x] == rank[find_y]){
                    rank[find_x]++;
                }
            }
        }
    }
 
     
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
         
        while (true) {
            final int N = sc.nextInt();
            final int M = sc.nextInt();
 
            if (N == 0 && M == 0) {
                break;
            }
             
            System.gc();
             
            WeightUnionFind wuf = new WeightUnionFind(N);
             
            for(int i = 0; i < M; i++){
                String op = sc.next();
                 
                if(op.equals("!")){
                    final int from = sc.nextInt() - 1;
                    final int to = sc.nextInt() - 1;
                    final int w = sc.nextInt();
                     
                    wuf.set_diff(from, to, w);
                    //System.out.println("DIFF " + from + " " + to + " " + w);
                }else{
                    final int from = sc.nextInt() - 1;
                    final int to = sc.nextInt() - 1;
                     
                    if(!wuf.same(from, to)){
                        System.out.println("UNKNOWN");
                    }else{
                        System.out.println(wuf.get_diff(from, to));
                    }
                }
                 
                //System.out.println("P : " + Arrays.toString(wuf.parent));
                //System.out.println("D : " + Arrays.toString(wuf.diff_weight));
            }
             
        }
 
        sc.close();
    }
 
}

</source>
<source file="../hum_codes_raw/s930221836.java" startline="1" endline="149" pcid="31299">
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.ListIterator;
import java.util.PriorityQueue;
import java.util.Scanner;
  
public class Main {
      
    public static class WeightUnionFind{
        int[] parent;
        int[] rank;
        int[] diff_weight;
          
        WeightUnionFind(int n){
            parent=new int[n];
            rank = new int[n];
            diff_weight = new int[n];
              
            for(int i=0;i<n;i++){
                parent[i]=i;
                rank[i] = 0;
                diff_weight[i] = 0;
            }
        }
          
        public int find(int x){
            if(parent[x]==x){
                return x;
            }
              
            return find(parent[x]);
        }
          
        public int find_diff(int x){
            if(parent[x] == x){
                return 0;
            }
              
            return find_diff(parent[x]) + diff_weight[x];
        }
          
        public Boolean same(int x,int y){
            return find(x)==find(y);
        }
          
        public int get_diff(int x, int y){
            if(!same(x, y)){
                return Integer.MIN_VALUE;
            }else{
                return find_diff(x) - find_diff(y);
            }
        }
        /*
        public void unite(int x,int y){
            x = find(x);
            y = find(y);
              
            if(x == y){
                return;
            }
              
            if(rank[x] < rank[y]){
                parent[x] = y;
            }else{
                parent[y] = x;
                if(rank[x] == rank[y]){
                    rank[x]++;
                }
            }
        }
        */
        public void set_diff(int x,int y, int d){
            final int find_x = find(x);
            final int find_y = find(y);
              
            if(find_x == find_y){
                return;
            }
              
            //System.out.println(x + " " + find_x + " " + y + " " + find_y + " " + diff_weight[y] + " " + diff_weight[x]);
            d -= find_diff(x) - find_diff(y);
              
            if(rank[find_x] < rank[find_y]){
                //diff_weight[x] += d + find_diff(y);
                diff_weight[find_x] = d;
                  
                parent[find_x] = find_y;
            }else{
                diff_weight[find_y] = -d;
                  
                parent[find_y] = find_x;
                if(rank[find_x] == rank[find_y]){
                    rank[find_x]++;
                }
            }
        }
    }
  
      
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
          
        while (true) {
            final int N = sc.nextInt();
            final int M = sc.nextInt();
  
            if (N == 0 && M == 0) {
                break;
            }
              
            System.gc();
              
            WeightUnionFind wuf = new WeightUnionFind(N);
              
            for(int i = 0; i < M; i++){
                String op = sc.next();
                  
                if(op.equals("!")){
                    final int from = sc.nextInt() - 1;
                    final int to = sc.nextInt() - 1;
                    final int w = sc.nextInt();
                      
                    wuf.set_diff(from, to, w);
                    //System.out.println("DIFF " + from + " " + to + " " + w);
                }else{
                    final int from = sc.nextInt() - 1;
                    final int to = sc.nextInt() - 1;
                      
                    if(!wuf.same(from, to)){
                        System.out.println("UNKNOWN");
                    }else{
                        System.out.println(wuf.get_diff(from, to));
                    }
                }
                  
                //System.out.println("P : " + Arrays.toString(wuf.parent));
                //System.out.println("D : " + Arrays.toString(wuf.diff_weight));
            }
              
        }
  
        sc.close();
    }
  
}

</source>
</class>

<class classid="242" nclones="2" nlines="43" similarity="100">
<source file="../hum_codes_raw/s515777634.java" startline="1" endline="59" pcid="17315">
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.lang.*;
import java.math.*;
import java.io.*;

import static java.lang.Math.*;
import static java.util.Arrays.*;

public class Main{

	Scanner sc=new Scanner(System.in);

	int INF=1<<28;
	double EPS=1e-9;

	void run(){
		for(int n=sc.nextInt(); n>0; n--){
			String s=sc.next();
			// debug(s);
			Matcher m=Pattern.compile("^>'(=+)#(=+)~$").matcher(s);
			if(m.find()){
				// debug(m.group(1), m.group(2));
				if(m.group(1).length()==m.group(2).length()){
					// debug("A");
					println("A");
					continue;
				}
			}
			m=Pattern.compile("^>\\^(Q=)+~~$").matcher(s);
			if(m.find()){
				// debug("B");
				println("B");
				continue;
			}
			// debug("NA");
			println("NA");
		}
	}

	void debug(Object... os){
		System.err.println(Arrays.deepToString(os));
	}

	void print(String s){
		System.out.print(s);
	}

	void println(String s){
		System.out.println(s);
	}

	public static void main(String[] args){
		// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));
		new Main().run();
	}
}

</source>
<source file="../hum_codes_raw/s917564111.java" startline="1" endline="54" pcid="30857">
import java.util.*;  
import java.util.regex.Matcher;  
import java.util.regex.Pattern;  
import java.lang.*;  
import java.math.*;  
import java.io.*;  
  
import static java.lang.Math.*;  
import static java.util.Arrays.*;  
  
public class Main{  
  
 Scanner sc=new Scanner(System.in);  
  
 int INF=1<<28;  
 double EPS=1e-9;  
  
 void run(){  
  for(int n=sc.nextInt(); n>0; n--){  
   String s=sc.next();  
   Matcher m=Pattern.compile("^>'(=+)#(=+)~$").matcher(s);  
   if(m.find()){  
    if(m.group(1).length()==m.group(2).length()){  
     println("A");  
     continue;  
    }  
   }  
   m=Pattern.compile("^>\\^(Q=)+~~$").matcher(s);  
   if(m.find()){  
    println("B");  
    continue;  
   }  
   println("NA");  
  }  
 }  
  
 void debug(Object... os){  
  System.err.println(Arrays.deepToString(os));  
 }  
  
 void print(String s){  
  System.out.print(s);  
 }  
  
 void println(String s){  
  System.out.println(s);  
 }  
  
 public static void main(String[] args){  
  // System.setOut(new PrintStream(new BufferedOutputStream(System.out)));  
  new Main().run();  
 }  
}  

</source>
</class>

<class classid="243" nclones="2" nlines="229" similarity="100">
<source file="../hum_codes_raw/s516269670.java" startline="1" endline="281" pcid="17326">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            EMsSolution solver = new EMsSolution();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class EMsSolution {
        Point[] pts;

        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            pts = new Point[n];

            for (int i = 0; i < n; i++) {
                pts[i] = new Point();
                pts[i].x = in.readInt();
                pts[i].y = in.readInt();
                pts[i].w = in.readInt();
            }
            Arrays.sort(pts, (a, b) -> Integer.compare(a.y, b.y));


            long[][] dp = new long[n][n + 1];
            long inf = (long) 1e18;


            long[] ans = new long[n + 1];
            Arrays.fill(ans, inf);
            for (int i = 0; i < 1 << n; i++) {
                for (int j = 0; j < n; j++) {
                    pts[j].minNow = Math.min(Math.abs(pts[j].x), Math.abs(pts[j].y));
                }


                for (int j = 0; j < n; j++) {
                    if (Bits.get(i, j) == 0) {
                        continue;
                    }
                    for (int k = 0; k < n; k++) {
                        pts[k].minNow = Math.min(pts[k].minNow, Math.abs(pts[k].x - pts[j].x));
                    }
                }
                long sum = 0;
                for (Point point : pts) {
                    sum += point.minNow * point.w;
                }
                int bitCount = Integer.bitCount(i);
                ans[bitCount] = Math.min(ans[bitCount], sum);

                //dp
                SequenceUtils.deepFill(dp, inf);
                for (int j = 0; j < n; j++) {
                    dp[j][1] = 0;
                    for (int k = 0; k <= j; k++) {
                        long cost = Math.min(pts[k].minNow, pts[j].y - pts[k].y);
                        dp[j][1] += cost * pts[k].w;
                    }

                    for (int t = 0; t < j; t++) {
                        //t + 1 to j
                        long cost = 0;
                        for (int k = t + 1; k <= j; k++) {
                            cost += Math.min(pts[k].minNow, Math.min(pts[j].y - pts[k].y, pts[k].y - pts[t].y)) * pts[k].w;
                        }
                        for (int k = 2; k <= n; k++) {
                            dp[j][k] = Math.min(dp[j][k], dp[t][k - 1] + cost);
                        }
                    }

                    //if it's the last one
                    long cost = 0;
                    for (int k = j + 1; k < n; k++) {
                        cost += Math.min(pts[k].minNow, pts[k].y - pts[j].y) * pts[k].w;
                    }
                    for (int k = 1; k + bitCount <= n; k++) {
                        ans[k + bitCount] = Math.min(ans[k + bitCount], cost + dp[j][k]);
                    }
                }
            }

            for (int i = 0; i <= n; i++) {
                out.println(ans[i]);
            }
        }

    }

    static class Bits {
        private Bits() {
        }

        public static int get(int x, int i) {
            return (x >>> i) & 1;
        }

    }

    static class Point {
        int x;
        int y;
        int minNow;
        long w;

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(long c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(long c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class SequenceUtils {
        public static void deepFill(Object array, long val) {
            if (!array.getClass().isArray()) {
                throw new IllegalArgumentException();
            }
            if (array instanceof long[]) {
                long[] longArray = (long[]) array;
                Arrays.fill(longArray, val);
            } else {
                Object[] objArray = (Object[]) array;
                for (Object obj : objArray) {
                    deepFill(obj, val);
                }
            }
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }
}


</source>
<source file="../hum_codes_raw/s578019056.java" startline="1" endline="281" pcid="19411">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            EMsSolution solver = new EMsSolution();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class EMsSolution {
        Point[] pts;

        public void solve(int testNumber, FastInput in, FastOutput out) {
            int n = in.readInt();
            pts = new Point[n];

            for (int i = 0; i < n; i++) {
                pts[i] = new Point();
                pts[i].x = in.readInt();
                pts[i].y = in.readInt();
                pts[i].w = in.readInt();
            }
            Arrays.sort(pts, (a, b) -> Integer.compare(a.y, b.y));


            long[][] dp = new long[n][n + 1];
            long inf = (long) 1e18;


            long[] ans = new long[n + 1];
            Arrays.fill(ans, inf);
            for (int i = 0; i < 1 << n; i++) {
                for (int j = 0; j < n; j++) {
                    pts[j].minNow = Math.min(Math.abs(pts[j].x), Math.abs(pts[j].y));
                }


                for (int j = 0; j < n; j++) {
                    if (Bits.get(i, j) == 0) {
                        continue;
                    }
                    for (int k = 0; k < n; k++) {
                        pts[k].minNow = Math.min(pts[k].minNow, Math.abs(pts[k].x - pts[j].x));
                    }
                }
                long sum = 0;
                for (Point point : pts) {
                    sum += point.minNow * point.w;
                }
                int bitCount = Integer.bitCount(i);
                ans[bitCount] = Math.min(ans[bitCount], sum);

                //dp
                SequenceUtils.deepFill(dp, inf);
                for (int j = 0; j < n; j++) {
                    dp[j][1] = 0;
                    for (int k = 0; k <= j; k++) {
                        long cost = Math.min(pts[k].minNow, pts[j].y - pts[k].y);
                        dp[j][1] += cost * pts[k].w;
                    }

                    for (int t = 0; t < j; t++) {
                        //t + 1 to j
                        long cost = 0;
                        for (int k = t + 1; k <= j; k++) {
                            cost += Math.min(pts[k].minNow, Math.min(pts[j].y - pts[k].y, pts[k].y - pts[t].y)) * pts[k].w;
                        }
                        for (int k = 2; k <= n; k++) {
                            dp[j][k] = Math.min(dp[j][k], dp[t][k - 1] + cost);
                        }
                    }

                    //if it's the last one
                    long cost = 0;
                    for (int k = j + 1; k < n; k++) {
                        cost += Math.min(pts[k].minNow, pts[k].y - pts[j].y) * pts[k].w;
                    }
                    for (int k = 1; k + bitCount <= n; k++) {
                        ans[k + bitCount] = Math.min(ans[k + bitCount], cost + dp[j][k]);
                    }
                }
            }

            for (int i = 0; i <= n; i++) {
                out.println(ans[i]);
            }
        }

    }

    static class Bits {
        private Bits() {
        }

        public static int get(int x, int i) {
            return (x >>> i) & 1;
        }

    }

    static class Point {
        int x;
        int y;
        int minNow;
        long w;

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(long c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(long c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class SequenceUtils {
        public static void deepFill(Object array, long val) {
            if (!array.getClass().isArray()) {
                throw new IllegalArgumentException();
            }
            if (array instanceof long[]) {
                long[] longArray = (long[]) array;
                Arrays.fill(longArray, val);
            } else {
                Object[] objArray = (Object[]) array;
                for (Object obj : objArray) {
                    deepFill(obj, val);
                }
            }
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

    }
}


</source>
</class>

<class classid="244" nclones="2" nlines="63" similarity="100">
<source file="../hum_codes_raw/s518337227.java" startline="1" endline="65" pcid="17415">
import java.io.*;
import  java.util.*;

import static java.lang.System.in;

class Main{
    static long[] X,sum;
    static Edge[] edges;
    static int[] id,unconnected;
    public static void main(String[] args)throws IOException{
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(), m = sc.nextInt();
        sum = new long[n+1];
        edges = new Edge[m];
        id = new int[n+1];
        unconnected = new int[n+1];

        for(int i=1;i<=n;i++) {
            sum[i] = sc.nextLong();
            id[i] = i;
        }
        for(int i=0;i<m;i++){
            int a = sc.nextInt(), b = sc.nextInt();
            long y = sc.nextLong();
            edges[i] = new Edge(a,b,y);
        }
        Arrays.sort(edges);
        for(int i=0;i<m;i++){
            Edge e = edges[i];
            union(e.left,e.right,e.weight);
        }
        int ans = unconnected[find(1)];
        System.out.println(ans);
    }
    static int find(int p){
        while(p!=id[p]){
            id[p] = id[id[p]];
            p = id[p];
        }
        return p;
    }
    static void union(int p, int q, long Y){
        int i = find(p), j = find(q);
        if(i==j){
            if(Y>sum[i]) unconnected[i]++;
        } else{
            if(Y<=sum[i]+sum[j]) unconnected[i]=0;
            else unconnected[i]+=1+unconnected[j];
            sum[i] += sum[j];
            id[j] = i;
        }
    }
    static class Edge implements Comparable<Edge>{
        int left, right;
        long weight;
        public Edge(int l, int r, long w){
            this.left = l; this.right = r;
            this.weight = w;
        }
        public int compareTo(Edge e){
            return Long.compare(this.weight,e.weight);
        }
    }
}

</source>
<source file="../hum_codes_raw/s552692819.java" startline="1" endline="65" pcid="18630">
import java.io.*;
import  java.util.*;
 
import static java.lang.System.in;
 
class Main{
    static long[] X,sum;
    static Edge[] edges;
    static int[] id,unconnected;
    public static void main(String[] args)throws IOException{
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(), m = sc.nextInt();
        sum = new long[n+1];
        edges = new Edge[m];
        id = new int[n+1];
        unconnected = new int[n+1];
 
        for(int i=1;i<=n;i++) {
            sum[i] = sc.nextLong();
            id[i] = i;
        }
        for(int i=0;i<m;i++){
            int a = sc.nextInt(), b = sc.nextInt();
            long y = sc.nextLong();
            edges[i] = new Edge(a,b,y);
        }
        Arrays.sort(edges);
        for(int i=0;i<m;i++){
            Edge e = edges[i];
            union(e.left,e.right,e.weight);
        }
        int ans = unconnected[find(1)];
        System.out.println(ans);
    }
    static int find(int p){
        while(p!=id[p]){
            id[p] = id[id[p]];
            p = id[p];
        }
        return p;
    }
    static void union(int p, int q, long Y){
        int i = find(p), j = find(q);
        if(i==j){
            if(Y>sum[i]) unconnected[i]++;
        } else{
            if(Y<=sum[i]+sum[j]) unconnected[i]=0;
            else unconnected[i]+=1+unconnected[j];
            sum[i] += sum[j];
            id[j] = i;
        }
    }
    static class Edge implements Comparable<Edge>{
        int left, right;
        long weight;
        public Edge(int l, int r, long w){
            this.left = l; this.right = r;
            this.weight = w;
        }
        public int compareTo(Edge e){
            return Long.compare(this.weight,e.weight);
        }
    }
}

</source>
</class>

<class classid="245" nclones="3" nlines="44" similarity="100">
<source file="../hum_codes_raw/s531092135.java" startline="1" endline="48" pcid="17876">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class Main{
	public static void main(String[] args)throws IOException{
		InputStreamReader isr = new InputStreamReader(System.in);
		BufferedReader reader = new BufferedReader(isr);
		String string;
		int n, m, a = 0, b = 0, c = 0;
		
		while(!(string = reader.readLine()).equals("0")){
			n = Integer.valueOf(string);
			m = Integer.valueOf(reader.readLine());
			
			int map[][] = new int[n][n];
			boolean visit[] = new boolean[n];
			for(int i = 0;i < n; i++) Arrays.fill(map[i], 1 << 29);
			for(int i = 0; i < m; i++){
				string = reader.readLine();
				a = Integer.valueOf(string.split(",")[0]);
				b = Integer.valueOf(string.split(",")[1]);
				c = (Integer.valueOf(string.split(",")[2]) - 100) / 100;
				map[a][b] = map[b][a] = c;
			}
			c = 0;
			visit[0] = true;
			for(int x = 0; x < n - 1; x++){
				m = 1 << 29;
				for(int i = 0; i < n; i++){
					if(map[0][i] < m && !visit[i]){
						m = map[0][i];
						b = i;
					}
				}
				visit[b] = true;
				c += map[0][b];
				for(int i = 0; i < n; i++){
					map[0][i] = Math.min(map[0][i], map[b][i]);
				};
			}
			System.out.println(c);
		}
		reader.close();
	}
}

</source>
<source file="../hum_codes_raw/s984361698.java" startline="1" endline="48" pcid="33104">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class Main{
	public static void main(String[] args)throws IOException{
		InputStreamReader isr = new InputStreamReader(System.in);
		BufferedReader reader = new BufferedReader(isr);
		String string;
		int n, m, a = 0, b = 0, c = 0;
		
		while(!(string = reader.readLine()).equals("0")){
			n = Integer.valueOf(string);
			m = Integer.valueOf(reader.readLine());
			
			int map[][] = new int[n][n];
			boolean visit[] = new boolean[n];
			for(int i = 0;i < n; i++) Arrays.fill(map[i], 1 << 29);
			for(int i = 0; i < m; i++){
				string = reader.readLine();
				a = Integer.valueOf(string.split(",")[0]);
				b = Integer.valueOf(string.split(",")[1]);
				c = (Integer.valueOf(string.split(",")[2]) - 100) / 100;
				map[a][b] = map[b][a] = c;
			}
			c = 0;
			visit[0] = true;
			for(int x = 0; x < n - 1; x++){
				m = 1 << 29;
				for(int i = 0; i < n; i++){
					if(map[0][i] < m && !visit[i]){
						m = map[0][i];
						b = i;
					}
				}
				visit[b] = true;
				c += map[0][b];
				for(int i = 0; i < n; i++){
					map[0][i] = Math.min(map[0][i], map[b][i]);
				}
			}
			System.out.println(c);
		}
		reader.close();
	}
}

</source>
<source file="../hum_codes_raw/s791655230.java" startline="1" endline="48" pcid="26597">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class Main{
	public static void main(String[] args)throws IOException{
		InputStreamReader isr = new InputStreamReader(System.in);
		BufferedReader reader = new BufferedReader(isr);
		String string;
		int n, m, a = 0, b = 0, c = 0;
		
		while(!(string = reader.readLine()).equals("0")){
			n = Integer.valueOf(string);
			m = Integer.valueOf(reader.readLine());
			
			int map[][] = new int[n][n];
			boolean visit[] = new boolean[n];
			for(int i = 0;i < n; i++) Arrays.fill(map[i], 1 << 29);
			for(int i = 0; i < m; i++){
				string = reader.readLine();
				a = Integer.valueOf(string.split(",")[0]);
				b = Integer.valueOf(string.split(",")[1]);
				c = (Integer.valueOf(string.split(",")[2]) - 100) / 100;
				map[a][b] = map[b][a] = c;
			}
			c = 0;
			visit[0] = true;
			for(int x = 0; x < n - 1; x++){
				m = 1 << 29;
				for(int i = 0; i < n; i++){
					if(map[0][i] < m && !visit[i]){
						m = map[0][i];
						b = i;
					}
				}
				visit[b] = true;
				c += map[0][b];
				for(int i = 0; i < n; i++){
					map[0][i] = Math.min(map[0][i], map[b][i]);
				};
			}
			System.out.println(c);
		}
		reader.close();
	}
}

</source>
</class>

<class classid="246" nclones="2" nlines="98" similarity="100">
<source file="../hum_codes_raw/s532090911.java" startline="1" endline="122" pcid="17910">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class Main {

	public static void main(String[] args) throws NumberFormatException, IOException {
		// TODO ?????????????????????????????????????????????
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());

        int[][] board = new int[8][8];
        
        for(int i = 0; i < 8 ; i++){
        	Arrays.fill(board[i], 0);
        }
        
        for(int i = 0; i < n; i++){
        	String[] tmpArray = br.readLine().split(" ");
        	int r = Integer.parseInt(tmpArray[0]);
        	int c = Integer.parseInt(tmpArray[1]);
        	board[r][c] = 1;
        }
        
        int nextC = getAvailableColumn(board, 8);
        if(nextC >= 0){
        	for(int i = 0; i < 8; i++){
        		boolean result = putQueen(board, 8, i, nextC);
        		if(result == true){
        			break;
        		}
        	}
        }
        //print
        for(int i = 0; i < 8; i++){
        	for(int j = 0; j < 8 ; j++){
        		if(board[i][j] == 1){
        			System.out.print("Q");
        		}
        		else{
        			System.out.print(".");
        		}
        	}
        	System.out.println();
        }
	}
	
	static int getAvailableColumn(int[][] board, int n){
		int j;
		for(j = 0; j < n ; j++){
			int queen = 0;
			for(int i = 0; i < n; i++){
				if(board[i][j] == 1){
					queen++;
					break;
				}
			}
			if(queen == 0){
				break;
			}
		}
		
		if(j >= n){
			return -1;
		}
		
		else {
			return j;
		}
	}
	
	static boolean putQueen(int[][] board, int n, int r, int c){
		//System.out.println("n "+n + " r "+r+" c "+c);
		//????????????????????????????????????????????????????????????????????????????
		for(int i = 0; i < n ; i++){
			if(board[i][c] == 1 && i != r){
				//System.out.println("error 1");
				return false;
			}
			if(board[r][i] == 1 && i != c){
				//System.out.println("error 2");
				return false;
			}
		}
		for(int i = 0; i < n; i++){
			if(  r+i < n && c+i < n && board[r+i][c+i] ==1){
				//System.out.println("error 3");
				return false;
			}
			if( r+i < n && c-i >= 0 && board[r+i][c-i] ==1 ){
				//System.out.println("error 4");
				return false;
			}
			if(  r-i >= 0 && c+i < n && board[r-i][c+i] ==1){
				//System.out.println("error 5");
				return false;
			}
			if( r-i >= 0 && c-i >= 0 && board[r-i][c-i] ==1 ){
				//System.out.println("error 6");
				return false;
			}
		}
		//System.out.println("("+r+","+c+") is OK");
		board[r][c] = 1;
		
		int nextColumn = getAvailableColumn(board, 8);
		if(nextColumn < 0){
			return true;
		}
		for(int i = 0; i < n ; i++){
			boolean result = putQueen(board, n, i, nextColumn);
			if(result == true){
				return true;
			}
		}
		board[r][c] = 0;
		return false;
	}

}

</source>
<source file="../hum_codes_raw/s599466638.java" startline="1" endline="123" pcid="33713">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class Main {

	public static void main(String[] args) throws NumberFormatException, IOException {
		// TODO ?????????????????????????????????????????????
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());

        int[][] board = new int[8][8];
        
        for(int i = 0; i < 8 ; i++){
        	Arrays.fill(board[i], 0);
        }
        
        for(int i = 0; i < n; i++){
        	String[] tmpArray = br.readLine().split(" ");
        	int r = Integer.parseInt(tmpArray[0]);
        	int c = Integer.parseInt(tmpArray[1]);
        	board[r][c] = 1;
        }
        
        int nextC = getAvailableColumn(board, 8);
        if(nextC >= 0){
        	for(int i = 0; i < 8; i++){
        		boolean result = putQueen(board, 8, i, nextC);
        		if(result == true){
        			break;
        		}
        	}
        }
        //print
        for(int i = 0; i < 8; i++){
        	for(int j = 0; j < 8 ; j++){
        		if(board[i][j] == 1){
        			System.out.print("Q");
        		}
        		else{
        			System.out.print(".");
        		}
        	}
        	System.out.println();
        }
	}
	
	static int getAvailableColumn(int[][] board, int n){
		int j;
		for(j = 0; j < n ; j++){
			int queen = 0;
			for(int i = 0; i < n; i++){
				if(board[i][j] == 1){
					queen++;
					break;
				}
			}
			if(queen == 0){
				break;
			}
		}
		
		if(j >= n){
			return -1;
		}
		
		else {
			return j;
		}
	}
	
	static boolean putQueen(int[][] board, int n, int r, int c){
		//System.out.println("n "+n + " r "+r+" c "+c);
		//????????????????????????????????????????????????????????????????????????????
		for(int i = 0; i < n ; i++){
			if(board[i][c] == 1 && i != r){
				//System.out.println("error 1");
				return false;
			}
			if(board[r][i] == 1 && i != c){
				//System.out.println("error 2");
				return false;
			}
		}
		for(int i = 0; i < n; i++){
			if(  r+i < n && c+i < n && board[r+i][c+i] ==1){
				//System.out.println("error 3");
				return false;
			}
			if( r+i < n && c-i >= 0 && board[r+i][c-i] ==1 ){
				//System.out.println("error 4");
				return false;
			}
			if(  r-i >= 0 && c+i < n && board[r-i][c+i] ==1){
				//System.out.println("error 5");
				return false;
			}
			if( r-i >= 0 && c-i >= 0 && board[r-i][c-i] ==1 ){
				//System.out.println("error 6");
				return false;
			}
		}
		//System.out.println("("+r+","+c+") is OK");
		board[r][c] = 1;
		
		int nextColumn = getAvailableColumn(board, 8);
		if(nextColumn < 0){
			return true;
		}
		for(int i = 0; i < n ; i++){
			boolean result = putQueen(board, n, i, nextColumn);
			if(result == true){
				return true;
			}
		}
		board[r][c] = 0;
		return false;
	}

}


</source>
</class>

<class classid="247" nclones="2" nlines="16" similarity="100">
<source file="../hum_codes_raw/s532333220.java" startline="1" endline="19" pcid="17923">
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int b = sc.nextInt();
			int r = sc.nextInt();
			int g = sc.nextInt();
			int c = sc.nextInt();
			int s = sc.nextInt();
			int t = sc.nextInt();
			if((b|r|g|c|s|t)==0)break;
			System.out.println(100 + b*15 + r*15 + (b*5+r*3)*15 + g*7 + c*2 - (b*5+r*3)*2 - (t-b*5-r*3-s)*3);
		}
	}
}

</source>
<source file="../hum_codes_raw/s941253588.java" startline="1" endline="20" pcid="31647">
import java.util.Scanner;

//Big Hit !
public class Main{

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int b = sc.nextInt();
			int r = sc.nextInt();
			int g = sc.nextInt();
			int c = sc.nextInt();
			int s = sc.nextInt();
			int t = sc.nextInt();
			if((b|r|g|c|s|t)==0)break;
			System.out.println(100 + b*15 + r*15 + (b*5+r*3)*15 + g*7 + c*2 - (b*5+r*3)*2 - (t-b*5-r*3-s)*3);
		}
	}
}

</source>
</class>

<class classid="248" nclones="2" nlines="24" similarity="100">
<source file="../hum_codes_raw/s539285290.java" startline="1" endline="29" pcid="18157">
import java.util.Scanner;
import java.util.Arrays;
 
public class Main{
  public static void main(String[] args){
    Scanner sc = new Scanner(System.in);
 
    long K = sc.nextLong();
    long P = 0L;
    long Dif = 1L;
 
    for(int i = 1; i <= K; i++){
      P += Dif;
      if(helper(P + Dif) > helper(P + 2 * Dif))
      Dif *= 10L;
      System.out.println(P);
    }
  }
  public static double helper(long n){
    double S = (double) n;
    double sum = 0.0;
    while(n != 0){
      sum += (double) n%10;
      n = n/10;
    }
    return S/sum;
  }
}

</source>
<source file="../hum_codes_raw/s605728998.java" startline="1" endline="29" pcid="20344">
import java.util.Scanner;
import java.util.Arrays;

public class Main{
  public static void main(String[] args){
    Scanner sc = new Scanner(System.in);

    long K = sc.nextLong();
    long P = 0L;
    long Dif = 1L;

    for(int i = 1; i <= K; i++){
      P += Dif;
      if(helper(P + Dif) > helper(P + 2 * Dif))
      Dif *= 10L;
      System.out.println(P);
    }
  }
  public static double helper(long n){
    double S = (double) n;
    double sum = 0.0;
    while(n != 0){
      sum += (double) n%10;
      n = n/10;
    }
    return S/sum;
  }
}

</source>
</class>

<class classid="249" nclones="2" nlines="57" similarity="100">
<source file="../hum_codes_raw/s547285486.java" startline="1" endline="55" pcid="18424">
import java.util.Scanner;
public class Main {
	public static void main(String[] args) throws java.io.IOException {
		Scanner scan = new Scanner(System.in);
		int N = scan.nextInt();
		int[] h = new int[N];
		int[] m = new int[N];
		for(int i = 0 ; i<N ; i++){
			h[i] = scan.nextInt();
			m[i] = scan.nextInt();
		}
		int M = scan.nextInt();
		int[] k = new int[M];
		int[] g = new int[M];
		int[] Z = new int[N+M];
		for(int i = 0 ; i<N ; i++){
			Z[i] =  h[i]*60+m[i];
		}
		for(int i = 0; i<M ; i++){
			k[i] = scan.nextInt();
			g[i] = scan.nextInt();
			Z[N+i] = k[i]*60+g[i];
		}
		int r;
		for(int i = 0; i < N+M ; i++){
			for(int j = i+1; j <M+N; j++){
				if(Z[i] > Z[j]){
					r = Z[i];
					Z[i] = Z[j];
					Z[j] = r;
				}
			}
		}
		for(int i = 0; i<N+M; i++){
			if(i == N+M-1){
				String s = String.valueOf(Z[i]%60);
				if(s.length() ==1){
					System.out.println(Z[i]/60+":0"+Z[i]%60);
				}else{
					System.out.println(Z[i]/60+":"+Z[i]%60);
				}
			}else{
				if(Z[i+1] != Z[i]){
					String s = String.valueOf(Z[i]%60);
					if(s.length() ==1){
						System.out.print(Z[i]/60+":0"+Z[i]%60+" ");
					}else{
						System.out.print(Z[i]/60+":"+Z[i]%60+" ");
					}
				}
			}
		}
	}
}

</source>
<source file="../hum_codes_raw/s840836143.java" startline="1" endline="55" pcid="28235">
import java.util.Scanner;
public class Main {
	public static void main(String[] args) throws java.io.IOException {
		Scanner scan = new Scanner(System.in);
		int N = scan.nextInt();
		int[] h = new int[N];
		int[] m = new int[N];
		for(int i = 0 ; i<N ; i++){
			h[i] = scan.nextInt();
			m[i] = scan.nextInt();
		}
		int M = scan.nextInt();
		int[] k = new int[M];
		int[] g = new int[M];
		int[] Z = new int[N+M];
		for(int i = 0 ; i<N ; i++){
			Z[i] =  h[i]*60+m[i];
		}
		for(int i = 0; i<M ; i++){
			k[i] = scan.nextInt();
			g[i] = scan.nextInt();
			Z[N+i] = k[i]*60+g[i];
		}
		int r;
		for(int i = 0; i < N+M ; i++){
			for(int j = i+1; j <M+N; j++){
				if(Z[i] > Z[j]){
					r = Z[i];
					Z[i] = Z[j];
					Z[j] = r;
				}
			}
		}
		for(int i = 0; i<N+M; i++){
			if(i == N+M-1){
				String s = String.valueOf(Z[i]%60);
				if(s.length() ==1){
					System.out.println(Z[i]/60+":0"+Z[i]%60);
				}else{
					System.out.println(Z[i]/60+":"+Z[i]%60);
				}
			}else{
				if(Z[i+1] != Z[i]){
					String s = String.valueOf(Z[i]%60);
					if(s.length() ==1){
						System.out.print(Z[i]/60+":0"+Z[i]%60+" ");
					}else{
						System.out.print(Z[i]/60+":"+Z[i]%60+" ");
					}
				}
			}
		}
	}
}

</source>
</class>

<class classid="250" nclones="2" nlines="80" similarity="100">
<source file="../hum_codes_raw/s548480030.java" startline="1" endline="99" pcid="18468">
import java.util.*;  
import java.lang.*;  
import java.math.*;  
import java.io.*;  
  
import static java.lang.Math.*;  
import static java.util.Arrays.*;  
  
public class Main{  
  
 Scanner sc=new Scanner(System.in);  
  
 int INF=1<<28;  
 double EPS=1e-9;  
  
 HashMap<Integer, Integer> map;  
 int[] a;  
 int w=4, h=2;  
  
 void run(){  
  a=new int[w*h];  
  init();  
  for(; sc.hasNext();){  
   for(int i=0; i<w*h; i++){  
    a[i]=sc.nextInt();  
   }  
   println(""+map.get(id(a)));  
  }  
 }  
  
 void init(){  
  
  LinkedList<S> que=new LinkedList<S>();  
  map=new HashMap<Integer, Integer>();  
  
  que.offer(new S(0, 0, new int[]{0, 1, 2, 3, 4, 5, 6, 7}));  
  map.put(id(que.peek().a), 0);  
  int[] dx={0, 0, -1, 1};  
  int[] dy={-1, 1, 0, 0};  
  
  for(; !que.isEmpty();){  
   S s=que.poll();  
   int p=s.y*w+s.x;  
   for(int i=0; i<4; i++){  
    int x2=s.x+dx[i];  
    int y2=s.y+dy[i];  
    int p2=y2*w+x2;  
    if(x2>=0&&x2<w&&y2>=0&&y2<h){  
     int[] a2=s.a.clone();  
     int t=a2[p];  
     a2[p]=a2[p2];  
     a2[p2]=t;  
     S s2=new S(x2, y2, a2);  
     if(!map.containsKey(id(s2.a))){  
      que.offer(s2);  
      map.put(id(s2.a), map.get(id(s.a))+1);  
     }  
    }  
   }  
  }  
 }  
  
 int id(int[] a){  
  int res=0;  
  for(int e : a){  
   res=res*10+e;  
  }  
  return res;  
 }  
  
 class S{  
  int x, y;  
  int[] a;  
  
  S(int x, int y, int[] a){  
   this.x=x;  
   this.y=y;  
   this.a=a;  
  }  
 }  
  
 void debug(Object... os){  
  System.err.println(Arrays.deepToString(os));  
 }  
  
 void print(String s){  
  System.out.print(s);  
 }  
  
 void println(String s){  
  System.out.println(s);  
 }  
  
 public static void main(String[] args){  
  // System.setOut(new PrintStream(new BufferedOutputStream(System.out)));  
  new Main().run();  
 }  
}  

</source>
<source file="../hum_codes_raw/s925499938.java" startline="1" endline="152" pcid="31129">
import java.util.*;
import java.lang.*;
import java.math.*;
import java.io.*;

import static java.lang.Math.*;
import static java.util.Arrays.*;

public class Main{

	Scanner sc=new Scanner(System.in);

	int INF=1<<28;
	double EPS=1e-9;

	HashMap<Integer, Integer> map;
	int[] a;
	int w=4, h=2;

	void run(){
		a=new int[w*h];
		init();
		for(; sc.hasNext();){
			for(int i=0; i<w*h; i++){
				a[i]=sc.nextInt();
			}
			println(""+map.get(id(a)));
		}
	}

	void init(){

		LinkedList<S> que=new LinkedList<S>();
		map=new HashMap<Integer, Integer>();

		que.offer(new S(0, 0, new int[]{0, 1, 2, 3, 4, 5, 6, 7}));
		map.put(id(que.peek().a), 0);
		int[] dx={0, 0, -1, 1};
		int[] dy={-1, 1, 0, 0};

		for(; !que.isEmpty();){
			S s=que.poll();
			int p=s.y*w+s.x;
			for(int i=0; i<4; i++){
				int x2=s.x+dx[i];
				int y2=s.y+dy[i];
				int p2=y2*w+x2;
				if(x2>=0&&x2<w&&y2>=0&&y2<h){
					int[] a2=s.a.clone();
					int t=a2[p];
					a2[p]=a2[p2];
					a2[p2]=t;
					S s2=new S(x2, y2, a2);
					if(!map.containsKey(id(s2.a))){
						que.offer(s2);
						map.put(id(s2.a), map.get(id(s.a))+1);
					}
				}
			}
		}
		/*
		 * debug("here");
		 * debug(map.get(1234567));
		 * debug(map.get(10234567));
		 * debug(map.get(76543210));
		 */
	}

	int id(int[] a){
		int res=0;
		for(int e : a){
			res=res*10+e;
		}
		return res;
	}

	/*
	 * void solve(){
	 * int x=-1, y=-1;
	 * for(int i=0; i<w*h; i++){
	 * if(a[i]==0){
	 * x=i%w;
	 * y=i/w;
	 * }
	 * }
	 * 
	 * LinkedList<S> que=new LinkedList<S>();
	 * TreeSet<Integer> set=new TreeSet<Integer>();
	 * 
	 * que.offer(new S(x, y, a, 0));
	 * set.add(que.peek().id);
	 * int[] dx={0, 0, -1, 1};
	 * int[] dy={-1, 1, 0, 0};
	 * 
	 * for(; !que.isEmpty();){
	 * S s=que.poll();
	 * 
	 * if(s.id==1234567){
	 * println(""+s.cnt);
	 * return;
	 * }
	 * 
	 * int p=s.y*w+s.x;
	 * for(int i=0; i<4; i++){
	 * int x2=s.x+dx[i];
	 * int y2=s.y+dy[i];
	 * int p2=y2*w+x2;
	 * if(x2>=0&&x2<w&&y2>=0&&y2<h){
	 * int[] a2=s.a.clone();
	 * int t=a2[p];
	 * a2[p]=a2[p2];
	 * a2[p2]=t;
	 * S s2=new S(x2, y2, a2, s.cnt+1);
	 * if(!set.contains(s2.id)){
	 * que.offer(s2);
	 * set.add(s2.id);
	 * }
	 * }
	 * }
	 * }
	 * }
	 */

	class S{
		int x, y;
		int[] a;

		S(int x, int y, int[] a){
			this.x=x;
			this.y=y;
			this.a=a;
		}
	}

	void debug(Object... os){
		System.err.println(Arrays.deepToString(os));
	}

	void print(String s){
		System.out.print(s);
	}

	void println(String s){
		System.out.println(s);
	}

	public static void main(String[] args){
		// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));
		new Main().run();
	}
}

</source>
</class>

<class classid="251" nclones="2" nlines="99" similarity="100">
<source file="../hum_codes_raw/s548942549.java" startline="1" endline="109" pcid="18497">
import java.util.Arrays;
import java.util.HashMap;
import java.util.Scanner;

class Team implements Comparable<Team>{
	int id;
	int syo;
	int slove;
	int penalty;
	Team(int a,int b,int c,int d){
		id=a;
		syo=b;
		slove=c;
		penalty=d;
	}
	@Override
	public int compareTo(Team o) {
		if(o.slove < this.slove){
			return -1;
		}
		else if(o.slove > this.slove){
			return 1;
		}
		else{
			if(o.penalty > this.penalty){
				return -1;
			}
			else if(o.penalty < this.penalty){
				return 1;
			}
			else{
				if(o.id > this.id){
					return -1;
				}
				else if(o.id < this.id){
					return 1;
				}
			}
		}
		return 0;
	}
}

public class Main {
	public static void main(String[] args) {
		new Main().run();
	}
	void run(){
		Scanner sc=new Scanner(System.in);
		while(true){
			int n=sc.nextInt();
			if(n==0) break;
			Team t[]=new Team[n];
			for(int i=0; i<n; i++){
				t[i]=new Team(sc.nextInt(),sc.nextInt(),sc.nextInt(),sc.nextInt());
			}
			Arrays.sort(t);
			
//			for(int i=0; i<n; i++){
//				System.err.println(t[i].id);
//			}
			
			int senbatsu[]=new int[n];
			HashMap<Integer, Integer> h=new HashMap<Integer, Integer>();
			int count=0;
			for(int i=0; i<n; i++){
				if(count<10){
					if(!h.containsKey(t[i].syo)){
						h.put(t[i].syo, 1);
						senbatsu[count]=t[i].id;
						count++;
					}
					else if(h.get(t[i].syo) < 3){
						int temp=h.get(t[i].syo);
						h.put(t[i].syo, temp+1);
						senbatsu[count]=t[i].id;
						count++;
					}
				}
				else if(count<20){
					if(!h.containsKey(t[i].syo)){
						h.put(t[i].syo, 1);
						senbatsu[count]=t[i].id;
						count++;
					}
					else if(h.get(t[i].syo) < 2){
						int temp=h.get(t[i].syo);
						h.put(t[i].syo, temp+1);
						senbatsu[count]=t[i].id;
						count++;
					}
				}
				else if(count<26){
					if(!h.containsKey(t[i].syo)){
						h.put(t[i].syo, 1);
						senbatsu[count]=t[i].id;
						count++;
					}
				}
			}
			//Arrays.sort(senbatsu, 0, count);
			for(int i=0; i<count; i++){
				System.out.println(senbatsu[i]);
			}
		}
	}

}

</source>
<source file="../hum_codes_raw/s782975474.java" startline="1" endline="109" pcid="26288">
import java.util.Arrays;
import java.util.HashMap;
import java.util.Scanner;

class Team implements Comparable<Team>{
	int id;
	int syo;
	int slove;
	int penalty;
	Team(int a,int b,int c,int d){
		id=a;
		syo=b;
		slove=c;
		penalty=d;
	}
	@Override
	public int compareTo(Team o) {
		if(o.slove < this.slove){
			return -1;
		}
		else if(o.slove > this.slove){
			return 1;
		}
		else{
			if(o.penalty > this.penalty){
				return -1;
			}
			else if(o.penalty < this.penalty){
				return 1;
			}
			else{
				if(o.id > this.id){
					return -1;
				}
				else if(o.id < this.id){
					return 1;
				}
			}
		}
		return 0;
	}
}

public class Main {
	public static void main(String[] args) {
		new Main().run();
	}
	void run(){
		Scanner sc=new Scanner(System.in);
		while(true){
			int n=sc.nextInt();
			if(n==0) break;
			Team t[]=new Team[n];
			for(int i=0; i<n; i++){
				t[i]=new Team(sc.nextInt(),sc.nextInt(),sc.nextInt(),sc.nextInt());
			}
			Arrays.sort(t);
			
//			for(int i=0; i<n; i++){
//				System.err.println(t[i].id);
//			}
			
			int senbatsu[]=new int[n];
			HashMap<Integer, Integer> h=new HashMap<Integer, Integer>();
			int count=0;
			for(int i=0; i<n; i++){
				if(count<10){
					if(!h.containsKey(t[i].syo)){
						h.put(t[i].syo, 1);
						senbatsu[count]=t[i].id;
						count++;
					}
					else if(h.get(t[i].syo) < 3){
						int temp=h.get(t[i].syo);
						h.put(t[i].syo, temp+1);
						senbatsu[count]=t[i].id;
						count++;
					}
				}
				else if(count<20){
					if(!h.containsKey(t[i].syo)){
						h.put(t[i].syo, 1);
						senbatsu[count]=t[i].id;
						count++;
					}
					else if(h.get(t[i].syo) < 2){
						int temp=h.get(t[i].syo);
						h.put(t[i].syo, temp+1);
						senbatsu[count]=t[i].id;
						count++;
					}
				}
				else if(count<26){
					if(!h.containsKey(t[i].syo)){
						h.put(t[i].syo, 1);
						senbatsu[count]=t[i].id;
						count++;
					}
				}
			}
			//Arrays.sort(senbatsu, 0, count);
			for(int i=0; i<count; i++){
				System.out.println(senbatsu[i]);
			}
		}
	}

}

</source>
</class>

<class classid="252" nclones="2" nlines="31" similarity="100">
<source file="../hum_codes_raw/s551783329.java" startline="1" endline="34" pcid="18595">
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			char[] s = sc.next().toCharArray();
			if(s[0]=='0')break;
			int a = 0;
			int b = 0;
			for(int i=1;i<s.length;i++){
				if(s[i]=='A')a++;
				else b++;
			}
			if(a>b)a++;
			else b++;
			System.out.println(a+" "+b);
			for(int j=0;j<2;j++){
				s = sc.next().toCharArray();
				a = 0;
				b = 0;
				for(int i=1;i<s.length;i++){
					if(s[i]=='A')a++;
					else b++;
				}
				if(a>b)a++;
				else b++;
				System.out.println(a+" "+b);
			}
		}
	}
}

</source>
<source file="../hum_codes_raw/s643016294.java" startline="1" endline="35" pcid="21571">
import java.util.Scanner;

//Badminton
public class Main{

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			char[] s = sc.next().toCharArray();
			if(s[0]=='0')break;
			int a = 0;
			int b = 0;
			for(int i=1;i<s.length;i++){
				if(s[i]=='A')a++;
				else b++;
			}
			if(a>b)a++;
			else b++;
			System.out.println(a+" "+b);
			for(int j=0;j<2;j++){
				s = sc.next().toCharArray();
				a = 0;
				b = 0;
				for(int i=1;i<s.length;i++){
					if(s[i]=='A')a++;
					else b++;
				}
				if(a>b)a++;
				else b++;
				System.out.println(a+" "+b);
			}
		}
	}
}

</source>
</class>

<class classid="253" nclones="2" nlines="66" similarity="100">
<source file="../hum_codes_raw/s555688246.java" startline="1" endline="79" pcid="18724">
import java.util.*;
import java.io.*;
import java.lang.*;
class Main{
  public static void main(String args[]){
    int id, l, r,root=0;
    StringBuilder build = new StringBuilder();
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();
    Node node[] = new Node[n];

    for(int i = 0; i<n; i++){
      node[i] = new Node();
    }

    for(int i = 0; i<n; i++){
      id = sc.nextInt();
      l = sc.nextInt();
      r =  sc.nextInt();
      node[id].left = l;
      node[id].right = r;
      if(l != -1)node[l].parent = id;
      if(r != -1)node[r].parent = id;
    }

    for(int i = 0;i<n; i++){
      if(node[i].parent==-1)root = i;
    }
    setDepth(root,0,node);

    for(int i = 0 ; i < n; i++){
      build.append("node ").append(i).append(": parent = ").append(node[i].parent).append(", sibling = ").append(getSibling(i,node)).append(", degree = ").append(getDegree(i,node)).append(", depth = ").append(node[i].depth).append(", height = ").append(getHeight(i, node));
      if(node[i].parent==-1)build.append(", root\n");
      else if(node[i].right == -1 && node[i].left == -1)build.append(", leaf\n");
      else build.append(", internal node\n");
    }

    System.out.print(build);

  }

  static int getHeight(int u, Node node[]){
    int h1 = 0;
    int h2 = 0;
    if(node[u].right != -1)h1 = getHeight(node[u].right, node) +1;
    if(node[u].left != -1)h2 = getHeight(node[u].left, node) +1;

    return Math.max(h1,h2);
  }

  static void setDepth(int u,int d,Node node_d[]){
    if( u == -1)return;
    node_d[u].depth = d;
    setDepth(node_d[u].right,node_d[u].depth+1, node_d);
    setDepth(node_d[u].left, node_d[u].depth+1, node_d);
  }

  static int getSibling(int u, Node node[]){
    if(node[u].parent == -1)return (-1);
    if(node[node[u].parent].left != u && node[node[u].parent].left!=-1)return node[node[u].parent].left;
    if(node[node[u].parent].right != u && node[node[u].parent].right!=-1)return node[node[u].parent].right;
    return (-1);
  }

  static int getDegree(int u, Node node[]){
    int count=0;
    if(node[u].left != -1)count++;
    if(node[u].right != -1)count++;
    return count;
  }
}

class Node{
  int parent = -1;
  int left = -1;
  int right = -1;
  int depth = 0;
}

</source>
<source file="../hum_codes_raw/s653475569.java" startline="1" endline="79" pcid="21932">
import java.util.*;
import java.io.*;
import java.lang.*;
class Main{
  public static void main(String args[]){
    int id, l, r,root=0;
    StringBuilder build = new StringBuilder();
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();
    Node node[] = new Node[n];

    for(int i = 0; i<n; i++){
      node[i] = new Node();
    }

    for(int i = 0; i<n; i++){
      id = sc.nextInt();
      l = sc.nextInt();
      r =  sc.nextInt();
      node[id].left = l;
      node[id].right = r;
      if(l != -1)node[l].parent = id;
      if(r != -1)node[r].parent = id;
    }

    for(int i = 0;i<n; i++){
      if(node[i].parent==-1)root = i;
    }
    setDepth(root,0,node);

    for(int i = 0 ; i < n; i++){
      build.append("node ").append(i).append(": parent = ").append(node[i].parent).append(", sibling = ").append(getSibling(i,node)).append(", degree = ").append(getDegree(i,node)).append(", depth = ").append(node[i].depth).append(", height = ").append(getHeight(i, node));
      if(node[i].parent==-1)build.append(", root\n");
      else if(node[i].right == -1 && node[i].left == -1)build.append(", leaf\n");
      else build.append(", internal node\n");
    }

    System.out.print(build);

  }

  static int getHeight(int u, Node node[]){
    int h1 = 0;
    int h2 = 0;
    if(node[u].right != -1)h1 = getHeight(node[u].right, node) +1;
    if(node[u].left != -1)h2 = getHeight(node[u].left, node) +1;

    return Math.max(h1,h2);
  }

  static void setDepth(int u,int d,Node node_d[]){
    if( u == -1)return;
    node_d[u].depth = d;
    setDepth(node_d[u].right,node_d[u].depth+1, node_d);
    setDepth(node_d[u].left, node_d[u].depth+1, node_d);
  }

  static int getSibling(int u, Node node[]){
    if(node[u].parent == -1)return (-1);
    if(node[node[u].parent].left != u && node[node[u].parent].left!=-1)return node[node[u].parent].left;
    if(node[node[u].parent].right != u && node[node[u].parent].right!=-1)return node[node[u].parent].right;
    return (-1);
  }

  static int getDegree(int u, Node node[]){
    int count=0;
    if(node[u].left != -1)count++;
    if(node[u].right != -1)count++;
    return count;
  }
}

class Node{
  int parent = -1;
  int left = -1;
  int right = -1;
  int depth = 0;
}

</source>
</class>

<class classid="254" nclones="2" nlines="33" similarity="100">
<source file="../hum_codes_raw/s561705604.java" startline="1" endline="37" pcid="18911">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

class Main{
	public static void main(String[] args)throws IOException {
		String str="";
		BufferedReader bfr = new BufferedReader(new InputStreamReader(System.in));
		String[] datas;
		int[] rika=new int[4];
		int[] syakai=new int[2];
		int rikamin=100;
		int syamin=100;

		int sum=0;

		for(int i=0; i<6; i++) {
			if(i<4) {
				rika[i]=Integer.parseInt(bfr.readLine());
				if(rika[i]<rikamin) {
					rikamin=rika[i];
				}
				sum+=rika[i];
			}
			else if(i>=4) {
				syakai[i-4]=Integer.parseInt(bfr.readLine());
				if(syakai[i-4]<syamin) {
					syamin=syakai[i-4];
				}
				sum+=syakai[i-4];
			}
		}
		sum=sum-syamin-rikamin;
		System.out.println(sum);
	}
}

</source>
<source file="../hum_codes_raw/s561966545.java" startline="1" endline="37" pcid="18920">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

class Main{
	public static void main(String[] args)throws IOException {
		String str="";
		BufferedReader bfr = new BufferedReader(new InputStreamReader(System.in));
		String[] datas;
		int[] rika=new int[4];
		int[] syakai=new int[2];
		int rikamin=100;
		int syamin=100;

		int sum=0;

		for(int i=0; i<6; i++) {
			if(i<4) {
				rika[i]=Integer.parseInt(bfr.readLine());
				if(rika[i]<rikamin) {
					rikamin=rika[i];
				}
				sum+=rika[i];
			}
			else if(i>=4) {
				syakai[i-4]=Integer.parseInt(bfr.readLine());
				if(syakai[i-4]<syamin) {
					syamin=syakai[i-4];
				}
				sum+=syakai[i-4];
			}
		}
		sum=sum-syamin-rikamin;
		System.out.println(sum);
	}
}

</source>
</class>

<class classid="255" nclones="2" nlines="102" similarity="100">
<source file="../hum_codes_raw/s565613690.java" startline="1" endline="119" pcid="19029">
import java.io.*;
import java.math.*;
import java.util.*;

public class Main {
    private static boolean debug = false;
    private static boolean elapsed = false;

    private static PrintWriter _out = new PrintWriter(System.out);
    private static PrintWriter _err = new PrintWriter(System.err);

    private Map<Integer, Node> nodes = new HashMap<>();

    private boolean[][] memo;

    private static class Node {
        int no;
        List<Node> list = new ArrayList<>();
        int color;
        public Node(int no) {
            this.no = no;
        }
    }
    private static class Query {
        int v;
        int d;
        int c;
        public Query(int v, int d, int c) {
            this.v = v;
            this.d = d;
            this.c = c;
        }
    }
    private void solve(Scanner sc) {
        int N = sc.nextInt();
        int M = sc.nextInt();
        for (int i = 0; i < N; ++i) {
            nodes.put(i + 1, new Node(i + 1));
        }
        for (int i = 0; i < M; ++i) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            nodes.get(a).list.add(nodes.get(b));
            nodes.get(b).list.add(nodes.get(a));
        }
        int Q = sc.nextInt();
        List<Query> queryList = new ArrayList<>();
        for (int i = 0; i < Q; ++i) {
            int v = sc.nextInt();
            int d = sc.nextInt();
            int c = sc.nextInt();
            Query query = new Query(v, d, c);
            queryList.add(query);
        }

        Collections.reverse(queryList);

        memo = new boolean[N + 1][11];

        for (Query query : queryList) {
            paint(query.v, query.d, query.c);
        }

        for (int i = 0; i < N; ++i) {
            _out.println(nodes.get(i + 1).color);
        }
    }
    private void paint(int v, int d, int c) {
        if (memo[v][d]) {
            return;
        }
        memo[v][d] = true;
        if (d == 0) {
            nodes.get(v).color = c;
            return;
        }

        Node node = nodes.get(v);
        paint(v, d - 1, c);
        for (Node child : node.list) {
            paint(child.no, d - 1, c);
        }
    }
    private static BigInteger C(long n, long r) {
        BigInteger res = BigInteger.ONE;
        for (long i = n; i > n - r; --i) {
            res = res.multiply(BigInteger.valueOf(i));
        }
        for (long i = r; i > 1; --i) {
            res = res.divide(BigInteger.valueOf(i));
        }
        return res;
    }
    private static BigInteger P(long n, long r) {
        BigInteger res = BigInteger.ONE;
        for (long i = n; i > n - r; --i) {
            res = res.multiply(BigInteger.valueOf(i));
        }
        return res;
    }
    /*
     * 10^10 > Integer.MAX_VALUE = 2147483647 > 10^9
     * 10^19 > Long.MAX_VALUE = 9223372036854775807L > 10^18
     */
    public static void main(String[] args) {
        long S = System.currentTimeMillis();

        Scanner sc = new Scanner(System.in);
        new Main().solve(sc);
        _out.flush();

        long G = System.currentTimeMillis();
        if (elapsed) {
            _err.println((G - S) + "ms");
        }
        _err.flush();
    }
}

</source>
<source file="../hum_codes_raw/s997922792.java" startline="1" endline="119" pcid="33598">
import java.io.*;
import java.math.*;
import java.util.*;
 
public class Main {
    private static boolean debug = false;
    private static boolean elapsed = false;
 
    private static PrintWriter _out = new PrintWriter(System.out);
    private static PrintWriter _err = new PrintWriter(System.err);
 
    private Map<Integer, Node> nodes = new HashMap<>();
 
    private boolean[][] memo;
 
    private static class Node {
        int no;
        List<Node> list = new ArrayList<>();
        int color;
        public Node(int no) {
            this.no = no;
        }
    }
    private static class Query {
        int v;
        int d;
        int c;
        public Query(int v, int d, int c) {
            this.v = v;
            this.d = d;
            this.c = c;
        }
    }
    private void solve(Scanner sc) {
        int N = sc.nextInt();
        int M = sc.nextInt();
        for (int i = 0; i < N; ++i) {
            nodes.put(i + 1, new Node(i + 1));
        }
        for (int i = 0; i < M; ++i) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            nodes.get(a).list.add(nodes.get(b));
            nodes.get(b).list.add(nodes.get(a));
        }
        int Q = sc.nextInt();
        List<Query> queryList = new ArrayList<>();
        for (int i = 0; i < Q; ++i) {
            int v = sc.nextInt();
            int d = sc.nextInt();
            int c = sc.nextInt();
            Query query = new Query(v, d, c);
            queryList.add(query);
        }
 
        Collections.reverse(queryList);
 
        memo = new boolean[N + 1][11];
 
        for (Query query : queryList) {
            paint(query.v, query.d, query.c);
        }
 
        for (int i = 0; i < N; ++i) {
            _out.println(nodes.get(i + 1).color);
        }
    }
    private void paint(int v, int d, int c) {
        if (memo[v][d]) {
            return;
        }
        memo[v][d] = true;
        if (d == 0) {
            nodes.get(v).color = c;
            return;
        }
 
        Node node = nodes.get(v);
        paint(v, d - 1, c);
        for (Node child : node.list) {
            paint(child.no, d - 1, c);
        }
    }
    private static BigInteger C(long n, long r) {
        BigInteger res = BigInteger.ONE;
        for (long i = n; i > n - r; --i) {
            res = res.multiply(BigInteger.valueOf(i));
        }
        for (long i = r; i > 1; --i) {
            res = res.divide(BigInteger.valueOf(i));
        }
        return res;
    }
    private static BigInteger P(long n, long r) {
        BigInteger res = BigInteger.ONE;
        for (long i = n; i > n - r; --i) {
            res = res.multiply(BigInteger.valueOf(i));
        }
        return res;
    }
    /*
     * 10^10 > Integer.MAX_VALUE = 2147483647 > 10^9
     * 10^19 > Long.MAX_VALUE = 9223372036854775807L > 10^18
     */
    public static void main(String[] args) {
        long S = System.currentTimeMillis();
 
        Scanner sc = new Scanner(System.in);
        new Main().solve(sc);
        _out.flush();
 
        long G = System.currentTimeMillis();
        if (elapsed) {
            _err.println((G - S) + "ms");
        }
        _err.flush();
    }
}

</source>
</class>

<class classid="256" nclones="2" nlines="318" similarity="100">
<source file="../hum_codes_raw/s566789840.java" startline="1" endline="375" pcid="19062">
import java.io.*;
import java.util.*;

class Solver {
  int n;
  long[] xs;
  long[] ys;
  String[] ds;
  
  
  long[] xds;
  long[] yds;
  
  public Solver(int n, long[] xs, long[] ys, String[] ds) {
    this.n = n;
    this.xs = xs;
    this.ys = ys;
    this.ds = ds;
  }
  
  public double solve() {
    xds = new long[n];
    yds = new long[n];
    
    for (int i = 0; i < n; i++) {
      switch(ds[i].charAt(0)) {
        case 'R':
          xds[i] = 1;
          yds[i] = 0;
          break;
        case 'L':
          xds[i] = -1;
          yds[i] = 0;
          break;
        case 'U':
          xds[i] = 0;
          yds[i] = 1;
          break;
        case 'D':
          xds[i] = 0;
          yds[i] = -1;
          break;
      }
    }
    
    List<Double> allHitTimes = new ArrayList<>();
    allHitTimes.add(0.0);
    allHitTimes.addAll(findMaxPointDirectionChangeTime(xs, xds));
    allHitTimes.addAll(findMaxPointDirectionChangeTime(ys, yds));
    reverseWorld();
    allHitTimes.addAll(findMaxPointDirectionChangeTime(xs, xds));
    allHitTimes.addAll(findMaxPointDirectionChangeTime(ys, yds));
    reverseWorld();
    
    Collections.sort(allHitTimes);
    double areaMin = solveTimeAt(allHitTimes.get(allHitTimes.size() - 1));
    for (int i = 1; i < allHitTimes.size(); i++) {
      areaMin = Math.min(areaMin, solveTimeRange(allHitTimes.get(i-1), allHitTimes.get(i)));
    }
    return areaMin;
  }
  
  private double solveTimeRange(double timeMin, double timeMax) {
    double timeMid = 0.5 * (timeMin + timeMax);
    
    double xMin = Double.MAX_VALUE;
    double xMax = -1.0 * Double.MAX_VALUE;
    double yMin = Double.MAX_VALUE;
    double yMax = -1.0 * Double.MAX_VALUE;
    int xMinIndex = 0;
    int xMaxIndex = 0;
    int yMinIndex = 0;
    int yMaxIndex = 0;
    
    for (int i = 0; i < n; i++) {
      double x = (double)xs[i] + (double)xds[i] * timeMid;
      double y = (double)ys[i] + (double)yds[i] * timeMid;
      if (xMin > x) {
        xMin = x;
        xMinIndex = i;
      }
      if (xMax < x) {
        xMax = x;
        xMaxIndex = i;
      }
      if (yMin > y) {
        yMin = y;
        yMinIndex = i;
      }
      if (yMax < y) {
        yMax = y;
        yMaxIndex = i;
      }
    }
    
    double w = xs[xMaxIndex] - xs[xMinIndex];
    double wd = xds[xMaxIndex] - xds[xMinIndex];
    double h = ys[yMaxIndex] - ys[yMinIndex];
    double hd = yds[yMaxIndex] - yds[yMinIndex];
    
    // Min (w + wd * t) * (h + hd * t)
    double a = wd * hd;
    double b = wd * h + hd * w;
    double c = w * h;
    return calculateMin(a, b, c, timeMin, timeMax);
  }
  
  private double calculate(double a, double b, double c, double x) {
    return a * x * x + b * x + c;
  }
  
  private double calculateMin(double a, double b, double c, double xMin, double xMax) {
    if (a == 0 && b == 0) {
      return c;
    }
    if (a == 0 && b > 0) {
      return calculate(a, b, c, xMin);
    }
    if (a == 0 && b < 0) {
      return calculate(a, b, c, xMax);
    }
    double answer = calculate(a, b, c, xMin);
    answer = Math.min(answer, calculate(a, b, c, xMax));
    
    double xAxis = -0.5 * b / a;
    if (xMin <= xAxis && xAxis <= xMax) {
      answer = Math.min(answer, calculate(a, b, c, xAxis));
    }
    return answer;
  }
  
  private double solveTimeAt(double time) {
    double xMin = Double.MAX_VALUE;
    double xMax = -1.0 * Double.MAX_VALUE;
    double yMin = Double.MAX_VALUE;
    double yMax = -1.0 * Double.MAX_VALUE;
    
    for (int i = 0; i < n; i++) {
      double x = (double)xs[i] + (double)xds[i] * time;
      double y = (double)ys[i] + (double)yds[i] * time;
      xMin = Math.min(xMin, x);
      xMax = Math.max(xMax, x);
      yMin = Math.min(yMin, y);
      yMax = Math.max(yMax, y);
    }
    return (xMax - xMin) * (yMax - yMin);
  }
  
  private void reverseWorld() {
    for (int i = 0; i < n; i++) {
      xs[i] *= -1;
      ys[i] *= -1;
      xds[i] *= -1;
      yds[i] *= -1;
    }
  }
  
  
  private List<Double> findMaxPointDirectionChangeTime(long[] zs, long[] zds) {
    List<Double> hitTimes = new ArrayList<>();
    
    long maxPointZ = zs[0];
    long maxPointZD = zds[0];
    for (int i = 1; i < n; i++) {
      if (maxPointZ < zs[i]) {
        maxPointZ = zs[i];
        maxPointZD = zds[i];
      }
    }
    if (maxPointZD > 0) {
      return hitTimes;
    }
    
    double firstHitTime = Double.MAX_VALUE;
    long firstHitZ = 0;
    long firstHitZD = 0;
    for (int i = 0; i < n; i++) {
      if (zds[i] == maxPointZD || zds[i] < 0) {
        continue;
      }
      // maxPointZ + t * maxPointZD == zs[i] + t * zds[i]
      // maxPointZ + t * maxPointZD == zs[i] + t * zds[i]
      double t = -1.0 * (maxPointZ - zs[i]) / (maxPointZD - zds[i]);
      if (0.0 <= t && t < firstHitTime) {
        firstHitTime = t;
        firstHitZ = zs[i];
        firstHitZD = zds[i];
      }
    }
    
    if (firstHitTime == Double.MAX_VALUE) {
      return hitTimes;
    }
    hitTimes.add(firstHitTime);
    
    if (firstHitZD > 0) {
      return hitTimes;
    }
    
    double secondHitTime = Double.MAX_VALUE;
    for (int i = 0; i < n; i++) {
      if (zds[i] <= 0) {
        continue;
      }
      
      double t = -1.0 * (firstHitZ - zs[i]) / (firstHitZD - zds[i]);
      if (firstHitTime <= t && t < secondHitTime) {
        secondHitTime = t;
      }
    }
    
    if (secondHitTime == Double.MAX_VALUE) {
      return hitTimes;
    }
    
    hitTimes.add(secondHitTime);
    return hitTimes;
  }
}

public class Main {
  private static void execute(ContestReader reader, PrintWriter out) {
    int n = reader.nextInt();
    long[] xs = new long[n];
    long[] ys = new long[n];
    String[] ds = new String[n];
    for (int i = 0; i < n; i++) {
      xs[i] = reader.nextLong();
      ys[i] = reader.nextLong();
      ds[i] = reader.next();
    }
    out.printf("%.20f\n", new Solver(n, xs, ys, ds).solve());
  }
  
  public static void main(String[] args) {
    ContestReader reader = new ContestReader(System.in);
    PrintWriter out = new PrintWriter(System.out);
    execute(reader, out);
    out.flush();
  }
}

class ContestReader {
  private BufferedReader reader;
  private StringTokenizer tokenizer;
  
  ContestReader(InputStream in) {
    reader = new BufferedReader(new InputStreamReader(in));
  }
  
  public String next() {
    while (tokenizer == null || !tokenizer.hasMoreTokens()) {
      try {
        tokenizer = new java.util.StringTokenizer(reader.readLine());
      } catch (Exception e) {
        throw new RuntimeException(e);
      }
    }
    return tokenizer.nextToken();
  }
  
  public int nextInt() {
    return Integer.parseInt(next());
  }
  
  public long nextLong() {
    return Long.parseLong(next());
  }
  
  public double nextDouble() {
    return Double.parseDouble(next());
  }
  
  public int[] nextIntArray(int n) {
    int[] array = new int[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextInt();
    }
    return array;
  }
  
  public long[] nextLongArray(int n) {
    long[] array = new long[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextLong();
    }
    return array;
  }
  
  public int[][] nextIntMatrix(int n, int m) {
    int[][] matrix = new int[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextInt();
      }
    }
    return matrix;
  }
  
  public long[][] nextLongMatrix(int n, int m) {
    long[][] matrix = new long[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextInt();
      }
    }
    return matrix;
  }
}

class Algorithm {
  private static void swap(Object[] list, int a, int b) {
    Object tmp = list[a];
    list[a] = list[b];
    list[b] = tmp;
  }
  
  public static <T extends Comparable<? super T>> boolean nextPermutation(T[] ts) {
    int rightMostAscendingOrderIndex = ts.length - 2;
    while (rightMostAscendingOrderIndex >= 0 &&
        ts[rightMostAscendingOrderIndex].compareTo(ts[rightMostAscendingOrderIndex + 1]) >= 0) {
      rightMostAscendingOrderIndex--;
    }
    if (rightMostAscendingOrderIndex < 0) {
      return false;
    }
    
    int rightMostGreatorIndex = ts.length - 1;
    while (ts[rightMostAscendingOrderIndex].compareTo(ts[rightMostGreatorIndex]) >= 0) {
      rightMostGreatorIndex--;
    }
    
    swap(ts, rightMostAscendingOrderIndex, rightMostGreatorIndex);
    for (int i = 0; i < (ts.length - rightMostAscendingOrderIndex - 1) / 2; i++) {
      swap(ts, rightMostAscendingOrderIndex + 1 + i, ts.length - 1 - i);
    }
    return true;
  }
  
  public static void shuffle(int[] array) {
    Random random = new Random();
    int n = array.length;
    for (int i = 0; i < n; i++) {
      int randomIndex = i + random.nextInt(n - i);
      
      int temp = array[i];
      array[i] = array[randomIndex];
      array[randomIndex] = temp;
    }
  }
  
  public static void shuffle(long[] array) {
    Random random = new Random();
    int n = array.length;
    for (int i = 0; i < n; i++) {
      int randomIndex = i + random.nextInt(n - i);
      
      long temp = array[i];
      array[i] = array[randomIndex];
      array[randomIndex] = temp;
    }
  }
  
  public static void sort(int[] array) {
    shuffle(array);
    Arrays.sort(array);
  }
  
  public static void sort(long[] array) {
    shuffle(array);
    Arrays.sort(array);
  }
}


</source>
<source file="../hum_codes_raw/s988807814.java" startline="1" endline="375" pcid="33254">
import java.io.*;
import java.util.*;

class Solver {
  int n;
  long[] xs;
  long[] ys;
  String[] ds;
  
  
  long[] xds;
  long[] yds;
  
  public Solver(int n, long[] xs, long[] ys, String[] ds) {
    this.n = n;
    this.xs = xs;
    this.ys = ys;
    this.ds = ds;
  }
  
  public double solve() {
    xds = new long[n];
    yds = new long[n];
    
    for (int i = 0; i < n; i++) {
      switch(ds[i].charAt(0)) {
        case 'R':
          xds[i] = 1;
          yds[i] = 0;
          break;
        case 'L':
          xds[i] = -1;
          yds[i] = 0;
          break;
        case 'U':
          xds[i] = 0;
          yds[i] = 1;
          break;
        case 'D':
          xds[i] = 0;
          yds[i] = -1;
          break;
      }
    }
    
    List<Double> allHitTimes = new ArrayList<>();
    allHitTimes.add(0.0);
    allHitTimes.addAll(findMaxPointDirectionChangeTime(xs, xds));
    allHitTimes.addAll(findMaxPointDirectionChangeTime(ys, yds));
    reverseWorld();
    allHitTimes.addAll(findMaxPointDirectionChangeTime(xs, xds));
    allHitTimes.addAll(findMaxPointDirectionChangeTime(ys, yds));
    reverseWorld();
    
    Collections.sort(allHitTimes);
    double areaMin = solveTimeAt(allHitTimes.get(allHitTimes.size() - 1));
    for (int i = 1; i < allHitTimes.size(); i++) {
      areaMin = Math.min(areaMin, solveTimeRange(allHitTimes.get(i-1), allHitTimes.get(i)));
    }
    return areaMin;
  }
  
  private double solveTimeRange(double timeMin, double timeMax) {
    double timeMid = 0.5 * (timeMin + timeMax);
    
    double xMin = Double.MAX_VALUE;
    double xMax = -1.0 * Double.MAX_VALUE;
    double yMin = Double.MAX_VALUE;
    double yMax = -1.0 * Double.MAX_VALUE;
    int xMinIndex = 0;
    int xMaxIndex = 0;
    int yMinIndex = 0;
    int yMaxIndex = 0;
    
    for (int i = 0; i < n; i++) {
      double x = (double)xs[i] + (double)xds[i] * timeMid;
      double y = (double)ys[i] + (double)yds[i] * timeMid;
      if (xMin > x) {
        xMin = x;
        xMinIndex = i;
      }
      if (xMax < x) {
        xMax = x;
        xMaxIndex = i;
      }
      if (yMin > y) {
        yMin = y;
        yMinIndex = i;
      }
      if (yMax < y) {
        yMax = y;
        yMaxIndex = i;
      }
    }
    
    double w = xs[xMaxIndex] - xs[xMinIndex];
    double wd = xds[xMaxIndex] - xds[xMinIndex];
    double h = ys[yMaxIndex] - ys[yMinIndex];
    double hd = yds[yMaxIndex] - yds[yMinIndex];
    
    // Min (w + wd * t) * (h + hd * t)
    double a = wd * hd;
    double b = wd * h + hd * w;
    double c = w * h;
    return calculateMin(a, b, c, timeMin, timeMax);
  }
  
  private double calculate(double a, double b, double c, double x) {
    return a * x * x + b * x + c;
  }
  
  private double calculateMin(double a, double b, double c, double xMin, double xMax) {
    if (a == 0 && b == 0) {
      return c;
    }
    if (a == 0 && b > 0) {
      return calculate(a, b, c, xMin);
    }
    if (a == 0 && b < 0) {
      return calculate(a, b, c, xMax);
    }
    double answer = calculate(a, b, c, xMin);
    answer = Math.min(answer, calculate(a, b, c, xMax));
    
    double xAxis = -0.5 * b / a;
    if (xMin <= xAxis && xAxis <= xMax) {
      answer = Math.min(answer, calculate(a, b, c, xAxis));
    }
    return answer;
  }
  
  private double solveTimeAt(double time) {
    double xMin = Double.MAX_VALUE;
    double xMax = -1.0 * Double.MAX_VALUE;
    double yMin = Double.MAX_VALUE;
    double yMax = -1.0 * Double.MAX_VALUE;
    
    for (int i = 0; i < n; i++) {
      double x = (double)xs[i] + (double)xds[i] * time;
      double y = (double)ys[i] + (double)yds[i] * time;
      xMin = Math.min(xMin, x);
      xMax = Math.max(xMax, x);
      yMin = Math.min(yMin, y);
      yMax = Math.max(yMax, y);
    }
    return (xMax - xMin) * (yMax - yMin);
  }
  
  private void reverseWorld() {
    for (int i = 0; i < n; i++) {
      xs[i] *= -1;
      ys[i] *= -1;
      xds[i] *= -1;
      yds[i] *= -1;
    }
  }
  
  
  private List<Double> findMaxPointDirectionChangeTime(long[] zs, long[] zds) {
    List<Double> hitTimes = new ArrayList<>();
    
    long maxPointZ = zs[0];
    long maxPointZD = zds[0];
    for (int i = 1; i < n; i++) {
      if (maxPointZ < zs[i]) {
        maxPointZ = zs[i];
        maxPointZD = zds[i];
      }
    }
    if (maxPointZD > 0) {
      return hitTimes;
    }
    
    double firstHitTime = Double.MAX_VALUE;
    long firstHitZ = 0;
    long firstHitZD = 0;
    for (int i = 0; i < n; i++) {
      if (zds[i] == maxPointZD || zds[i] < 0) {
        continue;
      }
      // maxPointZ + t * maxPointZD == zs[i] + t * zds[i]
      // maxPointZ + t * maxPointZD == zs[i] + t * zds[i]
      double t = -1.0 * (maxPointZ - zs[i]) / (maxPointZD - zds[i]);
      if (0.0 <= t && t < firstHitTime) {
        firstHitTime = t;
        firstHitZ = zs[i];
        firstHitZD = zds[i];
      }
    }
    
    if (firstHitTime == Double.MAX_VALUE) {
      return hitTimes;
    }
    hitTimes.add(firstHitTime);
    
    if (firstHitZD > 0) {
      return hitTimes;
    }
    
    double secondHitTime = Double.MAX_VALUE;
    for (int i = 0; i < n; i++) {
      if (zds[i] <= 0) {
        continue;
      }
      
      double t = -1.0 * (firstHitZ - zs[i]) / (firstHitZD - zds[i]);
      if (firstHitTime <= t && t < secondHitTime) {
        secondHitTime = t;
      }
    }
    
    if (secondHitTime == Double.MAX_VALUE) {
      return hitTimes;
    }
    
    hitTimes.add(secondHitTime);
    return hitTimes;
  }
}

public class Main {
  private static void execute(ContestReader reader, PrintWriter out) {
    int n = reader.nextInt();
    long[] xs = new long[n];
    long[] ys = new long[n];
    String[] ds = new String[n];
    for (int i = 0; i < n; i++) {
      xs[i] = reader.nextLong();
      ys[i] = reader.nextLong();
      ds[i] = reader.next();
    }
    out.printf("%.20f\n", new Solver(n, xs, ys, ds).solve());
  }
  
  public static void main(String[] args) {
    ContestReader reader = new ContestReader(System.in);
    PrintWriter out = new PrintWriter(System.out);
    execute(reader, out);
    out.flush();
  }
}

class ContestReader {
  private BufferedReader reader;
  private StringTokenizer tokenizer;
  
  ContestReader(InputStream in) {
    reader = new BufferedReader(new InputStreamReader(in));
  }
  
  public String next() {
    while (tokenizer == null || !tokenizer.hasMoreTokens()) {
      try {
        tokenizer = new java.util.StringTokenizer(reader.readLine());
      } catch (Exception e) {
        throw new RuntimeException(e);
      }
    }
    return tokenizer.nextToken();
  }
  
  public int nextInt() {
    return Integer.parseInt(next());
  }
  
  public long nextLong() {
    return Long.parseLong(next());
  }
  
  public double nextDouble() {
    return Double.parseDouble(next());
  }
  
  public int[] nextIntArray(int n) {
    int[] array = new int[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextInt();
    }
    return array;
  }
  
  public long[] nextLongArray(int n) {
    long[] array = new long[n];
    for (int i = 0; i < n; i++) {
      array[i] = nextLong();
    }
    return array;
  }
  
  public int[][] nextIntMatrix(int n, int m) {
    int[][] matrix = new int[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextInt();
      }
    }
    return matrix;
  }
  
  public long[][] nextLongMatrix(int n, int m) {
    long[][] matrix = new long[n][m];
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        matrix[i][j] = nextInt();
      }
    }
    return matrix;
  }
}

class Algorithm {
  private static void swap(Object[] list, int a, int b) {
    Object tmp = list[a];
    list[a] = list[b];
    list[b] = tmp;
  }
  
  public static <T extends Comparable<? super T>> boolean nextPermutation(T[] ts) {
    int rightMostAscendingOrderIndex = ts.length - 2;
    while (rightMostAscendingOrderIndex >= 0 &&
        ts[rightMostAscendingOrderIndex].compareTo(ts[rightMostAscendingOrderIndex + 1]) >= 0) {
      rightMostAscendingOrderIndex--;
    }
    if (rightMostAscendingOrderIndex < 0) {
      return false;
    }
    
    int rightMostGreatorIndex = ts.length - 1;
    while (ts[rightMostAscendingOrderIndex].compareTo(ts[rightMostGreatorIndex]) >= 0) {
      rightMostGreatorIndex--;
    }
    
    swap(ts, rightMostAscendingOrderIndex, rightMostGreatorIndex);
    for (int i = 0; i < (ts.length - rightMostAscendingOrderIndex - 1) / 2; i++) {
      swap(ts, rightMostAscendingOrderIndex + 1 + i, ts.length - 1 - i);
    }
    return true;
  }
  
  public static void shuffle(int[] array) {
    Random random = new Random();
    int n = array.length;
    for (int i = 0; i < n; i++) {
      int randomIndex = i + random.nextInt(n - i);
      
      int temp = array[i];
      array[i] = array[randomIndex];
      array[randomIndex] = temp;
    }
  }
  
  public static void shuffle(long[] array) {
    Random random = new Random();
    int n = array.length;
    for (int i = 0; i < n; i++) {
      int randomIndex = i + random.nextInt(n - i);
      
      long temp = array[i];
      array[i] = array[randomIndex];
      array[randomIndex] = temp;
    }
  }
  
  public static void sort(int[] array) {
    shuffle(array);
    Arrays.sort(array);
  }
  
  public static void sort(long[] array) {
    shuffle(array);
    Arrays.sort(array);
  }
}


</source>
</class>

<class classid="257" nclones="2" nlines="196" similarity="100">
<source file="../hum_codes_raw/s570316752.java" startline="1" endline="235" pcid="19178">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            DReversedLCS solver = new DReversedLCS();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class DReversedLCS {
        char[] s;
        int[][][] dp;

        public int dp(int l, int r, int k) {
            if (l > r) {
                return 0;
            }
            if (l == r) {
                return 1;
            }
            if (dp[l][r][k] == -1) {
                dp[l][r][k] = 0;
                //change nothing
                dp[l][r][k] = Math.max(dp(l + 1, r, k), dp(l, r - 1, k));
                if (s[l] == s[r]) {
                    dp[l][r][k] = dp(l + 1, r - 1, k) + 2;
                }
                if (k > 0) {
                    dp[l][r][k] = Math.max(dp[l][r][k], dp(l + 1, r - 1, k - 1) + 2);
                }
            }
            return dp[l][r][k];
        }

        public void solve(int testNumber, FastInput in, FastOutput out) {
            s = in.readString().toCharArray();
            int k = in.readInt();
            dp = new int[s.length][s.length][k + 1];
            SequenceUtils.deepFill(dp, -1);
            int ans = dp(0, s.length - 1, k);
            out.println(ans);
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class SequenceUtils {
        public static void deepFill(Object array, int val) {
            if (!array.getClass().isArray()) {
                throw new IllegalArgumentException();
            }
            if (array instanceof int[]) {
                int[] intArray = (int[]) array;
                Arrays.fill(intArray, val);
            } else {
                Object[] objArray = (Object[]) array;
                for (Object obj : objArray) {
                    deepFill(obj, val);
                }
            }
        }

    }

    static class FastInput {
        private final InputStream is;
        private StringBuilder defaultStringBuf = new StringBuilder(1 << 13);
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

        public String readString(StringBuilder builder) {
            skipBlank();

            while (next > 32) {
                builder.append((char) next);
                next = read();
            }

            return builder.toString();
        }

        public String readString() {
            defaultStringBuf.setLength(0);
            return readString(defaultStringBuf);
        }

    }
}


</source>
<source file="../hum_codes_raw/s976414384.java" startline="1" endline="235" pcid="32855">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 29);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            DReversedLCS solver = new DReversedLCS();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class DReversedLCS {
        char[] s;
        int[][][] dp;

        public int dp(int l, int r, int k) {
            if (l > r) {
                return 0;
            }
            if (l == r) {
                return 1;
            }
            if (dp[l][r][k] == -1) {
                dp[l][r][k] = 0;
                //change nothing
                dp[l][r][k] = Math.max(dp(l + 1, r, k), dp(l, r - 1, k));
                if (s[l] == s[r]) {
                    dp[l][r][k] = dp(l + 1, r - 1, k) + 2;
                }
                if (k > 0) {
                    dp[l][r][k] = Math.max(dp[l][r][k], dp(l + 1, r - 1, k - 1) + 2);
                }
            }
            return dp[l][r][k];
        }

        public void solve(int testNumber, FastInput in, FastOutput out) {
            s = in.readString().toCharArray();
            int k = in.readInt();
            dp = new int[s.length][s.length][k + 1];
            SequenceUtils.deepFill(dp, -1);
            int ans = dp(0, s.length - 1, k);
            out.println(ans);
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class SequenceUtils {
        public static void deepFill(Object array, int val) {
            if (!array.getClass().isArray()) {
                throw new IllegalArgumentException();
            }
            if (array instanceof int[]) {
                int[] intArray = (int[]) array;
                Arrays.fill(intArray, val);
            } else {
                Object[] objArray = (Object[]) array;
                for (Object obj : objArray) {
                    deepFill(obj, val);
                }
            }
        }

    }

    static class FastInput {
        private final InputStream is;
        private StringBuilder defaultStringBuf = new StringBuilder(1 << 13);
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readInt() {
            int sign = 1;

            skipBlank();
            if (next == '+' || next == '-') {
                sign = next == '+' ? 1 : -1;
                next = read();
            }

            int val = 0;
            if (sign == 1) {
                while (next >= '0' && next <= '9') {
                    val = val * 10 + next - '0';
                    next = read();
                }
            } else {
                while (next >= '0' && next <= '9') {
                    val = val * 10 - next + '0';
                    next = read();
                }
            }

            return val;
        }

        public String readString(StringBuilder builder) {
            skipBlank();

            while (next > 32) {
                builder.append((char) next);
                next = read();
            }

            return builder.toString();
        }

        public String readString() {
            defaultStringBuf.setLength(0);
            return readString(defaultStringBuf);
        }

    }
}


</source>
</class>

<class classid="258" nclones="2" nlines="38" similarity="100">
<source file="../hum_codes_raw/s575133689.java" startline="1" endline="51" pcid="19332">

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Stack;

public class Main {
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String[] tmpArray = br.readLine().split(" ");
		int n = Integer.parseInt(tmpArray[0]);
		int q = Integer.parseInt(tmpArray[1]);

		@SuppressWarnings("unchecked")
		ArrayList<Integer>[] queue = new ArrayList[n];
		for(int i = 0; i < n; i++){
			queue[i] = new ArrayList<Integer>();
		}

		for(int i = 0; i < q; i++){
			tmpArray = br.readLine().split(" ");

	
			if(tmpArray[0].equals("0")){
				int t = Integer.parseInt(tmpArray[1]);
				int x = Integer.parseInt(tmpArray[2]);

				queue[t].add(x);
			}
	
			else if(tmpArray[0].equals("1")){
				int t = Integer.parseInt(tmpArray[1]);

				if(!queue[t].isEmpty()){
					System.out.println(queue[t].get(0));
				}
			}
			
			else {
				int t = Integer.parseInt(tmpArray[1]);

				if(!queue[t].isEmpty()){
					queue[t].remove(0);
				}
			}
		}
	}
}


</source>
<source file="../hum_codes_raw/s863451359.java" startline="1" endline="51" pcid="29036">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Stack;

public class Main {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String[] tmpArray = br.readLine().split(" ");
		int n = Integer.parseInt(tmpArray[0]);
		int q = Integer.parseInt(tmpArray[1]);

		@SuppressWarnings("unchecked")
		ArrayList<Integer>[] queue = new ArrayList[n];
		for(int i = 0; i < n; i++){
			queue[i] = new ArrayList<Integer>();
		}

		for(int i = 0; i < q; i++){
			tmpArray = br.readLine().split(" ");

			//enqueue
			if(tmpArray[0].equals("0")){
				int t = Integer.parseInt(tmpArray[1]);
				int x = Integer.parseInt(tmpArray[2]);

				queue[t].add(x);
			}
			//front
			else if(tmpArray[0].equals("1")){
				int t = Integer.parseInt(tmpArray[1]);

				if(!queue[t].isEmpty()){
					System.out.println(queue[t].get(0));
				}
			}
			//dequeue
			else {
				int t = Integer.parseInt(tmpArray[1]);

				if(!queue[t].isEmpty()){
					queue[t].remove(0);
				}
			}
		}

	}
}

</source>
</class>

<class classid="259" nclones="2" nlines="55" similarity="100">
<source file="../hum_codes_raw/s577181364.java" startline="1" endline="71" pcid="19379">
import java.io.BufferedReader;
import java.io.InputStreamReader;

public class Main {
	private final static byte MASK_RIGHT = 0x0F; //4bit
	private final static int STRIP_LENGTH = 10; //1
	private static int[] punchTape = new int[100]; //10*10

	public static void main(String[] args) throws Exception {
		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in), 256);
		String sLine;
		while ((sLine = reader.readLine()) != null) {
			droppingInk(sLine.charAt(0) & MASK_RIGHT, sLine.charAt(2) & MASK_RIGHT, sLine.charAt(4) & MASK_RIGHT);
		}
		calcResult();
	}

	/**
	 *
	 */
	private static void droppingInk(int x, int y, int size) {
		sinking(x, y - 1);
		sinking(x - 1, y);
		sinking(x, y);
		sinking(x + 1, y);
		sinking(x, y + 1);
		if (size == 1) {
			return;
		}

		sinking(x - 1, y - 1);
		sinking(x + 1, y - 1);
		sinking(x - 1, y + 1);
		sinking(x + 1, y + 1);
		if (size == 2) {
			return;
		}

		sinking(x, y - 2);
		sinking(x - 2, y);
		sinking(x + 2, y);
		sinking(x, y + 2);
	}

	/**
	 * 
	 */
	private static void sinking(int x, int y) {
		if (x >= 0 && x < 10 && y >= 0 && y < 10) {
			punchTape[x * STRIP_LENGTH + y]++;
		}
	}

	/**
	 *
	 */
	private static void calcResult() {
		int white = 0;//
		int max = 0;//
		for (int cell : punchTape) {
			if (cell == 0) {
				white++;
			} else if (cell > max) {
				max = cell;
			}
		}
		System.out.println(white);
		System.out.println(max);
	}
}

</source>
<source file="../hum_codes_raw/s762004113.java" startline="1" endline="71" pcid="25595">
import java.io.BufferedReader;
import java.io.InputStreamReader;

public class Main {
	private final static byte MASK_RIGHT = 0x0F; //4bit
	private final static int STRIP_LENGTH = 10; //1
	private static int[] punchTape = new int[100]; //10*10

	public static void main(String[] args) throws Exception {
		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in), 256);
		String sLine;
		while ((sLine = reader.readLine()) != null) {
			droppingInk(sLine.charAt(0) & MASK_RIGHT, sLine.charAt(2) & MASK_RIGHT, sLine.charAt(4) & MASK_RIGHT);
		}
		calcResult();
	}

	/**
	 *
	 */
	private static void droppingInk(int x, int y, int size) {
		sinking(x, y - 1);
		sinking(x - 1, y);
		sinking(x, y);
		sinking(x + 1, y);
		sinking(x, y + 1);
		if (size == 1) {
			return;
		}

		sinking(x - 1, y - 1);
		sinking(x + 1, y - 1);
		sinking(x - 1, y + 1);
		sinking(x + 1, y + 1);
		if (size == 2) {
			return;
		}

		sinking(x, y - 2);
		sinking(x - 2, y);
		sinking(x + 2, y);
		sinking(x, y + 2);
	}

	/**
	 * 
	 */
	private static void sinking(int x, int y) {
		if (x >= 0 && x < 10 && y >= 0 && y < 10) {
			punchTape[x * STRIP_LENGTH + y]++;
		}
	}

	/**
	 *
	 */
	private static void calcResult() {
		int white = 0;//
		int max = 0;//
		for (int cell : punchTape) {
			if (cell == 0) {
				white++;
			} else if (cell > max) {
				max = cell;
			}
		}
		System.out.println(white);
		System.out.println(max);
	}
}

</source>
</class>

<class classid="260" nclones="2" nlines="65" similarity="100">
<source file="../hum_codes_raw/s577710680.java" startline="1" endline="64" pcid="19397">
import java.util.*;
public class Main {
	private static Scanner sc;
	public static void main(String[] args) {
		sc = new Scanner(System.in);
		byte a = sc.nextByte();
		for (int l=0; l<a; l++){
			byte gx=sc.nextByte();
			byte gy=sc.nextByte();
			byte No [][] = new byte [gx+1][gy+1];
			byte b = sc.nextByte();
			for (int k=0; k<b; k++){
				byte x1=sc.nextByte();
				byte y1=sc.nextByte();
				byte x2=sc.nextByte();
				byte y2=sc.nextByte();
				
				if (x1 == x2) {
					No [x1][(Math.max(y1, y2))]+=1;
				}
				else {No[(Math.max(x1,x2))][y1]+=2;}			
			}
			int Total[][] = new int [gx+1][gy+1];
			Total[0][0] = 1;
			for (int i=0; i<=gx; i++){
				for (int j=0; j<=gy; j++){
					if (No[i][j] == 0){
						if (i>0 & j>0){
							Total[i][j]=Total[i-1][j]+Total[i][j-1];
						}
						else if (i>0){
							Total[i][j]=Total[i-1][j];
						}
						else if (j>0){
							Total[i][j]=Total[i][j-1];
						}
						else;
					}
					else if(No[i][j] == 1){
						if (i>0){
							Total[i][j]=Total[i-1][j];
							}
						else Total[i][j]=0;
					}
					else if(No[i][j] == 2){
						if (j>0){
						Total[i][j]=Total[i][j-1];
						}
						else Total[i][j]=0;
					}
					else {
						Total[i][j]=0;
					}
				}
			}
			if (Total[gx][gy]==0){
				System.out.println("Miserable Hokusai!");
			}
			else {System.out.println(Total[gx][gy]);
			}
		}
	}
}

</source>
<source file="../hum_codes_raw/s998246257.java" startline="1" endline="64" pcid="33607">
import java.util.*;
public class Main {
	private static Scanner sc;
	public static void main(String[] args) {
		sc = new Scanner(System.in);
		byte a = sc.nextByte();
		for (int l=0; l<a; l++){
			byte gx=sc.nextByte();
			byte gy=sc.nextByte();
			byte No [][] = new byte [gx+1][gy+1];
			byte b = sc.nextByte();
			for (int k=0; k<b; k++){
				byte x1=sc.nextByte();
				byte y1=sc.nextByte();
				byte x2=sc.nextByte();
				byte y2=sc.nextByte();
				
				if (x1 == x2) {
					No [x1][(Math.max(y1, y2))]+=1;
				}
				else {No[(Math.max(x1,x2))][y1]+=2;}			
			}
			int Total[][] = new int [gx+1][gy+1];
			Total[0][0] = 1;
			for (int i=0; i<=gx; i++){
				for (int j=0; j<=gy; j++){
					if (No[i][j] == 0){
						if (i>0 & j>0){
							Total[i][j]=Total[i-1][j]+Total[i][j-1];
						}
						else if (i>0){
							Total[i][j]=Total[i-1][j];
						}
						else if (j>0){
							Total[i][j]=Total[i][j-1];
						}
						else;
					}
					else if(No[i][j] == 1){
						if (i>0){
							Total[i][j]=Total[i-1][j];
							}
						else Total[i][j]=0;
					}
					else if(No[i][j] == 2){
						if (j>0){
						Total[i][j]=Total[i][j-1];
						}
						else Total[i][j]=0;
					}
					else {
						Total[i][j]=0;
					}
				}
			}
			if (Total[gx][gy]==0){
				System.out.println("Miserable Hokusai!");
			}
			else {System.out.println(Total[gx][gy]);
			}
		}
	}
}

</source>
</class>

<class classid="261" nclones="2" nlines="92" similarity="100">
<source file="../hum_codes_raw/s583890283.java" startline="1" endline="122" pcid="19588">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

  public static void main(String[] args) {
    
    new Main().run();
  }

  public void run() {

    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      int n = Integer.parseInt(br.readLine());
      String op;
      String[] words;
      Tree tree = new Tree();

      for(int i=0,k=0; i<n; i++,k=0){
        words = br.readLine().split(" ");
        op  = words[k++];
        if ( op.equals("insert") ) { 
          tree.insert(Integer.parseInt(words[k++]));
        }
        else {
          tree.dispRoundPath();
        }
      }

    }
    catch(IOException e) {
      System.out.println("IOException!");
    }
  }
}

class Tree {

  static final BTreeNode NIL = new BTreeNode(-1);
  BTreeNode root;
  StringBuilder buf;

  public Tree() {
    root = NIL;
    buf = new StringBuilder();
  }

  public void insert(int val) {
    BTreeNode y = NIL;
    BTreeNode x = root;
    BTreeNode z = new BTreeNode(val);

    while( !x.equals(NIL) ) {
      y = x;
      if( z.key < x.key )
        x = x.left;
      else
        x = x.right;
    }
    z.parent = y;

    if( y.equals(NIL) ){
      root = z;
    }
    else if( z.key < y.key )
      y.left = z;
    else
      y.right = z;
  } 
  void preParse(BTreeNode u) {
    if( !u.equals(NIL) ) {
      buf.append(" ").append(u.key);
      preParse(u.left);
      preParse(u.right);
    }
  }
  void inParse(BTreeNode u) {
    if( !u.equals(NIL) ) {
      inParse(u.left);
      buf.append(" ").append(u.key);
      inParse(u.right);
    }
  }

  void dispRoundPath() {

    inParse(root);
    buf.append("\n");
    preParse(root);
    buf.append("\n");

    System.out.print(buf);
    buf.setLength(0);
  }
}

class BTreeNode {
  int key;
  BTreeNode parent,left,right;

  public BTreeNode(int key) {
    this.key = key;
    this.parent =
    this.left =
    this.right = Tree.NIL;
  }

  @Override
  public boolean equals(Object o) {
    if(o == this) return true;
    if(o == null) return false;
    if(!(o instanceof BTreeNode)) return false;

    BTreeNode node = (BTreeNode)o;
    if(!(this.key == node.key)) return false;

    return true;
  }
}

</source>
<source file="../hum_codes_raw/s635452209.java" startline="1" endline="122" pcid="21315">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

  public static void main(String[] args) {
    
    new Main().run();
  }

  public void run() {

    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      int n = Integer.parseInt(br.readLine());
      String op;
      String[] words;
      Tree tree = new Tree();

      for(int i=0,k=0; i<n; i++,k=0){
        words = br.readLine().split(" ");
        op  = words[k++];
        if ( op.equals("insert") ) { 
          tree.insert(Integer.parseInt(words[k++]));
        }
        else {
          tree.dispRoundPath();
        }
      }

    }
    catch(IOException e) {
      System.out.println("IOException!");
    }
  }
}

class Tree {

  static final BTreeNode NIL = new BTreeNode(-1);
  BTreeNode root;
  StringBuilder buf;

  public Tree() {
    root = NIL;
    buf = new StringBuilder();
  }

  public void insert(int val) {
    BTreeNode y = NIL;
    BTreeNode x = root;
    BTreeNode z = new BTreeNode(val);

    while( !x.equals(NIL) ) {
      y = x;
      if( z.key < x.key )
        x = x.left;
      else
        x = x.right;
    }
    z.parent = y;

    if( y.equals(NIL) ){
      root = z;
    }
    else if( z.key < y.key )
      y.left = z;
    else
      y.right = z;
  } 
  void preParse(BTreeNode u) {
    if( !u.equals(NIL) ) {
      buf.append(" ").append(u.key);
      preParse(u.left);
      preParse(u.right);
    }
  }
  void inParse(BTreeNode u) {
    if( !u.equals(NIL) ) {
      inParse(u.left);
      buf.append(" ").append(u.key);
      inParse(u.right);
    }
  }

  void dispRoundPath() {

    inParse(root);
    buf.append("\n");
    preParse(root);
    buf.append("\n");

    System.out.print(buf);
    buf.setLength(0);
  }
}

class BTreeNode {
  int key;
  BTreeNode parent,left,right;

  public BTreeNode(int key) {
    this.key = key;
    this.parent =
    this.left =
    this.right = Tree.NIL;
  }

  @Override
  public boolean equals(Object o) {
    if(o == this) return true;
    if(o == null) return false;
    if(!(o instanceof BTreeNode)) return false;

    BTreeNode node = (BTreeNode)o;
    if(!(this.key == node.key)) return false;

    return true;
  }
}

</source>
</class>

<class classid="262" nclones="2" nlines="10" similarity="100">
<source file="../hum_codes_raw/s590174077.java" startline="1" endline="12" pcid="19803">
import java.util.Scanner;

public class Main{
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int x = sc.nextInt();
        int y = sc.nextInt();
        int z = sc.nextInt();
        System.out.println(z + " " + x + " " + y);
    }
}

</source>
<source file="../hum_codes_raw/s684353770.java" startline="1" endline="14" pcid="22993">
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int x = sc.nextInt();
        int y = sc.nextInt();
        int z = sc.nextInt();
        System.out.println(z + " " + x + " " + y);
    }

}

</source>
</class>

<class classid="263" nclones="2" nlines="69" similarity="100">
<source file="../hum_codes_raw/s590523901.java" startline="1" endline="76" pcid="19813">
import java.util.Scanner;

public class Main{
    public static void main(String[] args){
        Scanner s = new Scanner(System.in);


        int i,j,t;
        String st;
   
        t = s.nextInt();
        for(i=0;i<t;i++){
            int[] num = new int[10];
            int[] g = new int[10],b =new int[10], r =new int[10];
            boolean ch=true;
            for(j=0;j<9;j++)num[j]=s.nextInt();
            for(j=0;j<9;j++){

                st = s.next();
                if(st.charAt(0)=='G')g[num[j]]++;
                else if(st.charAt(0)=='B')b[num[j]]++;
                else if(st.charAt(0)=='R')r[num[j]]++;
            }
            for(j=1;j<=9;j++){
                if(g[j]>=3)g[j]-=3;
                if(j<8&&g[j]==2&&g[j+1]>1&&g[j+2]>1){
                    g[j]-=2;
                    g[j+1]-=2;
                    g[j+2]-=2;
                }
                if(j<8&&g[j]==1&&g[j+1]>0&&g[j+2]>0){
                    g[j]--;
                    g[j+1]--;
                    g[j+2]--;
                }
                if(b[j]>=3)b[j]-=3;
                if(j<8&&b[j]==2&&b[j+1]>1&&b[j+2]>1){
                    b[j]-=2;
                    b[j+1]-=2;
                    b[j+2]-=2;
                }
                if(j<8&&b[j]==1&&b[j+1]>0&&b[j+2]>0){
                    b[j]--;
                    b[j+1]--;
                    b[j+2]--;
                }
                if(r[j]>=3)r[j]-=3;
                if(j<8&&g[j]==2&&r[j+1]>1&&r[j+2]>1){
                    r[j]-=2;
                    r[j+1]-=2;
                    r[j+2]-=2;
                }
                if(j<8&&r[j]==1&&r[j+1]>0&&r[j+2]>0){
                    r[j]--;
                    r[j+1]--;
                    r[j+2]--;
                }
                if(g[j]>0||b[j]>0||r[j]>0){
                    ch = false;
                    break;
                }   
            }
            if(ch==true)System.out.println(1);
            else System.out.println(0);
            for(j=0;j<=9;j++){
                g[j]=0;
                b[j]=0;
                r[j]=0;
                num[j]=0;
            }
            ch=true;
        }

    }
}

</source>
<source file="../hum_codes_raw/s615785556.java" startline="1" endline="77" pcid="20693">
import java.util.Scanner;
 
public class Main{
    public static void main(String[] args){
        Scanner s = new Scanner(System.in);
 
 
        int i,j,t;
        String st;
    
        t = s.nextInt();
        for(i=0;i<t;i++){
            int[] num = new int[10];
            int[] g = new int[10],b =new int[10], r =new int[10];
            boolean ch=true;
            for(j=0;j<9;j++)num[j]=s.nextInt();
            for(j=0;j<9;j++){
 
                st = s.next();
                if(st.charAt(0)=='G')g[num[j]]++;
                else if(st.charAt(0)=='B')b[num[j]]++;
                else if(st.charAt(0)=='R')r[num[j]]++;
            }
            for(j=1;j<=9;j++){
                if(g[j]>=3)g[j]-=3;
                if(j<8&&g[j]==2&&g[j+1]>1&&g[j+2]>1){
                    g[j]-=2;
                    g[j+1]-=2;
                    g[j+2]-=2;
                }
                if(j<8&&g[j]==1&&g[j+1]>0&&g[j+2]>0){
                    g[j]--;
                    g[j+1]--;
                    g[j+2]--;
                }
                if(b[j]>=3)b[j]-=3;
                if(j<8&&b[j]==2&&b[j+1]>1&&b[j+2]>1){
                    b[j]-=2;
                    b[j+1]-=2;
                    b[j+2]-=2;
                }
                if(j<8&&b[j]==1&&b[j+1]>0&&b[j+2]>0){
                    b[j]--;
                    b[j+1]--;
                    b[j+2]--;
                }
                if(r[j]>=3)r[j]-=3;
                if(j<8&&g[j]==2&&r[j+1]>1&&r[j+2]>1){
                    r[j]-=2;
                    r[j+1]-=2;
                    r[j+2]-=2;
                }
                if(j<8&&r[j]==1&&r[j+1]>0&&r[j+2]>0){
                    r[j]--;
                    r[j+1]--;
                    r[j+2]--;
                }
                if(g[j]>0||b[j]>0||r[j]>0){
                    ch = false;
                    break;
                }   
            }
            if(ch==true)System.out.println(1);
            else System.out.println(0);
            for(j=0;j<=9;j++){
                g[j]=0;
                b[j]=0;
                r[j]=0;
                num[j]=0;
            }
            ch=true;
        }
 
    }
}


</source>
</class>

<class classid="264" nclones="2" nlines="86" similarity="100">
<source file="../hum_codes_raw/s598183861.java" startline="1" endline="103" pcid="20073">

import java.util.*;

import static java.lang.Math.*;
import static java.util.Arrays.*;

public class Main {

	int INF = 1 << 28;
	int MAX = 30;
	double EPS = 1e-5;
	int n, m;
	int s, g;
	int map[][];
	int lim[][];
	
	void run() {
		Scanner sc = new Scanner(System.in);
		for(;;) {
			n = sc.nextInt();
			m = sc.nextInt();
			if( (n|m) == 0 ) break;
			s = sc.nextInt()-1;
			g = sc.nextInt()-1;
			map = new int[n][n];
			lim = new int[n][n];
			for(int i=0;i<m;i++) {
				int a = sc.nextInt()-1;
				int b = sc.nextInt()-1;
				int d = sc.nextInt();
				int l = sc.nextInt();
				map[a][b] = map[b][a] = d;
				lim[a][b] = lim[b][a] = l;
			}
			System.out.println(dijkstra());
		}
	}
	int dv[] = {-1,0,1};
	String dijkstra() {
		double t[][][] = new double[n][n+1][MAX+1];
		for(double[][] a:t ) for(double[] b:  a) fill(b, INF);
		t[s][n][0] = 0;
		PriorityQueue<Pair> que = new PriorityQueue<Pair>(1, new MyComp());
		Pair now = new Pair(s, -1, 1, 0, 0);
		que.add(now);
		for(;!que.isEmpty();) {
			now = que.remove();
//			debug(que);
//			debug(now.p, now.past_p, now.v, now.t);
			if( now.p == g && now.past_v == 1 ) return String.valueOf(now.t);
			if( 0 == now.v ) continue;
			for(int i=0;i<n;i++) {
				if( map[now.p][i] == 0 || now.p == i || now.past_p == i) continue;
				if( now.v > lim[now.p][i] ) continue;
				double time = now.t + (double)map[now.p][i] / now.v;
//				debug(now.p, i, map[now.p][i]*1.0/now.v);
				if(time < t[i][now.p][now.v]) {
					for(int j=0;j<3;j++) {
						if( now.v + dv[j] >= 0 ) {					
							que.add(new Pair(i, now.p, now.v+dv[j], now.v, time));
//							debug(i, now.p, now.v+dv[j], time);
						}
					}
					t[i][now.p][now.v] = time;
				}
			}
		}
		return "unreachable";
	}
	
	class Pair {
		int p, v, past_p, past_v;
		double t;
		Pair(int p, int past_p, int v, int past_v, double t) {
			this.p = p;
			this.v = v;
			this.t = t;
			this.past_p = past_p;
			this.past_v = past_v;
		}
	}
	
	class MyComp implements Comparator<Pair> {

		@Override
		public int compare(Pair o1, Pair o2) {
			// TODO 
			if(o1.t > o2.t ) return 1;
			else if(o1.t < o2.t) return -1;
			return o1.v - o2.v;
		}
		
	}

	public static void main(String[] args) {
		new Main().run();
	}

	void debug(Object... os) {
		System.err.println(Arrays.deepToString(os));
	}
}

</source>
<source file="../hum_codes_raw/s797920347.java" startline="1" endline="103" pcid="26808">

import java.util.*;

import static java.lang.Math.*;
import static java.util.Arrays.*;

public class Main {

	int INF = 1 << 28;
	int MAX = 30;
	double EPS = 1e-5;
	int n, m;
	int s, g;
	int map[][];
	int lim[][];
	
	void run() {
		Scanner sc = new Scanner(System.in);
		for(;;) {
			n = sc.nextInt();
			m = sc.nextInt();
			if( (n|m) == 0 ) break;
			s = sc.nextInt()-1;
			g = sc.nextInt()-1;
			map = new int[n][n];
			lim = new int[n][n];
			for(int i=0;i<m;i++) {
				int a = sc.nextInt()-1;
				int b = sc.nextInt()-1;
				int d = sc.nextInt();
				int l = sc.nextInt();
				map[a][b] = map[b][a] = d;
				lim[a][b] = lim[b][a] = l;
			}
			System.out.println(dijkstra());
		}
	}
	int dv[] = {-1,0,1};
	String dijkstra() {
		double t[][][] = new double[n][n+1][MAX+1];
		for(double[][] a:t ) for(double[] b:  a) fill(b, INF);
		t[s][n][0] = 0;
		PriorityQueue<Pair> que = new PriorityQueue<Pair>(1, new MyComp());
		Pair now = new Pair(s, -1, 1, 0, 0);
		que.add(now);
		for(;!que.isEmpty();) {
			now = que.remove();
//			debug(que);
//			debug(now.p, now.past_p, now.v, now.t);
			if( now.p == g && now.past_v == 1 ) return String.valueOf(now.t);
			if( 0 == now.v ) continue;
			for(int i=0;i<n;i++) {
				if( map[now.p][i] == 0 || now.p == i || now.past_p == i) continue;
				if( now.v > lim[now.p][i] ) continue;
				double time = now.t + (double)map[now.p][i] / now.v;
//				debug(now.p, i, map[now.p][i]*1.0/now.v);
				if(time < t[i][now.p][now.v]) {
					for(int j=0;j<3;j++) {
						if( now.v + dv[j] >= 0 ) {					
							que.add(new Pair(i, now.p, now.v+dv[j], now.v, time));
//							debug(i, now.p, now.v+dv[j], time);
						}
					}
					t[i][now.p][now.v] = time;
				}
			}
		}
		return "unreachable";
	}
	
	class Pair {
		int p, v, past_p, past_v;
		double t;
		Pair(int p, int past_p, int v, int past_v, double t) {
			this.p = p;
			this.v = v;
			this.t = t;
			this.past_p = past_p;
			this.past_v = past_v;
		}
	}
	
	class MyComp implements Comparator<Pair> {

		@Override
		public int compare(Pair o1, Pair o2) {
			// TODO 
			if(o1.t > o2.t ) return 1;
			else if(o1.t < o2.t) return -1;
			return o1.v - o2.v;
		}
		
	}

	public static void main(String[] args) {
		new Main().run();
	}

	void debug(Object... os) {
		System.err.println(Arrays.deepToString(os));
	}
}

</source>
</class>

<class classid="265" nclones="2" nlines="56" similarity="100">
<source file="../hum_codes_raw/s602264455.java" startline="1" endline="69" pcid="20223">
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		try(Scanner sc = new Scanner(System.in)){
			int V=sc.nextInt();//
			int E=sc.nextInt();//
			int s;//
			int t;//
			double[][] dist=new double[V+1][V+1];//(st)
			double[][] dp=new double[1<<V][V];
			double INF=1e100;
			
			for(int i=0; i<V; i++) {
				for(int j=0; j<V; j++) {
					dist[i][j]=INF;
				}
			}
			
			for(int i=0; i<E; i++) {
				s=sc.nextInt();
				t=sc.nextInt();
				dist[s][t]=sc.nextInt();
			}
			for(int i=0; i<(1<<V); i++) {
				for(int j=0; j<V; j++) {
					dp[i][j]=INF;
				}
			}
			dp[1][0]=0;//0
			
			for(int i=0; i<(1<<V); i++) {
				for(int j=0; j<V; j++) {//j
					if(dp[i][j]==INF) continue;
					for(int k=0; k<V; k++) {//k
						if((1&i>>k)==1) continue;//
						else if(dist[j][k]==INF) continue;//
						int nexti = i| (1<<k);//bitOR() 
						//System.out.printf("nexti=%d\n", nexti);
						double nextd=dp[i][j]+dist[j][k];
						dp[nexti][k]=Math.min(dp[nexti][k], nextd);
					}
				}
			}
//			for(int i=0; i<(1<<V); i++) {
//				for(int j=0; j<V; j++) {
//					System.out.printf("dp[%d][%d]=%f\n", i, j, dp[i][j]);
//				}
//			}
			int all=(1<<V)-1;//bit
			double ret=INF;
			for(int i=0; i<V; i++) {//0
				if(dp[all][i]==INF) {
					continue;
				}
				else if(dist[i][0]==INF) continue;//0
				double temp = dp[all][i]+dist[i][0];
				ret=Math.min(ret, temp);
			}
			if(ret==INF) {
				ret=-1;
			}//bit
			System.out.println((int)ret);
			

		}
	}
}

</source>
<source file="../hum_codes_raw/s884803887.java" startline="1" endline="69" pcid="29747">
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		try(Scanner sc = new Scanner(System.in)){
			int V=sc.nextInt();//
			int E=sc.nextInt();//
			int s;//
			int t;//
			double[][] dist=new double[V+1][V+1];//(st)
			double[][] dp=new double[1<<V][V];
			double INF=1e100;
			
			for(int i=0; i<V; i++) {
				for(int j=0; j<V; j++) {
					dist[i][j]=INF;
				}
			}
			
			for(int i=0; i<E; i++) {
				s=sc.nextInt();
				t=sc.nextInt();
				dist[s][t]=sc.nextInt();
			}
			for(int i=0; i<(1<<V); i++) {
				for(int j=0; j<V; j++) {
					dp[i][j]=INF;
				}
			}
			dp[1][0]=0;//0
			
			for(int i=0; i<(1<<V); i++) {
				for(int j=0; j<V; j++) {//j
					if(dp[i][j]==INF) continue;
					for(int k=0; k<V; k++) {//k
						if((1&i>>k)==1) continue;//
						else if(dist[j][k]==INF) continue;//
						int nexti = i| (1<<k);//bitOR() 
						//System.out.printf("nexti=%d\n", nexti);
						double nextd=dp[i][j]+dist[j][k];
						dp[nexti][k]=Math.min(dp[nexti][k], nextd);
					}
				}
			}
//			for(int i=0; i<(1<<V); i++) {
//				for(int j=0; j<V; j++) {
//					System.out.printf("dp[%d][%d]=%f\n", i, j, dp[i][j]);
//				}
//			}
			int all=(1<<V)-1;//bit
			double ret=INF;
			for(int i=0; i<V; i++) {//0
				if(dp[all][i]==INF) {
					continue;
				}
				else if(dist[i][0]==INF) continue;//0
				double temp = dp[all][i]+dist[i][0];
				ret=Math.min(ret, temp);
			}
			if(ret==INF) {
				ret=-1;
			}//bit
			System.out.println((int)ret);
			

		}
	}
}

</source>
</class>

<class classid="266" nclones="2" nlines="84" similarity="100">
<source file="../hum_codes_raw/s603191053.java" startline="1" endline="52" pcid="20253">
import java.util.*;
import java.io.*;

public class Main{

static BufferedReader s1;
static BufferedWriter out;
static String read() throws IOException{String line="";while(line.length()==0){line=s1.readLine();continue;}return line;}
static int int_v (String s1){return Integer.parseInt(s1);}
static long long_v(String s1){return Long.parseLong(s1);}
static int[] int_arr() throws IOException{String[] a=read().split("\\s+");int[] b=new int[a.length];for(int i=0;i<a.length;i++){b[i]=int_v(a[i]);}return b;}
static long[] long_arr() throws IOException{String[] a=read().split("\\s+");long[] b=new long[a.length];for(int i=0;i<a.length;i++){b[i]=long_v(a[i]);}return b;}
static void assign(){s1=new BufferedReader(new InputStreamReader(System.in));out=new BufferedWriter(new OutputStreamWriter(System.out));}
static long Modpow(long a,long p,long m){long res=1;while(p>0){if((p&1)!=0){res=(res*a)%m;}p >>=1;a=(a*a)%m;}return res;}
//......................................@uthor_Alx..............................................
static long mod=(long)1e9+7;
static long rec(long x, Map<Long,Long> map,long[][] op,long d){
    if(x<=0l){
        map.put(0l,0l); return 0l;
    }
    if(map.get(x)!=null) return map.get(x);
    long n=x;
    map.put(x,(long)4e18);
    if((map.get(x)+d-1)/d>n) map.put(x,d*n);
    for(int i=0;i<3;i++){
        if(x%op[i][0]==0){
            map.put(x,Math.min(map.get(x),rec(x/op[i][0],map,op,d)+op[i][1]));
        }
        else{
            map.put(x,Math.min(map.get(x),d*(x%op[i][0])+rec(x/op[i][0],map,op,d)+op[i][1]));
            map.put(x,Math.min(map.get(x),d*(op[i][0]-x%op[i][0])+rec(x/op[i][0]+1,map,op,d)+op[i][1]));
        }
    }
    
     return map.get(n);
}
public static void main(String[] args) throws  IOException{
                assign();
                int t=int_v(read());
               while(t--!=0){
                     long[] x=long_arr();
                     long n=x[0],a=x[1],b=x[2],c=x[3],d=x[4];
                     Map<Long,Long> map=new HashMap<>();
                     long[][] op=new long[][]{{2l,a},{3l,b},{5l,c}};
                     out.write(rec(n,map,op,d)+"\n");
               }

                out.flush();

    }
}

</source>
<source file="../hum_codes_raw/s814948591.java" startline="1" endline="52" pcid="27373">
import java.util.*;
import java.io.*;

public class Main{

static BufferedReader s1;
static BufferedWriter out;
static String read() throws IOException{String line="";while(line.length()==0){line=s1.readLine();continue;}return line;}
static int int_v (String s1){return Integer.parseInt(s1);}
static long long_v(String s1){return Long.parseLong(s1);}
static int[] int_arr() throws IOException{String[] a=read().split("\\s+");int[] b=new int[a.length];for(int i=0;i<a.length;i++){b[i]=int_v(a[i]);}return b;}
static long[] long_arr() throws IOException{String[] a=read().split("\\s+");long[] b=new long[a.length];for(int i=0;i<a.length;i++){b[i]=long_v(a[i]);}return b;}
static void assign(){s1=new BufferedReader(new InputStreamReader(System.in));out=new BufferedWriter(new OutputStreamWriter(System.out));}
static long Modpow(long a,long p,long m){long res=1;while(p>0){if((p&1)!=0){res=(res*a)%m;}p >>=1;a=(a*a)%m;}return res;}
//......................................@uthor_Alx..............................................
static long mod=(long)1e9+7;
static long rec(long x, Map<Long,Long> map,long[][] op,long d){
    if(x<=0l){
        map.put(0l,0l); return 0l;
    }
    if(map.get(x)!=null) return map.get(x);
    long n=x;
    map.put(x,(long)4e18);
    if((map.get(x)+d-1)/d>n) map.put(x,d*n);
    for(int i=0;i<3;i++){
        if(x%op[i][0]==0){
            map.put(x,Math.min(map.get(x),rec(x/op[i][0],map,op,d)+op[i][1]));
        }
        else{
            map.put(x,Math.min(map.get(x),d*(x%op[i][0])+rec(x/op[i][0],map,op,d)+op[i][1]));
            map.put(x,Math.min(map.get(x),d*(op[i][0]-x%op[i][0])+rec(x/op[i][0]+1,map,op,d)+op[i][1]));
        }
    }
    
     return map.get(n);
}
public static void main(String[] args) throws  IOException{
                assign();
                int t=int_v(read());
               while(t--!=0){
                     long[] x=long_arr();
                     long n=x[0],a=x[1],b=x[2],c=x[3],d=x[4];
                     Map<Long,Long> map=new HashMap<>();
                     long[][] op=new long[][]{{2l,a},{3l,b},{5l,c}};
                     out.write(rec(n,map,op,d)+"\n");
               }

                out.flush();

    }
}

</source>
</class>

<class classid="267" nclones="2" nlines="34" similarity="100">
<source file="../hum_codes_raw/s606960694.java" startline="1" endline="51" pcid="20391">
import java.util.*;
import java.awt.geom.*;

public class Main{
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);

		while(true){
			int n = sc.nextInt();
			if(n == 0) break;
			Point2D[] p = new Point2D[n];

			for(int i=0;i<n;i++){
				String[] s = sc.next().split(",");
				p[i] = new Point2D.Double(Double.parseDouble(s[0]), Double.parseDouble(s[1]));
			}

			System.out.println(p.length - convexHull(p).length);
		}
	}

	public static Point2D[] convexHull(Point2D[] ps) {        
		Arrays.sort(ps , new Comparator< Point2D >() {
				public int compare(Point2D o1, Point2D o2) {
					if(o1.getX() < o2.getX()) return -1;
					else if(o1.getX() > o2.getX()) return 1;
					else if(o1.getY() < o2.getY()) return -1;
					else if(o1.getY() > o2.getY()) return 1;
					else return 0;        
				}
			});
		int n = ps.length, k = 0;
		Point2D[] ch = new Point2D[2 * n];

		for (int i = 0; i < n; ch[k++] = ps[i++])
			while (k >= 2
						 && Line2D.relativeCCW(ch[k - 2].getX(), ch[k - 2].getY(),
																	 ch[k - 1].getX(), ch[k - 1].getY(), ps[i].getX(),
																	 ps[i].getY()) <= 0)
				k--;

		for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])
			while (k >= t
						 && Line2D.relativeCCW(ch[k - 2].getX(), ch[k - 2].getY(),
																	 ch[k - 1].getX(), ch[k - 1].getY(), ps[i].getX(),
																	 ps[i].getY()) <= 0)
				k--;
		return Arrays.copyOf(ch, k - 1);
	}
}

</source>
<source file="../hum_codes_raw/s792253704.java" startline="1" endline="51" pcid="26618">
import java.util.*;
import java.awt.geom.*;

public class Main{
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);

		while(true){
			int n = sc.nextInt();
			if(n == 0) break;
			Point2D[] p = new Point2D[n];

			for(int i=0;i<n;i++){
				String[] s = sc.next().split(",");
				p[i] = new Point2D.Double(Double.parseDouble(s[0]), Double.parseDouble(s[1]));
			}

			System.out.println(p.length - convexHull(p).length);
		}
	}

	public static Point2D[] convexHull(Point2D[] ps) {        
		Arrays.sort(ps , new Comparator< Point2D >() {
				public int compare(Point2D o1, Point2D o2) {
					if(o1.getX() < o2.getX()) return -1;
					else if(o1.getX() > o2.getX()) return 1;
					else if(o1.getY() < o2.getY()) return -1;
					else if(o1.getY() > o2.getY()) return 1;
					else return 0;        
				}
			});
		int n = ps.length, k = 0;
		Point2D[] ch = new Point2D[2 * n];

		for (int i = 0; i < n; ch[k++] = ps[i++])
			while (k >= 2
						 && Line2D.relativeCCW(ch[k - 2].getX(), ch[k - 2].getY(),
																	 ch[k - 1].getX(), ch[k - 1].getY(), ps[i].getX(),
																	 ps[i].getY()) <= 0)
				k--;

		for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])
			while (k >= t
						 && Line2D.relativeCCW(ch[k - 2].getX(), ch[k - 2].getY(),
																	 ch[k - 1].getX(), ch[k - 1].getY(), ps[i].getX(),
																	 ps[i].getY()) <= 0)
				k--;
		return Arrays.copyOf(ch, k - 1);
	}
}

</source>
</class>

<class classid="268" nclones="2" nlines="26" similarity="100">
<source file="../hum_codes_raw/s609863463.java" startline="1" endline="33" pcid="20490">
import java.util.*;
 
public class Main {
     
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
         
        while(sc.hasNext()){
            int n = sc.nextInt();
            for(int k=0;k<n;k++){
                String s = sc.next();
                int[] num = new int[8];
 
                for(int i=0;i<8;i++){
                    num[i] = Integer.valueOf(s.substring(i,i+1));
                }
                Arrays.sort(num);
                int a = 0;
                int b = 0;
                int c = 1;
                for(int i=0;i<8;i++){
                    a += num[i]*c;
                    b += num[7-i]*c;
                    c *= 10;
                }
                System.out.println(a-b);
                 
            }
        }
     
    }   
}

</source>
<source file="../hum_codes_raw/s767590340.java" startline="1" endline="33" pcid="25773">
import java.util.*;

public class Main {
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		while(sc.hasNext()){
			int n = sc.nextInt();
			for(int k=0;k<n;k++){
				String s = sc.next();
				int[] num = new int[8];

				for(int i=0;i<8;i++){
					num[i] = Integer.valueOf(s.substring(i,i+1));
				}
				Arrays.sort(num);
				int a = 0;
				int b = 0;
				int c = 1;
				for(int i=0;i<8;i++){
					a += num[i]*c;
					b += num[7-i]*c;
					c *= 10;
				}
				System.out.println(a-b);
				
			}
		}
	
	}	
}

</source>
</class>

<class classid="269" nclones="3" nlines="10" similarity="100">
<source file="../hum_codes_raw/s624782978.java" startline="1" endline="16" pcid="20976">
import java.util.Scanner;

public class Main {
  public static void main(String[] args) {
    Scanner scanner = new Scanner(System.in);

    // abh
    int a = scanner.nextInt();
    int b = scanner.nextInt();
    int h = scanner.nextInt();

    // ( + ) *  / 2
    System.out.println((a + b) * h / 2);
  }
}

</source>
<source file="../hum_codes_raw/s854014023.java" startline="1" endline="13" pcid="28709">
import java.util.Scanner;

public class Main {
  public static void main(String[] args) {
    Scanner scanner = new Scanner(System.in);
    int a = scanner.nextInt();
    int b = scanner.nextInt();
    int h = scanner.nextInt();
    
    System.out.println((a + b) * h / 2);
  }
}

</source>
<source file="../hum_codes_raw/s789025168.java" startline="1" endline="17" pcid="26490">
import java.util.Scanner;

/**
 * archeryue
 * 9/19/16
 */
public class Main {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int a = scanner.nextInt();
        int b = scanner.nextInt();
        int h = scanner.nextInt();
        System.out.println((a + b) * h / 2);
    }
}

</source>
</class>

<class classid="270" nclones="2" nlines="149" similarity="100">
<source file="../hum_codes_raw/s626787143.java" startline="1" endline="181" pcid="21034">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 27);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            DYetAnotherPalindromePartitioning solver = new DYetAnotherPalindromePartitioning();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class DYetAnotherPalindromePartitioning {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            char[] s = new char[(int) 2e5];
            int n = in.readString(s, 0);
            int charset = 'z' - 'a' + 1;
            int[] dp = new int[1 << charset];
            int inf = (int) 1e8;
            Arrays.fill(dp, inf);
            int pre = 0;
            dp[pre] = 0;
            for (int i = 0; i < n; i++) {
                int x = s[i] - 'a';
                int bit = 1 << x;
                pre ^= bit;

                int ans = inf;
                ans = Math.min(ans, dp[pre] + 1);
                for (int j = 0; j < charset; j++) {
                    ans = Math.min(ans, dp[pre ^ (1 << j)] + 1);
                }
                dp[pre] = Math.min(dp[pre], ans);

                if (i == n - 1) {
                    out.println(ans);
                    return;
                }
            }
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readString(char[] data, int offset) {
            skipBlank();

            int originalOffset = offset;
            while (next > 32) {
                data[offset++] = (char) next;
                next = read();
            }

            return offset - originalOffset;
        }

    }
}

</source>
<source file="../hum_codes_raw/s838965784.java" startline="1" endline="182" pcid="28167">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.io.Closeable;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(null, new TaskAdapter(), "", 1 << 27);
        thread.start();
        thread.join();
    }

    static class TaskAdapter implements Runnable {
        @Override
        public void run() {
            InputStream inputStream = System.in;
            OutputStream outputStream = System.out;
            FastInput in = new FastInput(inputStream);
            FastOutput out = new FastOutput(outputStream);
            DYetAnotherPalindromePartitioning solver = new DYetAnotherPalindromePartitioning();
            solver.solve(1, in, out);
            out.close();
        }
    }

    static class DYetAnotherPalindromePartitioning {
        public void solve(int testNumber, FastInput in, FastOutput out) {
            char[] s = new char[(int) 2e5];
            int n = in.readString(s, 0);
            int charset = 'z' - 'a' + 1;
            int[] dp = new int[1 << charset];
            int inf = (int) 1e8;
            Arrays.fill(dp, inf);
            int pre = 0;
            dp[pre] = 0;
            for (int i = 0; i < n; i++) {
                int x = s[i] - 'a';
                int bit = 1 << x;
                pre ^= bit;

                int ans = inf;
                ans = Math.min(ans, dp[pre] + 1);
                for (int j = 0; j < charset; j++) {
                    ans = Math.min(ans, dp[pre ^ (1 << j)] + 1);
                }
                dp[pre] = Math.min(dp[pre], ans);

                if (i == n - 1) {
                    out.println(ans);
                    return;
                }
            }
        }

    }

    static class FastOutput implements AutoCloseable, Closeable, Appendable {
        private StringBuilder cache = new StringBuilder(10 << 20);
        private final Writer os;

        public FastOutput append(CharSequence csq) {
            cache.append(csq);
            return this;
        }

        public FastOutput append(CharSequence csq, int start, int end) {
            cache.append(csq, start, end);
            return this;
        }

        public FastOutput(Writer os) {
            this.os = os;
        }

        public FastOutput(OutputStream os) {
            this(new OutputStreamWriter(os));
        }

        public FastOutput append(char c) {
            cache.append(c);
            return this;
        }

        public FastOutput append(int c) {
            cache.append(c);
            return this;
        }

        public FastOutput println(int c) {
            return append(c).println();
        }

        public FastOutput println() {
            cache.append(System.lineSeparator());
            return this;
        }

        public FastOutput flush() {
            try {
                os.append(cache);
                os.flush();
                cache.setLength(0);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
            return this;
        }

        public void close() {
            flush();
            try {
                os.close();
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }

        public String toString() {
            return cache.toString();
        }

    }

    static class FastInput {
        private final InputStream is;
        private byte[] buf = new byte[1 << 13];
        private int bufLen;
        private int bufOffset;
        private int next;

        public FastInput(InputStream is) {
            this.is = is;
        }

        private int read() {
            while (bufLen == bufOffset) {
                bufOffset = 0;
                try {
                    bufLen = is.read(buf);
                } catch (IOException e) {
                    bufLen = -1;
                }
                if (bufLen == -1) {
                    return -1;
                }
            }
            return buf[bufOffset++];
        }

        public void skipBlank() {
            while (next >= 0 && next <= 32) {
                next = read();
            }
        }

        public int readString(char[] data, int offset) {
            skipBlank();

            int originalOffset = offset;
            while (next > 32) {
                data[offset++] = (char) next;
                next = read();
            }

            return offset - originalOffset;
        }

    }
}


</source>
</class>

<class classid="271" nclones="2" nlines="83" similarity="100">
<source file="../hum_codes_raw/s639169281.java" startline="1" endline="123" pcid="21437">
import java.util.*;
import java.io.*;
import java.math.*;

import static java.lang.Math.*;
import static java.util.Arrays.*;
import static java.util.Collections.*;

public class Main{
    static long mod=1000000007;
    // static int dx[]={1,-1,0,0};
    // static int dy[]={0,0,1,-1};
    // static int dx[]={1,-1,0,0,1,1,-1,-1};
    // static int dy[]={0,0,1,-1,1,-1,1,-1};
    // PriorityQueue<Integer> que = new PriorityQueue<Integer>(); 
    //HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();
    //ArrayList<Integer> lis = new ArrayList<Integer>();
    public  static void main(String[] args)   throws Exception, IOException{
        Reader sc = new Reader(System.in);
        PrintWriter out=new PrintWriter(System.out);

        int n=sc.nextInt(),a=0;
        long ans=0,e[]=new long[n];
        for( int i=0; i<n; i++ ){
            e[i] = sc.nextLong();
        }
        while(true){
            sort(e);
            int x=-1;
                if(e[n-1]<n) break;
            long c=e[n-1]/n;
            //db(c,x,e,++a);
            ans+=c;
            for( int i=0; i<n-1; i++ ){
                e[i] += c;
            }
            e[n-1] -= c * n;
        }
        out.println(ans); 
        out.flush();
    }

    static void db(Object... os){
        System.err.println(Arrays.deepToString(os));
    }

    static boolean validpos(int x,int y,int r, int c){
        return x<r && 0<=x && y<c && 0<=y;
    }
     
    static boolean bit(long x,int k){
        // weather k-th bit (from right) be one or zero
        return  ( 0 < ( (x>>k) & 1 )  )  ? true:false;
    }
}

class Pair implements Comparable<Pair>{
    int x,y,id;
    Pair(int x, int y,int id) {
        this.x=x;
        this.y=y;
        this.id=id;
    } 
    public int compareTo(Pair p){
        return p.x -     x;
    } 
}

// class Pair implements Comparable<Pair>{
//     int x,y;
//     Pair(int x, int y) {
//         this.x=x;
//         this.y=y;
//     } 
//     public int compareTo(Pair p){//descend
//         return p.x - x;
//     } 

// }

class P implements Comparable<P>{
    int diff,id1,id2;
    P(int diff, int id1,int id2) {
        this.diff=diff;
        this.id1=id1;
        this.id2=id2;
    } 
      
    public int compareTo(P p){//ascend
        return diff - p.diff;
    } 
}

class Reader
{ 
    private BufferedReader x;
    private StringTokenizer st;
    
    public Reader(InputStream in)
    {
        x = new BufferedReader(new InputStreamReader(in));
        st = null;
    }
    public String nextString() throws IOException
    {
        while( st==null || !st.hasMoreTokens() )
            st = new StringTokenizer(x.readLine());
        return st.nextToken();
    }
    public int nextInt() throws IOException
    {
        return Integer.parseInt(nextString());
    }
    public long nextLong() throws IOException
    {
        return Long.parseLong(nextString());
    }
    public double nextDouble() throws IOException
    {
        return Double.parseDouble(nextString());
    }
}

</source>
<source file="../hum_codes_raw/s957996237.java" startline="1" endline="123" pcid="32198">
import java.util.*;
import java.io.*;
import java.math.*;

import static java.lang.Math.*;
import static java.util.Arrays.*;
import static java.util.Collections.*;

public class Main{
    static long mod=1000000007;
    // static int dx[]={1,-1,0,0};
    // static int dy[]={0,0,1,-1};
    // static int dx[]={1,-1,0,0,1,1,-1,-1};
    // static int dy[]={0,0,1,-1,1,-1,1,-1};
    // PriorityQueue<Integer> que = new PriorityQueue<Integer>(); 
    //HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();
    //ArrayList<Integer> lis = new ArrayList<Integer>();
    public  static void main(String[] args)   throws Exception, IOException{
        Reader sc = new Reader(System.in);
        PrintWriter out=new PrintWriter(System.out);

        int n=sc.nextInt(),a=0;
        long ans=0,e[]=new long[n];
        for( int i=0; i<n; i++ ){
            e[i] = sc.nextLong();
        }
        while(true){
            sort(e);
            int x=-1;
                if(e[n-1]<n) break;
            long c=e[n-1]/n;
            //db(c,x,e,++a);
            ans+=c;
            for( int i=0; i<n-1; i++ ){
                e[i] += c;
            }
            e[n-1] -= c * n;
        }
        out.println(ans); 
        out.flush();
    }

    static void db(Object... os){
        System.err.println(Arrays.deepToString(os));
    }

    static boolean validpos(int x,int y,int r, int c){
        return x<r && 0<=x && y<c && 0<=y;
    }
     
    static boolean bit(long x,int k){
        // weather k-th bit (from right) be one or zero
        return  ( 0 < ( (x>>k) & 1 )  )  ? true:false;
    }
}

class Pair implements Comparable<Pair>{
    int x,y,id;
    Pair(int x, int y,int id) {
        this.x=x;
        this.y=y;
        this.id=id;
    } 
    public int compareTo(Pair p){
        return p.x -     x;
    } 
}

// class Pair implements Comparable<Pair>{
//     int x,y;
//     Pair(int x, int y) {
//         this.x=x;
//         this.y=y;
//     } 
//     public int compareTo(Pair p){//descend
//         return p.x - x;
//     } 

// }

class P implements Comparable<P>{
    int diff,id1,id2;
    P(int diff, int id1,int id2) {
        this.diff=diff;
        this.id1=id1;
        this.id2=id2;
    } 
      
    public int compareTo(P p){//ascend
        return diff - p.diff;
    } 
}

class Reader
{ 
    private BufferedReader x;
    private StringTokenizer st;
    
    public Reader(InputStream in)
    {
        x = new BufferedReader(new InputStreamReader(in));
        st = null;
    }
    public String nextString() throws IOException
    {
        while( st==null || !st.hasMoreTokens() )
            st = new StringTokenizer(x.readLine());
        return st.nextToken();
    }
    public int nextInt() throws IOException
    {
        return Integer.parseInt(nextString());
    }
    public long nextLong() throws IOException
    {
        return Long.parseLong(nextString());
    }
    public double nextDouble() throws IOException
    {
        return Double.parseDouble(nextString());
    }
}

</source>
</class>

<class classid="272" nclones="2" nlines="40" similarity="100">
<source file="../hum_codes_raw/s641161060.java" startline="1" endline="51" pcid="21507">
import java.util.Scanner;
class Main
{
    public static void main(String args[])
    {
	Scanner scan=new Scanner(System.in);
	while(true)
	    {
		int n=scan.nextInt();
		if(n==0)break;
		int s[]=new int[n];
		char x[]=new char[100];
		int f=0;
		String str=scan.next();
		for(int i=0;i<100;i++)
		    {
			x[i]=str.charAt(i);
			if(x[i]=='S')
			    {
				f+=s[i%n]+1;
				s[i%n]=0;
			    }
			else if(x[i]=='M')s[i%n]++;
			else 
			    {
				s[i%n]+=f+1;
				f=0;
			    }
		    }
		for(int i=0;i<n;i++)
		    {
			for(int j=n-1;j>i;j--)
			    {
				if(s[j]<s[j-1])
				    {
				int t=s[j];
				s[j]=s[j-1];
				s[j-1]=t;
				    }
			    }
		    }
		for(int i=0;i<n;i++)
		    {
			System.out.print((i!=n)?s[i]+" ":"");
		    }
		System.out.print(f);
		System.out.println();
	    }
    }
}

</source>
<source file="../hum_codes_raw/s665449186.java" startline="1" endline="51" pcid="22347">
import java.util.Scanner;
class Main
{
    public static void main(String args[])
    {
	Scanner scan=new Scanner(System.in);
	while(true)
	    {
		int n=scan.nextInt();
		if(n==0)break;
		int s[]=new int[n];
		char x[]=new char[100];
		int f=0;
		String str=scan.next();
		for(int i=0;i<100;i++)
		    {
			x[i]=str.charAt(i);
			if(x[i]=='S')
			    {
				f+=s[i%n]+1;
				s[i%n]=0;
			    }
			else if(x[i]=='M')s[i%n]++;
			else 
			    {
				s[i%n]+=f+1;
				f=0;
			    }
		    }
		for(int i=0;i<n;i++)
		    {
			for(int j=n-1;j>i;j--)
			    {
				if(s[j]<s[j-1])
				    {
				int t=s[j];
				s[j]=s[j-1];
				s[j-1]=t;
				    }
			    }
		    }
		for(int i=0;i<n;i++)
		    {
			System.out.print((i!=n)?s[i]+" ":"");
		    }
		System.out.print(f);
		System.out.println();
	    }
    }
}

</source>
</class>

<class classid="273" nclones="2" nlines="91" similarity="100">
<source file="../hum_codes_raw/s647488374.java" startline="1" endline="108" pcid="21738">


import java.util.*;
import java.lang.*;
import java.math.*;
import java.io.*;
 
import static java.lang.Math.*;
import static java.util.Arrays.*;
 
public class Main{
 
    Scanner sc=new Scanner(System.in);;
 
    int INF=1<<28;
    double EPS=1e-9;
 
    int[][] a;
    int w, h;
    boolean[][] visited;
 
    void run(){
        for(;;){
            h=sc.nextInt();
            w=sc.nextInt();
            if((h|w)==0){
                break;
            }
            a=new int[h][w];
            visited=new boolean[h][w];
            for(int j=0; j<h; j++){
                String s=sc.next();
                for(int i=0; i<w; i++){
                    switch(s.charAt(i)){
                    case '@':
                        a[j][i]=0;
                        break;
                    case '#':
                        a[j][i]=1;
                        break;
                    case '*':
                        a[j][i]=2;
                        break;
                    }
                }
            }
            solve();
        }
    }
 
    void solve(){
        int ans=0;
        for(int j=0; j<h; j++){
            for(int i=0; i<w; i++){
                if(!visited[j][i]){
                    ans++;
                    bfs(i, j);
                }
            }
        }
        println(ans+"");
    }
 
    void bfs(int x, int y){
        LinkedList<P> que=new LinkedList<P>();
        que.offer(new P(x, y));
        visited[y][x]=true;
        int[] dx={0, 0, -1, 1};
        int[] dy={-1, 1, 0, 0};
        for(; !que.isEmpty();){
            P p=que.poll();
            for(int i=0; i<4; i++){
                P q=new P(p.x+dx[i], p.y+dy[i]);
                if(q.x>=0&&q.x<w&&q.y>=0&&q.y<h&&!visited[q.y][q.x]
                        &&a[p.y][p.x]==a[q.y][q.x]){
                    que.offer(q);
                    visited[q.y][q.x]=true;
                }
            }
        }
    }
 
    class P{
        int x, y;
 
        P(int x, int y){
            this.x=x;
            this.y=y;
        }
    }
 
    void debug(Object... os){
        System.err.println(Arrays.deepToString(os));
    }
 
    void print(String s){
        System.out.print(s);
    }
 
    void println(String s){
        System.out.println(s);
    }
 
    public static void main(String[] args){
        new Main().run();
    }
}

</source>
<source file="../hum_codes_raw/s686809997.java" startline="1" endline="106" pcid="23074">
import java.util.*;
import java.lang.*;
import java.math.*;
import java.io.*;

import static java.lang.Math.*;
import static java.util.Arrays.*;

public class Main{

	Scanner sc=new Scanner(System.in);;

	int INF=1<<28;
	double EPS=1e-9;

	int[][] a;
	int w, h;
	boolean[][] visited;

	void run(){
		for(;;){
			h=sc.nextInt();
			w=sc.nextInt();
			if((h|w)==0){
				break;
			}
			a=new int[h][w];
			visited=new boolean[h][w];
			for(int j=0; j<h; j++){
				String s=sc.next();
				for(int i=0; i<w; i++){
					switch(s.charAt(i)){
					case '@':
						a[j][i]=0;
						break;
					case '#':
						a[j][i]=1;
						break;
					case '*':
						a[j][i]=2;
						break;
					}
				}
			}
			solve();
		}
	}

	void solve(){
		int ans=0;
		for(int j=0; j<h; j++){
			for(int i=0; i<w; i++){
				if(!visited[j][i]){
					ans++;
					bfs(i, j);
				}
			}
		}
		println(ans+"");
	}

	void bfs(int x, int y){
		LinkedList<P> que=new LinkedList<P>();
		que.offer(new P(x, y));
		visited[y][x]=true;
		int[] dx={0, 0, -1, 1};
		int[] dy={-1, 1, 0, 0};
		for(; !que.isEmpty();){
			P p=que.poll();
			for(int i=0; i<4; i++){
				P q=new P(p.x+dx[i], p.y+dy[i]);
				if(q.x>=0&&q.x<w&&q.y>=0&&q.y<h&&!visited[q.y][q.x]
						&&a[p.y][p.x]==a[q.y][q.x]){
					que.offer(q);
					visited[q.y][q.x]=true;
				}
			}
		}
	}

	class P{
		int x, y;

		P(int x, int y){
			this.x=x;
			this.y=y;
		}
	}

	void debug(Object... os){
		System.err.println(Arrays.deepToString(os));
	}

	void print(String s){
		System.out.print(s);
	}

	void println(String s){
		System.out.println(s);
	}

	public static void main(String[] args){
		new Main().run();
	}
}

</source>
</class>

<class classid="274" nclones="2" nlines="21" similarity="100">
<source file="../hum_codes_raw/s651263458.java" startline="1" endline="23" pcid="21862">
import java.util.Scanner;
 
public class Main {
 
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int a = scanner.nextInt();
        int b = scanner.nextInt();
        int c = scanner.nextInt();
        int d = scanner.nextInt();
        int x = 0;
        int y = 0;
        x = ((n+a-1) / a) * b;
        y = ((n+c-1) / c) * d;
        if (x >= y) {
            System.out.println(y);
        } else {
            System.out.println(x);
        }
    }
}

</source>
<source file="../hum_codes_raw/s916398522.java" startline="1" endline="25" pcid="30816">

import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int a = scanner.nextInt();
        int b = scanner.nextInt();
        int c = scanner.nextInt();
        int d = scanner.nextInt();
        int x = 0;
        int y = 0;
        x = ((n+a-1) / a) * b;
        y = ((n+c-1) / c) * d;
        if (x >= y) {
            System.out.println(y);
        } else {
            System.out.println(x);
        }
    }
}


</source>
</class>

<class classid="275" nclones="2" nlines="28" similarity="100">
<source file="../hum_codes_raw/s655257449.java" startline="1" endline="29" pcid="21998">
import java.util.*;
public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int m = sc.nextInt();
			if(m==0)break;
			int[] a = new int[m+1];
			int[] b = new int[m+1];
			for(int i=1;i<=m;i++){
				a[i] = sc.nextInt();
				b[i] = sc.nextInt();
			}
			int[][] p = new int[m+1][1001];
			p[0][0] = 1;
			for(int i=1;i<=m;i++){
				for(int k=0;k<1001;k++){
					for(int s=0;s<=b[i];s++){
						if(k-a[i]*s<0)break;
						p[i][k] += p[i-1][k-s*a[i]];
					}
				}
			}
			int g = sc.nextInt();
			while(g--!=0)System.out.println(p[m][sc.nextInt()]);
		}
	}
}

</source>
<source file="../hum_codes_raw/s777478378.java" startline="1" endline="29" pcid="26102">
import java.util.*;
public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(true){
			int m = sc.nextInt();
			if(m==0)break;
			int[] a = new int[m+1];
			int[] b = new int[m+1];
			for(int i=1;i<=m;i++){
				a[i] = sc.nextInt();
				b[i] = sc.nextInt();
			}
			int[][] p = new int[m+1][1001];
			p[0][0] = 1;
			for(int i=1;i<=m;i++){
				for(int k=0;k<1001;k++){
					for(int s=0;s<=b[i];s++){
						if(k-a[i]*s<0)break;
						p[i][k] += p[i-1][k-s*a[i]];
					}
				}
			}
			int g = sc.nextInt();
			while(g--!=0)System.out.println(p[m][sc.nextInt()]);
		}
	}
}

</source>
</class>

<class classid="276" nclones="2" nlines="484" similarity="100">
<source file="../hum_codes_raw/s667004134.java" startline="1" endline="645" pcid="22407">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class Main {
	final int _intMax = Integer.MAX_VALUE; // =2147483647>10^9
	final int _intMin = Integer.MIN_VALUE;
	final long _longMax = Long.MAX_VALUE; // =9223372036854775807L>10^18
	final long _longMin = Long.MIN_VALUE;
	final char[] _azAry = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',
			's', 't', 'u', 'v', 'w', 'x', 'y', 'z' };

	void solve() {
		Prime prime = new Prime();
		int n = readNum();
		StringBuilder sb = new StringBuilder();
		for (int i = 11; n > 0; i += 5) {
			if (prime.isPrime(i)) {
				sb.append(i).append(" ");
				n--;
			}
		}
		pln(sb.toString().trim());
	}

	// -----------------------------------------------------
	// 2018/05/06 r27
	// -----------------------------------------------------
	List<Character> getazList() {
		List<Character> list = new ArrayList<>();
		for (char ch : _azAry)
			list.add(ch);
		return list;
	}

	int getDx(int idx) {
		int[] dx = { 0, 1, 1, 1, 0, -1, -1, -1 };
		return dx[idx];
	}

	int getDy(int idx) {
		int[] dy = { -1, -1, 0, 1, 1, 1, 0, -1 };
		return dy[idx];
	}

	class Bitmap {
		int mx;
		int my;
		boolean[][] map;

		public Bitmap(int mx, int my) {
			this.mx = mx;
			this.my = my;
			map = new boolean[my + 2][mx + 2];
		}

		public boolean is(int x, int y) {
			return map[y][x];
		}

		public void set(int x, int y, boolean b) {
			map[y][x] = b;
		}
	}

	class CharList implements Iterable<Character> {
		class CharComparator implements Comparator<Character> {
			int sign;

			public CharComparator(boolean bAsc) {
				sign = bAsc ? 1 : -1;
			}

			public int compare(Character o1, Character o2) {
				return sign * Character.compare(o1, o2);
			}
		}

		List<Character> list = new ArrayList<>();
		CharComparator asc = new CharComparator(true);
		CharComparator desc = new CharComparator(false);

		public void add(char ch) {
			list.add(ch);
		}

		public char get(int idx) {
			return list.get(idx);
		}

		public char getLast() {
			return list.get(list.size() - 1);
		}

		public Iterator<Character> iterator() {
			return list.iterator();
		}

		public void remove(int idx) {
			list.remove(idx);
		}

		public void removeLast() {
			list.remove(list.size() - 1);
		}

		public int size() {
			return list.size();
		}

		public void sort(boolean bAsc) {
			if (bAsc)
				Collections.sort(list, asc);
			else
				Collections.sort(list, desc);
		}

		public String toString() {
			StringBuilder sb = new StringBuilder();
			for (char ch : list)
				sb.append(ch);
			return sb.toString();
		}
	}

	class Counter<K> {
		Map<K, Integer> map = new HashMap<>();

		public Counter() {
		}

		public Counter(Iterable<K> itr) {
			for (K obj : itr) {
				add(obj);
			}
		}

		public void add(K key) {
			Integer cnt = map.get(key);
			if (cnt == null)
				map.put(key, 1);
			else
				map.put(key, cnt + 1);
		}

		public int get(K key) {
			Integer cnt = map.get(key);
			if (cnt == null)
				return 0;
			else
				return cnt;
		}

		public Set<K> keySet() {
			return map.keySet();
		}
	}

	class IntList implements Iterable<Integer> {
		class Info {
			int idx;
			int val;

			public Info(int idx, int val) {
				this.idx = idx;
				this.val = val;
			}

			public String toString() {
				return "(" + idx + ", " + val + ")";
			}
		}

		class InfoComparator implements Comparator<Info> {
			int sign;

			public InfoComparator(boolean bAsc) {
				sign = bAsc ? 1 : -1;
			}

			public int compare(Info o1, Info o2) {
				return sign * Integer.compare(o1.val, o2.val);
			}
		}

		List<Info> list = new ArrayList<>();
		InfoComparator asc = new InfoComparator(true);
		InfoComparator desc = new InfoComparator(false);

		public IntList() {
		}

		public IntList(int[] ia) {
			for (int i = 0; i < ia.length; i++)
				add(ia[i]);
		}

		public void add(int val) {
			list.add(new Info(list.size(), val));
		}

		public void add(int idx, int val) {
			list.add(new Info(idx, val));
		}

		public int getIdx(int idx) {
			return list.get(idx).idx;
		}

		public int getVal(int idx) {
			return list.get(idx).val;
		}

		public int getLastVal() {
			return list.get(list.size() - 1).val;
		}

		public Iterator<Integer> iterator() {
			List<Integer> vallist = new ArrayList<>();
			for (Info info : list)
				vallist.add(info.val);
			return vallist.iterator();
		}

		public void remove(int idx) {
			list.remove(idx);
		}

		public void removeLast() {
			list.remove(list.size() - 1);
		}

		public int size() {
			return list.size();
		}

		public void sort(boolean bAsc) {
			if (bAsc)
				Collections.sort(list, asc);
			else
				Collections.sort(list, desc);
		}
	}

	class Point {
		int x;
		int y;

		public Point(int x, int y) {
			this.x = x;
			this.y = y;
		}

		public Point(Point pt) {
			this.x = pt.x;
			this.y = pt.y;
		}

		public boolean equals(Object o) {
			if (o instanceof Point) {
				Point that = (Point) o;
				return (x == that.x) && (y == that.y);
			}
			return false;
		}

		public long getManhattanDistance(Point pt) {
			return abs((long) pt.x - this.x) + abs((long) pt.y - this.y);
		}

		public int hashCode() {
			return x + (y * 31);
		}

		public String toString() {
			return "(" + x + ", " + y + ")";
		}
	}

	class PointList implements Iterable<Point> {
		class PointComparator implements Comparator<Point> {
			int mode;

			public PointComparator(int prop, boolean bAsc) {
				switch (prop) {
				case 1:
					if (bAsc)
						this.mode = 11;
					else
						this.mode = 12;
					break;
				case 2:
					if (bAsc)
						this.mode = 21;
					else
						this.mode = 22;
					break;
				default:
					throw new RuntimeException();
				}
			}

			public int compare(Point p1, Point p2) {
				switch (mode) {
				case 11:
					return 1 * Integer.compare(p1.x, p2.x);
				case 12:
					return -1 * Integer.compare(p1.x, p2.x);
				case 21:
					return 1 * Integer.compare(p1.y, p2.y);
				case 22:
					return -1 * Integer.compare(p1.y, p2.y);
				}
				throw new IllegalStateException();
			}
		}

		List<Point> list = new ArrayList<>();

		public void add(int x, int y) {
			list.add(new Point(x, y));
		}

		public Point get(int idx) {
			return list.get(idx);
		}

		public Iterator<Point> iterator() {
			return list.iterator();
		}

		public void remove(int idx) {
			list.remove(idx);
		}

		public int size() {
			return list.size();
		}

		public void sort(int prop, boolean bAsc) {
			PointComparator c = new PointComparator(prop, bAsc);
			Collections.sort(list, c);
		}
	}

	class Prime {
		final int maxPrime = 1000;
		final int[] prime = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,
				89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193,
				197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313,
				317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443,
				449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587,
				593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719,
				727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859,
				863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997 };
		final Set<Integer> primeSet = new HashSet<>();

		Prime() {
			for (int p : prime)
				primeSet.add(p);
		}

		boolean isPrime(int n) {
			if (n <= maxPrime)
				return primeSet.contains(n);
			for (int i : prime) {
				if (n % i == 0)
					return false;
			}
			int sqrtNum = (int) Math.ceil(Math.sqrt(n));
			for (int i = maxPrime + 1; i <= sqrtNum; i += 2) {
				if (n % i == 0)
					return false;
			}
			return true;
		}
	}

	class StrList implements Iterable<String> {
		class StrComparator implements Comparator<String> {
			int sign;

			public StrComparator(boolean bAsc) {
				sign = bAsc ? 1 : -1;
			}

			public int compare(String o1, String o2) {
				return sign * o1.compareTo(o2);
			}
		}

		List<String> list = new ArrayList<>();
		StrComparator asc = new StrComparator(true);
		StrComparator desc = new StrComparator(false);

		public StrList() {
		}

		public StrList(String[] sa) {
			for (int i = 0; i < sa.length; i++)
				list.add(sa[i]);
		}

		public void add(String s) {
			list.add(s);
		}

		public String get(int idx) {
			return list.get(idx);
		}

		public Iterator<String> iterator() {
			return list.iterator();
		}

		public int size() {
			return list.size();
		}

		public void sort(boolean bAsc) {
			if (bAsc)
				Collections.sort(list, asc);
			else
				Collections.sort(list, desc);
		}
	}

	int abs(int a) {
		return (a >= 0) ? a : -a;
	}

	long abs(long a) {
		return (a >= 0) ? a : -a;
	}

	long ceil(long a, long b) {
		if (a < 0) {
			return -1 * floor(-a, b);
		}
		return ((a + b - 1) / b) * b;
	}

	long floor(long a, long b) {
		if (a < 0) {
			return -1 * ceil(-a, b);
		}
		return (a / b) * b;
	}

	int max(int a, int b) {
		return (a > b) ? a : b;
	}

	long max(long a, long b) {
		return (a > b) ? a : b;
	}

	int min(int a, int b) {
		return (a < b) ? a : b;
	}

	long min(long a, long b) {
		return (a < b) ? a : b;
	}

	int reed(long a, int n) {
		while (n-- > 0)
			a /= 10;
		return (int) (a % 10);
	}

	int sqrt(long a) {
		return (int) Math.sqrt(a);
	}

	int pint(String s) {
		return Integer.parseInt(s);
	}

	long plong(String s) {
		return Long.parseLong(s);
	}

	String readLine() {
		try {
			return _in.readLine();
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}

	int readNum() {
		String line = readLine();
		return pint(line);
	}

	long readLong() {
		String line = readLine();
		return plong(line);
	}

	String[] readFlds() {
		String line = readLine();
		return line.split(" ");
	}

	String[] readLines(int n) {
		String[] lines = new String[n];
		for (int i = 0; i < n; i++)
			lines[i] = readLine();
		return lines;
	}

	CharList readChars() {
		CharList list = new CharList();
		String line = readLine();
		for (int i = 0; i < line.length(); i++)
			list.add(line.charAt(i));
		return list;
	}

	int[] readNums() {
		String[] flds = readFlds();
		int[] nums = new int[flds.length];
		for (int i = 0; i < flds.length; i++)
			nums[i] = pint(flds[i]);
		return nums;
	}

	int[] readNums(int n) {
		int[] nums = new int[n];
		for (int i = 0; i < n; i++)
			nums[i] = readNum();
		return nums;
	}

	long[] readLongs() {
		String[] flds = readFlds();
		long[] nums = new long[flds.length];
		for (int i = 0; i < flds.length; i++)
			nums[i] = plong(flds[i]);
		return nums;
	}

	long[] readLongs(int n) {
		long[] nums = new long[n];
		for (int i = 0; i < n; i++)
			nums[i] = readLong();
		return nums;
	}

	Main pln() {
		_out.println();
		return this;
	}

	Main p(char c) {
		_out.print(c);
		return this;
	}

	Main p(char c, int n) {
		for (int i = 0; i < n; i++)
			p(c);
		return this;
	}

	Main pln(char c) {
		_out.println(c);
		return this;
	}

	Main p(double d) {
		_out.print(d);
		return this;
	}

	Main pln(double d) {
		_out.println(d);
		return this;
	}

	Main p(long l) {
		_out.print(l);
		return this;
	}

	Main pln(long l) {
		_out.println(l);
		return this;
	}

	Main p(String s) {
		_out.print(s);
		return this;
	}

	Main p(String s, int idx) {
		_out.print(s.charAt(idx));
		return this;
	}

	Main pln(String s) {
		_out.println(s);
		return this;
	}

	Main pln(int[] ia) {
		for (int i = 0; i < ia.length; i++)
			_out.println(ia[i]);
		return this;
	}

	Main pln(long[] la) {
		for (int i = 0; i < la.length; i++)
			_out.println(la[i]);
		return this;
	}

	static BufferedReader _in;
	static PrintWriter _out;
	static boolean _bElapsed = false;

	public static void main(String[] args) {
		long start = System.currentTimeMillis();
		_in = new BufferedReader(new InputStreamReader(System.in));
		_out = new PrintWriter(System.out);
		new Main().solve();
		_out.flush();
		long end = System.currentTimeMillis();
		if (_bElapsed)
			System.err.println((end - start) + "ms");
	}
}

</source>
<source file="../hum_codes_raw/s743962494.java" startline="1" endline="645" pcid="24990">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class Main {
	final int _intMax = Integer.MAX_VALUE; // =2147483647>10^9
	final int _intMin = Integer.MIN_VALUE;
	final long _longMax = Long.MAX_VALUE; // =9223372036854775807L>10^18
	final long _longMin = Long.MIN_VALUE;
	final char[] _azAry = { 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',
			's', 't', 'u', 'v', 'w', 'x', 'y', 'z' };

	void solve() {
		Prime prime = new Prime();
		int n = readNum();
		StringBuilder sb = new StringBuilder();
		for (int i = 11; n > 0; i += 5) {
			if (prime.isPrime(i)) {
				sb.append(i).append(" ");
				n--;
			}
		}
		pln(sb.toString().trim());
	}

	// -----------------------------------------------------
	// 2018/05/06 r27
	// -----------------------------------------------------
	List<Character> getazList() {
		List<Character> list = new ArrayList<>();
		for (char ch : _azAry)
			list.add(ch);
		return list;
	}

	int getDx(int idx) {
		int[] dx = { 0, 1, 1, 1, 0, -1, -1, -1 };
		return dx[idx];
	}

	int getDy(int idx) {
		int[] dy = { -1, -1, 0, 1, 1, 1, 0, -1 };
		return dy[idx];
	}

	class Bitmap {
		int mx;
		int my;
		boolean[][] map;

		public Bitmap(int mx, int my) {
			this.mx = mx;
			this.my = my;
			map = new boolean[my + 2][mx + 2];
		}

		public boolean is(int x, int y) {
			return map[y][x];
		}

		public void set(int x, int y, boolean b) {
			map[y][x] = b;
		}
	}

	class CharList implements Iterable<Character> {
		class CharComparator implements Comparator<Character> {
			int sign;

			public CharComparator(boolean bAsc) {
				sign = bAsc ? 1 : -1;
			}

			public int compare(Character o1, Character o2) {
				return sign * Character.compare(o1, o2);
			}
		}

		List<Character> list = new ArrayList<>();
		CharComparator asc = new CharComparator(true);
		CharComparator desc = new CharComparator(false);

		public void add(char ch) {
			list.add(ch);
		}

		public char get(int idx) {
			return list.get(idx);
		}

		public char getLast() {
			return list.get(list.size() - 1);
		}

		public Iterator<Character> iterator() {
			return list.iterator();
		}

		public void remove(int idx) {
			list.remove(idx);
		}

		public void removeLast() {
			list.remove(list.size() - 1);
		}

		public int size() {
			return list.size();
		}

		public void sort(boolean bAsc) {
			if (bAsc)
				Collections.sort(list, asc);
			else
				Collections.sort(list, desc);
		}

		public String toString() {
			StringBuilder sb = new StringBuilder();
			for (char ch : list)
				sb.append(ch);
			return sb.toString();
		}
	}

	class Counter<K> {
		Map<K, Integer> map = new HashMap<>();

		public Counter() {
		}

		public Counter(Iterable<K> itr) {
			for (K obj : itr) {
				add(obj);
			}
		}

		public void add(K key) {
			Integer cnt = map.get(key);
			if (cnt == null)
				map.put(key, 1);
			else
				map.put(key, cnt + 1);
		}

		public int get(K key) {
			Integer cnt = map.get(key);
			if (cnt == null)
				return 0;
			else
				return cnt;
		}

		public Set<K> keySet() {
			return map.keySet();
		}
	}

	class IntList implements Iterable<Integer> {
		class Info {
			int idx;
			int val;

			public Info(int idx, int val) {
				this.idx = idx;
				this.val = val;
			}

			public String toString() {
				return "(" + idx + ", " + val + ")";
			}
		}

		class InfoComparator implements Comparator<Info> {
			int sign;

			public InfoComparator(boolean bAsc) {
				sign = bAsc ? 1 : -1;
			}

			public int compare(Info o1, Info o2) {
				return sign * Integer.compare(o1.val, o2.val);
			}
		}

		List<Info> list = new ArrayList<>();
		InfoComparator asc = new InfoComparator(true);
		InfoComparator desc = new InfoComparator(false);

		public IntList() {
		}

		public IntList(int[] ia) {
			for (int i = 0; i < ia.length; i++)
				add(ia[i]);
		}

		public void add(int val) {
			list.add(new Info(list.size(), val));
		}

		public void add(int idx, int val) {
			list.add(new Info(idx, val));
		}

		public int getIdx(int idx) {
			return list.get(idx).idx;
		}

		public int getVal(int idx) {
			return list.get(idx).val;
		}

		public int getLastVal() {
			return list.get(list.size() - 1).val;
		}

		public Iterator<Integer> iterator() {
			List<Integer> vallist = new ArrayList<>();
			for (Info info : list)
				vallist.add(info.val);
			return vallist.iterator();
		}

		public void remove(int idx) {
			list.remove(idx);
		}

		public void removeLast() {
			list.remove(list.size() - 1);
		}

		public int size() {
			return list.size();
		}

		public void sort(boolean bAsc) {
			if (bAsc)
				Collections.sort(list, asc);
			else
				Collections.sort(list, desc);
		}
	}

	class Point {
		int x;
		int y;

		public Point(int x, int y) {
			this.x = x;
			this.y = y;
		}

		public Point(Point pt) {
			this.x = pt.x;
			this.y = pt.y;
		}

		public boolean equals(Object o) {
			if (o instanceof Point) {
				Point that = (Point) o;
				return (x == that.x) && (y == that.y);
			}
			return false;
		}

		public long getManhattanDistance(Point pt) {
			return abs((long) pt.x - this.x) + abs((long) pt.y - this.y);
		}

		public int hashCode() {
			return x + (y * 31);
		}

		public String toString() {
			return "(" + x + ", " + y + ")";
		}
	}

	class PointList implements Iterable<Point> {
		class PointComparator implements Comparator<Point> {
			int mode;

			public PointComparator(int prop, boolean bAsc) {
				switch (prop) {
				case 1:
					if (bAsc)
						this.mode = 11;
					else
						this.mode = 12;
					break;
				case 2:
					if (bAsc)
						this.mode = 21;
					else
						this.mode = 22;
					break;
				default:
					throw new RuntimeException();
				}
			}

			public int compare(Point p1, Point p2) {
				switch (mode) {
				case 11:
					return 1 * Integer.compare(p1.x, p2.x);
				case 12:
					return -1 * Integer.compare(p1.x, p2.x);
				case 21:
					return 1 * Integer.compare(p1.y, p2.y);
				case 22:
					return -1 * Integer.compare(p1.y, p2.y);
				}
				throw new IllegalStateException();
			}
		}

		List<Point> list = new ArrayList<>();

		public void add(int x, int y) {
			list.add(new Point(x, y));
		}

		public Point get(int idx) {
			return list.get(idx);
		}

		public Iterator<Point> iterator() {
			return list.iterator();
		}

		public void remove(int idx) {
			list.remove(idx);
		}

		public int size() {
			return list.size();
		}

		public void sort(int prop, boolean bAsc) {
			PointComparator c = new PointComparator(prop, bAsc);
			Collections.sort(list, c);
		}
	}

	class Prime {
		final int maxPrime = 1000;
		final int[] prime = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,
				89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193,
				197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313,
				317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443,
				449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587,
				593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719,
				727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859,
				863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997 };
		final Set<Integer> primeSet = new HashSet<>();

		Prime() {
			for (int p : prime)
				primeSet.add(p);
		}

		boolean isPrime(int n) {
			if (n <= maxPrime)
				return primeSet.contains(n);
			for (int i : prime) {
				if (n % i == 0)
					return false;
			}
			int sqrtNum = (int) Math.ceil(Math.sqrt(n));
			for (int i = maxPrime + 1; i <= sqrtNum; i += 2) {
				if (n % i == 0)
					return false;
			}
			return true;
		}
	}

	class StrList implements Iterable<String> {
		class StrComparator implements Comparator<String> {
			int sign;

			public StrComparator(boolean bAsc) {
				sign = bAsc ? 1 : -1;
			}

			public int compare(String o1, String o2) {
				return sign * o1.compareTo(o2);
			}
		}

		List<String> list = new ArrayList<>();
		StrComparator asc = new StrComparator(true);
		StrComparator desc = new StrComparator(false);

		public StrList() {
		}

		public StrList(String[] sa) {
			for (int i = 0; i < sa.length; i++)
				list.add(sa[i]);
		}

		public void add(String s) {
			list.add(s);
		}

		public String get(int idx) {
			return list.get(idx);
		}

		public Iterator<String> iterator() {
			return list.iterator();
		}

		public int size() {
			return list.size();
		}

		public void sort(boolean bAsc) {
			if (bAsc)
				Collections.sort(list, asc);
			else
				Collections.sort(list, desc);
		}
	}

	int abs(int a) {
		return (a >= 0) ? a : -a;
	}

	long abs(long a) {
		return (a >= 0) ? a : -a;
	}

	long ceil(long a, long b) {
		if (a < 0) {
			return -1 * floor(-a, b);
		}
		return ((a + b - 1) / b) * b;
	}

	long floor(long a, long b) {
		if (a < 0) {
			return -1 * ceil(-a, b);
		}
		return (a / b) * b;
	}

	int max(int a, int b) {
		return (a > b) ? a : b;
	}

	long max(long a, long b) {
		return (a > b) ? a : b;
	}

	int min(int a, int b) {
		return (a < b) ? a : b;
	}

	long min(long a, long b) {
		return (a < b) ? a : b;
	}

	int reed(long a, int n) {
		while (n-- > 0)
			a /= 10;
		return (int) (a % 10);
	}

	int sqrt(long a) {
		return (int) Math.sqrt(a);
	}

	int pint(String s) {
		return Integer.parseInt(s);
	}

	long plong(String s) {
		return Long.parseLong(s);
	}

	String readLine() {
		try {
			return _in.readLine();
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}

	int readNum() {
		String line = readLine();
		return pint(line);
	}

	long readLong() {
		String line = readLine();
		return plong(line);
	}

	String[] readFlds() {
		String line = readLine();
		return line.split(" ");
	}

	String[] readLines(int n) {
		String[] lines = new String[n];
		for (int i = 0; i < n; i++)
			lines[i] = readLine();
		return lines;
	}

	CharList readChars() {
		CharList list = new CharList();
		String line = readLine();
		for (int i = 0; i < line.length(); i++)
			list.add(line.charAt(i));
		return list;
	}

	int[] readNums() {
		String[] flds = readFlds();
		int[] nums = new int[flds.length];
		for (int i = 0; i < flds.length; i++)
			nums[i] = pint(flds[i]);
		return nums;
	}

	int[] readNums(int n) {
		int[] nums = new int[n];
		for (int i = 0; i < n; i++)
			nums[i] = readNum();
		return nums;
	}

	long[] readLongs() {
		String[] flds = readFlds();
		long[] nums = new long[flds.length];
		for (int i = 0; i < flds.length; i++)
			nums[i] = plong(flds[i]);
		return nums;
	}

	long[] readLongs(int n) {
		long[] nums = new long[n];
		for (int i = 0; i < n; i++)
			nums[i] = readLong();
		return nums;
	}

	Main pln() {
		_out.println();
		return this;
	}

	Main p(char c) {
		_out.print(c);
		return this;
	}

	Main p(char c, int n) {
		for (int i = 0; i < n; i++)
			p(c);
		return this;
	}

	Main pln(char c) {
		_out.println(c);
		return this;
	}

	Main p(double d) {
		_out.print(d);
		return this;
	}

	Main pln(double d) {
		_out.println(d);
		return this;
	}

	Main p(long l) {
		_out.print(l);
		return this;
	}

	Main pln(long l) {
		_out.println(l);
		return this;
	}

	Main p(String s) {
		_out.print(s);
		return this;
	}

	Main p(String s, int idx) {
		_out.print(s.charAt(idx));
		return this;
	}

	Main pln(String s) {
		_out.println(s);
		return this;
	}

	Main pln(int[] ia) {
		for (int i = 0; i < ia.length; i++)
			_out.println(ia[i]);
		return this;
	}

	Main pln(long[] la) {
		for (int i = 0; i < la.length; i++)
			_out.println(la[i]);
		return this;
	}

	static BufferedReader _in;
	static PrintWriter _out;
	static boolean _bElapsed = false;

	public static void main(String[] args) {
		long start = System.currentTimeMillis();
		_in = new BufferedReader(new InputStreamReader(System.in));
		_out = new PrintWriter(System.out);
		new Main().solve();
		_out.flush();
		long end = System.currentTimeMillis();
		if (_bElapsed)
			System.err.println((end - start) + "ms");
	}
}

</source>
</class>

<class classid="277" nclones="2" nlines="99" similarity="100">
<source file="../hum_codes_raw/s667272876.java" startline="1" endline="136" pcid="22414">
import java.io.*;
import java.util.*;

class Main{
	public static void main(String[] args){
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		try{
			String input_str;
			while((input_str = br.readLine()) != null){
				String[] input_strs = input_str.split(" ");

				// 
				Node node1 = new Node(input_strs[1]);
				Node node2 = new Node(input_strs[2]);
				Node result_node = new Node();

				// intersection
				if(input_strs[0].equals("i")){
					result_node.intersection(node1, node2);
				}

				// union
				if(input_strs[0].equals("u")){
					result_node.union(node1, node2);
				}

				System.out.println(result_node.toString());
			}
		}catch(Exception e){
			System.out.println("Error");
		}

		/*
		Node node1 = new Node("((,),(,))");
		System.out.println("node1: " + node1.toString());

		Node node2 = new Node("((,(,)),)");
		System.out.println("node2: " + node2.toString());

		Node inode = new Node();
		inode.intersection(node1, node2);
		System.out.println("inode: " + inode.toString());

		Node unode = new Node();
		unode.union(node1, node2);
		System.out.println("unode: " + unode.toString());
		*/
	}
}

class Node{
	Node left;
	Node right;

	Node(){
		left = null;
		right = null;
	}

	Node(String str){
		//System.out.println(str);

		int lvl = 0;
		for(int i = 0; i < str.length(); i++){
			char ch = str.charAt(i);
			if(ch == '(') lvl++;
			if(ch == ')') lvl--;
			if(ch == ',' && lvl == 1){
				// 
				String left_str = str.substring(1, i);
				if(left_str.length() == 0){
					left = null;
				}else{
					left = new Node(left_str);
				}

				// 
				String right_str = str.substring(i+1, str.length()-1);
				if(right_str.length() == 0){
					right = null;
				}else{
					right = new Node(right_str);
				}
			}
		}
	}

	public String toString(){
		String result = "(";
		if(left != null) result += left.toString();
		result += ",";
		if(right != null) result += right.toString();
		result += ")";
		return result;
	}

	public Node intersection(Node node1, Node node2){
		// intersection  null  null
		//  null  intersection
		// left
		if(node1.left != null && node2.left != null){
			left = new Node();
			left.intersection(node1.left, node2.left);
		}
		// right
		if(node1.right != null && node2.right != null){
			//  null 
			right = new Node();
			right.intersection(node1.right, node2.right);
		}
		return this;
	}

	public Node union(Node node1, Node node2){
		// left
		if(node1.left == null){
			left = node2.left;
		}else if(node2.left == null){
			left = node1.left;
		}else{
			left = new Node();
			left.union(node1.left, node2.left);
		}
		// right
		if(node1.right == null){
			right = node2.right;
		}else if(node2.right == null){
			right = node1.right;
		}else{
			right = new Node();
			right.union(node1.right, node2.right);
		}
		return this;
	}
}

</source>
<source file="../hum_codes_raw/s881270089.java" startline="1" endline="116" pcid="29617">
import java.io.*;
import java.util.*;
 
class Main{
    public static void main(String[] args){
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        try{
            String input_str;
            while((input_str = br.readLine()) != null){
                String[] input_strs = input_str.split(" ");
 
                // 
                Node node1 = new Node(input_strs[1]);
                Node node2 = new Node(input_strs[2]);
                Node result_node = new Node();
 
                // intersection
                if(input_strs[0].equals("i")){
                    result_node.intersection(node1, node2);
                }
 
                // union
                if(input_strs[0].equals("u")){
                    result_node.union(node1, node2);
                }
 
                System.out.println(result_node.toString());
            }
        }catch(Exception e){
            System.out.println("Error");
        }
    }
}
 
class Node{
    Node left;
    Node right;
 
    Node(){
        left = null;
        right = null;
    }
 
    Node(String str){
        int lvl = 0;
        for(int i = 0; i < str.length(); i++){
            char ch = str.charAt(i);
            if(ch == '(') lvl++;
            if(ch == ')') lvl--;
            if(ch == ',' && lvl == 1){
                // 
                String left_str = str.substring(1, i);
                if(left_str.length() == 0){
                    left = null;
                }else{
                    left = new Node(left_str);
                }
 
                // 
                String right_str = str.substring(i+1, str.length()-1);
                if(right_str.length() == 0){
                    right = null;
                }else{
                    right = new Node(right_str);
                }
            }
        }
    }
 
    public String toString(){
        String result = "(";
        if(left != null) result += left.toString();
        result += ",";
        if(right != null) result += right.toString();
        result += ")";
        return result;
    }
 
    public Node intersection(Node node1, Node node2){
        // left
        if(node1.left != null && node2.left != null){
            left = new Node();
            left.intersection(node1.left, node2.left);
        }
        // right
        if(node1.right != null && node2.right != null){
            //  null 
            right = new Node();
            right.intersection(node1.right, node2.right);
        }
        return this;
    }
 
    public Node union(Node node1, Node node2){
        // left
        if(node1.left == null){
            left = node2.left;
        }else if(node2.left == null){
            left = node1.left;
        }else{
            left = new Node();
            left.union(node1.left, node2.left);
        }
        // right
        if(node1.right == null){
            right = node2.right;
        }else if(node2.right == null){
            right = node1.right;
        }else{
            right = new Node();
            right.union(node1.right, node2.right);
        }
        return this;
    }
}

</source>
</class>

<class classid="278" nclones="2" nlines="56" similarity="100">
<source file="../hum_codes_raw/s667781206.java" startline="1" endline="72" pcid="22431">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;

public class Main {

  int H,W;
  int sy,sx;
  int cnt;
  boolean[][] map;
  int[] dy = {-1,0,1,0}, dx = {0,1,0,-1}; 
  public static void main(String[] args) {
    new Main().run();
  }
  public void run() {

    try(BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(System.out) ) {

      String[] lines;
      // StringBuilder buf = new StringBuilder();
      while(true) {
        lines = in.readLine().split(" ");
        W = Integer.parseInt(lines[0]);
        H = Integer.parseInt(lines[1]);

        if( W==0 && H==0) break;

        map = new boolean[H][W];

        String line;
        for(int y=0; y<H; y++) {
          char ch;
          line = in.readLine();
          for(int x=0; x<W; x++) {
            ch = line.charAt(x);
            map[y][x] = ch == '#' ? false : true;
            if(ch == '@') {
              sy = y; sx = x;
            }
          }
        }

        cnt = 0;
        dfs(sy,sx);
        // buf.append(cnt).append("\n");
        out.println(cnt);
      }

      // System.out.print(buf);
      out.flush();
    }
    catch(IOException e) {
      System.err.println(e);
    }
  }

  private void dfs(int y, int x) {
    map[y][x] = false;
    cnt++;

    for(int i=0; i<4; i++) {
      int ny = y + dy[i], nx = x + dx[i];
      if(0 <= ny && ny < H && 0 <= nx && nx < W && map[ny][nx]) {
        dfs(ny,nx);
      }
    }
    return;
  }
}

</source>
<source file="../hum_codes_raw/s788167550.java" startline="1" endline="72" pcid="26460">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;

public class Main {

  int H,W;
  int sy,sx;
  int cnt;
  boolean[][] map;
  int[] dy = {-1,0,1,0}, dx = {0,1,0,-1}; 
  public static void main(String[] args) {
    new Main().run();
  }
  public void run() {

    try(BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(System.out) ) {

      String[] lines;
      // StringBuilder buf = new StringBuilder();
      while(true) {
        lines = in.readLine().split(" ");
        W = Integer.parseInt(lines[0]);
        H = Integer.parseInt(lines[1]);

        if( W==0 && H==0) break;

        map = new boolean[H][W];

        String line;
        for(int y=0; y<H; y++) {
          char ch;
          line = in.readLine();
          for(int x=0; x<W; x++) {
            ch = line.charAt(x);
            map[y][x] = ch == '#' ? false : true;
            if(ch == '@') {
              sy = y; sx = x;
            }
          }
        }

        cnt = 0;
        dfs(sy,sx);
        // buf.append(cnt).append("\n");
        out.println(cnt);
      }

      // System.out.print(buf);
      out.flush();
    }
    catch(IOException e) {
      System.err.println(e);
    }
  }

  private void dfs(int y, int x) {
    map[y][x] = false;
    cnt++;

    for(int i=0; i<4; i++) {
      int ny = y + dy[i], nx = x + dx[i];
      if(0 <= ny && ny < H && 0 <= nx && nx < W && map[ny][nx]) {
        dfs(ny,nx);
      }
    }
    return;
  }
}

</source>
</class>

<class classid="279" nclones="3" nlines="51" similarity="100">
<source file="../hum_codes_raw/s672841375.java" startline="1" endline="78" pcid="22607">
import java.util.*;



class Main{

    public static void main(String[] args){

	int gyo,retu,n;
	String sc;
	Scanner in = new Scanner(System.in);


	gyo = in.nextInt();
	retu = in.nextInt();
	n = in.nextInt();
	int[][] jm = new int[gyo+1][retu+1];
	int[][] om = new int[gyo+1][retu+1];
	int[][] im = new int[gyo+1][retu+1];
	for(int i=0;i<=gyo;i++){
	    for(int j=0;j<=retu;j++){
		jm[i][j]=0;
		om[i][j]=0;
		im[i][j]=0;
	    }
	}

	//Arrays.fill(jm,0); //memsetImem2G[gHm[v
	//Arrays.fill(om,0);
	//Arrays.fill(im,0);

	for(int i=1;i<=gyo;i++){
	    sc = in.next();
	    for(int j=0;j<retu;j++){
		char cc[] = sc.toCharArray();
		jm[i][j+1]=jm[i-1][j+1]+jm[i][j]-jm[i-1][j];
		om[i][j+1] = om[i-1][j+1]+om[i][j]-om[i-1][j];
		im[i][j+1]=im[i-1][j+1]+im[i][j]-im[i-1][j];
		if(cc[j] == 'J'){
		    jm[i][j+1]++;
		}else if(cc[j] == 'O'){
		    om[i][j+1]++;
		}else if(cc[j] == 'I'){
		    im[i][j+1]++;
		}


	    }
	}

	/*	
		for(int i=0;i<=gyo;i++){
		for(int j=0;j<=retu;j++)System.out.print(jm[i][j] + " ");
		System.out.printf("\n");
		}
	*/
	
	int a,b,c,d;
	for(int i=0;i<n;i++){
	    a = in.nextInt();
	    b = in.nextInt();
	    c = in.nextInt();
	    d = in.nextInt();
	    System.out.print(jm[c][d]-jm[a-1][d]-jm[c][b-1]+jm[a-1][b-1]);
	    System.out.print(" ");
	    System.out.print(om[c][d]-om[a-1][d]-om[c][b-1]+om[a-1][b-1]);
	    System.out.print(" ");
	    System.out.println(im[c][d]-im[a-1][d]-im[c][b-1]+im[a-1][b-1]);

	}
	


    }


}

</source>
<source file="../hum_codes_raw/s966835667.java" startline="1" endline="84" pcid="32511">
import java.util.*;


//p
//
//
//m[g
//2


class Main{

    public static void main(String[] args){

	int gyo,retu,n;
	String sc;
	Scanner in = new Scanner(System.in);


	gyo = in.nextInt();
	retu = in.nextInt();
	n = in.nextInt();
	int[][] jm = new int[gyo+1][retu+1];
	int[][] om = new int[gyo+1][retu+1];
	int[][] im = new int[gyo+1][retu+1];
	for(int i=0;i<=gyo;i++){
	    for(int j=0;j<=retu;j++){
		jm[i][j]=0;
		om[i][j]=0;
		im[i][j]=0;
	    }
	}

	//Arrays.fill(jm,0); //memsetImem2G[gHm[v
	//Arrays.fill(om,0);
	//Arrays.fill(im,0);

	for(int i=1;i<=gyo;i++){
	    sc = in.next();
	    for(int j=0;j<retu;j++){
		char cc[] = sc.toCharArray();
		jm[i][j+1]=jm[i-1][j+1]+jm[i][j]-jm[i-1][j];
		om[i][j+1] = om[i-1][j+1]+om[i][j]-om[i-1][j];
		im[i][j+1]=im[i-1][j+1]+im[i][j]-im[i-1][j];
		if(cc[j] == 'J'){
		    jm[i][j+1]++;
		}else if(cc[j] == 'O'){
		    om[i][j+1]++;
		}else if(cc[j] == 'I'){
		    im[i][j+1]++;
		}


	    }
	}

	/*	
		for(int i=0;i<=gyo;i++){
		for(int j=0;j<=retu;j++)System.out.print(jm[i][j] + " ");
		System.out.printf("\n");
		}
	*/
	
	int a,b,c,d;
	for(int i=0;i<n;i++){
	    a = in.nextInt();
	    b = in.nextInt();
	    c = in.nextInt();
	    d = in.nextInt();
	    System.out.print(jm[c][d]-jm[a-1][d]-jm[c][b-1]+jm[a-1][b-1]);
	    System.out.print(" ");
	    System.out.print(om[c][d]-om[a-1][d]-om[c][b-1]+om[a-1][b-1]);
	    System.out.print(" ");
	    System.out.println(im[c][d]-im[a-1][d]-im[c][b-1]+im[a-1][b-1]);

	}
	


    }


}

</source>
<source file="../hum_codes_raw/s764844827.java" startline="1" endline="78" pcid="25684">
import java.util.*;



class Main{

    public static void main(String[] args){

	int gyo,retu,n;
	String sc;
	Scanner in = new Scanner(System.in);


	gyo = in.nextInt();
	retu = in.nextInt();
	n = in.nextInt();
	int[][] jm = new int[gyo+1][retu+1];
	int[][] om = new int[gyo+1][retu+1];
	int[][] im = new int[gyo+1][retu+1];
	for(int i=0;i<=gyo;i++){
	    for(int j=0;j<=retu;j++){
		jm[i][j]=0;
		om[i][j]=0;
		im[i][j]=0;
	    }
	}

	//Arrays.fill(jm,0); //memset
	//Arrays.fill(om,0);
	//Arrays.fill(im,0);

	for(int i=1;i<=gyo;i++){
	    sc = in.next();
	    for(int j=0;j<retu;j++){
		char cc[] = sc.toCharArray();
		jm[i][j+1]=jm[i-1][j+1]+jm[i][j]-jm[i-1][j];
		om[i][j+1] = om[i-1][j+1]+om[i][j]-om[i-1][j];
		im[i][j+1]=im[i-1][j+1]+im[i][j]-im[i-1][j];
		if(cc[j] == 'J'){
		    jm[i][j+1]++;
		}else if(cc[j] == 'O'){
		    om[i][j+1]++;
		}else if(cc[j] == 'I'){
		    im[i][j+1]++;
		}


	    }
	}

	/*	
		for(int i=0;i<=gyo;i++){
		for(int j=0;j<=retu;j++)System.out.print(jm[i][j] + " ");
		System.out.printf("\n");
		}
	*/
	
	int a,b,c,d;
	for(int i=0;i<n;i++){
	    a = in.nextInt();
	    b = in.nextInt();
	    c = in.nextInt();
	    d = in.nextInt();
	    System.out.print(jm[c][d]-jm[a-1][d]-jm[c][b-1]+jm[a-1][b-1]);
	    System.out.print(" ");
	    System.out.print(om[c][d]-om[a-1][d]-om[c][b-1]+om[a-1][b-1]);
	    System.out.print(" ");
	    System.out.println(im[c][d]-im[a-1][d]-im[c][b-1]+im[a-1][b-1]);

	}
	


    }


}

</source>
</class>

<class classid="280" nclones="2" nlines="194" similarity="100">
<source file="../hum_codes_raw/s676825637.java" startline="1" endline="192" pcid="22742">
import java.io.*;
        
class Main{
static int[] sx={0,0,1,0,-1};
static int[] sy={0,1,0,-1,0};
static int[] mx={0,0,1,0,-1,-1,-1,1,1};
static int[] my={0,1,0,-1,0,-1,1,-1,1};
static int[] lx={0,0,1,0,-1,-1,-1,1,1,0,2,0,-2};
static int[] ly={0,1,0,-1,0,-1,1,-1,1,2,0,-2,0};
static int total;
static int res;
static int[][] map=new int[10][10];
static int[][][] drop=new int[10][10][3];
static void sd(int x,int y){
for(int i=0;i<sx.length;i++){
map[x+sx[i]][y+sy[i]]--;
}
total-=5;
res--;
}
static void sr(int x,int y){
for(int i=0;i<sx.length;i++){
map[x+sx[i]][y+sy[i]]++;
}
total+=5;
res++;
}
static boolean scd(int x,int y){
for(int i=0;i<sx.length;i++){
int nx=x+sx[i];
int ny=y+sy[i];
if(nx<0||ny<0||nx>=10||ny>=10||map[nx][ny]==0){
return false;
}
}
return true;
}
static void md(int x,int y){
for(int i=0;i<mx.length;i++){
map[x+mx[i]][y+my[i]]--;
}
total-=9;
res--;
}
static void mr(int x,int y){
for(int i=0;i<mx.length;i++){
map[x+mx[i]][y+my[i]]++;
}
total+=9;
res++;
}
static boolean mcd(int x,int y){
for(int i=0;i<mx.length;i++){
int nx=x+mx[i];
int ny=y+my[i];
if(nx<0||ny<0||nx>=10||ny>=10||map[nx][ny]==0){
return false;
}
}
return true;
}
static void ld(int x,int y){
for(int i=0;i<lx.length;i++){
map[x+lx[i]][y+ly[i]]--;
}
total-=13;
res--;
}
static void lr(int x,int y){
for(int i=0;i<lx.length;i++){
map[x+lx[i]][y+ly[i]]++;
}
total+=13;
res++;
}
static boolean lcd(int x,int y){
for(int i=0;i<lx.length;i++){
int nx=x+lx[i];
int ny=y+ly[i];
if(nx<0||ny<0||nx>=10||ny>=10||map[nx][ny]==0){
return false;
}
}
return true;
}
public static void main(String[] args) throws IOException{
BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
res=Integer.parseInt(br.readLine());
total=0;
int m;
for(int i=0;i<10;i++){
String[] value=br.readLine().split(" ");
for(int j=0;j<10;j++){
int num=Integer.parseInt(value[j]);
map[i][j]=num;
total+=num;
}
}
if(search(1,1,3)){
for(int i=1;i<9;i++){
for(int j=1;j<9;j++){
for(int k=1;k<=3;k++){
m=drop[i][j][k-1];
if(m!=0){
for(int l=0;l<m;l++){
System.out.println(j+" "+i+" "+k);
}
}
}
}
}
}
}
static boolean searchnext(int x,int y){
if(x==8){
return search(1,y+1,3);
}
return search(x+1,y,3);
}
static boolean search(int x,int y,int size){
if(res==0&&total==0){
return true;
}
else if(total<res*5||total>res*13){
return false;
}
else if(res==0){
return false;
}
if(y==9){
return false;
}
if(y>2&&x==1){
for(int i=0;i<10;i++){
if(map[i][y-3]!=0){
return false;
}
}
}
while(true){
switch(size){
case 3:if(lcd(x,y)){
       ld(x,y);
       drop[x][y][2]++;
       if(searchnext(x,y)){
       return true;
       }
       else{
       if(scd(x,y)&&search(x,y,3)){
       return true;
       }
       lr(x,y);
       drop[x][y][2]--;
       }
       }
       size--;
case 2:if(mcd(x,y)){
       md(x,y);
       drop[x][y][1]++;
       if(searchnext(x,y)){
       return true;
       }
       else{
       if(scd(x,y)&&search(x,y,2)){
       return true;
       }
       mr(x,y);
       drop[x][y][1]--;
       }
       }
       size--;
case 1:if(scd(x,y)){
       sd(x,y);
       drop[x][y][0]++;
       if(searchnext(x,y)){
       return true;
       }
       else{
       if(scd(x,y)&&search(x,y,1)){
       return true;
       }
       sr(x,y);
       drop[x][y][0]--;
       }
       }
       size--;
case 0:return searchnext(x,y);
}
}
}
}

</source>
<source file="../hum_codes_raw/s953973035.java" startline="1" endline="192" pcid="32059">
import java.io.*;
         
class Main{
static int[] sx={0,0,1,0,-1};
static int[] sy={0,1,0,-1,0};
static int[] mx={0,0,1,0,-1,-1,-1,1,1};
static int[] my={0,1,0,-1,0,-1,1,-1,1};
static int[] lx={0,0,1,0,-1,-1,-1,1,1,0,2,0,-2};
static int[] ly={0,1,0,-1,0,-1,1,-1,1,2,0,-2,0};
static int total;
static int res;
static int[][] map=new int[10][10];
static int[][][] drop=new int[10][10][3];
static void sd(int x,int y){
for(int i=0;i<sx.length;i++){
map[x+sx[i]][y+sy[i]]--;
}
total-=5;
res--;
}
static void sr(int x,int y){
for(int i=0;i<sx.length;i++){
map[x+sx[i]][y+sy[i]]++;
}
total+=5;
res++;
}
static boolean scd(int x,int y){
for(int i=0;i<sx.length;i++){
int nx=x+sx[i];
int ny=y+sy[i];
if(nx<0||ny<0||nx>=10||ny>=10||map[nx][ny]==0){
return false;
}
}
return true;
}
static void md(int x,int y){
for(int i=0;i<mx.length;i++){
map[x+mx[i]][y+my[i]]--;
}
total-=9;
res--;
}
static void mr(int x,int y){
for(int i=0;i<mx.length;i++){
map[x+mx[i]][y+my[i]]++;
}
total+=9;
res++;
}
static boolean mcd(int x,int y){
for(int i=0;i<mx.length;i++){
int nx=x+mx[i];
int ny=y+my[i];
if(nx<0||ny<0||nx>=10||ny>=10||map[nx][ny]==0){
return false;
}
}
return true;
}
static void ld(int x,int y){
for(int i=0;i<lx.length;i++){
map[x+lx[i]][y+ly[i]]--;
}
total-=13;
res--;
}
static void lr(int x,int y){
for(int i=0;i<lx.length;i++){
map[x+lx[i]][y+ly[i]]++;
}
total+=13;
res++;
}
static boolean lcd(int x,int y){
for(int i=0;i<lx.length;i++){
int nx=x+lx[i];
int ny=y+ly[i];
if(nx<0||ny<0||nx>=10||ny>=10||map[nx][ny]==0){
return false;
}
}
return true;
}
public static void main(String[] args) throws IOException{
BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
res=Integer.parseInt(br.readLine());
total=0;
int m;
for(int i=0;i<10;i++){
String[] value=br.readLine().split(" ");
for(int j=0;j<10;j++){
int num=Integer.parseInt(value[j]);
map[i][j]=num;
total+=num;
}
}
if(search(1,1,3)){
for(int i=1;i<9;i++){
for(int j=1;j<9;j++){
for(int k=1;k<=3;k++){
m=drop[i][j][k-1];
if(m!=0){
for(int l=0;l<m;l++){
System.out.println(j+" "+i+" "+k);
}
}
}
}
}
}
}
static boolean searchnext(int x,int y){
if(x==8){
return search(1,y+1,3);
}
return search(x+1,y,3);
}
static boolean search(int x,int y,int size){
if(res==0&&total==0){
return true;
}
else if(total<res*5||total>res*13){
return false;
}
else if(res==0){
return false;
}
if(y==9){
return false;
}
if(y>2&&x==1){
for(int i=0;i<10;i++){
if(map[i][y-3]!=0){
return false;
}
}
}
while(true){
switch(size){
case 3:if(lcd(x,y)){
       ld(x,y);
       drop[x][y][2]++;
       if(searchnext(x,y)){
       return true;
       }
       else{
       if(scd(x,y)&&search(x,y,3)){
       return true;
       }
       lr(x,y);
       drop[x][y][2]--;
       }
       }
       size--;
case 2:if(mcd(x,y)){
       md(x,y);
       drop[x][y][1]++;
       if(searchnext(x,y)){
       return true;
       }
       else{
       if(scd(x,y)&&search(x,y,2)){
       return true;
       }
       mr(x,y);
       drop[x][y][1]--;
       }
       }
       size--;
case 1:if(scd(x,y)){
       sd(x,y);
       drop[x][y][0]++;
       if(searchnext(x,y)){
       return true;
       }
       else{
       if(scd(x,y)&&search(x,y,1)){
       return true;
       }
       sr(x,y);
       drop[x][y][0]--;
       }
       }
       size--;
case 0:return searchnext(x,y);
}
}
}
}

</source>
</class>

<class classid="281" nclones="2" nlines="15" similarity="100">
<source file="../hum_codes_raw/s681438131.java" startline="1" endline="19" pcid="22901">

import java.util.Scanner;

public class Main {
   public static void main(String[] args) {
      Scanner sc = new Scanner(System.in);
      int a = sc.nextInt();
      int b = sc.nextInt();
      int c = sc.nextInt();
     
       if(a < b && b < c){
           System.out.printf("Yes\n");
       }
       else {
    	   System.out.printf("No\n");
       }
   }
}

</source>
<source file="../hum_codes_raw/s991534137.java" startline="1" endline="24" pcid="33362">
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {


		Scanner sc = new Scanner(System.in);

		int a = sc.nextInt();
		int b = sc.nextInt();
		int c = sc.nextInt();

		if(a < b && b < c){
			System.out.printf("Yes\n");
		}else{
			System.out.printf("No\n");
		}
	}
}




</source>
</class>

<class classid="282" nclones="2" nlines="33" similarity="100">
<source file="../hum_codes_raw/s683051354.java" startline="1" endline="37" pcid="22951">
//Volume1-0102
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {

		//initialization
		int    out,
		       runner,
		       score;
		String s;

        //input
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        while(n-- > 0){
        	out    = 0;
        	runner = 0;
        	score  = 0;
        	while(out != 3){
            	s = sc.next();
            	if(s.equals("HIT")){
            		if   (runner == 3){score++; }
            		else              {runner++;}
           		}
            	if(s.equals("OUT")){out++;}
            	if(s.equals("HOMERUN")){
            		score += runner + 1;
            		runner = 0;
            	}
        	}
        	System.out.println(score);
        }
	}
}

</source>
<source file="../hum_codes_raw/s730872863.java" startline="1" endline="41" pcid="24566">
//Volume1-0103
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {

		//initialization
		int    out,
		       runner,
		       score;
		String s;

        //input
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        while(n-- > 0){
        	out    = 0;
        	runner = 0;
        	score  = 0;
        	while(out != 3){
            	s = sc.next();

            	//calculation
            	if(s.equals("HIT")){
            		if   (runner == 3){score++; }
            		else              {runner++;}
           		}
            	if(s.equals("OUT")){out++;}
            	if(s.equals("HOMERUN")){
            		score += runner + 1;
            		runner = 0;
            	}
        	}

        	//output
        	System.out.println(score);
        }
	}
}

</source>
</class>

<class classid="283" nclones="2" nlines="77" similarity="100">
<source file="../hum_codes_raw/s690494390.java" startline="1" endline="96" pcid="23222">
import java.util.Scanner;
import java.util.LinkedList;
import java.util.Queue;
 
 
public class Main{
    public static int[] dp=new int[77777777];
    public static void main(String[] args){
        Scanner s = new Scanner(System.in);
       int[][] a = new int[2][4];
       int i,j,m;
       long k=1,n=0;
       m = solve(76543210);
       while(s.hasNext()){
       for(i=0;i<2;i++){
           for(j=0;j<4;j++){
        m=s.nextInt();
        n+=k*(long)m;
        k*=10;
       }
    }
 
 
            
       // m = solve(n);
        System.out.println(Main.dp[(int)n]);
        n=0;
        k=1;
}
    }
    public static int solve(long n){
        Queue<Long> qu=new LinkedList<Long>();
        int[] x = {1,-1,0,0},y= {0,0,1,-1};
        long[] zc =new long[50000];
        int[][] arr = new int[2][4];
        int i,j,zh=-5,zw=-5,e,ppp=0,col=0,kri=0;
        long k=n,temp,no;
        boolean ch=false,chk=false;
        qu.add(n);
        while(true){
            if(qu.size()==0)return 0;
        k = qu.remove();
  //      if(k%100000000==76543210)return (int)k/100000000+kri;
        for(i=0;i<2;i++){
            for(j=0;j<4;j++){
                arr[i][j]=(int)k%10;
                k/=10;
                if(arr[i][j]==0){
                    zh=i;
                    zw=j;
                }
            }
        }
   //     System.out.println(k+" " +col);
        if(k==19){
            kri=20;
            k=0;
        }
        else k++;
 
        k*=100000000;
        no = k;
        for(e=0;e<4;e++){
            if(zh+x[e]>=0&&zh+x[e]<2&&zw+y[e]>=0&&zw+y[e]<4){
            arr[zh][zw] = arr[zh+x[e]][zw+y[e]];
            arr[zh+x[e]][zw+y[e]]=0;
        temp =1;
        for(i=0;i<2;i++){
            for(j=0;j<4;j++){
                k+=temp*(long)arr[i][j];
                temp*=10;
            }
        }
       /* for(ppp=0;ppp<col;ppp++)if(zc[ppp]==k%100000000)ch=true;
        if(ch==false){
            zc[col]=k%100000000;
            qu.add(k);
            col++;
        }*/
        if(Main.dp[(int)k%100000000]==0){
            Main.dp[(int)k%100000000]=(int)k/100000000+kri;
            //System.out.println(sep3.dp[(int)k%100000000]+" "+k%100000000);
            qu.add(k);
        }
        else ch = false;
        k = no;
        arr[zh+x[e]][zw+y[e]] = arr[zh][zw];
        arr[zh][zw]=0;
    }
}
    }
}
 
    }


</source>
<source file="../hum_codes_raw/s906574798.java" startline="1" endline="97" pcid="30501">
import java.util.Scanner;
import java.util.LinkedList;
import java.util.Queue;


public class Main{
    public static int[] dp=new int[77777777];
    public static void main(String[] args){
        Scanner s = new Scanner(System.in);
       int[][] a = new int[2][4];
       int i,j,m;
       long k=1,n=0;
       m = solve(76543210);
       while(s.hasNext()){
       for(i=0;i<2;i++){
           for(j=0;j<4;j++){
        m=s.nextInt();
        n+=k*(long)m;
        k*=10;
       }
    }


           
       // m = solve(n);
        System.out.println(Main.dp[(int)n]);
        n=0;
        k=1;
}
    }
    public static int solve(long n){
        Queue<Long> qu=new LinkedList<Long>();
        int[] x = {1,-1,0,0},y= {0,0,1,-1};
        long[] zc =new long[50000];
        int[][] arr = new int[2][4];
        int i,j,zh=-5,zw=-5,e,ppp=0,col=0,kri=0;
        long k=n,temp,no;
        boolean ch=false,chk=false;
        qu.add(n);
        while(true){
            if(qu.size()==0)return 0;
        k = qu.remove();
  //      if(k%100000000==76543210)return (int)k/100000000+kri;
        for(i=0;i<2;i++){
            for(j=0;j<4;j++){
                arr[i][j]=(int)k%10;
                k/=10;
                if(arr[i][j]==0){
                    zh=i;
                    zw=j;
                }
            }
        }
   //     System.out.println(k+" " +col);
        if(k==19){
            kri=20;
            k=0;
        }
        else k++;

        k*=100000000;
        no = k;
        for(e=0;e<4;e++){
            if(zh+x[e]>=0&&zh+x[e]<2&&zw+y[e]>=0&&zw+y[e]<4){
            arr[zh][zw] = arr[zh+x[e]][zw+y[e]];
            arr[zh+x[e]][zw+y[e]]=0;
        temp =1;
        for(i=0;i<2;i++){
            for(j=0;j<4;j++){
                k+=temp*(long)arr[i][j];
                temp*=10;
            }
        }
       /* for(ppp=0;ppp<col;ppp++)if(zc[ppp]==k%100000000)ch=true;
        if(ch==false){
            zc[col]=k%100000000;
            qu.add(k);
            col++;
        }*/
        if(Main.dp[(int)k%100000000]==0){
            Main.dp[(int)k%100000000]=(int)k/100000000+kri;
            //System.out.println(sep3.dp[(int)k%100000000]+" "+k%100000000);
            qu.add(k);
        }
        else ch = false;
        k = no;
        arr[zh+x[e]][zw+y[e]] = arr[zh][zw];
        arr[zh][zw]=0;
    }
}
    }
}

    }



</source>
</class>

<class classid="284" nclones="2" nlines="45" similarity="100">
<source file="../hum_codes_raw/s699035761.java" startline="1" endline="55" pcid="23511">

import java.util.*;
import static java.lang.Math.*;
import static java.util.Arrays.*;

public class Main {

	int INF = 1 << 28;

	void run() {
		Scanner sc = new Scanner(System.in);
		for(;;) {
			int n = sc.nextInt();
			if(n==0) break;
			int maxn = 0;
			int map[][] = new int[10][10];
			for(int[] a: map) fill(a, INF);
			for(int i=0;i<n;i++) {
				int a = sc.nextInt();
				int b = sc.nextInt();
				int c = sc.nextInt();
				maxn = max(maxn, max(a,b));
				map[a][b] = map[b][a] = c;
			}
			maxn++;
			for(int i=0;i<maxn;i++) map[i][i] = 0;
			for(int k=0;k<maxn;k++) for(int i=0;i<maxn;i++) for(int j=0;j<maxn;j++) {
				map[i][j] = min(map[i][j], map[i][k] + map[k][j]);
			}
//			for(int[] a: map) debug(a);
			
			int node = -1;
			int min = INF;
			for(int i=0;i<maxn;i++) {
				int sum = 0;
				for(int j=0;j<maxn;j++) sum += map[i][j];
				if(min > sum) {
					node = i;
					min = sum;
				}
			}
			System.out.println(node + " " + min);
			
		}
	}

	public static void main(String[] args) {
		new Main().run();
	}

	void debug(Object... os) {
		System.err.println(Arrays.deepToString(os));
	}
}

</source>
<source file="../hum_codes_raw/s821492058.java" startline="1" endline="55" pcid="27576">

import java.util.*;
import static java.lang.Math.*;
import static java.util.Arrays.*;

public class Main {

	int INF = 1 << 28;

	void run() {
		Scanner sc = new Scanner(System.in);
		for(;;) {
			int n = sc.nextInt();
			if(n==0) break;
			int maxn = 0;
			int map[][] = new int[10][10];
			for(int[] a: map) fill(a, INF);
			for(int i=0;i<n;i++) {
				int a = sc.nextInt();
				int b = sc.nextInt();
				int c = sc.nextInt();
				maxn = max(maxn, max(a,b));
				map[a][b] = map[b][a] = c;
			}
			maxn++;
			for(int i=0;i<maxn;i++) map[i][i] = 0;
			for(int k=0;k<maxn;k++) for(int i=0;i<maxn;i++) for(int j=0;j<maxn;j++) {
				map[i][j] = min(map[i][j], map[i][k] + map[k][j]);
			}
//			for(int[] a: map) debug(a);
			
			int node = -1;
			int min = INF;
			for(int i=0;i<maxn;i++) {
				int sum = 0;
				for(int j=0;j<maxn;j++) sum += map[i][j];
				if(min > sum) {
					node = i;
					min = sum;
				}
			}
			System.out.println(node + " " + min);
			
		}
	}

	public static void main(String[] args) {
		new Main().run();
	}

	void debug(Object... os) {
		System.err.println(Arrays.deepToString(os));
	}
}

</source>
</class>

<class classid="285" nclones="2" nlines="20" similarity="100">
<source file="../hum_codes_raw/s701832384.java" startline="1" endline="26" pcid="23609">
import java.util.Scanner;

public class Main{

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int A = sc.nextInt();// 500
		int B = sc.nextInt();// 100
		int C = sc.nextInt();// 50
		int X = sc.nextInt();
		int ans = 0;
		int i,j,k;
		for (i = 0; i <= A; i++) {
			for (j = 0; j <= B; j++) {
				for (k = 0; k <= C; k++) {
					if (500 * i + 100 * j + 50 * k == X)
						ans+=1;
				}
			}
		}
		System.out.println(ans);

		
	}
}

</source>
<source file="../hum_codes_raw/s906415007.java" startline="1" endline="26" pcid="30498">
import java.util.Scanner;

public class Main{

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int A = sc.nextInt();// 500
		int B = sc.nextInt();// 100
		int C = sc.nextInt();// 50
		int X = sc.nextInt();
		int ans = 0;
		int i,j,k;
		for (i = 0; i <= A; i++) {
			for (j = 0; j <= B; j++) {
				for (k = 0; k <= C; k++) {
					if (500 * i + 100 * j + 50 * k == X)
						ans+=1;
				}
			}
		}
		System.out.println(ans);

		
	}
}

</source>
</class>

<class classid="286" nclones="2" nlines="88" similarity="100">
<source file="../hum_codes_raw/s715389482.java" startline="1" endline="100" pcid="24044">
import java.util.*;
import java.lang.*;
import java.math.*;
import java.io.*;

import static java.lang.Math.*;
import static java.util.Arrays.*;

public class Main{

	Scanner sc=new Scanner(System.in);

	static final int INF=1<<28;
	static final double EPS=1e-9;

	int n, s;
	int[][] sum;

	void run(){
		n=10;
		s=330;
		init();
		for(; sc.hasNext();){
			n=sc.nextInt();
			s=sc.nextInt();
			if(n<=10&&s<=330){
				println(sum[n-1][s]+"");
			}else{
				println("0");
			}
		}
		sc.close();
	}

	void init(){
		int[][] dp=new int[s+1][1<<10];
		int[][] dp2=new int[s+1][1<<10];
		sum=new int[n][s+1];
		dp[0][0]=1;

		for(int j=0; j<n; j++){
			for(int i=0; i<=s; i++){
				System.arraycopy(dp[i], 0, dp2[i], 0, 1<<10);
				Arrays.fill(dp[i], 0);
			}
			for(int i=0; i<10; i++){
				int d=(j+1)*i;
				for(int b=0; b<1<<10; b++){
					if(((1<<i)&b)==0){
						for(int k=0; k+d<=s; k++){
							dp[k+d][(1<<i)|b]+=dp2[k][b];
						}
					}
				}
			}
			for(int i=0; i<=s; i++){
				for(int b=0; b<1<<10; b++){
					sum[j][i]+=dp[i][b];
				}
			}
		}
	}

	int rec(int sum, int flag, int k){
		if(sum>s){
			return 0;
		}
		if(k==n){
			if(sum==s){
				return 1;
			}else{
				return 0;
			}
		}
		int ret=0;
		for(int i=0; i<10; i++){
			if(((1<<i)&flag)==0){
				ret+=rec(sum+(k+1)*i, (1<<i)|flag, k+1);
			}
		}
		return ret;
	}

	void debug(Object... os){
		System.err.println(Arrays.deepToString(os));
	}

	void print(String s){
		System.out.print(s);
	}

	void println(String s){
		System.out.println(s);
	}

	public static void main(String[] args){
		new Main().run();
	}
}

</source>
<source file="../hum_codes_raw/s727772113.java" startline="1" endline="108" pcid="24469">
import java.util.*;
import java.lang.*;
import java.math.*;
import java.io.*;

import static java.lang.Math.*;
import static java.util.Arrays.*;

public class Main{

	Scanner sc=new Scanner(System.in);

	static final int INF=1<<28;
	static final double EPS=1e-9;

	int n, s;
	int[][] sum;

	void run(){
		n=10;
		s=330;
		init();
		for(; sc.hasNext();){
			n=sc.nextInt();
			s=sc.nextInt();
			if(n<=10&&s<=330){
				println(sum[n-1][s]+"");
			}else{
				println("0");
			}
		}
		sc.close();
	}

	void init(){
		int[][] dp=new int[s+1][1<<10];
		int[][] dp2=new int[s+1][1<<10];
		sum=new int[n][s+1];
		dp[0][0]=1;

		for(int j=0; j<n; j++){
			for(int i=0; i<=s; i++){
				System.arraycopy(dp[i], 0, dp2[i], 0, 1<<10);
				Arrays.fill(dp[i], 0);
			}
			for(int i=0; i<10; i++){
				int d=(j+1)*i;
				for(int b=0; b<1<<10; b++){
					if(((1<<i)&b)==0){
						for(int k=0; k+d<=s; k++){
							dp[k+d][(1<<i)|b]+=dp2[k][b];
						}
					}
				}
			}
			for(int i=0; i<=s; i++){
				for(int b=0; b<1<<10; b++){
					sum[j][i]+=dp[i][b];
				}
			}
		}

		/*
		 * int ans=0;
		 * for(int i=0; i<1<<10; i++){
		 * ans+=dp[s][i];
		 * }
		 * println(ans+"");
		 */
	}

	int rec(int sum, int flag, int k){
		if(sum>s){
			return 0;
		}
		if(k==n){
			if(sum==s){
				return 1;
			}else{
				return 0;
			}
		}
		int ret=0;
		for(int i=0; i<10; i++){
			if(((1<<i)&flag)==0){
				ret+=rec(sum+(k+1)*i, (1<<i)|flag, k+1);
			}
		}
		return ret;
	}

	void debug(Object... os){
		System.err.println(Arrays.deepToString(os));
	}

	void print(String s){
		System.out.print(s);
	}

	void println(String s){
		System.out.println(s);
	}

	public static void main(String[] args){
		new Main().run();
	}
}

</source>
</class>

<class classid="287" nclones="2" nlines="149" similarity="100">
<source file="../hum_codes_raw/s715753651.java" startline="1" endline="192" pcid="24056">
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;
import java.util.Arrays;
import java.util.NoSuchElementException;
public class Main {
    private static final PrintStream ps     = System.out;
    private static final InputStream IS     = System.in;
    private static final byte[]      BUFFER = new byte[1024];
    private static int               ptr    = 0;
    private static int               buflen = 0;

    public static void main(String[] args) {
        final int max = Integer.MAX_VALUE;
        int n = ni();
        int[][] g = new int[n][n];
        for (int i = 0; i < n; i++) {
            Arrays.fill(g[i], max);
        }
        
        for (int i = 0; i < n; i++) {
            int u = ni();
            int m = ni();
            for (int j = 0; j < m; j++) {
                g[u][ni()] = ni();
            }
        }
        
//        UArr.printArr2D(g);
        int[] d = dijkstra(g, 0);
        for (int i = 0; i < n; i++) {
            ps.println(i + " " + d[i]);
        }
    }
    
    
    static int[] dijkstra(int[][] g, int from) {
        final int MAX = Integer.MAX_VALUE;
        int n = g.length;
        
        int[] d = new int[n];
        Arrays.fill(d, MAX);
        d[from] = 0;
        
        boolean[] visited = new boolean[n];
        
        while (true) {
            int u = -1;
            int min = MAX;
            for (int i = 0; i < n; i++) {
                if (!visited[i] && d[i] < min) {
                    u = i;
                    min = d[i];
                }
            }
            if (min == MAX) break;
            
            visited[u] = true;
            for (int i = 0; i < n; i++) {
                if (g[u][i] != MAX) {
                    d[i] = Math.min(d[i], d[u] + g[u][i]);
                }
            }
        }
        return d;
    }

    private static boolean hasNextByte() {
        if (ptr < buflen)
            return true;
        else {
            ptr = 0;
            try {
                buflen = IS.read(BUFFER);
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0)
                return false;
        }
        return true;
    }

    private static int readByte() {
        if (hasNextByte())
            return BUFFER[ptr++];
        else
            return -1;
    }

    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }

    public static boolean hasNext() {
        while (hasNextByte() && !isPrintableChar(BUFFER[ptr]))
            ptr++;
        return hasNextByte();
    }

    public static String n() {
        if (!hasNext())
            throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while (isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }

    public static long nl() {
        if (!hasNext())
            throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b)
            throw new NumberFormatException();
        while (true) {
            if ('0' <= b && b <= '9') {
                n *= 10;
                n += b - '0';
            } else if (b == -1 || !isPrintableChar(b))
                return minus ? -n : n;
            else
                throw new NumberFormatException();
            b = readByte();
        }
    }

    public static int ni() {
        long nl = nl();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)
            throw new NumberFormatException();
        return (int) nl;
    }

    public static double nextDouble() {
        return Double.parseDouble(n());
    }

    private static int[] nia(int n) {
        int[] a = new int[n];
        for (int i = 0; i < n; i++)
            a[i] = ni();
        return a;
    }

    private static long[] nla(int n) {
        long[] a = new long[n];
        for (int i = 0; i < n; i++)
            a[i] = nl();
        return a;
    }

    private static String[] na(int n) {
        String[] a = new String[n];
        for (int i = 0; i < n; i++)
            a[i] = n();
        return a;
    }

    private static int[][] nia2(int n, int m) {
        int[][] a = new int[n][m];
        for (int i = 0; i < n; i++)
            a[i] = nia(m);
        return a;
    }

    private static long[][] nla2(int n, int m) {
        long[][] a = new long[n][m];
        for (int i = 0; i < n; i++)
            a[i] = nla(m);
        return a;
    }

    private static char[][] nca2(int n) {
        char[][] a = new char[n][];
        for (int i = 0; i < n; i++)
            a[i] = n().toCharArray();
        return a;

    }
}


</source>
<source file="../hum_codes_raw/s846270822.java" startline="1" endline="194" pcid="28423">

import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;
import java.util.Arrays;
import java.util.NoSuchElementException;

public class Main {
    private static final PrintStream ps     = System.out;
    private static final InputStream IS     = System.in;
    private static final byte[]      BUFFER = new byte[1024];
    private static int               ptr    = 0;
    private static int               buflen = 0;

    public static void main(String[] args) {
        final int max = Integer.MAX_VALUE;
        int n = ni();
        int[][] g = new int[n][n];
        for (int i = 0; i < n; i++) {
            Arrays.fill(g[i], max);
        }
        
        for (int i = 0; i < n; i++) {
            int u = ni();
            int m = ni();
            for (int j = 0; j < m; j++) {
                g[u][ni()] = ni();
            }
        }
        
//        UArr.printArr2D(g);
        int[] d = dijkstra(g, 0);
        for (int i = 0; i < n; i++) {
            ps.println(i + " " + d[i]);
        }
    }
    
    
    static int[] dijkstra(int[][] g, int from) {
        final int MAX = Integer.MAX_VALUE;
        int n = g.length;
        
        int[] d = new int[n];
        Arrays.fill(d, MAX);
        d[from] = 0;
        
        boolean[] visited = new boolean[n];
        
        while (true) {
            int u = -1;
            int min = MAX;
            for (int i = 0; i < n; i++) {
                if (!visited[i] && d[i] < min) {
                    u = i;
                    min = d[i];
                }
            }
            if (min == MAX) break;
            
            visited[u] = true;
            for (int i = 0; i < n; i++) {
                if (g[u][i] != MAX) {
                    d[i] = Math.min(d[i], d[u] + g[u][i]);
                }
            }
        }
        return d;
    }

    private static boolean hasNextByte() {
        if (ptr < buflen)
            return true;
        else {
            ptr = 0;
            try {
                buflen = IS.read(BUFFER);
            } catch (IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0)
                return false;
        }
        return true;
    }

    private static int readByte() {
        if (hasNextByte())
            return BUFFER[ptr++];
        else
            return -1;
    }

    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }

    public static boolean hasNext() {
        while (hasNextByte() && !isPrintableChar(BUFFER[ptr]))
            ptr++;
        return hasNextByte();
    }

    public static String n() {
        if (!hasNext())
            throw new NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while (isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }

    public static long nl() {
        if (!hasNext())
            throw new NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b)
            throw new NumberFormatException();
        while (true) {
            if ('0' <= b && b <= '9') {
                n *= 10;
                n += b - '0';
            } else if (b == -1 || !isPrintableChar(b))
                return minus ? -n : n;
            else
                throw new NumberFormatException();
            b = readByte();
        }
    }

    public static int ni() {
        long nl = nl();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)
            throw new NumberFormatException();
        return (int) nl;
    }

    public static double nextDouble() {
        return Double.parseDouble(n());
    }

    private static int[] nia(int n) {
        int[] a = new int[n];
        for (int i = 0; i < n; i++)
            a[i] = ni();
        return a;
    }

    private static long[] nla(int n) {
        long[] a = new long[n];
        for (int i = 0; i < n; i++)
            a[i] = nl();
        return a;
    }

    private static String[] na(int n) {
        String[] a = new String[n];
        for (int i = 0; i < n; i++)
            a[i] = n();
        return a;
    }

    private static int[][] nia2(int n, int m) {
        int[][] a = new int[n][m];
        for (int i = 0; i < n; i++)
            a[i] = nia(m);
        return a;
    }

    private static long[][] nla2(int n, int m) {
        long[][] a = new long[n][m];
        for (int i = 0; i < n; i++)
            a[i] = nla(m);
        return a;
    }

    private static char[][] nca2(int n) {
        char[][] a = new char[n][];
        for (int i = 0; i < n; i++)
            a[i] = n().toCharArray();
        return a;

    }
}


</source>
</class>

<class classid="288" nclones="2" nlines="10" similarity="100">
<source file="../hum_codes_raw/s716387324.java" startline="1" endline="14" pcid="24081">
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;

class Main{
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        String[] input = br.readLine().split(" ");

        System.out.println((Integer.parseInt(input[0]) + Integer.parseInt(input[1])) / 2);
    }
} 

</source>
<source file="../hum_codes_raw/s783566823.java" startline="1" endline="15" pcid="26313">
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;

class Main{
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        String[] input = br.readLine().split(" ");

        System.out.println((Integer.parseInt(input[0]) + Integer.parseInt(input[1])) / 2);
    }
} 


</source>
</class>

<class classid="289" nclones="2" nlines="140" similarity="100">
<source file="../hum_codes_raw/s724609023.java" startline="1" endline="157" pcid="24370">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.Arrays;
import java.util.Scanner;
import java.util.StringTokenizer;
 
public class Main {
 
    public static class WeightedUnionFind{
        int[] par; // ????????????
        int[] ws;  // ????????????????????
         
        public WeightedUnionFind(int n){
            par = new int[n];
            ws  = new int[n];
            for(int i = 0; i < n; i++){ 
                par[i] = -1;
            }
        }
         
        public int find(int x){
            if(par[x] < 0){
                return x;
            }else{
                final int parent = find(par[x]);
                ws[x] += ws[par[x]];
                par[x] = parent;
                return parent;
            }
        }
         
        public int weight(int x){
            find(x);
            return ws[x];
        }
         
        public boolean union(int x, int y, int w){ // x <-(w)- y (x + w = y)
            w += weight(x);
            w -= weight(y);
            x = find(x);
            y = find(y);
             
            if(x != y){
                if(par[y] < par[x]) {  // ???????????????????????????????????????????????????.
                    int tmp = x; x = y; y = tmp;
                    w = -w;
                }
                par[x] += par[y];
                par[y] = x;
                ws[y] = w;
                 
                return true;
            }else{
                return false;
            }
        }
         
        public boolean same(int x, int y){
            return find(x) == find(y);
        }
         
        public Integer diff(int x, int y){ // x - y ???????????. ??????????????????null.
            if(!same(x, y)){
                return null;
            }else{
                return this.weight(x) - this.weight(y);
            }
        }
         
        public int size(int x){
            return -par[find(x)];
        }
    }
     
    public static void main(String[] args) throws IOException {
        Scanner sc = new Scanner(System.in);
 
        while(true){
            final int n = sc.nextInt();
            final int m = sc.nextInt();
             
            if(n == 0 && m == 0){
                break;
            }
             
            WeightedUnionFind uf = new WeightedUnionFind(n);
             
            for(int i = 0; i < m; i++){
                final char ops = sc.nextChar();
                 
                if('?' == ops){
                    final int r = sc.nextInt() - 1;
                    final int l = sc.nextInt() - 1;
                    final Integer ret = uf.diff(r, l);
                    System.out.println(ret == null ? "UNKNOWN" : -ret);
                }else{
                    final int r = sc.nextInt() - 1;
                    final int l = sc.nextInt() - 1;
                    final int w = sc.nextInt();
                     
                    uf.union(r, l, w);
                }
            }
        }
         
        sc.close();
    }
     
    public static class Scanner {
        private Reader br;
 
        public Scanner(InputStream is) throws IOException {
            br = new BufferedReader(new InputStreamReader(is));
        }
         
        public int nextInt() throws IOException {
            int sign = 1;
            int b = br.read();
             
            while(((b < '0') || ('9' < b)) && b != '-' && b != '+'){
                if(b == -1){ return 0; }
                b = br.read();
            }
             
            if(b == '-'){
                sign = -1;
                b = br.read();
            }else if(b == '+'){
                b = br.read();
            }
             
            int ret = b - '0';
            while(true){
                b = br.read();
                if(b < '0' || b > '9'){ return sign * ret; }
                ret *= 10;
                ret += b - '0';
            }
        }
         
        public char nextChar() throws IOException{
            int b = br.read();
            while(Character.isWhitespace(b)){
                b = br.read();
            }
            return (char)(b);
        }
         
        public void close() throws IOException {
            br.close();
        }
    }
}

</source>
<source file="../hum_codes_raw/s964356831.java" startline="1" endline="157" pcid="32408">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.Arrays;
import java.util.Scanner;
import java.util.StringTokenizer;

public class Main {

	public static class WeightedUnionFind{
	    int[] par; // 
	    int[] ws;  // 
	    
	    public WeightedUnionFind(int n){
	        par = new int[n];
	        ws  = new int[n];
	        for(int i = 0; i < n; i++){ 
	        	par[i] = -1;
	        }
	    }
	    
	    public int find(int x){
	    	if(par[x] < 0){
	    		return x;
	    	}else{
	    		final int parent = find(par[x]);
	    		ws[x] += ws[par[x]];
	    		par[x] = parent;
	    		return parent;
	    	}
	    }
	    
	    public int weight(int x){
	    	find(x);
	    	return ws[x];
	    }
	    
	    public boolean union(int x, int y, int w){ // x <-(w)- y (x + w = y)
	    	w += weight(x);
	    	w -= weight(y);
	        x = find(x);
	        y = find(y);
	        
	        if(x != y){
	            if(par[y] < par[x]) {  // .
	                int tmp = x; x = y; y = tmp;
	                w = -w;
	            }
	            par[x] += par[y];
	            par[y] = x;
	            ws[y] = w;
	            
	            return true;
	        }else{
	            return false;
	        }
	    }
	    
	    public boolean same(int x, int y){
	        return find(x) == find(y);
	    }
	    
	    public Integer diff(int x, int y){ // x - y . null.
	    	if(!same(x, y)){
	    		return null;
	    	}else{
	    		return this.weight(x) - this.weight(y);
	    	}
	    }
	    
	    public int size(int x){
	        return -par[find(x)];
	    }
	}
	
	public static void main(String[] args) throws IOException {
		Scanner sc = new Scanner(System.in);

		while(true){
			final int n = sc.nextInt();
			final int m = sc.nextInt();
			
			if(n == 0 && m == 0){
				break;
			}
			
			WeightedUnionFind uf = new WeightedUnionFind(n);
			
			for(int i = 0; i < m; i++){
				final char ops = sc.nextChar();
				
				if('?' == ops){
					final int r = sc.nextInt() - 1;
					final int l = sc.nextInt() - 1;
					final Integer ret = uf.diff(r, l);
					System.out.println(ret == null ? "UNKNOWN" : -ret);
				}else{
					final int r = sc.nextInt() - 1;
					final int l = sc.nextInt() - 1;
					final int w = sc.nextInt();
					
					uf.union(r, l, w);
				}
			}
		}
		
		sc.close();
	}
	
	public static class Scanner {
	    private Reader br;

	    public Scanner(InputStream is) throws IOException {
	        br = new BufferedReader(new InputStreamReader(is));
	    }
	    
	    public int nextInt() throws IOException {
	    	int sign = 1;
	    	int b = br.read();
	    	
	    	while(((b < '0') || ('9' < b)) && b != '-' && b != '+'){
	    		if(b == -1){ return 0; }
	    		b = br.read();
	    	}
	    	
	    	if(b == '-'){
	    		sign = -1;
	    		b = br.read();
	    	}else if(b == '+'){
	    		b = br.read();
	    	}
	    	
	    	int ret = b - '0';
	    	while(true){
	    		b = br.read();
	    		if(b < '0' || b > '9'){ return sign * ret; }
	    		ret *= 10;
	    		ret += b - '0';
	    	}
	    }
	    
	    public char nextChar() throws IOException{
	    	int b = br.read();
	    	while(Character.isWhitespace(b)){
	    		b = br.read();
	    	}
	    	return (char)(b);
	    }
	    
	    public void close() throws IOException {
	        br.close();
	    }
	}
}

</source>
</class>

<class classid="290" nclones="2" nlines="97" similarity="100">
<source file="../hum_codes_raw/s737451188.java" startline="1" endline="111" pcid="24791">
import java.util.*;
 
public class Main {
	static int N;
	static long A, B;
	static long[] S;
	static long[][] dpA;
	static long[][] dpB;
	static BinaryIndexedTree bitA;
	static BinaryIndexedTree bitB;
	static final long MOD = 1_000_000_000 + 7;
 
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		N = sc.nextInt();
		A = sc.nextLong();
		B = sc.nextLong();
		S = new long[N];
		dpA = new long[2][N];
		dpB = new long[2][N];
		bitA = new BinaryIndexedTree(N);
		bitB = new BinaryIndexedTree(N);
		Stack<Query> stackA = new Stack<>();
		Stack<Query> stackB = new Stack<>();
		for (int i = 0; i < N; ++i) {
			S[i] = sc.nextLong();
		}
		Arrays.sort(S);
 
		bitA.addVal(0 + 1, 1);
		bitB.addVal(0 + 1, 1);
		stackA.push(new Query(0 + 1, 1));
		stackB.push(new Query(0 + 1, 1));
		int leftA = -1;
		int leftB = -1;
		for (int i = 0; i + 1 < N; ++i) {
			long sA = 0;
			long sB = 0;
			while (S[i + 1] - S[leftA + 1] >= A)
				++leftA;
			while (S[i + 1] - S[leftB + 1] >= B)
				++leftB;
			sB = bitA.getVal((leftB + 1) + 1);
			sA = bitB.getVal((leftA + 1) + 1);
			if (S[i + 1] - S[i] < A) {
				while (!stackA.isEmpty()) {
					Query q = stackA.pop();
					bitA.addVal(q.pos, -q.val);
				}
			}
			if (S[i + 1] - S[i] < B) {
				while (!stackB.isEmpty()) {
					Query q = stackB.pop();
					bitB.addVal(q.pos, -q.val);
				}
			}
			bitA.addVal((i + 1) + 1, sA);
			bitB.addVal((i + 1) + 1, sB);
			stackA.add(new Query((i + 1) + 1, sA));
			stackB.add(new Query((i + 1) + 1, sB));
		}
		System.out.println((bitA.getVal(N) + bitB.getVal(N)) % MOD);
	}
 
	static class BinaryIndexedTree {
		int n;
		long[] val;
 
		public BinaryIndexedTree(int n) {
			this.n = n;
			val = new long[n + 1];
		}
 
		void addVal(int k, long v) {
			while (k <= n) {
				val[k] += v;
				val[k] = (val[k] + MOD) % MOD;
				k += k & -k;
			}
		}
 
		long getVal(int k) {
			long s = 0;
			while (k > 0) {
				s += val[k];
				s = (s + MOD) % MOD;
				k -= k & -k;
			}
			return s;
		}
 
		void clear() {
			val = new long[n + 1];
		}
	}
 
	static class Query {
		int pos;
		long val;
 
		public Query(int pos, long val) {
			this.pos = pos;
			this.val = val;
		}
	}
 
	static void tr(Object... objects) {
		System.out.println(Arrays.deepToString(objects));
	}
}

</source>
<source file="../hum_codes_raw/s747884507.java" startline="1" endline="111" pcid="25126">
import java.util.*;

public class Main {
	static int N;
	static long A, B;
	static long[] S;
	static long[][] dpA;
	static long[][] dpB;
	static BinaryIndexedTree bitA;
	static BinaryIndexedTree bitB;
	static final long MOD = 1_000_000_000 + 7;

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		N = sc.nextInt();
		A = sc.nextLong();
		B = sc.nextLong();
		S = new long[N];
		dpA = new long[2][N];
		dpB = new long[2][N];
		bitA = new BinaryIndexedTree(N);
		bitB = new BinaryIndexedTree(N);
		Stack<Query> stackA = new Stack<>();
		Stack<Query> stackB = new Stack<>();
		for (int i = 0; i < N; ++i) {
			S[i] = sc.nextLong();
		}
		Arrays.sort(S);

		bitA.addVal(0 + 1, 1);
		bitB.addVal(0 + 1, 1);
		stackA.push(new Query(0 + 1, 1));
		stackB.push(new Query(0 + 1, 1));
		int leftA = -1;
		int leftB = -1;
		for (int i = 0; i + 1 < N; ++i) {
			long sA = 0;
			long sB = 0;
			while (S[i + 1] - S[leftA + 1] >= A)
				++leftA;
			while (S[i + 1] - S[leftB + 1] >= B)
				++leftB;
			sB = bitA.getVal((leftB + 1) + 1);
			sA = bitB.getVal((leftA + 1) + 1);
			if (S[i + 1] - S[i] < A) {
				while (!stackA.isEmpty()) {
					Query q = stackA.pop();
					bitA.addVal(q.pos, -q.val);
				}
			}
			if (S[i + 1] - S[i] < B) {
				while (!stackB.isEmpty()) {
					Query q = stackB.pop();
					bitB.addVal(q.pos, -q.val);
				}
			}
			bitA.addVal((i + 1) + 1, sA);
			bitB.addVal((i + 1) + 1, sB);
			stackA.add(new Query((i + 1) + 1, sA));
			stackB.add(new Query((i + 1) + 1, sB));
		}
		System.out.println((bitA.getVal(N) + bitB.getVal(N)) % MOD);
	}

	static class BinaryIndexedTree {
		int n;
		long[] val;

		public BinaryIndexedTree(int n) {
			this.n = n;
			val = new long[n + 1];
		}

		void addVal(int k, long v) {
			while (k <= n) {
				val[k] += v;
				val[k] = (val[k] + MOD) % MOD;
				k += k & -k;
			}
		}

		long getVal(int k) {
			long s = 0;
			while (k > 0) {
				s += val[k];
				s = (s + MOD) % MOD;
				k -= k & -k;
			}
			return s;
		}

		void clear() {
			val = new long[n + 1];
		}
	}

	static class Query {
		int pos;
		long val;

		public Query(int pos, long val) {
			this.pos = pos;
			this.val = val;
		}
	}

	static void tr(Object... objects) {
		System.out.println(Arrays.deepToString(objects));
	}
}

</source>
</class>

<class classid="291" nclones="2" nlines="11" similarity="100">
<source file="../hum_codes_raw/s739842892.java" startline="1" endline="10" pcid="24853">
import java.util.Scanner;
public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int sum = 0;
		for(int i = 0; i < 5; i++){sum += Math.max(40, sc.nextInt());}
		System.out.println(sum/5);
	}
}

</source>
<source file="../hum_codes_raw/s953989737.java" startline="1" endline="20" pcid="32060">
import java.util.Scanner;
 
 
public class Main {
     
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
         
         
        int sum = 0;
        for(int i = 0; i < 5; i++){
            sum += Math.max(40, sc.nextInt());
        }
         
        System.out.println(sum / 5);
         
    }
 
}

</source>
</class>

<class classid="292" nclones="2" nlines="56" similarity="100">
<source file="../hum_codes_raw/s740463383.java" startline="1" endline="68" pcid="24881">
// This file is a "Hello, world!" in Java language by OpenJDK for wandbox.
import java.util.*;
import java.io.*;

class Main
{
	public static void main(String[] args)
	{
		new Main().run();
	}
	
	void run(){
		Scanner sc=new Scanner(System.in);
		int N=sc.nextInt();
		int[] A=new int[N];
		int[] A_diff=new int[2*N-1];
		int[] B=new int[N];
		int[] B_diff=new int[N];
		for(int i=0;i<N;++i)A[i]=sc.nextInt();
		for(int i=0;i<N;++i)B[i]=sc.nextInt();
		for(int i=0;i<N;++i)A_diff[i]=A[i]^A[(i+1)%N];
		for(int i=0;i<N;++i)B_diff[i]=B[i]^B[(i+1)%N];
		for(int i=0;i<N-1;++i)A_diff[i+N]=A_diff[i];
		boolean[] search=search(A_diff,B_diff);
		int ans=0;
		PrintWriter pw=new PrintWriter(System.out);
		for(int i=0;i<N;++i){
			if(search[i]){
				pw.println(i+" " +(B[0]^A[i]));
			}
		}
		pw.close();
	}
	
	boolean[] search(int[] a,int[] b){
		int[] border=border(b);
		boolean[] ret=new boolean[a.length];
		int s=0,t=0,match=0;
		for(int i=0;i<a.length;++i){
			while(match>=0&&(match>=b.length||b[match]!=a[i]))match=(match==0?-1:border[match-1]);
			++match;
			if(match==b.length){ret[i-match+1]=true;}
		}
		return ret;
	}
	
	int[] border(int[] b){
		int n=b.length;
		int[] pat=new int[n];
		int match=0;
		for(int i=1;i<n;++i){
			while(match>=0&&b[i]!=b[match])
				match=(match==0?-1:pat[match-1]);
			++match;
			pat[i]=match;
		}
		return pat;
	}
	
	void tr(Object...o){System.out.println(Arrays.deepToString(o));}
}

// OpenJDK reference:
//   http://openjdk.java.net/

// Java language references:
//   http://docs.oracle.com/javase

</source>
<source file="../hum_codes_raw/s836157593.java" startline="1" endline="68" pcid="28070">
// This file is a "Hello, world!" in Java language by OpenJDK for wandbox.
import java.util.*;
import java.io.*;

class Main
{
    public static void main(String[] args)
    {
		new Main().run();
    }
	
	void run(){
		Scanner sc=new Scanner(System.in);
		int N=sc.nextInt();
		int[] A=new int[N];
		int[] A_diff=new int[2*N-1];
		int[] B=new int[N];
		int[] B_diff=new int[N];
		for(int i=0;i<N;++i)A[i]=sc.nextInt();
		for(int i=0;i<N;++i)B[i]=sc.nextInt();
		for(int i=0;i<N;++i)A_diff[i]=A[i]^A[(i+1)%N];
		for(int i=0;i<N;++i)B_diff[i]=B[i]^B[(i+1)%N];
		for(int i=0;i<N-1;++i)A_diff[i+N]=A_diff[i];
		boolean[] search=search(A_diff,B_diff);
		int ans=0;
		PrintWriter pw=new PrintWriter(System.out);
		for(int i=0;i<N;++i){
			if(search[i]){
				pw.println(i+" " +(B[0]^A[i]));
			}
		}
		pw.close();
	}
	
	boolean[] search(int[] a,int[] b){
		int[] border=border(b);
		boolean[] ret=new boolean[a.length];
		int s=0,t=0,match=0;
		for(int i=0;i<a.length;++i){
			while(match>=0&&(match>=b.length||b[match]!=a[i]))match=(match==0?-1:border[match-1]);
			++match;
			if(match==b.length){ret[i-match+1]=true;}
		}
		return ret;
	}
	
	int[] border(int[] b){
		int n=b.length;
		int[] pat=new int[n];
		int match=0;
		for(int i=1;i<n;++i){
			while(match>=0&&b[i]!=b[match])
				match=(match==0?-1:pat[match-1]);
			++match;
			pat[i]=match;
		}
		return pat;
	}
	
	void tr(Object...o){System.out.println(Arrays.deepToString(o));}
}

// OpenJDK reference:
//   http://openjdk.java.net/

// Java language references:
//   http://docs.oracle.com/javase

</source>
</class>

<class classid="293" nclones="2" nlines="49" similarity="100">
<source file="../hum_codes_raw/s742846647.java" startline="1" endline="66" pcid="24959">

import java.util.Scanner;


public class Main {
	
	public static class BIT {
		int[] dat;
		
		public BIT(int n){
			dat = new int[n + 1];
		}
		
		public void add(int k, int a){ // k : 0-indexed
			for(int i = k + 1; i < dat.length; i += i & -i){
				dat[i] += a;	
			}
		}
		
		public int sum(int s, int t){ // [s, t)
			if(s > 0) return sum(0, t) - sum(0, s);
			
			int ret = 0;
			for(int i = t; i > 0; i -= i & -i) {
				ret += dat[i];
			}
			return ret;
		}
		
		public int get(int k){ // k : 0-indexed
			int p = Integer.highestOneBit(dat.length - 1);
			for(int q = p; q > 0; q >>= 1, p |= q){
				if( p >= dat.length || k < dat[p]) p ^= q;
				else k -= dat[p];
			}
			return p;
		}
	}
	
	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		
		while(true){
			final int n = sc.nextInt();
			final int k = sc.nextInt();
			
			if(n == 0 && k == 0){
				break;
			}
			
			BIT bit = new BIT(n);
			for(int i = 0; i < n; i++){
				bit.add(i, sc.nextInt());
			}
			
			int max = Integer.MIN_VALUE;
			for(int start = 0; start < n - k + 1; start++){
				max = Math.max(max, bit.sum(start, start + k));
				//System.out.println("[" + start + " " + (start + k) + ") = " + bit.sum(start, start + k));
			}
		
		System.out.println(max);
		}
	}
}

</source>
<source file="../hum_codes_raw/s856221251.java" startline="1" endline="65" pcid="28780">
import java.util.Scanner;


public class Main {

		public static class BIT{
				int[] dat;
				
				public BIT(int n){
						dat = new int[n + 1];
				}
				
				public void add(int k, int a){
						for(int i = k + 1; i < dat.length; i += i & -i){
								dat[i] += a;	
						}
				}
				
				public int sum(int s, int t){
						if(s > 0) return sum(0, t) - sum(0, s);
						
						int ret = 0;
						for(int i = t; i > 0; i -= i & -i) {
								ret += dat[i];
						}
						return ret;
				}
				
				public int get(int k){
						int p = Integer.highestOneBit(dat.length - 1);
						for(int q = p; q > 0; q >>= 1, p |= q){
								if( p >= dat.length || k < dat[p]) p ^= q;
								else k -= dat[p];
						}
						return p;
				}
		}
		
		public static void main(String[] args){
				Scanner sc = new Scanner(System.in);
				
				while(true){
						final int n = sc.nextInt();
						final int k = sc.nextInt();

						if(n == 0 && k == 0){
								break;
						}

						BIT bit = new BIT(n);
						for(int i = 0; i < n; i++){
								bit.add(i, sc.nextInt());
						}

						int max = Integer.MIN_VALUE;
						for(int start = 0; start < n - k + 1; start++){
								max = Math.max(max, bit.sum(start, start + k));
								//System.out.println("[" + start + " " + (start + k) + ") = " + bit.sum(start, start + k));
						}
						
						System.out.println(max);
				}
		}
}

</source>
</class>

<class classid="294" nclones="2" nlines="54" similarity="100">
<source file="../hum_codes_raw/s747076084.java" startline="1" endline="59" pcid="25089">


import java.util.Scanner;

public class Main {
	int width;//?????????????????????
	int height;//????????????????????????
	//?????????????????????????????????
	void printData(int crowd[][]){
		for(int i = 0;i <height;i++){
			for(int j = 0;j < width;j++){
				if(j < width-1){
					System.out.print(crowd[j][i]+" ");					
				}else{
					System.out.print(crowd[j][i]);						
				}
			}
			System.out.println();
		}	
	}
	//????????????????????????????????????????????????????????????????
	void calcCrowd(int crowd[][]){
		for(int i = 0;i <height;i++){
			for(int j = 0;j < width;j++){
				for(int k = width-1;k >= 0;k--){
					if(crowd[k][i] == 0 && crowd[j][i] == -1 && k < j){
						crowd[j][i] = j-k;
					}
				}
			}
		}		
	}
	void doIt(){
		Scanner sc = new Scanner(System.in);
		this.height = sc.nextInt();
		this.width = sc.nextInt();
		String c[] = new String[height];
		int crowd[][] = new int[width][height];
		for(int i = 0; i < height;i++){
			c[i] = sc.next();
		}
		for(int i = 0;i <height;i++){
			for(int j = 0;j < width;j++){
				if(c[i].charAt(j) == 'c'){
					crowd[j][i] = 0;
				}else{
					crowd[j][i] = -1;	
				}
			}
		}
		calcCrowd(crowd);
		printData(crowd);
	}
	public static void main(String[] args) {
		new Main().doIt();
	}

}

</source>
<source file="../hum_codes_raw/s984250523.java" startline="1" endline="58" pcid="33097">

import java.util.Scanner;

public class Main {
	int width;//?????????????????????
	int height;//????????????????????????
	//?????????????????????????????????
	void printData(int crowd[][]){
		for(int i = 0;i <height;i++){
			for(int j = 0;j < width;j++){
				if(j < width-1){
					System.out.print(crowd[j][i]+" ");					
				}else{
					System.out.print(crowd[j][i]);						
				}
			}
			System.out.println();
		}	
	}
	//????????????????????????????????????????????????????????????????
	void calcCrowd(int crowd[][]){
		for(int i = 0;i <height;i++){
			for(int j = 0;j < width;j++){
				for(int k = width-1;k >= 0;k--){
					if(crowd[k][i] == 0 && crowd[j][i] == -1 && k < j){
						crowd[j][i] = j-k;
					}
				}
			}
		}		
	}
	void doIt(){
		Scanner sc = new Scanner(System.in);
		this.height = sc.nextInt();
		this.width = sc.nextInt();
		String c[] = new String[height];
		int crowd[][] = new int[width][height];
		for(int i = 0; i < height;i++){
			c[i] = sc.next();
		}
		for(int i = 0;i <height;i++){
			for(int j = 0;j < width;j++){
				if(c[i].charAt(j) == 'c'){
					crowd[j][i] = 0;
				}else{
					crowd[j][i] = -1;	
				}
			}
		}
		calcCrowd(crowd);
		printData(crowd);
	}
	public static void main(String[] args) {
		new Main().doIt();
	}

}

</source>
</class>

<class classid="295" nclones="2" nlines="38" similarity="100">
<source file="../hum_codes_raw/s751521433.java" startline="1" endline="54" pcid="25254">
import java.util.Scanner;
public class Main
{
	public static void main(String arg[])
	{
		Scanner in = new Scanner(System.in);
		while(in.hasNext())
		{
			int n=in.nextInt();
			if(n==0)
				return;
			int a[]=new int[n];
			int b[]=new int[n];

			for(int i=0; i<n;i++)
			{
				a[i]=in.nextInt();
				b[i]=in.nextInt();
			}
			for(int i=0;i<n;i++)
			{
				int m=i;
				for(int j=i;j<n; j++)
				{
					if(b[j]<b[m])
						m=j;
				}
				int tmp =b[i];
				b[i] = b[m];
				b[m] = tmp;
				tmp =a[i];
				a[i]=a[m];
				a[m]=tmp;
			}
			//for(int i=0;i<n; i++)
			//System.out.println(a[i]+" "+b[i]);
			boolean flag=true;
			int T=0;
			int W=0;
			for(int i=0;i <n;i++)
			{
				T+=a[i];
				W=b[i];
				if(T>W)
					flag=false;
			}
			if(flag)
				System.out.println("Yes");
			else
				System.out.println("No");
		}
	}
}

</source>
<source file="../hum_codes_raw/s934430464.java" startline="1" endline="52" pcid="31422">
import java.util.Scanner;
public class Main
{
	public static void main(String arg[])
	{
		Scanner in = new Scanner(System.in);
		while(in.hasNext())
		{
			int n=in.nextInt();
			if(n==0)
				return;
			int a[]=new int[n];
			int b[]=new int[n];

			for(int i=0; i<n;i++)
			{
				a[i]=in.nextInt();
				b[i]=in.nextInt();
			}
			for(int i=0;i<n;i++)
			{
				int m=i;
				for(int j=i;j<n; j++)
				{
					if(b[j]<b[m])
						m=j;
				}
				int tmp =b[i];
				b[i] = b[m];
				b[m] = tmp;
				tmp =a[i];
				a[i]=a[m];
				a[m]=tmp;
			}
			boolean flag=true;
			int T=0;
			int W=0;
			for(int i=0;i <n;i++)
			{
				T+=a[i];
				W=b[i];
				if(T>W)
					flag=false;
			}
			if(flag)
				System.out.println("Yes");
			else
				System.out.println("No");
		}
	}
}

</source>
</class>

<class classid="296" nclones="2" nlines="40" similarity="100">
<source file="../hum_codes_raw/s762799528.java" startline="1" endline="41" pcid="25622">
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		List<Integer> list = new ArrayList<>();
		for (int i = 0; i < n; i++) {
			list.add(sc.nextInt());
		}
		int m = sc.nextInt();
		List<Integer> list2 = new ArrayList<>();
		for (int i = 0; i < m; i++) {
			list2.add(sc.nextInt());
		}
		int size = Math.min(list.size(), list2.size());
		int res = -1;
		for (int i = 0; i < size; i++) {
			if (list2.get(i) > list.get(i)) {
				res = 1;
				break;
			} else if (list2.get(i) < list.get(i)) {
				res = 0;
				break;
			}
		}
		if (res < 0) {
			if (m > n) {
				res = 1;
			} else {
				res = 0;
			}
		}
		System.out.println(res);
	}
}


</source>
<source file="../hum_codes_raw/s923869292.java" startline="1" endline="42" pcid="31067">
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		List<Integer> list = new ArrayList<>();
		for (int i = 0; i < n; i++) {
			list.add(sc.nextInt());
		}
		int m = sc.nextInt();
		List<Integer> list2 = new ArrayList<>();
		for (int i = 0; i < m; i++) {
			list2.add(sc.nextInt());
		}
		int size = Math.min(list.size(), list2.size());
		int res = -1;
		for (int i = 0; i < size; i++) {
			if (list2.get(i) > list.get(i)) {
				res = 1;
				break;
			} else if (list2.get(i) < list.get(i)) {
				res = 0;
				break;
			}
		}
		if (res < 0) {
			if (m > n) {
				res = 1;
			} else {
				res = 0;
			}
		}
		System.out.println(res);
	}
}



</source>
</class>

<class classid="297" nclones="2" nlines="30" similarity="100">
<source file="../hum_codes_raw/s772727847.java" startline="1" endline="34" pcid="25942">
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main{

	void run(){
		Scanner sc = new Scanner(System.in);
		for(;;){
			int n = sc.nextInt();
			if(n==0)break;
			boolean[][] e = new boolean[n][n+1];
			for(int i=0;i<n;i++){
				int m = sc.nextInt();
				while(m--!=0)e[i][sc.nextInt()]=true;
			}
			boolean[] f = new boolean[n+1];
			int K = sc.nextInt();
			while(K--!=0)f[sc.nextInt()]=true;
			List<Integer> l = new ArrayList<Integer>();
			for(int i=0;i<n;i++){
				boolean ok = true;
				for(int j=1;j<=n;j++)if(f[j]&&!e[i][j])ok=false;
				if(ok)l.add(i+1);
			}
			System.out.println(l.isEmpty()||l.size()>1?-1:l.get(0));
		}
	}
	
	public static void main(String[] args) {
		new Main().run();
	}
}

</source>
<source file="../hum_codes_raw/s820968583.java" startline="1" endline="35" pcid="27552">
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

//Save Your Privacy!
public class Main{

	void run(){
		Scanner sc = new Scanner(System.in);
		for(;;){
			int n = sc.nextInt();
			if(n==0)break;
			boolean[][] e = new boolean[n][n+1];
			for(int i=0;i<n;i++){
				int m = sc.nextInt();
				while(m--!=0)e[i][sc.nextInt()]=true;
			}
			boolean[] f = new boolean[n+1];
			int K = sc.nextInt();
			while(K--!=0)f[sc.nextInt()]=true;
			List<Integer> l = new ArrayList<Integer>();
			for(int i=0;i<n;i++){
				boolean ok = true;
				for(int j=1;j<=n;j++)if(f[j]&&!e[i][j])ok=false;
				if(ok)l.add(i+1);
			}
			System.out.println(l.isEmpty()||l.size()>1?-1:l.get(0));
		}
	}
	
	public static void main(String[] args) {
		new Main().run();
	}
}

</source>
</class>

<class classid="298" nclones="2" nlines="40" similarity="100">
<source file="../hum_codes_raw/s773259980.java" startline="1" endline="50" pcid="25964">
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        try (Scanner sc = new Scanner(System.in)) {
            while(true){
                int n = sc.nextInt();
                int r = sc.nextInt();

                if(n==0){
                    break;
                }
                int[] card = new int[n];
                for(int i=0;i<n;i++){
                    card[i] = n-i;
                }

                for(int i=0;i<r;i++){
                    int p = sc.nextInt();
                    int c = sc.nextInt();

                    int[] shuffleC = new int[c];
                    int[] shuffleP = new int[p];

                    for(int j=0;j<p-1;j++){
                        shuffleP[j] = card[j];
                    }
                    for(int j=0;j<c;j++){
                        shuffleC[j] = card[p-1+j];
                    }

                    for(int j=0;j<c;j++){
                        card[j] = shuffleC[j];
                    }
                    for(int j=0;j<p-1;j++){
                        card[j+c] = shuffleP[j];
                    }

                    shuffleC = null;
                    shuffleP = null;

                }
                
                System.out.println(card[0]);
                
                card =null;
            }
        }  
    }
}

</source>
<source file="../hum_codes_raw/s985822988.java" startline="1" endline="50" pcid="33163">
import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        try (Scanner sc = new Scanner(System.in)) {
            while(true){
                int n = sc.nextInt();
                int r = sc.nextInt();

                if(n==0){
                    break;
                }
                int[] card = new int[n];
                for(int i=0;i<n;i++){
                    card[i] = n-i;
                }

                for(int i=0;i<r;i++){
                    int p = sc.nextInt();
                    int c = sc.nextInt();

                    int[] shuffleC = new int[c];
                    int[] shuffleP = new int[p];

                    for(int j=0;j<p-1;j++){
                        shuffleP[j] = card[j];
                    }
                    for(int j=0;j<c;j++){
                        shuffleC[j] = card[p-1+j];
                    }

                    for(int j=0;j<c;j++){
                        card[j] = shuffleC[j];
                    }
                    for(int j=0;j<p-1;j++){
                        card[j+c] = shuffleP[j];
                    }

                    shuffleC = null;
                    shuffleP = null;

                }
                
                System.out.println(card[0]);
                
                card =null;
            }
        }  
    }
}

</source>
</class>

<class classid="299" nclones="2" nlines="179" similarity="100">
<source file="../hum_codes_raw/s790111644.java" startline="1" endline="228" pcid="26530">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.PrintStream;
import java.io.BufferedWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        D solver = new D();
        solver.solve(1, in, out);
        out.close();
    }

    static class D {
        public void solve(int testNumber, InputReader in, OutputWriter out) {
//        for (int LL = 2; LL <= 16; LL++) {
//            List<Edge> edges = solve(LL);
//            System.err.println("");
//            System.err.println("solving L = " + LL);
//            for (Edge e : edges) {
//                System.err.println(e.x + " " + e.y + " " + e.w);
//            }
//        }
//        for (int LL = 1<<19; LL >= (1<<19) - 20; LL--) {
//            List<Edge> edges = solve(LL);
//            System.err.println("");
//            System.err.println("solving L = " + LL);
//            for (Edge e : edges) {
//                System.err.println(e.x + " " + e.y + " " + e.w);
//            }
//        }

            int L = in.readInt();
            List<D.Edge> edges = solve(L);
            int n = 0;
            for (D.Edge e : edges) {
                n = Math.max(n, e.x);
                n = Math.max(n, e.y);
            }
            n++;
            for (D.Edge e : edges) {
                e.normalize(n);
            }
            out.printLine(n + " " + edges.size());
            for (D.Edge e : edges) {
                out.printLine(e.x + " " + e.y + " " + e.w);
            }
        }

        private List<D.Edge> solve(int L) {
            int n = getVertCount(L);
            List<D.Edge> edges = new ArrayList<>();
            for (int i = 0; i < n - 1; i++) {
                edges.add(new D.Edge(i + 1, i, 0));
                edges.add(new D.Edge(i + 1, i, 1 << i));
            }
//        System.err.println("L = " + L);
            if ((L & (L - 1)) == 0) {
                return edges;
            }
            if (L == 6) {
                System.err.print("");
            }
            int have = Integer.highestOneBit(L);
            while (have < L) { // L is not 2^n-1
                int bit = Integer.numberOfTrailingZeros(Integer.highestOneBit(L - have));
                int first = have;
                int last = have + (1 << bit) - 1;
                int pw = 19;
                while (have + (1 << pw) - 1 >= L) {
                    pw--;
                }
//            System.err.println("have = " + have + ", first = " + first + ", last = " + last);
                edges.add(new D.Edge(n - 1, pw, have));
                have += 1 << bit;
            }
            if (n < 1 || n > 20) {
                throw new AssertionError();
            }
            if (edges.size() > 60) {
                throw new AssertionError();
            }
            return edges;
        }

        private int getVertCount(int L) {
            return Integer.numberOfTrailingZeros(Integer.highestOneBit(L)) + 1;
        }

        static class Edge {
            int x;
            int y;
            int w;

            public Edge(int x, int y, int w) {
                this.x = x;
                this.y = y;
                this.w = w;
            }

            public void normalize(int n) {
                x = n - x;
                y = n - y;
            }

        }

    }

    static class OutputWriter {
        private final PrintWriter writer;

        public OutputWriter(OutputStream outputStream) {
            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
        }

        public OutputWriter(Writer writer) {
            this.writer = new PrintWriter(writer);
        }

        public void print(Object... objects) {
            for (int i = 0; i < objects.length; i++) {
                if (i != 0) {
                    writer.print(' ');
                }
                writer.print(objects[i]);
            }
        }

        public void printLine(Object... objects) {
            print(objects);
            writer.println();
        }

        public void close() {
            writer.close();
        }

    }

    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private InputReader.SpaceCharFilter filter;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int readInt() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public boolean isSpaceChar(int c) {
            if (filter != null) {
                return filter.isSpaceChar(c);
            }
            return isWhitespace(c);
        }

        public static boolean isWhitespace(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);

        }

    }
}


</source>
<source file="../hum_codes_raw/s830003646.java" startline="1" endline="228" pcid="27841">
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.PrintStream;
import java.io.BufferedWriter;
import java.util.InputMismatchException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.io.Writer;
import java.io.OutputStreamWriter;
import java.io.InputStream;

/**
 * Built using CHelper plug-in
 * Actual solution is at the top
 */
public class Main {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        OutputWriter out = new OutputWriter(outputStream);
        D solver = new D();
        solver.solve(1, in, out);
        out.close();
    }

    static class D {
        public void solve(int testNumber, InputReader in, OutputWriter out) {
//        for (int LL = 2; LL <= 16; LL++) {
//            List<Edge> edges = solve(LL);
//            System.err.println("");
//            System.err.println("solving L = " + LL);
//            for (Edge e : edges) {
//                System.err.println(e.x + " " + e.y + " " + e.w);
//            }
//        }
//        for (int LL = 1<<19; LL >= (1<<19) - 20; LL--) {
//            List<Edge> edges = solve(LL);
//            System.err.println("");
//            System.err.println("solving L = " + LL);
//            for (Edge e : edges) {
//                System.err.println(e.x + " " + e.y + " " + e.w);
//            }
//        }

            int L = in.readInt();
            List<D.Edge> edges = solve(L);
            int n = 0;
            for (D.Edge e : edges) {
                n = Math.max(n, e.x);
                n = Math.max(n, e.y);
            }
            n++;
            for (D.Edge e : edges) {
                e.normalize(n);
            }
            out.printLine(n + " " + edges.size());
            for (D.Edge e : edges) {
                out.printLine(e.x + " " + e.y + " " + e.w);
            }
        }

        private List<D.Edge> solve(int L) {
            int n = getVertCount(L);
            List<D.Edge> edges = new ArrayList<>();
            for (int i = 0; i < n - 1; i++) {
                edges.add(new D.Edge(i + 1, i, 0));
                edges.add(new D.Edge(i + 1, i, 1 << i));
            }
//        System.err.println("L = " + L);
            if ((L & (L - 1)) == 0) {
                return edges;
            }
            if (L == 6) {
                System.err.print("");
            }
            int have = Integer.highestOneBit(L);
            while (have < L) { // L is not 2^n-1
                int bit = Integer.numberOfTrailingZeros(Integer.highestOneBit(L - have));
                int first = have;
                int last = have + (1 << bit) - 1;
                int pw = 19;
                while (have + (1 << pw) - 1 >= L) {
                    pw--;
                }
//            System.err.println("have = " + have + ", first = " + first + ", last = " + last);
                edges.add(new D.Edge(n - 1, pw, have));
                have += 1 << bit;
            }
            if (n < 1 || n > 20) {
                throw new AssertionError();
            }
            if (edges.size() > 60) {
                throw new AssertionError();
            }
            return edges;
        }

        private int getVertCount(int L) {
            return Integer.numberOfTrailingZeros(Integer.highestOneBit(L)) + 1;
        }

        static class Edge {
            int x;
            int y;
            int w;

            public Edge(int x, int y, int w) {
                this.x = x;
                this.y = y;
                this.w = w;
            }

            public void normalize(int n) {
                x = n - x;
                y = n - y;
            }

        }

    }

    static class OutputWriter {
        private final PrintWriter writer;

        public OutputWriter(OutputStream outputStream) {
            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
        }

        public OutputWriter(Writer writer) {
            this.writer = new PrintWriter(writer);
        }

        public void print(Object... objects) {
            for (int i = 0; i < objects.length; i++) {
                if (i != 0) {
                    writer.print(' ');
                }
                writer.print(objects[i]);
            }
        }

        public void printLine(Object... objects) {
            print(objects);
            writer.println();
        }

        public void close() {
            writer.close();
        }

    }

    static class InputReader {
        private InputStream stream;
        private byte[] buf = new byte[1024];
        private int curChar;
        private int numChars;
        private InputReader.SpaceCharFilter filter;

        public InputReader(InputStream stream) {
            this.stream = stream;
        }

        public int read() {
            if (numChars == -1) {
                throw new InputMismatchException();
            }
            if (curChar >= numChars) {
                curChar = 0;
                try {
                    numChars = stream.read(buf);
                } catch (IOException e) {
                    throw new InputMismatchException();
                }
                if (numChars <= 0) {
                    return -1;
                }
            }
            return buf[curChar++];
        }

        public int readInt() {
            int c = read();
            while (isSpaceChar(c)) {
                c = read();
            }
            int sgn = 1;
            if (c == '-') {
                sgn = -1;
                c = read();
            }
            int res = 0;
            do {
                if (c < '0' || c > '9') {
                    throw new InputMismatchException();
                }
                res *= 10;
                res += c - '0';
                c = read();
            } while (!isSpaceChar(c));
            return res * sgn;
        }

        public boolean isSpaceChar(int c) {
            if (filter != null) {
                return filter.isSpaceChar(c);
            }
            return isWhitespace(c);
        }

        public static boolean isWhitespace(int c) {
            return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
        }

        public interface SpaceCharFilter {
            public boolean isSpaceChar(int ch);

        }

    }
}


</source>
</class>

<class classid="300" nclones="2" nlines="20" similarity="100">
<source file="../hum_codes_raw/s803034229.java" startline="1" endline="25" pcid="26971">
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class Main {
	public static void main(String[] args){
		Map<String,Integer> sales = new HashMap<>();
		Scanner sc = new Scanner(System.in);

		int a = sc.nextInt();

		for(int i = 0; i < a;i++){
			int x= sc.nextInt();
			String key = sc.next();
			if(x ==0){
				sales.put(key,sc.nextInt());
			}else{
				System.out.println(sales.get(key));

			}
		}
	}
}


</source>
<source file="../hum_codes_raw/s888664655.java" startline="1" endline="25" pcid="29883">
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class Main {
	public static void main(String[] args){
		Map<String,Integer> sales = new HashMap<>();
		Scanner sc = new Scanner(System.in);

		int a = sc.nextInt();

		for(int i = 0; i < a;i++){
			int x= sc.nextInt();
			String key = sc.next();
			if(x ==0){
				sales.put(key,sc.nextInt());
			}else{
				System.out.println(sales.get(key));

			}
		}
	}
}


</source>
</class>

<class classid="301" nclones="2" nlines="15" similarity="100">
<source file="../hum_codes_raw/s817243344.java" startline="1" endline="18" pcid="27444">
import java.util.Scanner;

public class Main {

	public static void main(String[] args){
		Scanner sc = new Scanner(System.in);
		int a = sc.nextInt();
		int b = sc.nextInt();
		int c = sc.nextInt();

		if(a+b+c >=22){
			System.out.println("bust");
		}else{
			System.out.println("win");
		}
	}
}

</source>
<source file="../hum_codes_raw/s862774890.java" startline="1" endline="20" pcid="29015">
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);

		int a = sc.nextInt();
		int b = sc.nextInt();
		int c = sc.nextInt();

		if(a+b+c >= 22) {
			System.out.println("bust");
		}else {
			System.out.println("win");
		}
	}

}

</source>
</class>

<class classid="302" nclones="2" nlines="25" similarity="100">
<source file="../hum_codes_raw/s842681883.java" startline="1" endline="2" pcid="28297">
import java.util.*;class Main{public static void main(String[]args){Scanner sc = new Scanner(System.in);int c=0;for(;;){  int s=sc.nextInt();if(s==0)break;if(c!=0)System.out.println();String tn[] =new String[s];int tp[]=new int[s];  int tpc[]=new int[s];for(int i=0;i<s;i++){ tn[i]=sc.next();tp[i]=(sc.nextInt()*3+sc.nextInt()*0+sc.nextInt());tpc[i]=tp[i];}Arrays.sort(tpc);for(int i=tpc[s-1];i>-1;i--){ for(int j=0;j<s;j++) if(i==tp[j])System.out.println(tn[j]+","+tp[j]);}c++;}}}

</source>
<source file="../hum_codes_raw/s863726903.java" startline="1" endline="29" pcid="29043">
import java.util.*;

 class Main{
    public static void main(String[]args){
        Scanner sc = new Scanner(System.in);
 int c=0;
      for(;;){  
        int s=sc.nextInt();
        if(s==0)break;
        if(c!=0)System.out.println();
   
   String tn[] =new String[s];
    int tp[]=new int[s]; 
    int tpc[]=new int[s];
    for(int i=0;i<s;i++){ 
    	tn[i]=sc.next();
    	tp[i]=(sc.nextInt()*3+sc.nextInt()*0+sc.nextInt());
        tpc[i]=tp[i];
    }
    Arrays.sort(tpc);
    for(int i=tpc[s-1];i>-1;i--){ 
    	for(int j=0;j<s;j++) if(i==tp[j])
    	System.out.println(tn[j]+","+tp[j]);
    }
    c++;
      }
    }
}

</source>
</class>

<class classid="303" nclones="2" nlines="40" similarity="100">
<source file="../hum_codes_raw/s843749289.java" startline="1" endline="53" pcid="28334">
import java.util.Scanner;

public class Main {

	static boolean[] primes;

	static void primeSet(final int MAX){
		primes = new boolean[MAX+1];

		primes[2] = true;
		for(int i=3;i<=MAX;i+=2){
			primes[i] = true;
		}
		int rt = (int) Math.sqrt(MAX);
		for(int i=3;i<=rt;i+=2){
			if(primes[i]){
				for(int j=i*2;j<=MAX;j+=i){
					primes[j] = false;
				}
			}
		}
	}

	public static void main(String[] args) {
		Scanner stdIn = new Scanner(System.in);

		while(true){
			int max = 0;
			int n = stdIn.nextInt();

			if(max<n){
				primeSet(n);
				max=n;
			}
			
			if(n==0){
				break;
			}

			// if() then "0" Bn=7 ... [2,5]

			int cnt = 0;
			for(int i=2;i<=n/2;i++){
				if(primes[i]&&primes[n-i]){
//					System.out.println("["+i+","+(n-i)+"]");
					cnt++;
				}
			}
			System.out.println(cnt);
		}
	}
}

</source>
<source file="../hum_codes_raw/s951909513.java" startline="1" endline="55" pcid="31975">
import java.util.Scanner;

public class Main {

	// AOJ 0056 , 0185 

	static boolean[] primes;

	static void primeSet(final int MAX){
		primes = new boolean[MAX+1];

		primes[2] = true;
		for(int i=3;i<=MAX;i+=2){
			primes[i] = true;
		}
		int rt = (int) Math.sqrt(MAX);
		for(int i=3;i<=rt;i+=2){
			if(primes[i]){
				for(int j=i*2;j<=MAX;j+=i){
					primes[j] = false;
				}
			}
		}
	}

	public static void main(String[] args) {
		Scanner stdIn = new Scanner(System.in);

		while(true){
			int max = 0;
			int n = stdIn.nextInt();

			if(max<n){
				primeSet(n);
				max=n;
			}

			if(n==0){
				break;
			}

			// if() then "0" n=7 ... [2,5]

			int cnt = 0;
			for(int i=2;i<=n/2;i++){
				if(primes[i]&&primes[n-i]){
					// System.out.println("["+i+","+(n-i)+"]");
					cnt++;
				}
			}
			System.out.println(cnt);
		}
	}
}

</source>
</class>

<class classid="304" nclones="2" nlines="76" similarity="100">
<source file="../hum_codes_raw/s844951879.java" startline="1" endline="95" pcid="28370">
import java.io.IOException;

public class Main {

	public static void main(String[] args) {
		while (true) {
			int n = nextInt();
			if (n == 0) {
				break;
			}

			int[][] cir = new int[n][4];
			int[] above = new int[n];// 

			int[] bitDP = new int[1 << n];

			for (int i = 0; i < n; i++) {
				int x = nextInt();
				int y = nextInt();
				int r = nextInt();
				int c = nextInt();
				cir[i][0] = x;
				cir[i][1] = y;
				cir[i][2] = r;
				cir[i][3] = c;

				for (int j = 0; j < i; j++) {
					// 
					int jx = cir[j][0] - x;
					int jy = cir[j][1] - y;
					int jr = cir[j][2];
					double dist = Math.sqrt(jx * jx + jy * jy);
					if (dist < r + jr) {
						above[i] += (1 << j);
					}
				}
			}

			int max = 0;
			for (int bit = 0; bit < bitDP.length; bit++) {
				// 
				if (bit != 0 && bitDP[bit] == 0) {
					continue;
				}
				for (int i = 0; i < n; i++) {
					// ij
					if ((bit & (1 << i)) != 0) {
						continue;
					}
					for (int j = i + 1; j < n; j++) {
						// ij
						if ((bit & ((1 << i) + (1 << j))) != 0) {
							continue;
						}
						// ij
						if ((above[i] & bit) != above[i] || (above[j] & bit) != above[j]) {
							continue;
						}
						// 
						if (cir[i][3] == cir[j][3]) {
							int newbit = bit + (1 << i) + (1 << j);
							bitDP[newbit] = Math.max(bitDP[newbit], bitDP[bit] + 2);
							max = Math.max(max, bitDP[newbit]);
						}
					}
				}
			}

			System.out.println(max);
			System.gc();
		}
	}

	static int nextInt() {
		int c;
		try {
			c = System.in.read();
			while (c != '-' && (c < '0' || c > '9'))
				c = System.in.read();
			if (c == '-')
				return -nextInt();
			int res = 0;
			while (c >= '0' && c <= '9') {
				res = res * 10 + c - '0';
				c = System.in.read();
			}
			return res;
		} catch (IOException e) {
			e.printStackTrace();
		}
		return -1;
	}

}

</source>
<source file="../hum_codes_raw/s928209330.java" startline="1" endline="95" pcid="31231">
import java.io.IOException;

public class Main {

	public static void main(String[] args) {
		while (true) {
			int n = nextInt();
			if (n == 0) {
				break;
			}

			int[][] cir = new int[n][4];
			int[] above = new int[n];// ???????

			int[] bitDP = new int[1 << n];

			for (int i = 0; i < n; i++) {
				int x = nextInt();
				int y = nextInt();
				int r = nextInt();
				int c = nextInt();
				cir[i][0] = x;
				cir[i][1] = y;
				cir[i][2] = r;
				cir[i][3] = c;

				for (int j = 0; j < i; j++) {
					// ?????????????
					int jx = cir[j][0] - x;
					int jy = cir[j][1] - y;
					int jr = cir[j][2];
					double dist = Math.sqrt(jx * jx + jy * jy);
					if (dist < r + jr) {
						above[i] += (1 << j);
					}
				}
			}

			int max = 0;
			for (int bit = 0; bit < bitDP.length; bit++) {
				// ???????
				if (bit != 0 && bitDP[bit] == 0) {
					continue;
				}
				for (int i = 0; i < n; i++) {
					// ???j??????????
					if ((bit & (1 << i)) != 0) {
						continue;
					}
					for (int j = i + 1; j < n; j++) {
						// ???j??????????
						if ((bit & ((1 << i) + (1 << j))) != 0) {
							continue;
						}
						// i?j???????????????
						if ((above[i] & bit) != above[i] || (above[j] & bit) != above[j]) {
							continue;
						}
						// ????????
						if (cir[i][3] == cir[j][3]) {
							int newbit = bit + (1 << i) + (1 << j);
							bitDP[newbit] = Math.max(bitDP[newbit], bitDP[bit] + 2);
							max = Math.max(max, bitDP[newbit]);
						}
					}
				}
			}

			System.out.println(max);
			System.gc();
		}
	}

	static int nextInt() {
		int c;
		try {
			c = System.in.read();
			while (c != '-' && (c < '0' || c > '9'))
				c = System.in.read();
			if (c == '-')
				return -nextInt();
			int res = 0;
			while (c >= '0' && c <= '9') {
				res = res * 10 + c - '0';
				c = System.in.read();
			}
			return res;
		} catch (IOException e) {
			e.printStackTrace();
		}
		return -1;
	}

}

</source>
</class>

<class classid="305" nclones="2" nlines="29" similarity="100">
<source file="../hum_codes_raw/s845515756.java" startline="1" endline="33" pcid="28394">
import java.util.Scanner;
 
//Flying Jenny
public class Main{
 
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int[] c = {4,1,4,1,2,1,2,1};
        while(sc.hasNext()){
            int[] a = new int[8];
            for(int i=0;i<8;i++)a[i]=sc.nextInt();
            int min = Integer.MAX_VALUE;
            String v = "";
            for(int top=0;top<8;top++){
                int r = 0;
                String m = "";
                for(int j=0;j<8;j++){
                    r += Math.max(0, a[j]-c[(top+j)%8]);
                    m += c[(top+j)%8];
                }
                if(r<min){
                    min = r;
                    v = m;
                }
                else if(r==min&&m.compareTo(v)<0)v = m;
            }
            System.out.print(v.charAt(0));
            for(int i=1;i<8;i++)System.out.print(" "+v.charAt(i));
            System.out.println();
        }
    }
}

</source>
<source file="../hum_codes_raw/s864941032.java" startline="1" endline="33" pcid="29074">
import java.util.Scanner;

//Flying Jenny
public class Main{

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int[] c = {4,1,4,1,2,1,2,1};
		while(sc.hasNext()){
			int[] a = new int[8];
			for(int i=0;i<8;i++)a[i]=sc.nextInt();
			int min = Integer.MAX_VALUE;
			String v = "";
			for(int top=0;top<8;top++){
				int r = 0;
				String m = "";
				for(int j=0;j<8;j++){
					r += Math.max(0, a[j]-c[(top+j)%8]);
					m += c[(top+j)%8];
				}
				if(r<min){
					min = r;
					v = m;
				}
				else if(r==min&&m.compareTo(v)<0)v = m;
			}
			System.out.print(v.charAt(0));
			for(int i=1;i<8;i++)System.out.print(" "+v.charAt(i));
			System.out.println();
		}
	}
}

</source>
</class>

<class classid="306" nclones="2" nlines="31" similarity="100">
<source file="../hum_codes_raw/s863917875.java" startline="1" endline="26" pcid="29046">
import java.util.Scanner;
	import java.util.*;
	
	public class Main{
		
		public static void main(String[] args) {
			
			Scanner sc=new Scanner(System.in);
			
		while(true){int n=sc.nextInt();if(n==0){break;}
		int N[]=new int[n+1];
		
		for(int i=0;i<n+1;i++){N[i]=sc.nextInt();}
		
		bi:for(int i=0;i<n+1;i++){
			List<Integer>tousa=new ArrayList<Integer>();
		for(int p=0;p<n+1;p++){
			tousa.add(N[p]);}
		tousa.remove(i);
			for(int p=0;p<n-2;p++){
				if(tousa.get(p)-tousa.get(p+1)!=tousa.get(p+1)-tousa.get(p+2)){continue bi;}
			}System.out.println(N[i]);break;
		
		}}}}
		

</source>
<source file="../hum_codes_raw/s959716567.java" startline="1" endline="33" pcid="32257">
import java.util.Scanner;
	import java.util.*;
	
	public class Main{
		
		public static void main(String[] args) {
			
			Scanner sc=new Scanner(System.in);
			
		while(true){int n=sc.nextInt();if(n==0){break;}
		int N[]=new int[n+1];
		
		for(int i=0;i<n+1;i++){N[i]=sc.nextInt();}
		
		bi:for(int i=0;i<n+1;i++){
			List<Integer>tousa=new ArrayList<Integer>();
		for(int p=0;p<n+1;p++){
			tousa.add(N[p]);}
		tousa.remove(i);
			for(int p=0;p<n-2;p++){
				if(tousa.get(p)-tousa.get(p+1)!=tousa.get(p+1)-tousa.get(p+2)){continue bi;}
			}System.out.println(N[i]);break;
		
		}}}}
		
		
		
		
		
		
		
		

</source>
</class>

<class classid="307" nclones="2" nlines="82" similarity="100">
<source file="../hum_codes_raw/s870448175.java" startline="1" endline="100" pcid="29277">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

  public static void main(String[] args) {
  
    new Main().run();
  }

  public void run() {

    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      int n = Integer.parseInt(br.readLine());
      Card[] cards = new Card[n];
      char suit;
      int  value;

      for ( int i=0; i<n; i++ ) {
        suit = (char)br.read(); br.skip(1);
        value = Integer.parseInt(br.readLine());
        cards[i] = new Card(suit, value, i);
      }

      quickSortOfCards(cards, 0, n-1);
      dispCardArray(cards);
    }
    catch(IOException e) {
      System.out.println("IOException!");
    }
  }

  public void quickSortOfCards(Card[] card, int p, int r) {

    if( p < r) {
      int q = partitionOfCards(card, p, r);
      quickSortOfCards(card, p, q-1);
      quickSortOfCards(card, q+1, r);
    }
  }

  public int partitionOfCards(Card[] card, int p, int r) {

    int x = card[r].value;
    int i = p-1;
    Card t;

    for(int j=p; j<r; j++) {
      if(card[j].value <= x) {
        t = card[++i]; card[i] = card[j]; card[j] = t;
      }
    }
    t = card[i+1]; card[i+1] = card[r]; card[r] = t;

    return i+1;
  }

public void dispCardArray(Card[] target) {
  StringBuilder s = new StringBuilder();
  int l=target.length;
  boolean isStable = true;
  String sortState = "Stable";

  s.append(target[0]).append("\n");
  for (int i=1; i<l; i++) {
    s.append(target[i]).append("\n");
    if(isStable && target[i-1].value == target[i].value 
      && target[i-1].storedNo > target[i].storedNo) {
      sortState = "Not stable";
      isStable = false;
    }
  }

  System.out.println(sortState);
  System.out.print(s);
  }
}

class Card {
  char suit;
  int value;
  int storedNo;

  public Card( char suit, int value, int storedNo ) {
    this.suit  = suit;
    this.value = value;
    this.storedNo = storedNo;
  }
  public Card( Card card ) {
    this(card.suit, card.value, card.storedNo);
  }

  @Override
  public String toString() {
    return suit + " " + String.valueOf(value);
  }
}

</source>
<source file="../hum_codes_raw/s972659004.java" startline="1" endline="100" pcid="32725">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

  public static void main(String[] args) {
  
    new Main().run();
  }

  public void run() {

    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      int n = Integer.parseInt(br.readLine());
      Card[] cards = new Card[n];
      char suit;
      int  value;

      for ( int i=0; i<n; i++ ) {
        suit = (char)br.read(); br.skip(1);
        value = Integer.parseInt(br.readLine());
        cards[i] = new Card(suit, value, i);
      }

      quickSortOfCards(cards, 0, n-1);
      dispCardArray(cards);
    }
    catch(IOException e) {
      System.out.println("IOException!");
    }
  }

  public void quickSortOfCards(Card[] card, int p, int r) {

    if( p < r) {
      int q = partitionOfCards(card, p, r);
      quickSortOfCards(card, p, q-1);
      quickSortOfCards(card, q+1, r);
    }
  }

  public int partitionOfCards(Card[] card, int p, int r) {

    int x = card[r].value;
    int i = p-1;
    Card t;

    for(int j=p; j<r; j++) {
      if(card[j].value <= x) {
        t = card[++i]; card[i] = card[j]; card[j] = t;
      }
    }
    t = card[i+1]; card[i+1] = card[r]; card[r] = t;

    return i+1;
  }

public void dispCardArray(Card[] target) {
  StringBuilder s = new StringBuilder();
  int l=target.length;
  boolean isStable = true;
  String sortState = "Stable";

  s.append(target[0]).append("\n");
  for (int i=1; i<l; i++) {
    s.append(target[i]).append("\n");
    if(isStable && target[i-1].value == target[i].value 
      && target[i-1].storedNo > target[i].storedNo) {
      sortState = "Not stable";
      isStable = false;
    }
  }

  System.out.println(sortState);
  System.out.print(s);
  }
}

class Card {
  char suit;
  int value;
  int storedNo;

  public Card( char suit, int value, int storedNo ) {
    this.suit  = suit;
    this.value = value;
    this.storedNo = storedNo;
  }
  public Card( Card card ) {
    this(card.suit, card.value, card.storedNo);
  }

  @Override
  public String toString() {
    return suit + " " + String.valueOf(value);
  }
}

</source>
</class>

<class classid="308" nclones="2" nlines="13" similarity="100">
<source file="../hum_codes_raw/s881248582.java" startline="1" endline="15" pcid="29614">
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int [] a = new int [N];
        for(int i=0; i<N; i++){
            a[i] = sc.nextInt();
        }
        Arrays.sort(a);
        System.out.println(a[N-1]-a[0]);
    }
}

</source>
<source file="../hum_codes_raw/s925507872.java" startline="1" endline="14" pcid="31131">
import java.util.*;
public class Main{
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int N = sc.nextInt();
    int[] a = new int[N];
    for (int i=0; i<N; i++){
      a[i] = sc.nextInt();
    }
    Arrays.sort(a);
    System.out.println(a[N-1]-a[0]);
  }
}

</source>
</class>

<class classid="309" nclones="2" nlines="22" similarity="100">
<source file="../hum_codes_raw/s881835494.java" startline="1" endline="31" pcid="29635">
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(sc.hasNext()) {
		char[] a = sc.next().toCharArray();
		char[] b = sc.next().toCharArray();
		int[][] dp = new int[a.length][b.length];
		int max = 0;
		for(int i = 0; i < a.length; i++) {
			for(int j = 0; j < b.length; j++) {
				if(a[i] == b[j]) {
					if(i != 0 && j != 0)
					dp[i][j] = Math.max(dp[i-1][j-1]+1, 1);
					else dp[i][j] = 1;
				}
				max = Math.max(dp[i][j], max);
				
				
			}
		}
		System.out.println(max);
		}
		
	}

	
}

</source>
<source file="../hum_codes_raw/s895881206.java" startline="1" endline="32" pcid="30147">
import java.util.*;

public class Main {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(sc.hasNext()) {
		char[] a = sc.next().toCharArray();
		char[] b = sc.next().toCharArray();
		int[][] dp = new int[a.length][b.length];
		int max = 0;
		for(int i = 0; i < a.length; i++) {
			for(int j = 0; j < b.length; j++) {
				if(a[i] == b[j]) {
					if(i != 0 && j != 0)
					dp[i][j] = Math.max(dp[i-1][j-1]+1, 1);
					else dp[i][j] = 1;
					max = Math.max(dp[i][j], max);
				}
				
				
				
			}
		}
		System.out.println(max);
		}
		
	}

	
}

</source>
</class>

<class classid="310" nclones="2" nlines="29" similarity="100">
<source file="../hum_codes_raw/s921794084.java" startline="1" endline="51" pcid="31005">
import java.util.*;
public class Main
{
	public static void main(String[] args) 
	{
		Scanner in=new Scanner(System.in);
		int m[][]={
				{1,2,1,2,1,4,1,4},
				{1,2,1,4,1,4,1,2},
				{1,4,1,2,1,2,1,4},
				{1,4,1,4,1,2,1,2},
				{2,1,2,1,4,1,4,1},
				{2,1,4,1,4,1,2,1},
				{4,1,2,1,2,1,4,1},
				{4,1,4,1,2,1,2,1},
		};
		while(in.hasNext())
		{
			int a[]=new int[8];
			for(int i=0;i<8;i++)
				a[i]=in.nextInt();
			
			int id=-1;
			int min=Integer.MAX_VALUE;
			for(int i=0;i<8;i++)
			{
				int sam=0;
				for(int j=0;j<8;j++)
				{
					int cnt=m[i][j]-a[j];
					if(cnt>0)
						sam+=cnt;
				}
				if(sam<min)
				{
					min=sam;
					id=i;
				}
			}
			for(int i=0;i<7;i++)
				System.out.print(m[id][i]+" ");
			System.out.println(m[id][7]);
		}
	}

	static public void debug(Object... o)
	{
		System.out.println(Arrays.deepToString(o));
	}
}

</source>
<source file="../hum_codes_raw/s972797820.java" startline="1" endline="51" pcid="32733">
import java.util.*;
public class Main
{
    public static void main(String[] args) 
    {
        Scanner in=new Scanner(System.in);
        int m[][]={
                {1,2,1,2,1,4,1,4},
                {1,2,1,4,1,4,1,2},
                {1,4,1,2,1,2,1,4},
                {1,4,1,4,1,2,1,2},
                {2,1,2,1,4,1,4,1},
                {2,1,4,1,4,1,2,1},
                {4,1,2,1,2,1,4,1},
                {4,1,4,1,2,1,2,1},
        };
        while(in.hasNext())
        {
            int a[]=new int[8];
            for(int i=0;i<8;i++)
                a[i]=in.nextInt();
             
            int id=-1;
            int min=Integer.MAX_VALUE;
            for(int i=0;i<8;i++)
            {
                int sam=0;
                for(int j=0;j<8;j++)
                {
                    int cnt=m[i][j]-a[j];
                    if(cnt>0)
                        sam+=cnt;
                }
                if(sam<min)
                {
                    min=sam;
                    id=i;
                }
            }
            for(int i=0;i<7;i++)
                System.out.print(m[id][i]+" ");
            System.out.println(m[id][7]);
        }
    }
 
    static public void debug(Object... o)
    {
        System.out.println(Arrays.deepToString(o));
    }
}

</source>
</class>

<class classid="311" nclones="2" nlines="16" similarity="100">
<source file="../hum_codes_raw/s934462189.java" startline="1" endline="18" pcid="31424">
import java.util.*;

class Main {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
	String s = sc.next();

    if (s.equals("Sunny")) {
	  System.out.println("Cloudy");
    } else if (s.equals("Cloudy")) {
      System.out.println("Rainy");
    } else {
      System.out.println("Sunny");
    }
    
  }
}

</source>
<source file="../hum_codes_raw/s956305632.java" startline="1" endline="16" pcid="32145">
import java.util.*;

class Main{
  public static void main(String[] args){
    Scanner sc = new Scanner(System.in);
    String s = sc.next();
    if(s.equals("Sunny")){
      System.out.println("Cloudy");
    }else if(s.equals("Cloudy")){
      System.out.println("Rainy");
    }else{
      System.out.println("Sunny");
    }
  }
}

</source>
</class>

<class classid="312" nclones="2" nlines="10" similarity="100">
<source file="../hum_codes_raw/s945990009.java" startline="1" endline="15" pcid="31792">
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int X = sc.nextInt();
		int A = sc.nextInt();
		int B = sc.nextInt();

		System.out.println((X-A) % B);

	}
}


</source>
<source file="../hum_codes_raw/s957275050.java" startline="1" endline="20" pcid="32171">
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		// TODO 

		Scanner sc = new Scanner(System.in);

		int X = sc.nextInt();
		int A = sc.nextInt();
		int B = sc.nextInt();

			System.out.println((X-A)%B);


		}
	}


</source>
</class>

<class classid="313" nclones="3" nlines="116" similarity="100">
<source file="../hum_codes_raw/s965431320.java" startline="1" endline="143" pcid="32455">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class Main {

  public static void main(String[] args) {
    
    new Main().run();
  }

  public void run() {

    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      String[] nm = br.readLine().split(" ");
      int n = Integer.parseInt(nm[0]);
      int m = Integer.parseInt(nm[1]);
      Graph graph = new Graph(n);
      String[] vInfo;
      int idS,idT;

      for(int i=0; i<m; i++) {
        vInfo = br.readLine().split(" ");
        idS   = Integer.parseInt(vInfo[0]);
        idT   = Integer.parseInt(vInfo[1]);
        graph.setAjacentList(idS, idT);
        graph.setAjacentList(idT, idS);
      }
      graph.vertexSearch();

      int q = Integer.parseInt(br.readLine());
      StringBuilder buf = new StringBuilder();
      for(int i=0; i<q; i++) {
        vInfo = br.readLine().split(" ");
        idS   = Integer.parseInt(vInfo[0]);
        idT   = Integer.parseInt(vInfo[1]);
        buf.append(graph.isConnected(idS, idT) ? "yes" : "no")
           .append("\n");
      }

      System.out.print(buf);
    }
    catch (IOException e) {
      System.err.println(e);
    }
  }

  class Graph {

    Vertex[] vertices;
    Queue<Vertex> queue;
    int time;

    public Graph(int size ) {
      vertices  = new Vertex[size];
      queue = new ArrayDeque<>(size);
      time = 0;
      for (int i=0; i<size; i++) {
        vertices[i] = new Vertex(i);
      }
    }

    public void setVertex(int id) {
      vertices[convIdToIndex(id)] = new Vertex(id);
    }
    public void setAjacentList(int id, int ajacent) {
      vertices[convIdToIndex(id)].ajacent
      .add(convIdToIndex(ajacent));
    }
    public void vertexSearch() {
      int color = 10;

      for (Vertex v : vertices) {
        if(v.state == Vertex.WHITE)
        GroupingByBFS(v.index,color++);
      }
    }
    public void dispReport() {
      StringBuilder buf = new StringBuilder();

      for (Vertex v : vertices) {
          buf.append(v.id).append(" ")
             .append(v.distance).append("\n");
      }

      System.out.print(buf);
    }
    public int convIdToIndex(int id) {
      return id - Vertex. DIFF_ID_INDEX;
    }
    public boolean isConnected(int idS, int idT) {
      return vertices[idS].state == vertices[idT].state;
    }

    private void GroupingByBFS(int index, int color) {
      vertices[index].state = Vertex.GRAY;
      vertices[index].distance = 0;
      queue.offer(vertices[index]);

      Vertex v;
      while(queue.peek() != null) {
        v = queue.poll();
        for (int ajcIndex : v.ajacent) {
          if(vertices[ajcIndex].state == Vertex.WHITE) {
            vertices[ajcIndex].state = Vertex.GRAY;
            vertices[ajcIndex].distance = v.distance + 1;
            queue.offer(vertices[ajcIndex]);
          }
        }
        v.state =color;
      }
    }

    class Vertex {

      static final int WHITE = 0;
      static final int GRAY  = 1;
      static final int BLACK = 2;
      static final int DIFF_ID_INDEX = 0;
      int id;
      int index;
      int state;
      List<Integer> ajacent;
      int findTime;
      int doneTime;
      int distance;

      public Vertex(int id) {
        this.id = id;
        index = id-DIFF_ID_INDEX;
        state = WHITE;
        distance = -1;
        ajacent = new LinkedList<>();
      }
    }
  }
}

</source>
<source file="../hum_codes_raw/s992552471.java" startline="1" endline="143" pcid="33393">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class Main {

  public static void main(String[] args) {
    
    new Main().run();
  }

  public void run() {

    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      String[] nm = br.readLine().split(" ");
      int n = Integer.parseInt(nm[0]);
      int m = Integer.parseInt(nm[1]);
      Graph graph = new Graph(n);
      String[] vInfo;
      int idS,idT;

      for(int i=0; i<m; i++) {
        vInfo = br.readLine().split(" ");
        idS   = Integer.parseInt(vInfo[0]);
        idT   = Integer.parseInt(vInfo[1]);
        graph.setAjacentList(idS, idT);
        graph.setAjacentList(idT, idS);
      }
      graph.vertexSearch();

      int q = Integer.parseInt(br.readLine());
      StringBuilder buf = new StringBuilder();
      for(int i=0; i<q; i++) {
        vInfo = br.readLine().split(" ");
        idS   = Integer.parseInt(vInfo[0]);
        idT   = Integer.parseInt(vInfo[1]);
        buf.append(graph.isConnected(idS, idT) ? "yes" : "no")
           .append("\n");
      }

      System.out.print(buf);
    }
    catch (IOException e) {
      System.err.println(e);
    }
  }

  class Graph {

    Vertex[] vertices;
    Queue<Vertex> queue;
    int time;

    public Graph(int size ) {
      vertices  = new Vertex[size];
      queue = new ArrayDeque<>(size);
      time = 0;
      for (int i=0; i<size; i++) {
        vertices[i] = new Vertex(i);
      }
    }

    public void setVertex(int id) {
      vertices[convIdToIndex(id)] = new Vertex(id);
    }
    public void setAjacentList(int id, int ajacent) {
      vertices[convIdToIndex(id)].ajacent
      .add(convIdToIndex(ajacent));
    }
    public void vertexSearch() {
      int color = 10;

      for (Vertex v : vertices) {
        if(v.state == Vertex.WHITE)
        GroupingByBFS(v.index,color++);
      }
    }
    public void dispReport() {
      StringBuilder buf = new StringBuilder();

      for (Vertex v : vertices) {
          buf.append(v.id).append(" ")
             .append(v.distance).append("\n");
      }

      System.out.print(buf);
    }
    public int convIdToIndex(int id) {
      return id - Vertex. DIFF_ID_INDEX;
    }
    public boolean isConnected(int idS, int idT) {
      return vertices[idS].state == vertices[idT].state;
    }

    private void GroupingByBFS(int index, int color) {
      vertices[index].state = Vertex.GRAY;
      vertices[index].distance = 0;
      queue.offer(vertices[index]);

      Vertex v;
      while(queue.peek() != null) {
        v = queue.poll();
        for (int ajcIndex : v.ajacent) {
          if(vertices[ajcIndex].state == Vertex.WHITE) {
            vertices[ajcIndex].state = Vertex.GRAY;
            vertices[ajcIndex].distance = v.distance + 1;
            queue.offer(vertices[ajcIndex]);
          }
        }
        v.state =color;
      }
    }

    class Vertex {

      static final int WHITE = 0;
      static final int GRAY  = 1;
      static final int BLACK = 2;
      static final int DIFF_ID_INDEX = 0;
      int id;
      int index;
      int state;
      List<Integer> ajacent;
      int findTime;
      int doneTime;
      int distance;

      public Vertex(int id) {
        this.id = id;
        index = id-DIFF_ID_INDEX;
        state = WHITE;
        distance = -1;
        ajacent = new LinkedList<>();
      }
    }
  }
}

</source>
<source file="../hum_codes_raw/s982466613.java" startline="1" endline="143" pcid="33041">
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class Main {

  public static void main(String[] args) {
    
    new Main().run();
  }

  public void run() {

    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {

      String[] nm = br.readLine().split(" ");
      int n = Integer.parseInt(nm[0]);
      int m = Integer.parseInt(nm[1]);
      Graph graph = new Graph(n);
      String[] vInfo;
      int idS,idT;

      for(int i=0; i<m; i++) {
        vInfo = br.readLine().split(" ");
        idS   = Integer.parseInt(vInfo[0]);
        idT   = Integer.parseInt(vInfo[1]);
        graph.setAjacentList(idS, idT);
        graph.setAjacentList(idT, idS);
      }
      graph.vertexSearch();

      int q = Integer.parseInt(br.readLine());
      StringBuilder buf = new StringBuilder();
      for(int i=0; i<q; i++) {
        vInfo = br.readLine().split(" ");
        idS   = Integer.parseInt(vInfo[0]);
        idT   = Integer.parseInt(vInfo[1]);
        buf.append(graph.isConnected(idS, idT) ? "yes" : "no")
           .append("\n");
      }

      System.out.print(buf);
    }
    catch (IOException e) {
      System.err.println(e);
    }
  }

  class Graph {

    Vertex[] vertices;
    Queue<Vertex> queue;
    int time;

    public Graph(int size ) {
      vertices  = new Vertex[size];
      queue = new ArrayDeque<>(size);
      time = 0;
      for (int i=0; i<size; i++) {
        vertices[i] = new Vertex(i);
      }
    }

    public void setVertex(int id) {
      vertices[convIdToIndex(id)] = new Vertex(id);
    }
    public void setAjacentList(int id, int ajacent) {
      vertices[convIdToIndex(id)].ajacent
      .add(convIdToIndex(ajacent));
    }
    public void vertexSearch() {
      int color = 10;

      for (Vertex v : vertices) {
        if(v.state == Vertex.WHITE)
        GroupingByBFS(v.index,color++);
      }
    }
    public void dispReport() {
      StringBuilder buf = new StringBuilder();

      for (Vertex v : vertices) {
          buf.append(v.id).append(" ")
             .append(v.distance).append("\n");
      }

      System.out.print(buf);
    }
    public int convIdToIndex(int id) {
      return id - Vertex. DIFF_ID_INDEX;
    }
    public boolean isConnected(int idS, int idT) {
      return vertices[idS].state == vertices[idT].state;
    }

    private void GroupingByBFS(int index, int color) {
      vertices[index].state = Vertex.GRAY;
      vertices[index].distance = 0;
      queue.offer(vertices[index]);

      Vertex v;
      while(queue.peek() != null) {
        v = queue.poll();
        for (int ajcIndex : v.ajacent) {
          if(vertices[ajcIndex].state == Vertex.WHITE) {
            vertices[ajcIndex].state = Vertex.GRAY;
            vertices[ajcIndex].distance = v.distance + 1;
            queue.offer(vertices[ajcIndex]);
          }
        }
        v.state =color;
      }
    }

    class Vertex {

      static final int WHITE = 0;
      static final int GRAY  = 1;
      static final int BLACK = 2;
      static final int DIFF_ID_INDEX = 0;
      int id;
      int index;
      int state;
      List<Integer> ajacent;
      int findTime;
      int doneTime;
      int distance;

      public Vertex(int id) {
        this.id = id;
        index = id-DIFF_ID_INDEX;
        state = WHITE;
        distance = -1;
        ajacent = new LinkedList<>();
      }
    }
  }
}

</source>
</class>

</clones>
